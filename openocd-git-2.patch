From fa3f3de6d572b5506e0838e3d3d72e4eaccaf527 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 01/94] initial commit with all changes as of Oct10

---
 src/jtag/jtag.h               |    2 -
 src/server/gdb_server.c       |   12 +-
 src/target/Makefile.am        |    6 +
 src/target/adi_v5_cmsis_dap.c |    2 +-
 src/target/adi_v5_jtag.c      |   44 +-
 src/target/adi_v5_swd.c       |   50 +-
 src/target/arm.h              |   11 +
 src/target/arm_adi_v5.c       |   37 +-
 src/target/arm_adi_v5.h       |   16 +-
 src/target/arm_opcodes.h      |   25 +-
 src/target/armv4_5.c          |    3 +-
 src/target/armv7a.h           |    3 +-
 src/target/armv7m.h           |    1 -
 src/target/armv8.c            | 1535 +++++++++++++++++++
 src/target/armv8.h            |   66 +
 src/target/armv8_dpm.c        | 1004 +++++++++++++
 src/target/cortex_a.c         |   73 +-
 src/target/cortex_a.h         |    1 -
 src/target/cortex_a53.c       | 3289 +++++++++++++++++++++++++++++++++++++++++
 src/target/cortex_m.c         |   93 +-
 src/target/cortex_m.h         |    1 -
 src/target/target.c           |   95 +-
 src/target/target.h           |   19 +-
 src/target/target_type.h      |   17 +
 24 files changed, 6258 insertions(+), 147 deletions(-)
 mode change 100644 => 100755 src/target/adi_v5_cmsis_dap.c
 create mode 100755 src/target/armv8.c
 create mode 100755 src/target/armv8.h
 create mode 100755 src/target/armv8_dpm.c
 mode change 100644 => 100755 src/target/cortex_a.c
 create mode 100755 src/target/cortex_a53.c
 mode change 100644 => 100755 src/target/cortex_m.c

diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index eda4ccd..5216689 100644
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -155,8 +155,6 @@ struct jtag_tap {
 	struct jtag_tap_event_action *event_action;
 
 	struct jtag_tap *next_tap;
-	/* dap instance if some null if no instance , initialized to 0 by calloc*/
-	struct adiv5_dap *dap;
 	/* private pointer to support none-jtag specific functions */
 	void *priv;
 };
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index 152a06c..b926be9 100644
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -1253,7 +1253,7 @@ static int gdb_get_register_packet(struct connection *connection,
 #ifdef _DEBUG_GDB_IO_
 	LOG_DEBUG("-");
 #endif
-
+	//SQU: isn't this too expensive to read a group registers instead of just read the need one?
 	retval = target_get_gdb_reg_list(target, &reg_list, &reg_list_size,
 			REG_CLASS_ALL);
 	if (retval != ERROR_OK)
@@ -1350,8 +1350,8 @@ static int gdb_read_memory_packet(struct connection *connection,
 {
 	struct target *target = get_target_from_connection(connection);
 	char *separator;
-	uint32_t addr = 0;
-	uint32_t len = 0;
+	uint64_t addr = 0;
+	uint32_t len = 0; //below mem api might not support 64bit, and it is unlikely the size would be huge. So assume uint32_t is good enough
 
 	uint8_t *buffer;
 	char *hex_buffer;
@@ -1361,14 +1361,14 @@ static int gdb_read_memory_packet(struct connection *connection,
 	/* skip command character */
 	packet++;
 
-	addr = strtoul(packet, &separator, 16);
+	addr = strtoull(packet, &separator, 16);
 
 	if (*separator != ',') {
 		LOG_ERROR("incomplete read memory packet received, dropping connection");
 		return ERROR_SERVER_REMOTE_CLOSED;
 	}
 
-	len = strtoul(separator + 1, NULL, 16);
+	len = strtoull(separator + 1, NULL, 16);
 
 	if (!len) {
 		LOG_WARNING("invalid read memory packet received (len == 0)");
@@ -1378,7 +1378,7 @@ static int gdb_read_memory_packet(struct connection *connection,
 
 	buffer = malloc(len);
 
-	LOG_DEBUG("addr: 0x%8.8" PRIx32 ", len: 0x%8.8" PRIx32 "", addr, len);
+	LOG_DEBUG("addr: 0x%" PRIx64 ", len: 0x%" PRIx32, addr, len);
 
 	retval = target_read_buffer(target, addr, len, buffer);
 
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index bf80c64..d232e58 100644
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -31,6 +31,7 @@ libtarget_la_SOURCES = \
 	$(ARMV4_5_SRC) \
 	$(ARMV6_SRC) \
 	$(ARMV7_SRC) \
+	$(ARMV8_SRC) \
 	$(ARM_MISC_SRC) \
 	$(AVR32_SRC) \
 	$(MIPS32_SRC) \
@@ -83,6 +84,11 @@ ARMV7_SRC = \
 	armv7a.c \
 	cortex_a.c
 
+ARMV8_SRC = \
+	armv8.c \
+	armv8_dpm.c \
+	cortex_a53.c
+
 ARM_DEBUG_SRC = \
 	arm_dpm.c \
 	arm_jtag.c \
diff --git a/src/target/adi_v5_cmsis_dap.c b/src/target/adi_v5_cmsis_dap.c
old mode 100644
new mode 100755
index 9cdf08a..4fb3886
--- a/src/target/adi_v5_cmsis_dap.c
+++ b/src/target/adi_v5_cmsis_dap.c
@@ -116,7 +116,7 @@ static int cmsis_dap_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
 		return ERROR_OK;
 
 	dap->ap_bank_value = select_ap_bank;
-	select_ap_bank |= dap->ap_current;
+	select_ap_bank |= dap->ap_current<<24;
 
 	cmsis_dap_queue_dp_write(dap, DP_SELECT, select_ap_bank);
 	return ERROR_OK;
diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 1100b17..105fba2 100644
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -50,6 +50,11 @@
 #define JTAG_ACK_OK_FAULT	0x2
 #define JTAG_ACK_WAIT		0x1
 
+struct adiv5_jtag_dap {
+	struct adiv5_dap dap;
+	struct jtag_tap *tap;
+};
+
 static int jtag_ap_q_abort(struct adiv5_dap *dap, uint8_t *ack);
 
 /***************************************************************************
@@ -81,14 +86,22 @@ static int adi_jtag_dp_scan(struct adiv5_dap *dap,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
 {
-	struct arm_jtag *jtag_info = dap->jtag_info;
+	struct adiv5_jtag_dap *jtag_dap = container_of(dap, struct adiv5_jtag_dap, dap);
 	struct scan_field fields[2];
 	uint8_t out_addr_buf;
-	int retval;
 
-	retval = arm_jtag_set_instr(jtag_info, instr, NULL, TAP_IDLE);
-	if (retval != ERROR_OK)
-		return retval;
+	if (buf_get_u32(jtag_dap->tap->cur_instr, 0, jtag_dap->tap->ir_length) != instr) {
+		struct scan_field field;
+		field.num_bits = jtag_dap->tap->ir_length;
+
+		uint8_t t[DIV_ROUND_UP(field.num_bits, 8)];
+		buf_set_u32(t, 0, field.num_bits, instr);
+
+		field.out_value = t;
+		field.in_value = NULL;
+
+		jtag_add_ir_scan(jtag_dap->tap, &field, TAP_IDLE);
+	}
 
 	/* Scan out a read or write operation using some DP or AP register.
 	 * For APACC access with any sticky error flag set, this is discarded.
@@ -107,7 +120,7 @@ static int adi_jtag_dp_scan(struct adiv5_dap *dap,
 	fields[1].out_value = outvalue;
 	fields[1].in_value = invalue;
 
-	jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_IDLE);
+	jtag_add_dr_scan(jtag_dap->tap, 2, fields, TAP_IDLE);
 
 	/* Add specified number of tck clocks after starting memory bus
 	 * access, giving the hardware time to complete the access.
@@ -365,7 +378,7 @@ static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
 		return ERROR_OK;
 	dap->ap_bank_value = select_ap_bank;
 
-	select_ap_bank |= dap->ap_current;
+	select_ap_bank |= dap->ap_current<<24;
 
 	return jtag_dp_q_write(dap, DP_SELECT, select_ap_bank);
 }
@@ -468,3 +481,20 @@ int dap_to_jtag(struct target *target)
 
 	return retval;
 }
+
+void adiv5_jtag_dap_create(struct adiv5_jtag_dap *jtag_dap, struct jtag_tap *tap)
+{
+	/* TODO: Maybe create the super class, i.e. adiv5_dap_create(&swd_dap->dap); */
+	jtag_dap->dap.ops = &jtag_dp_ops;
+	jtag_dap->tap = tap;
+}
+
+struct adiv5_dap *adiv5_jtag_dap_new(struct jtag_tap *tap)
+{
+	struct adiv5_jtag_dap *jtag_dap = calloc(1, sizeof(*jtag_dap));
+	if (jtag_dap == NULL)
+		return NULL;
+
+	adiv5_jtag_dap_create(jtag_dap, tap);
+	return &jtag_dap->dap;
+}
diff --git a/src/target/adi_v5_swd.c b/src/target/adi_v5_swd.c
index 6e322fb..11c3883 100644
--- a/src/target/adi_v5_swd.c
+++ b/src/target/adi_v5_swd.c
@@ -58,6 +58,10 @@
 /* YUK! - but this is currently a global.... */
 extern struct jtag_interface *jtag_interface;
 static bool do_sync;
+struct adiv5_swd_dap {
+	struct adiv5_dap dap;
+	const struct swd_driver *swd;
+};
 
 static void swd_finish_read(struct adiv5_dap *dap)
 {
@@ -129,7 +133,8 @@ static void swd_queue_dp_bankselect(struct adiv5_dap *dap, unsigned reg)
 static int swd_queue_dp_read(struct adiv5_dap *dap, unsigned reg,
 		uint32_t *data)
 {
-	const struct swd_driver *swd = jtag_interface->swd;
+	struct adiv5_swd_dap *swd_dap = container_of(dap, struct adiv5_swd_dap, dap);
+	const struct swd_driver *swd = swd_dap->swd;
 	assert(swd);
 
 	swd_queue_dp_bankselect(dap, reg);
@@ -142,7 +147,8 @@ static int swd_queue_dp_read(struct adiv5_dap *dap, unsigned reg,
 static int swd_queue_dp_write(struct adiv5_dap *dap, unsigned reg,
 		uint32_t data)
 {
-	const struct swd_driver *swd = jtag_interface->swd;
+	struct adiv5_swd_dap *swd_dap = container_of(dap, struct adiv5_swd_dap, dap);
+	const struct swd_driver *swd = swd_dap->swd;
 	assert(swd);
 
 	swd_finish_read(dap);
@@ -169,7 +175,8 @@ static void swd_queue_ap_bankselect(struct adiv5_dap *dap, unsigned reg)
 static int swd_queue_ap_read(struct adiv5_dap *dap, unsigned reg,
 		uint32_t *data)
 {
-	const struct swd_driver *swd = jtag_interface->swd;
+	struct adiv5_swd_dap *swd_dap = container_of(dap, struct adiv5_swd_dap, dap);
+	const struct swd_driver *swd = swd_dap->swd;
 	assert(swd);
 
 	swd_queue_ap_bankselect(dap, reg);
@@ -182,7 +189,8 @@ static int swd_queue_ap_read(struct adiv5_dap *dap, unsigned reg,
 static int swd_queue_ap_write(struct adiv5_dap *dap, unsigned reg,
 		uint32_t data)
 {
-	const struct swd_driver *swd = jtag_interface->swd;
+	struct adiv5_swd_dap *swd_dap = container_of(dap, struct adiv5_swd_dap, dap);
+	const struct swd_driver *swd = swd_dap->swd;
 	assert(swd);
 
 	swd_finish_read(dap);
@@ -250,7 +258,7 @@ static const uint8_t jtag2swd_bitseq[] = {
  */
 int dap_to_swd(struct target *target)
 {
-	struct arm *arm = target_to_arm(target);
+    struct arm *arm = target_to_arm(target);
 	int retval;
 
 	if (!arm->dap) {
@@ -269,9 +277,6 @@ int dap_to_swd(struct target *target)
 	if (retval == ERROR_OK)
 		retval = jtag_execute_queue();
 
-	/* set up the DAP's ops vector for SWD mode. */
-	arm->dap->ops = &swd_dap_ops;
-
 	return retval;
 }
 
@@ -375,7 +380,11 @@ static int swd_select(struct command_context *ctx)
 	if (retval != ERROR_OK)
 		return retval;
 
-	const struct swd_driver *swd = jtag_interface->swd;
+	struct target *target = get_current_target(ctx);
+	struct arm *arm = target_to_arm(target);
+	struct adiv5_dap *dap = arm->dap;
+	struct adiv5_swd_dap *swd_dap = container_of(dap, struct adiv5_swd_dap, dap);
+	const struct swd_driver *swd = swd_dap->swd;
 
 	 /* be sure driver is in SWD mode; start
 	  * with hardware default TRN (1), it can be changed later
@@ -391,6 +400,8 @@ static int swd_select(struct command_context *ctx)
 		return retval;
 	}
 
+	global_dap = adiv5_swd_dap_new(swd);
+
 	/* force DAP into SWD mode (not JTAG) */
 	/*retval = dap_to_swd(target);*/
 
@@ -411,10 +422,6 @@ static int swd_init(struct command_context *ctx)
 	uint32_t idcode;
 	int status;
 
-	/* Force the DAP's ops vector for SWD mode.
-	 * messy - is there a better way? */
-	arm->dap->ops = &swd_dap_ops;
-
 	/* FIXME validate transport config ... is the
 	 * configured DAP present (check IDCODE)?
 	 * Is *only* one DAP configured?
@@ -456,3 +463,20 @@ bool transport_is_swd(void)
 {
 	return get_current_transport() == &swd_transport;
 }
+
+void adiv5_swd_dap_create(struct adiv5_swd_dap *swd_dap, const struct swd_driver *swd)
+{
+	/* TODO: Maybe create the super class, i.e. adiv5_dap_create(&swd_dap->dap); */
+	swd_dap->dap.ops = &swd_dap_ops;
+	swd_dap->swd = swd;
+}
+
+struct adiv5_dap *adiv5_swd_dap_new(const struct swd_driver *swd)
+{
+	struct adiv5_swd_dap *swd_dap = calloc(1, sizeof(*swd_dap));
+	if (swd_dap == NULL)
+		return NULL;
+
+	adiv5_swd_dap_create(swd_dap, swd);
+	return &swd_dap->dap;
+}
diff --git a/src/target/arm.h b/src/target/arm.h
index 88b5902..5bea751 100644
--- a/src/target/arm.h
+++ b/src/target/arm.h
@@ -67,6 +67,14 @@ enum arm_mode {
 	ARM_MODE_USER_THREAD = 1,
 	ARM_MODE_HANDLER = 2,
 
+	//ARM_MODE_EL0t = 0, same as ARM_MODE_THREAD
+	ARM_MODE_EL1t = 4,
+	ARM_MODE_EL1h = 5,
+	ARM_MODE_EL2t = 8,
+	ARM_MODE_EL2h = 9,
+	ARM_MODE_EL3t = 12,
+	ARM_MODE_EL3h = 13,
+
 	ARM_MODE_ANY = -1
 };
 
@@ -128,6 +136,9 @@ struct arm {
 	/** Flag reporting armv6m based core. */
 	bool is_armv6m;
 
+	/** Flag reporting armv6m based core. */
+	bool is_armv8;
+
 	/** Flag reporting whether semihosting is active. */
 	bool is_semihosting;
 
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index a059531..95a18bc 100644
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -77,6 +77,8 @@
 #include "arm_adi_v5.h"
 #include <helper/time_support.h>
 
+struct adiv5_dap *global_dap;
+
 /* ARM ADI Specification requires at least 10 bits used for TAR autoincrement  */
 
 /*
@@ -105,10 +107,8 @@ static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address
  */
 void dap_ap_select(struct adiv5_dap *dap, uint8_t ap)
 {
-	uint32_t new_ap = (ap << 24) & 0xFF000000;
-
-	if (new_ap != dap->ap_current) {
-		dap->ap_current = new_ap;
+	if (ap != dap->ap_current) {
+		dap->ap_current = ap;
 		/* Switching AP invalidates cached values.
 		 * Values MUST BE UPDATED BEFORE AP ACCESS.
 		 */
@@ -121,7 +121,7 @@ void dap_ap_select(struct adiv5_dap *dap, uint8_t ap)
 static int dap_setup_accessport_csw(struct adiv5_dap *dap, uint32_t csw)
 {
 	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT |
-		dap->apcsw[dap->ap_current >> 24];
+		dap->apcsw[dap->ap_current];
 
 	if (csw != dap->ap_csw_value) {
 		/* LOG_DEBUG("DAP: Set CSW %x",csw); */
@@ -646,21 +646,15 @@ int ahbap_debugport_init(struct adiv5_dap *dap)
 
 	LOG_DEBUG(" ");
 
-	/* JTAG-DP or SWJ-DP, in JTAG mode
-	 * ... for SWD mode this is patched as part
-	 * of link switchover
-	 */
-	if (!dap->ops)
-		dap->ops = &jtag_dp_ops;
-
 	/* Default MEM-AP setup.
 	 *
 	 * REVISIT AP #0 may be an inappropriate default for this.
 	 * Should we probe, or take a hint from the caller?
 	 * Presumably we can ignore the possibility of multiple APs.
 	 */
+	/*SQU: Should not hard coded it. Let's hard coded in cortex-m and cortex-a for now
 	dap->ap_current = !0;
-	dap_ap_select(dap, 0);
+	dap_ap_select(dap, 0);*/
 	dap->last_read = NULL;
 
 	/* DP initialization */
@@ -692,12 +686,13 @@ int ahbap_debugport_init(struct adiv5_dap *dap)
 	if (retval != ERROR_OK)
 		return retval;
 
-	LOG_DEBUG("DAP: wait CSYSPWRUPACK");
+	/*LOG_DEBUG("DAP: wait CSYSPWRUPACK");
 	retval = dap_dp_poll_register(dap, DP_CTRL_STAT,
 				      CSYSPWRUPACK, CSYSPWRUPACK,
 				      DAP_POWER_DOMAIN_TIMEOUT);
 	if (retval != ERROR_OK)
-		return retval;
+		//return retval; SQU: for QCOM chip, ignore this as without bootloader, this bit might be not set
+        LOG_USER("DAP: Timeout for waiting CSYSPWRUPACK");*/
 
 	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
 	if (retval != ERROR_OK)
@@ -722,7 +717,8 @@ int ahbap_debugport_init(struct adiv5_dap *dap)
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = dap_queue_ap_read(dap, AP_REG_CFG, &cfg);
+	//retval = dap_queue_ap_read(dap, AP_REG_CFG, &cfg); SQU: for Krait this will cause problem
+    cfg=0xF;
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -798,8 +794,8 @@ int dap_find_ap(struct adiv5_dap *dap, enum ap_type type_to_find, uint8_t *ap_nu
 		 * 31-28 : Revision
 		 * 27-24 : JEDEC bank (0x4 for ARM)
 		 * 23-17 : JEDEC code (0x3B for ARM)
-		 * 16    : Mem-AP
-		 * 15-8  : Reserved
+		 * 16-13 : Mem-AP
+		 * 12-8  : Reserved
 		 *  7-0  : AP Identity (1=AHB-AP 2=APB-AP 0x10=JTAG-AP)
 		 */
 
@@ -808,12 +804,13 @@ int dap_find_ap(struct adiv5_dap *dap, enum ap_type type_to_find, uint8_t *ap_nu
 		 */
 		if ((retval == ERROR_OK) &&                  /* Register read success */
 			((id_val & 0x0FFF0000) == 0x04770000) && /* Jedec codes match */
-			((id_val & 0xFF) == type_to_find)) {     /* type matches*/
+			((id_val & 0xFF) == type_to_find)) {     /* type matches. SQU: updated based on ADI V5+*/
 
 			LOG_DEBUG("Found %s at AP index: %d (IDR=0x%08" PRIX32 ")",
 						(type_to_find == AP_TYPE_AHB_AP)  ? "AHB-AP"  :
 						(type_to_find == AP_TYPE_APB_AP)  ? "APB-AP"  :
-						(type_to_find == AP_TYPE_JTAG_AP) ? "JTAG-AP" : "Unknown",
+						(type_to_find == AP_TYPE_JTAG_AP) ? "JTAG-AP" :
+						(type_to_find == AP_TYPE_AXI_AP)  ? "AXI-AP"  : "Unknown",
 						ap, id_val);
 
 			*ap_num_out = ap;
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index dee3117..160478a 100644
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -140,7 +140,6 @@
 struct adiv5_dap {
 	const struct dap_ops *ops;
 
-	struct arm_jtag *jtag_info;
 	/* Control config */
 	uint32_t dp_ctrl_stat;
 
@@ -200,18 +199,22 @@ struct adiv5_dap {
 	uint32_t	memaccess_tck;
 
 	/* Size of TAR autoincrement block, ARM ADI Specification requires at least 10 bits */
+	/* FIXME: This is not a feature of the DAP, it's specific to the MEM-AP used. */
 	uint32_t tar_autoincr_block;
 
 	/* true if packed transfers are supported by the MEM-AP */
+	/* FIXME: This is not a feature of the DAP, it's specific to the MEM-AP used. */
 	bool packed_transfers;
 
 	/* true if unaligned memory access is not supported by the MEM-AP */
+	/* FIXME: This is not a feature of the DAP, it's specific to the MEM-AP used. */
 	bool unaligned_access_bad;
 
 	/* The TI TMS470 and TMS570 series processors use a BE-32 memory ordering
 	 * despite lack of support in the ARMv7 architecture. Memory access through
 	 * the AHB-AP has strange byte ordering these processors, and we need to
 	 * swizzle appropriately. */
+	/* FIXME: This is not a feature of the DAP, it's specific to the MEM-AP used. */
 	bool ti_be_32_quirks;
 };
 
@@ -255,7 +258,8 @@ struct dap_ops {
 enum ap_type {
 	AP_TYPE_AHB_AP  = 0x01,  /* AHB Memory-AP */
 	AP_TYPE_APB_AP  = 0x02,  /* APB Memory-AP */
-	AP_TYPE_JTAG_AP = 0x10   /* JTAG-AP - JTAG master for controlling other JTAG devices */
+	AP_TYPE_JTAG_AP = 0x10,  /* JTAG-AP - JTAG master for controlling other JTAG devices */
+	AP_TYPE_AXI_AP  = 0x04,  /* AXI3/AXI4 Memory-AP */
 };
 
 /**
@@ -405,7 +409,7 @@ static inline int dap_dp_poll_register(struct adiv5_dap *dap, unsigned reg,
 /** Accessor for currently selected DAP-AP number (0..255) */
 static inline uint8_t dap_ap_get_select(struct adiv5_dap *swjdp)
 {
-	return (uint8_t)(swjdp->ap_current >> 24);
+	return (uint8_t)(swjdp->ap_current);
 }
 
 /* AP selection applies to future AP transactions */
@@ -480,6 +484,12 @@ int dap_to_swd(struct target *target);
 /* Put debug link into JTAG mode */
 int dap_to_jtag(struct target *target);
 
+extern struct adiv5_dap *global_dap;
+
+struct swd_driver;
+struct adiv5_dap *adiv5_jtag_dap_new(struct jtag_tap *tap);
+struct adiv5_dap *adiv5_swd_dap_new(const struct swd_driver *swd);
+
 extern const struct command_registration dap_command_handlers[];
 
 #endif
diff --git a/src/target/arm_opcodes.h b/src/target/arm_opcodes.h
index 81c4766..5490319 100644
--- a/src/target/arm_opcodes.h
+++ b/src/target/arm_opcodes.h
@@ -83,6 +83,7 @@
  */
 #define ARMV4_5_MSR_GP(Rm, Field, R) \
 	(0xe120f000 | (Rm) | ((Field) << 16) | ((R) << 22))
+
 #define ARMV4_5_MSR_IM(Im, Rotate, Field, R) \
 	(0xe320f000 | (Im)  | ((Rotate) << 8) | ((Field) << 16) | ((R) << 22))
 
@@ -175,6 +176,16 @@
 	(0xee100010 | (CRm) | ((op2) << 5) | ((CP) << 8) \
 	| ((Rd) << 12) | ((CRn) << 16) | ((op1) << 21))
 
+#define ARMV8_T32_MRC(CP, op1, Rd, CRn, CRm, op2) \
+	(0x0010ee10 | ((CRm)<<16) | ((op2) << 21) | ((CP) << 24) \
+	| ((Rd) << 28) | (CRn) | ((op1) << 5))
+
+#define ARMV8_A64_MSR(op0, op1, CRn, CRm, op2, Rt) \
+	(0xD5100000 | (0<<21) | ((op0-2)<<19) | (op1<<16) | (CRn<<12) | (CRm<<8) | (op2<<5) | Rt)
+
+#define ARMV8_A64_MRS(op0, op1, CRn, CRm, op2, Rt) \
+	(0xD5100000 | (1<<21) | ((op0-2)<<19) | (op1<<16) | (CRn<<12) | (CRm<<8) | (op2<<5) | Rt)
+
 /* Move to coprocessor from ARM register
  * CP: Coprocessor number
  * op1: Coprocessor opcode
@@ -187,11 +198,19 @@
 	(0xee000010 | (CRm) | ((op2) << 5) | ((CP) << 8) \
 	| ((Rd) << 12) | ((CRn) << 16) | ((op1) << 21))
 
+#define ARMV8_T32_MCR(CP, op1, Rd, CRn, CRm, op2) \
+	(0x0010ee00 | ((CRm)<<16) | ((op2) << 21) | ((CP) << 24) \
+	| ((Rd) << 28) | (CRn) | ((op1) << 5))
+
+
 /* Breakpoint instruction (ARMv5)
  * Im: 16-bit immediate
  */
-#define ARMV5_BKPT(Im) (0xe1200070 | ((Im & 0xfff0) << 8) | (Im & 0xf))
-
+//#define ARMV5_BKPT(Im) (0xe1200070 | ((Im & 0xfff0) << 8) | (Im & 0xf))
+//SQU: bug in above code. Updated as below:
+#define ARMV5_BKPT(Im) (0xe1200070 | ((Im & 0xfff0) << 4) | (Im & 0xf))
+#define ARMV8_A64_HLT(Im) (0xD4400000 | (Im << 5) )
+#define ARMV8_A32_HLT(Im) (0xE1000070 | ((Im & 0xfff0) << 4) | (Im & 0xf))
 
 /* Thumb mode instructions
  *
@@ -279,7 +298,7 @@
 #define ARMV5_T_BKPT(Im) \
 	((0xbe00 | (Im)) \
 	| ((0xbe00 | (Im)) << 16))
-
+#define ARMV8_T_HLT(Im) (0xBA80 | (Im))
 /* Move to Register from Special Register
  *	32 bit Thumb2 instruction
  * Rd: destination register
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index dc77af2..c905357 100644
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -155,6 +155,7 @@ static const struct {
 		.name = "Handler",
 		.psr = ARM_MODE_HANDLER,
 	},
+
 };
 
 /** Map PSR mode bits to the name of an ARM processor operating mode. */
@@ -442,7 +443,7 @@ struct reg *arm_reg_current(struct arm *arm, unsigned regnum)
 		return NULL;
 
 	if (!arm->map) {
-		LOG_ERROR("Register map is not available yet, the target is not fully initialised");
+		LOG_ERROR("Register map is not available yet, the target is not fully initialized");
 		r = arm->core_cache->reg_list + regnum;
 	} else
 		r = arm->core_cache->reg_list + arm->map[regnum];
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 341114b..5cd7a64 100644
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -92,11 +92,10 @@ struct armv7a_common {
 	int common_magic;
 	struct reg_cache *core_cache;
 
-	struct adiv5_dap dap;
-
 	/* Core Debug Unit */
 	struct arm_dpm dpm;
 	uint32_t debug_base;
+	uint32_t cti_base;
 	uint8_t debug_ap;
 	uint8_t memory_ap;
 	bool memory_ap_available;
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 86c9aee..ca409df 100644
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -144,7 +144,6 @@ struct armv7m_common {
 
 	int common_magic;
 	int exception_number;
-	struct adiv5_dap dap;
 
 	int fp_feature;
 	uint32_t demcr;
diff --git a/src/target/armv8.c b/src/target/armv8.c
new file mode 100755
index 0000000..bfc09fe
--- /dev/null
+++ b/src/target/armv8.c
@@ -0,0 +1,1535 @@
+/* Modified from armv4_5.c by Strong Qu for supporting ARMv8. For license, refer to original code */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arm.h"
+#include "armv4_5.h"
+#include "arm_jtag.h"
+#include "breakpoints.h"
+#include "arm_disassembler.h"
+#include <helper/binarybuffer.h>
+#include "algorithm.h"
+#include "register.h"
+#include "armv8.h"
+
+#define keep_old_code 0
+
+/* offsets into armv4_5 core register cache */
+enum {
+/*	ARMV4_5_CPSR = 31, */
+	ARMV4_5_SPSR_FIQ = 32,
+	ARMV4_5_SPSR_IRQ = 33,
+	ARMV4_5_SPSR_SVC = 34,
+	ARMV4_5_SPSR_ABT = 35,
+	ARMV4_5_SPSR_UND = 36,
+	ARM_SPSR_MON = 41,
+};
+
+static const uint8_t arm_usr_indices[17] = {
+	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, ARMV4_5_CPSR,
+};
+
+static const uint8_t arm_fiq_indices[8] = {
+	16, 17, 18, 19, 20, 21, 22, ARMV4_5_SPSR_FIQ,
+};
+
+static const uint8_t arm_irq_indices[3] = {
+	23, 24, ARMV4_5_SPSR_IRQ,
+};
+
+static const uint8_t arm_svc_indices[3] = {
+	25, 26, ARMV4_5_SPSR_SVC,
+};
+
+static const uint8_t arm_abt_indices[3] = {
+	27, 28, ARMV4_5_SPSR_ABT,
+};
+
+static const uint8_t arm_und_indices[3] = {
+	29, 30, ARMV4_5_SPSR_UND,
+};
+
+static const uint8_t arm_mon_indices[3] = {
+	39, 40, ARM_SPSR_MON,
+};
+
+static const struct {
+	const char *name;
+	unsigned short psr;
+	/* For user and system modes, these list indices for all registers.
+	 * otherwise they're just indices for the shadow registers and SPSR.
+	 */
+	unsigned short n_indices;
+	const uint8_t *indices;
+} arm_mode_data[] = {
+	/* Seven modes are standard from ARM7 on. "System" and "User" share
+	 * the same registers; other modes shadow from 3 to 8 registers.
+	 */
+	{
+		.name = "User",
+		.psr = ARM_MODE_USR,
+		.n_indices = ARRAY_SIZE(arm_usr_indices),
+		.indices = arm_usr_indices,
+	},
+	{
+		.name = "FIQ",
+		.psr = ARM_MODE_FIQ,
+		.n_indices = ARRAY_SIZE(arm_fiq_indices),
+		.indices = arm_fiq_indices,
+	},
+	{
+		.name = "Supervisor",
+		.psr = ARM_MODE_SVC,
+		.n_indices = ARRAY_SIZE(arm_svc_indices),
+		.indices = arm_svc_indices,
+	},
+	{
+		.name = "Abort",
+		.psr = ARM_MODE_ABT,
+		.n_indices = ARRAY_SIZE(arm_abt_indices),
+		.indices = arm_abt_indices,
+	},
+	{
+		.name = "IRQ",
+		.psr = ARM_MODE_IRQ,
+		.n_indices = ARRAY_SIZE(arm_irq_indices),
+		.indices = arm_irq_indices,
+	},
+	{
+		.name = "Undefined instruction",
+		.psr = ARM_MODE_UND,
+		.n_indices = ARRAY_SIZE(arm_und_indices),
+		.indices = arm_und_indices,
+	},
+	{
+		.name = "System",
+		.psr = ARM_MODE_SYS,
+		.n_indices = ARRAY_SIZE(arm_usr_indices),
+		.indices = arm_usr_indices,
+	},
+	/* TrustZone "Security Extensions" add a secure monitor mode.
+	 * This is distinct from a "debug monitor" which can support
+	 * non-halting debug, in conjunction with some debuggers.
+	 */
+	{
+		.name = "Secure Monitor",
+		.psr = ARM_MODE_MON,
+		.n_indices = ARRAY_SIZE(arm_mon_indices),
+		.indices = arm_mon_indices,
+	},
+
+	/* These special modes are currently only supported
+	 * by ARMv6M and ARMv7M profiles */
+	{
+		.name = "Thread/EL0t",
+		.psr = ARM_MODE_THREAD,
+	},
+	{
+		.name = "Thread (User)",
+		.psr = ARM_MODE_USER_THREAD,
+	},
+	{
+		.name = "Handler",
+		.psr = ARM_MODE_HANDLER,
+	},
+
+	/* EL0t treated same as ARM_MODE_THREAD
+    {
+		.name = "EL0t",
+		.psr = ARM_MODE_EL0t,
+	},*/
+	{
+		.name = "EL1t",
+		.psr = ARM_MODE_EL1t,
+	},
+	{
+		.name = "EL1h",
+		.psr = ARM_MODE_EL1h,
+	},
+	{
+		.name = "EL2t",
+		.psr = ARM_MODE_EL2t,
+	},
+	{
+		.name = "EL2h",
+		.psr = ARM_MODE_EL2h,
+	},
+	{
+		.name = "EL3t",
+		.psr = ARM_MODE_EL3t,
+	},
+	{
+		.name = "EL3h",
+		.psr = ARM_MODE_EL3h,
+	},
+};
+
+#if keep_old_code
+/** Map PSR mode bits to the name of an ARM processor operating mode. */
+const char *arm_mode_name(unsigned psr_mode)
+{
+	for (unsigned i = 0; i < ARRAY_SIZE(arm_mode_data); i++) {
+		if (arm_mode_data[i].psr == psr_mode)
+			return arm_mode_data[i].name;
+	}
+	LOG_ERROR("unrecognized psr mode: %#02x", psr_mode);
+	return "UNRECOGNIZED";
+}
+
+/** Return true iff the parameter denotes a valid ARM processor mode. */
+bool is_arm_mode(unsigned psr_mode)
+{
+	for (unsigned i = 0; i < ARRAY_SIZE(arm_mode_data); i++) {
+		if (arm_mode_data[i].psr == psr_mode)
+			return true;
+	}
+	return false;
+}
+
+/** Map PSR mode bits to linear number indexing armv4_5_core_reg_map */
+int arm_mode_to_number(enum arm_mode mode)
+{
+	switch (mode) {
+		case ARM_MODE_ANY:
+		/* map MODE_ANY to user mode */
+		case ARM_MODE_USR:
+			return 0;
+		case ARM_MODE_FIQ:
+			return 1;
+		case ARM_MODE_IRQ:
+			return 2;
+		case ARM_MODE_SVC:
+			return 3;
+		case ARM_MODE_ABT:
+			return 4;
+		case ARM_MODE_UND:
+			return 5;
+		case ARM_MODE_SYS:
+			return 6;
+		case ARM_MODE_MON:
+			return 7;
+		default:
+			LOG_ERROR("invalid mode value encountered %d", mode);
+			return -1;
+	}
+}
+
+/** Map linear number indexing armv4_5_core_reg_map to PSR mode bits. */
+enum arm_mode armv4_5_number_to_mode(int number)
+{
+	switch (number) {
+		case 0:
+			return ARM_MODE_USR;
+		case 1:
+			return ARM_MODE_FIQ;
+		case 2:
+			return ARM_MODE_IRQ;
+		case 3:
+			return ARM_MODE_SVC;
+		case 4:
+			return ARM_MODE_ABT;
+		case 5:
+			return ARM_MODE_UND;
+		case 6:
+			return ARM_MODE_SYS;
+		case 7:
+			return ARM_MODE_MON;
+		default:
+			LOG_ERROR("mode index out of bounds %d", number);
+			return ARM_MODE_ANY;
+	}
+}
+
+static const char *arm_state_strings[] = {
+	"ARM", "Thumb", "Jazelle", "ThumbEE",
+};
+#endif
+
+/* Templates for ARM core registers.
+ *
+ * NOTE:  offsets in this table are coupled to the arm_mode_data
+ * table above, the armv4_5_core_reg_map array below, and also to
+ * the ARMV4_5_CPSR symbol (which should vanish after ARM11 updates).
+ */
+static const struct {
+	/* The name is used for e.g. the "regs" command. */
+	const char *name;
+
+	/* The {cookie, mode} tuple uniquely identifies one register.
+	 * In a given mode, cookies 0..15 map to registers R0..R15,
+	 * with R13..R15 usually called SP, LR, PC.
+	 *
+	 * MODE_ANY is used as *input* to the mapping, and indicates
+	 * various special cases (sigh) and errors.
+	 *
+	 * Cookie 16 is (currently) confusing, since it indicates
+	 * CPSR -or- SPSR depending on whether 'mode' is MODE_ANY.
+	 * (Exception modes have both CPSR and SPSR registers ...)
+	 */
+	unsigned cookie;
+	unsigned gdb_index;
+	enum arm_mode mode;
+} arm_core_regs[] = {
+	/* IMPORTANT:  we guarantee that the first eight cached registers
+	 * correspond to r0..r7, and the fifteenth to PC, so that callers
+	 * don't need to map them.
+	 */
+	{ .name = "x0", .cookie = 0, .mode = ARM_MODE_ANY, .gdb_index = 0, },
+	{ .name = "x1", .cookie = 1, .mode = ARM_MODE_ANY, .gdb_index = 1, },
+	{ .name = "x2", .cookie = 2, .mode = ARM_MODE_ANY, .gdb_index = 2, },
+	{ .name = "x3", .cookie = 3, .mode = ARM_MODE_ANY, .gdb_index = 3, },
+	{ .name = "x4", .cookie = 4, .mode = ARM_MODE_ANY, .gdb_index = 4, },
+	{ .name = "x5", .cookie = 5, .mode = ARM_MODE_ANY, .gdb_index = 5, },
+	{ .name = "x6", .cookie = 6, .mode = ARM_MODE_ANY, .gdb_index = 6, },
+	{ .name = "x7", .cookie = 7, .mode = ARM_MODE_ANY, .gdb_index = 7, },
+	{ .name = "x8", .cookie = 8, .mode = ARM_MODE_ANY, .gdb_index = 8, },
+	{ .name = "x9", .cookie = 9, .mode = ARM_MODE_ANY, .gdb_index = 9, },
+	{ .name = "x10", .cookie = 10, .mode = ARM_MODE_ANY, .gdb_index = 10, },
+	{ .name = "x11", .cookie = 11, .mode = ARM_MODE_ANY, .gdb_index = 11, },
+	{ .name = "x12", .cookie = 12, .mode = ARM_MODE_ANY, .gdb_index = 12, },
+	{ .name = "x13", .cookie = 13, .mode = ARM_MODE_ANY, .gdb_index = 13, },
+	{ .name = "x14", .cookie = 14, .mode = ARM_MODE_ANY, .gdb_index = 14, },
+	{ .name = "x15", .cookie = 15, .mode = ARM_MODE_ANY, .gdb_index = 15, },
+	{ .name = "x16", .cookie = 16, .mode = ARM_MODE_ANY, .gdb_index = 16, },
+	{ .name = "x17", .cookie = 17, .mode = ARM_MODE_ANY, .gdb_index = 17, },
+	{ .name = "x18", .cookie = 18, .mode = ARM_MODE_ANY, .gdb_index = 18, },
+	{ .name = "x19", .cookie = 19, .mode = ARM_MODE_ANY, .gdb_index = 19, },
+	{ .name = "x20", .cookie = 20, .mode = ARM_MODE_ANY, .gdb_index = 20, },
+	{ .name = "x21", .cookie = 21, .mode = ARM_MODE_ANY, .gdb_index = 21, },
+	{ .name = "x22", .cookie = 22, .mode = ARM_MODE_ANY, .gdb_index = 22, },
+	{ .name = "x23", .cookie = 23, .mode = ARM_MODE_ANY, .gdb_index = 23, },
+	{ .name = "x24", .cookie = 24, .mode = ARM_MODE_ANY, .gdb_index = 24, },
+	{ .name = "x25", .cookie = 25, .mode = ARM_MODE_ANY, .gdb_index = 25, },
+	{ .name = "x26", .cookie = 26, .mode = ARM_MODE_ANY, .gdb_index = 26, },
+	{ .name = "x27", .cookie = 27, .mode = ARM_MODE_ANY, .gdb_index = 27, },
+	{ .name = "x28", .cookie = 28, .mode = ARM_MODE_ANY, .gdb_index = 28, },
+	{ .name = "x29", .cookie = 29, .mode = ARM_MODE_ANY, .gdb_index = 29, },
+	{ .name = "x30", .cookie = 30, .mode = ARM_MODE_ANY, .gdb_index = 30, },
+	{ .name = "x31", .cookie = 31, .mode = ARM_MODE_ANY, .gdb_index = 31, },
+	{ .name = "pc", .cookie = 32, .mode = ARM_MODE_ANY, .gdb_index = 32, },
+	{ .name = "cpsr", .cookie = 33, .mode = ARM_MODE_ANY, .gdb_index = 33, },
+};
+
+#if use_old_code
+/* map core mode (USR, FIQ, ...) and register number to
+ * indices into the register cache
+ */
+const int armv4_5_core_reg_map[8][17] = {
+	{	/* USR */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 31
+	},
+	{	/* FIQ (8 shadows of USR, vs normal 3) */
+		0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 15, 32
+	},
+	{	/* IRQ */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 23, 24, 15, 33
+	},
+	{	/* SVC */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 25, 26, 15, 34
+	},
+	{	/* ABT */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 27, 28, 15, 35
+	},
+	{	/* UND */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 29, 30, 15, 36
+	},
+	{	/* SYS (same registers as USR) */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 31
+	},
+	{	/* MON */
+		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 37, 38, 15, 39,
+	}
+};
+
+/**
+ * Configures host-side ARM records to reflect the specified CPSR.
+ * Later, code can use arm_reg_current() to map register numbers
+ * according to how they are exposed by this mode.
+ */
+void arm_set_cpsr(struct arm *arm, uint32_t cpsr)
+{
+	enum arm_mode mode = cpsr & 0x1f;
+	int num;
+
+	/* NOTE:  this may be called very early, before the register
+	 * cache is set up.  We can't defend against many errors, in
+	 * particular against CPSRs that aren't valid *here* ...
+	 */
+	if (arm->cpsr) {
+		buf_set_u32(arm->cpsr->value, 0, 32, cpsr);
+		arm->cpsr->valid = 1;
+		arm->cpsr->dirty = 0;
+	}
+
+	arm->core_mode = mode;
+
+	/* mode_to_number() warned; set up a somewhat-sane mapping */
+	num = arm_mode_to_number(mode);
+	if (num < 0) {
+		mode = ARM_MODE_USR;
+		num = 0;
+	}
+
+	arm->map = &armv4_5_core_reg_map[num][0];
+	arm->spsr = (mode == ARM_MODE_USR || mode == ARM_MODE_SYS)
+		? NULL
+		: arm->core_cache->reg_list + arm->map[16];
+
+	/* Older ARMs won't have the J bit */
+	enum arm_state state;
+
+	if (cpsr & (1 << 5)) {	/* T */
+		if (cpsr & (1 << 24)) {	/* J */
+			LOG_WARNING("ThumbEE -- incomplete support");
+			state = ARM_STATE_THUMB_EE;
+		} else
+			state = ARM_STATE_THUMB;
+	} else {
+		if (cpsr & (1 << 24)) {	/* J */
+			LOG_ERROR("Jazelle state handling is BROKEN!");
+			state = ARM_STATE_JAZELLE;
+		} else
+			state = ARM_STATE_ARM;
+	}
+	arm->core_state = state;
+
+	LOG_DEBUG("set CPSR %#8.8x: %s mode, %s state", (unsigned) cpsr,
+		arm_mode_name(mode),
+		arm_state_strings[arm->core_state]);
+}
+#endif
+
+/**
+ * Returns handle to the register currently mapped to a given number.
+ * Someone must have called arm_set_cpsr() before.
+ *
+ * \param arm This core's state and registers are used.
+ * \param regnum From 0..15 corresponding to R0..R14 and PC.
+ *	Note that R0..R7 don't require mapping; you may access those
+ *	as the first eight entries in the register cache.  Likewise
+ *	R15 (PC) doesn't need mapping; you may also access it directly.
+ *	However, R8..R14, and SPSR (arm->spsr) *must* be mapped.
+ *	CPSR (arm->cpsr) is also not mapped.
+ */
+struct reg *armv8_reg_current(struct arm *arm, unsigned regnum)
+{
+	struct reg *r;
+
+	if (regnum > 33)
+		return NULL;
+
+	if (!arm->map) {
+		LOG_ERROR("Register map is not available yet, the target is not fully initialized");
+		r = arm->core_cache->reg_list + regnum;
+	} else
+		r = arm->core_cache->reg_list + arm->map[regnum];
+
+	/* e.g. invalid CPSR said "secure monitor" mode on a core
+	 * that doesn't support it...
+	 */
+	if (!r) {
+		LOG_ERROR("Invalid CPSR mode");
+		r = arm->core_cache->reg_list + regnum;
+	}
+
+	return r;
+}
+
+static int armv8_get_core_reg(struct reg *reg)
+{
+	int retval;
+	struct arm_reg *reg_arch_info = reg->arch_info;
+	struct target *target = reg_arch_info->target;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	retval = reg_arch_info->arm->read_core_reg(target, reg,
+			reg_arch_info->num, reg_arch_info->mode);
+	if (retval == ERROR_OK) {
+		reg->valid = 1;
+		reg->dirty = 0;
+	}
+
+	return retval;
+}
+
+static int armv8_set_core_reg(struct reg *reg, uint8_t *buf)
+{
+	struct arm_reg *reg_arch_info = reg->arch_info;
+	struct target *target = reg_arch_info->target;
+	struct arm *armv4_5_target = target_to_arm(target);
+	uint32_t value = buf_get_u32(buf, 0, 32);
+
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("Target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* Except for CPSR, the "reg" command exposes a writeback model
+	 * for the register cache.
+	 */
+	if (reg == armv4_5_target->cpsr) {
+		arm_set_cpsr(armv4_5_target, value);
+
+		/* Older cores need help to be in ARM mode during halt
+		 * mode debug, so we clear the J and T bits if we flush.
+		 * For newer cores (v6/v7a/v7r) we don't need that, but
+		 * it won't hurt since CPSR is always flushed anyway.
+		 */
+		if (armv4_5_target->core_mode !=
+			(enum arm_mode)(value & 0x1f)) {
+			LOG_DEBUG("changing ARM core mode to '%s'",
+				arm_mode_name(value & 0x1f));
+			value &= ~((1 << 24) | (1 << 5));
+			armv4_5_target->write_core_reg(target, reg,
+				16, ARM_MODE_ANY, value);
+		}
+	} else {
+		buf_set_u32(reg->value, 0, 32, value);
+		reg->valid = 1;
+	}
+	reg->dirty = 1;
+
+	return ERROR_OK;
+}
+
+static const struct reg_arch_type armv8_reg_type = {
+	.get = armv8_get_core_reg,
+	.set = armv8_set_core_reg,
+};
+
+struct reg_cache *armv8_build_reg_cache(struct target *target, struct arm *arm)
+{
+	int num_regs = ARRAY_SIZE(arm_core_regs);
+	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
+	struct reg *reg_list = calloc(num_regs, sizeof(struct reg));
+	struct arm_reg *reg_arch_info = calloc(num_regs, sizeof(struct arm_reg));
+	int i;
+
+	if (!cache || !reg_list || !reg_arch_info) {
+		free(cache);
+		free(reg_list);
+		free(reg_arch_info);
+		return NULL;
+	}
+
+	cache->name = "ARM registers";
+	cache->next = NULL;
+	cache->reg_list = reg_list;
+	cache->num_regs = 0;
+
+	for (i = 0; i < num_regs; i++) {
+		reg_arch_info[i].num = arm_core_regs[i].cookie;
+		reg_arch_info[i].mode = arm_core_regs[i].mode;
+		reg_arch_info[i].target = target;
+		reg_arch_info[i].arm = arm;
+
+		reg_list[i].name = (char *) arm_core_regs[i].name;
+		reg_list[i].number = arm_core_regs[i].gdb_index;
+		reg_list[i].size = 64;
+		reg_list[i].value = &reg_arch_info[i].value;
+		reg_list[i].type = &armv8_reg_type;
+		reg_list[i].arch_info = &reg_arch_info[i];
+		reg_list[i].exist = true;
+
+		/* This really depends on the calling convention in use */
+		reg_list[i].caller_save = false;
+
+		/* Registers data type, as used by GDB target description */
+		reg_list[i].reg_data_type = malloc(sizeof(struct reg_data_type));
+		switch (arm_core_regs[i].cookie) {
+		case 31: //sp
+			reg_list[i].reg_data_type->type = REG_TYPE_DATA_PTR;
+			break;
+		case 30: //lr
+		case 32: //pc
+			reg_list[i].reg_data_type->type = REG_TYPE_CODE_PTR;
+		    break;
+		default:
+			reg_list[i].reg_data_type->type = REG_TYPE_UINT64;
+		    break;
+		}
+
+		/* let GDB shows banked registers only in "info all-reg" */
+		reg_list[i].feature = malloc(sizeof(struct reg_feature));
+		reg_list[i].feature->name = "org.gnu.gdb.arm.core";
+		reg_list[i].group = "general";
+
+		cache->num_regs++;
+	}
+
+	arm->pc = reg_list + 32;
+	arm->cpsr = reg_list + 33;
+	arm->core_cache = cache;
+	return cache;
+}
+
+#if use_old_code
+int arm_arch_state(struct target *target)
+{
+	struct arm *arm = target_to_arm(target);
+
+	if (arm->common_magic != ARM_COMMON_MAGIC) {
+		LOG_ERROR("BUG: called for a non-ARM target");
+		return ERROR_FAIL;
+	}
+
+	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
+		"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "%s",
+		arm_state_strings[arm->core_state],
+		debug_reason_name(target),
+		arm_mode_name(arm->core_mode),
+		buf_get_u32(arm->cpsr->value, 0, 32),
+		buf_get_u32(arm->pc->value, 0, 32),
+		arm->is_semihosting ? ", semihosting" : "");
+
+	return ERROR_OK;
+}
+
+#define ARMV4_5_CORE_REG_MODENUM(cache, mode, num) \
+	(cache->reg_list[armv4_5_core_reg_map[mode][num]])
+
+COMMAND_HANDLER(handle_armv4_5_reg_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+	struct reg *regs;
+
+	if (!is_arm(arm)) {
+		command_print(CMD_CTX, "current target isn't an ARM");
+		return ERROR_FAIL;
+	}
+
+	if (target->state != TARGET_HALTED) {
+		command_print(CMD_CTX, "error: target must be halted for register accesses");
+		return ERROR_FAIL;
+	}
+
+	if (arm->core_type != ARM_MODE_ANY) {
+		command_print(CMD_CTX,
+			"Microcontroller Profile not supported - use standard reg cmd");
+		return ERROR_OK;
+	}
+
+	if (!is_arm_mode(arm->core_mode)) {
+		LOG_ERROR("not a valid arm core mode - communication failure?");
+		return ERROR_FAIL;
+	}
+
+	if (!arm->full_context) {
+		command_print(CMD_CTX, "error: target doesn't support %s",
+			CMD_NAME);
+		return ERROR_FAIL;
+	}
+
+	regs = arm->core_cache->reg_list;
+
+	for (unsigned mode = 0; mode < ARRAY_SIZE(arm_mode_data); mode++) {
+		const char *name;
+		char *sep = "\n";
+		char *shadow = "";
+
+		/* label this bank of registers (or shadows) */
+		switch (arm_mode_data[mode].psr) {
+			case ARM_MODE_SYS:
+				continue;
+			case ARM_MODE_USR:
+				name = "System and User";
+				sep = "";
+				break;
+			case ARM_MODE_MON:
+				if (arm->core_type != ARM_MODE_MON)
+					continue;
+			/* FALLTHROUGH */
+			default:
+				name = arm_mode_data[mode].name;
+				shadow = "shadow ";
+				break;
+		}
+		command_print(CMD_CTX, "%s%s mode %sregisters",
+			sep, name, shadow);
+
+		/* display N rows of up to 4 registers each */
+		for (unsigned i = 0; i < arm_mode_data[mode].n_indices; ) {
+			char output[80];
+			int output_len = 0;
+
+			for (unsigned j = 0; j < 4; j++, i++) {
+				uint32_t value;
+				struct reg *reg = regs;
+
+				if (i >= arm_mode_data[mode].n_indices)
+					break;
+
+				reg += arm_mode_data[mode].indices[i];
+
+				/* REVISIT be smarter about faults... */
+				if (!reg->valid)
+					arm->full_context(target);
+
+				value = buf_get_u32(reg->value, 0, 32);
+				output_len += snprintf(output + output_len,
+						sizeof(output) - output_len,
+						"%8s: %8.8" PRIx32 " ",
+						reg->name, value);
+			}
+			command_print(CMD_CTX, "%s", output);
+		}
+	}
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_armv4_5_core_state_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct arm *arm = target_to_arm(target);
+
+	if (!is_arm(arm)) {
+		command_print(CMD_CTX, "current target isn't an ARM");
+		return ERROR_FAIL;
+	}
+
+	if (arm->core_type == ARM_MODE_THREAD) {
+		/* armv7m not supported */
+		command_print(CMD_CTX, "Unsupported Command");
+		return ERROR_OK;
+	}
+
+	if (CMD_ARGC > 0) {
+		if (strcmp(CMD_ARGV[0], "arm") == 0)
+			arm->core_state = ARM_STATE_ARM;
+		if (strcmp(CMD_ARGV[0], "thumb") == 0)
+			arm->core_state = ARM_STATE_THUMB;
+	}
+
+	command_print(CMD_CTX, "core state: %s", arm_state_strings[arm->core_state]);
+
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(handle_arm_disassemble_command)
+{
+	int retval = ERROR_OK;
+	struct target *target = get_current_target(CMD_CTX);
+
+	if (target == NULL) {
+		LOG_ERROR("No target selected");
+		return ERROR_FAIL;
+	}
+
+	struct arm *arm = target_to_arm(target);
+	uint32_t address;
+	int count = 1;
+	int thumb = 0;
+
+	if (!is_arm(arm)) {
+		command_print(CMD_CTX, "current target isn't an ARM");
+		return ERROR_FAIL;
+	}
+
+	if (arm->core_type == ARM_MODE_THREAD) {
+		/* armv7m is always thumb mode */
+		thumb = 1;
+	}
+
+	switch (CMD_ARGC) {
+		case 3:
+			if (strcmp(CMD_ARGV[2], "thumb") != 0)
+				goto usage;
+			thumb = 1;
+		/* FALL THROUGH */
+		case 2:
+			COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], count);
+		/* FALL THROUGH */
+		case 1:
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+			if (address & 0x01) {
+				if (!thumb) {
+					command_print(CMD_CTX, "Disassemble as Thumb");
+					thumb = 1;
+				}
+				address &= ~1;
+			}
+			break;
+		default:
+usage:
+			count = 0;
+			retval = ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	while (count-- > 0) {
+		struct arm_instruction cur_instruction;
+
+		if (thumb) {
+			/* Always use Thumb2 disassembly for best handling
+			 * of 32-bit BL/BLX, and to work with newer cores
+			 * (some ARMv6, all ARMv7) that use Thumb2.
+			 */
+			retval = thumb2_opcode(target, address,
+					&cur_instruction);
+			if (retval != ERROR_OK)
+				break;
+		} else {
+			uint32_t opcode;
+
+			retval = target_read_u32(target, address, &opcode);
+			if (retval != ERROR_OK)
+				break;
+			retval = arm_evaluate_opcode(opcode, address,
+					&cur_instruction) != ERROR_OK;
+			if (retval != ERROR_OK)
+				break;
+		}
+		command_print(CMD_CTX, "%s", cur_instruction.text);
+		address += cur_instruction.instruction_size;
+	}
+
+	return retval;
+}
+
+static int jim_mcrmrc(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
+{
+	struct command_context *context;
+	struct target *target;
+	struct arm *arm;
+	int retval;
+
+	context = current_command_context(interp);
+	assert(context != NULL);
+
+	target = get_current_target(context);
+	if (target == NULL) {
+		LOG_ERROR("%s: no current target", __func__);
+		return JIM_ERR;
+	}
+	if (!target_was_examined(target)) {
+		LOG_ERROR("%s: not yet examined", target_name(target));
+		return JIM_ERR;
+	}
+	arm = target_to_arm(target);
+	if (!is_arm(arm)) {
+		LOG_ERROR("%s: not an ARM", target_name(target));
+		return JIM_ERR;
+	}
+
+	if ((argc < 6) || (argc > 7)) {
+		/* FIXME use the command name to verify # params... */
+		LOG_ERROR("%s: wrong number of arguments", __func__);
+		return JIM_ERR;
+	}
+
+	int cpnum;
+	uint32_t op1;
+	uint32_t op2;
+	uint32_t CRn;
+	uint32_t CRm;
+	uint32_t value;
+	long l;
+
+	/* NOTE:  parameter sequence matches ARM instruction set usage:
+	 *	MCR	pNUM, op1, rX, CRn, CRm, op2	; write CP from rX
+	 *	MRC	pNUM, op1, rX, CRn, CRm, op2	; read CP into rX
+	 * The "rX" is necessarily omitted; it uses Tcl mechanisms.
+	 */
+	retval = Jim_GetLong(interp, argv[1], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0xf) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+			"coprocessor", (int) l);
+		return JIM_ERR;
+	}
+	cpnum = l;
+
+	retval = Jim_GetLong(interp, argv[2], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0x7) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+			"op1", (int) l);
+		return JIM_ERR;
+	}
+	op1 = l;
+
+	retval = Jim_GetLong(interp, argv[3], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0xf) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+			"CRn", (int) l);
+		return JIM_ERR;
+	}
+	CRn = l;
+
+	retval = Jim_GetLong(interp, argv[4], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0xf) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+			"CRm", (int) l);
+		return JIM_ERR;
+	}
+	CRm = l;
+
+	retval = Jim_GetLong(interp, argv[5], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0x7) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+			"op2", (int) l);
+		return JIM_ERR;
+	}
+	op2 = l;
+
+	value = 0;
+
+	/* FIXME don't assume "mrc" vs "mcr" from the number of params;
+	 * that could easily be a typo!  Check both...
+	 *
+	 * FIXME change the call syntax here ... simplest to just pass
+	 * the MRC() or MCR() instruction to be executed.  That will also
+	 * let us support the "mrc2" and "mcr2" opcodes (toggling one bit)
+	 * if that's ever needed.
+	 */
+	if (argc == 7) {
+		retval = Jim_GetLong(interp, argv[6], &l);
+		if (retval != JIM_OK)
+			return retval;
+		value = l;
+
+		/* NOTE: parameters reordered! */
+		/* ARMV4_5_MCR(cpnum, op1, 0, CRn, CRm, op2) */
+		retval = arm->mcr(target, cpnum, op1, op2, CRn, CRm, value);
+		if (retval != ERROR_OK)
+			return JIM_ERR;
+	} else {
+		/* NOTE: parameters reordered! */
+		/* ARMV4_5_MRC(cpnum, op1, 0, CRn, CRm, op2) */
+		retval = arm->mrc(target, cpnum, op1, op2, CRn, CRm, &value);
+		if (retval != ERROR_OK)
+			return JIM_ERR;
+
+		Jim_SetResult(interp, Jim_NewIntObj(interp, value));
+	}
+
+	return JIM_OK;
+}
+
+COMMAND_HANDLER(handle_arm_semihosting_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+
+	if (target == NULL) {
+		LOG_ERROR("No target selected");
+		return ERROR_FAIL;
+	}
+
+	struct arm *arm = target_to_arm(target);
+
+	if (!is_arm(arm)) {
+		command_print(CMD_CTX, "current target isn't an ARM");
+		return ERROR_FAIL;
+	}
+
+	if (!arm->setup_semihosting) {
+		command_print(CMD_CTX, "semihosting not supported for current target");
+		return ERROR_FAIL;
+	}
+
+	if (CMD_ARGC > 0) {
+		int semihosting;
+
+		COMMAND_PARSE_ENABLE(CMD_ARGV[0], semihosting);
+
+		if (!target_was_examined(target)) {
+			LOG_ERROR("Target not examined yet");
+			return ERROR_FAIL;
+		}
+
+		if (arm->setup_semihosting(target, semihosting) != ERROR_OK) {
+			LOG_ERROR("Failed to Configure semihosting");
+			return ERROR_FAIL;
+		}
+
+		/* FIXME never let that "catch" be dropped! */
+		arm->is_semihosting = semihosting;
+	}
+
+	command_print(CMD_CTX, "semihosting is %s",
+		arm->is_semihosting
+		? "enabled" : "disabled");
+
+	return ERROR_OK;
+}
+
+static const struct command_registration arm_exec_command_handlers[] = {
+	{
+		.name = "reg",
+		.handler = handle_armv4_5_reg_command,
+		.mode = COMMAND_EXEC,
+		.help = "display ARM core registers",
+		.usage = "",
+	},
+	{
+		.name = "core_state",
+		.handler = handle_armv4_5_core_state_command,
+		.mode = COMMAND_EXEC,
+		.usage = "['arm'|'thumb']",
+		.help = "display/change ARM core state",
+	},
+	{
+		.name = "disassemble",
+		.handler = handle_arm_disassemble_command,
+		.mode = COMMAND_EXEC,
+		.usage = "address [count ['thumb']]",
+		.help = "disassemble instructions ",
+	},
+	{
+		.name = "mcr",
+		.mode = COMMAND_EXEC,
+		.jim_handler = &jim_mcrmrc,
+		.help = "write coprocessor register",
+		.usage = "cpnum op1 CRn CRm op2 value",
+	},
+	{
+		.name = "mrc",
+		.jim_handler = &jim_mcrmrc,
+		.help = "read coprocessor register",
+		.usage = "cpnum op1 CRn CRm op2",
+	},
+	{
+		"semihosting",
+		.handler = handle_arm_semihosting_command,
+		.mode = COMMAND_EXEC,
+		.usage = "['enable'|'disable']",
+		.help = "activate support for semihosting operations",
+	},
+
+	COMMAND_REGISTRATION_DONE
+};
+const struct command_registration arm_command_handlers[] = {
+	{
+		.name = "arm",
+		.mode = COMMAND_ANY,
+		.help = "ARM command group",
+		.usage = "",
+		.chain = arm_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+#endif
+
+int armv8_get_gdb_reg_list(struct target *target,
+		struct reg **reg_list[], int *reg_list_size,
+		enum target_register_class reg_class)
+{
+	struct arm *arm = target_to_arm(target);
+	unsigned int i;
+
+	//if(!target->is_64b) return arm_get_gdb_reg_list(target, reg_list, reg_list_size, reg_class);
+	if (!is_arm_mode(arm->core_mode)) {
+		LOG_ERROR("not a valid arm core mode - communication failure?");
+		return ERROR_FAIL;
+	}
+
+	switch (reg_class) {
+	case REG_CLASS_GENERAL:
+	case REG_CLASS_ALL:
+		*reg_list_size = 33;
+		*reg_list = malloc(sizeof(struct reg *) * (*reg_list_size));
+		for (i = 0; i < 33; i++)
+			(*reg_list)[i] = arm->core_cache->reg_list+i; //no mapping needed for ARMv8: armv8_reg_current(arm, i);
+		return ERROR_OK;
+		break;
+
+	default:
+		LOG_ERROR("not a valid register class type in query.");
+		return ERROR_FAIL;
+		break;
+	}
+}
+
+#if use_old_code
+/* wait for execution to complete and check exit point */
+static int armv4_5_run_algorithm_completion(struct target *target,
+	uint32_t exit_point,
+	int timeout_ms,
+	void *arch_info)
+{
+	int retval;
+	struct arm *arm = target_to_arm(target);
+
+	retval = target_wait_state(target, TARGET_HALTED, timeout_ms);
+	if (retval != ERROR_OK)
+		return retval;
+	if (target->state != TARGET_HALTED) {
+		retval = target_halt(target);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_wait_state(target, TARGET_HALTED, 500);
+		if (retval != ERROR_OK)
+			return retval;
+		return ERROR_TARGET_TIMEOUT;
+	}
+
+	/* fast exit: ARMv5+ code can use BKPT */
+	if (exit_point && buf_get_u32(arm->pc->value, 0, 32) != exit_point) {
+		LOG_WARNING(
+			"target reentered debug state, but not at the desired exit point: 0x%4.4" PRIx32 "",
+			buf_get_u32(arm->pc->value, 0, 32));
+		return ERROR_TARGET_TIMEOUT;
+	}
+
+	return ERROR_OK;
+}
+
+int armv4_5_run_algorithm_inner(struct target *target,
+	int num_mem_params, struct mem_param *mem_params,
+	int num_reg_params, struct reg_param *reg_params,
+	uint32_t entry_point, uint32_t exit_point,
+	int timeout_ms, void *arch_info,
+	int (*run_it)(struct target *target, uint32_t exit_point,
+	int timeout_ms, void *arch_info))
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_algorithm *arm_algorithm_info = arch_info;
+	enum arm_state core_state = arm->core_state;
+	uint32_t context[17];
+	uint32_t cpsr;
+	int exit_breakpoint_size = 0;
+	int i;
+	int retval = ERROR_OK;
+
+	LOG_DEBUG("Running algorithm");
+
+	if (arm_algorithm_info->common_magic != ARM_COMMON_MAGIC) {
+		LOG_ERROR("current target isn't an ARMV4/5 target");
+		return ERROR_TARGET_INVALID;
+	}
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	if (!is_arm_mode(arm->core_mode)) {
+		LOG_ERROR("not a valid arm core mode - communication failure?");
+		return ERROR_FAIL;
+	}
+
+	/* armv5 and later can terminate with BKPT instruction; less overhead */
+	if (!exit_point && arm->is_armv4) {
+		LOG_ERROR("ARMv4 target needs HW breakpoint location");
+		return ERROR_FAIL;
+	}
+
+	/* save r0..pc, cpsr-or-spsr, and then cpsr-for-sure;
+	 * they'll be restored later.
+	 */
+	for (i = 0; i <= 16; i++) {
+		struct reg *r;
+
+		r = &ARMV4_5_CORE_REG_MODE(arm->core_cache,
+				arm_algorithm_info->core_mode, i);
+		if (!r->valid)
+			arm->read_core_reg(target, r, i,
+				arm_algorithm_info->core_mode);
+		context[i] = buf_get_u32(r->value, 0, 32);
+	}
+	cpsr = buf_get_u32(arm->cpsr->value, 0, 32);
+
+	for (i = 0; i < num_mem_params; i++) {
+		retval = target_write_buffer(target, mem_params[i].address, mem_params[i].size,
+				mem_params[i].value);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	for (i = 0; i < num_reg_params; i++) {
+		struct reg *reg = register_get_by_name(arm->core_cache, reg_params[i].reg_name, 0);
+		if (!reg) {
+			LOG_ERROR("BUG: register '%s' not found", reg_params[i].reg_name);
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+
+		if (reg->size != reg_params[i].size) {
+			LOG_ERROR("BUG: register '%s' size doesn't match reg_params[i].size",
+				reg_params[i].reg_name);
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		}
+
+		retval = armv4_5_set_core_reg(reg, reg_params[i].value);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	arm->core_state = arm_algorithm_info->core_state;
+	if (arm->core_state == ARM_STATE_ARM)
+		exit_breakpoint_size = 4;
+	else if (arm->core_state == ARM_STATE_THUMB)
+		exit_breakpoint_size = 2;
+	else {
+		LOG_ERROR("BUG: can't execute algorithms when not in ARM or Thumb state");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	if (arm_algorithm_info->core_mode != ARM_MODE_ANY) {
+		LOG_DEBUG("setting core_mode: 0x%2.2x",
+			arm_algorithm_info->core_mode);
+		buf_set_u32(arm->cpsr->value, 0, 5,
+			arm_algorithm_info->core_mode);
+		arm->cpsr->dirty = 1;
+		arm->cpsr->valid = 1;
+	}
+
+	/* terminate using a hardware or (ARMv5+) software breakpoint */
+	if (exit_point) {
+		retval = breakpoint_add(target, exit_point,
+				exit_breakpoint_size, BKPT_HARD);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("can't add HW breakpoint to terminate algorithm");
+			return ERROR_TARGET_FAILURE;
+		}
+	}
+
+	retval = target_resume(target, 0, entry_point, 1, 1);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = run_it(target, exit_point, timeout_ms, arch_info);
+
+	if (exit_point)
+		breakpoint_remove(target, exit_point);
+
+	if (retval != ERROR_OK)
+		return retval;
+
+	for (i = 0; i < num_mem_params; i++) {
+		if (mem_params[i].direction != PARAM_OUT) {
+			int retvaltemp = target_read_buffer(target, mem_params[i].address,
+					mem_params[i].size,
+					mem_params[i].value);
+			if (retvaltemp != ERROR_OK)
+				retval = retvaltemp;
+		}
+	}
+
+	for (i = 0; i < num_reg_params; i++) {
+		if (reg_params[i].direction != PARAM_OUT) {
+
+			struct reg *reg = register_get_by_name(arm->core_cache,
+					reg_params[i].reg_name,
+					0);
+			if (!reg) {
+				LOG_ERROR("BUG: register '%s' not found", reg_params[i].reg_name);
+				retval = ERROR_COMMAND_SYNTAX_ERROR;
+				continue;
+			}
+
+			if (reg->size != reg_params[i].size) {
+				LOG_ERROR(
+					"BUG: register '%s' size doesn't match reg_params[i].size",
+					reg_params[i].reg_name);
+				retval = ERROR_COMMAND_SYNTAX_ERROR;
+				continue;
+			}
+
+			buf_set_u32(reg_params[i].value, 0, 32, buf_get_u32(reg->value, 0, 32));
+		}
+	}
+
+	/* restore everything we saved before (17 or 18 registers) */
+	for (i = 0; i <= 16; i++) {
+		uint32_t regvalue;
+		regvalue = buf_get_u32(ARMV4_5_CORE_REG_MODE(arm->core_cache,
+				arm_algorithm_info->core_mode, i).value, 0, 32);
+		if (regvalue != context[i]) {
+			LOG_DEBUG("restoring register %s with value 0x%8.8" PRIx32 "",
+				ARMV4_5_CORE_REG_MODE(arm->core_cache,
+				arm_algorithm_info->core_mode, i).name, context[i]);
+			buf_set_u32(ARMV4_5_CORE_REG_MODE(arm->core_cache,
+				arm_algorithm_info->core_mode, i).value, 0, 32, context[i]);
+			ARMV4_5_CORE_REG_MODE(arm->core_cache, arm_algorithm_info->core_mode,
+				i).valid = 1;
+			ARMV4_5_CORE_REG_MODE(arm->core_cache, arm_algorithm_info->core_mode,
+				i).dirty = 1;
+		}
+	}
+
+	arm_set_cpsr(arm, cpsr);
+	arm->cpsr->dirty = 1;
+
+	arm->core_state = core_state;
+
+	return retval;
+}
+
+int armv4_5_run_algorithm(struct target *target,
+	int num_mem_params,
+	struct mem_param *mem_params,
+	int num_reg_params,
+	struct reg_param *reg_params,
+	uint32_t entry_point,
+	uint32_t exit_point,
+	int timeout_ms,
+	void *arch_info)
+{
+	return armv4_5_run_algorithm_inner(target,
+			num_mem_params,
+			mem_params,
+			num_reg_params,
+			reg_params,
+			entry_point,
+			exit_point,
+			timeout_ms,
+			arch_info,
+			armv4_5_run_algorithm_completion);
+}
+
+/**
+ * Runs ARM code in the target to calculate a CRC32 checksum.
+ *
+ */
+int arm_checksum_memory(struct target *target,
+	uint32_t address, uint32_t count, uint32_t *checksum)
+{
+	struct working_area *crc_algorithm;
+	struct arm_algorithm arm_algo;
+	struct arm *arm = target_to_arm(target);
+	struct reg_param reg_params[2];
+	int retval;
+	uint32_t i;
+	uint32_t exit_var = 0;
+
+	/* see contrib/loaders/checksum/armv4_5_crc.s for src */
+
+	static const uint32_t arm_crc_code[] = {
+		0xE1A02000,		/* mov		r2, r0 */
+		0xE3E00000,		/* mov		r0, #0xffffffff */
+		0xE1A03001,		/* mov		r3, r1 */
+		0xE3A04000,		/* mov		r4, #0 */
+		0xEA00000B,		/* b		ncomp */
+		/* nbyte: */
+		0xE7D21004,		/* ldrb	r1, [r2, r4] */
+		0xE59F7030,		/* ldr		r7, CRC32XOR */
+		0xE0200C01,		/* eor		r0, r0, r1, asl 24 */
+		0xE3A05000,		/* mov		r5, #0 */
+		/* loop: */
+		0xE3500000,		/* cmp		r0, #0 */
+		0xE1A06080,		/* mov		r6, r0, asl #1 */
+		0xE2855001,		/* add		r5, r5, #1 */
+		0xE1A00006,		/* mov		r0, r6 */
+		0xB0260007,		/* eorlt	r0, r6, r7 */
+		0xE3550008,		/* cmp		r5, #8 */
+		0x1AFFFFF8,		/* bne		loop */
+		0xE2844001,		/* add		r4, r4, #1 */
+		/* ncomp: */
+		0xE1540003,		/* cmp		r4, r3 */
+		0x1AFFFFF1,		/* bne		nbyte */
+		/* end: */
+		0xe1200070,		/* bkpt		#0 */
+		/* CRC32XOR: */
+		0x04C11DB7		/* .word 0x04C11DB7 */
+	};
+
+	retval = target_alloc_working_area(target,
+			sizeof(arm_crc_code), &crc_algorithm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* convert code into a buffer in target endianness */
+	for (i = 0; i < ARRAY_SIZE(arm_crc_code); i++) {
+		retval = target_write_u32(target,
+				crc_algorithm->address + i * sizeof(uint32_t),
+				arm_crc_code[i]);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	arm_algo.common_magic = ARM_COMMON_MAGIC;
+	arm_algo.core_mode = ARM_MODE_SVC;
+	arm_algo.core_state = ARM_STATE_ARM;
+
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+
+	buf_set_u32(reg_params[0].value, 0, 32, address);
+	buf_set_u32(reg_params[1].value, 0, 32, count);
+
+	/* 20 second timeout/megabyte */
+	int timeout = 20000 * (1 + (count / (1024 * 1024)));
+
+	/* armv4 must exit using a hardware breakpoint */
+	if (arm->is_armv4)
+		exit_var = crc_algorithm->address + sizeof(arm_crc_code) - 8;
+
+	retval = target_run_algorithm(target, 0, NULL, 2, reg_params,
+			crc_algorithm->address,
+			exit_var,
+			timeout, &arm_algo);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("error executing ARM crc algorithm");
+		destroy_reg_param(&reg_params[0]);
+		destroy_reg_param(&reg_params[1]);
+		target_free_working_area(target, crc_algorithm);
+		return retval;
+	}
+
+	*checksum = buf_get_u32(reg_params[0].value, 0, 32);
+
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+
+	target_free_working_area(target, crc_algorithm);
+
+	return ERROR_OK;
+}
+
+/**
+ * Runs ARM code in the target to check whether a memory block holds
+ * all ones.  NOR flash which has been erased, and thus may be written,
+ * holds all ones.
+ *
+ */
+int arm_blank_check_memory(struct target *target,
+	uint32_t address, uint32_t count, uint32_t *blank)
+{
+	struct working_area *check_algorithm;
+	struct reg_param reg_params[3];
+	struct arm_algorithm arm_algo;
+	struct arm *arm = target_to_arm(target);
+	int retval;
+	uint32_t i;
+	uint32_t exit_var = 0;
+
+	/* see contrib/loaders/erase_check/armv4_5_erase_check.s for src */
+
+	static const uint32_t check_code[] = {
+		/* loop: */
+		0xe4d03001,		/* ldrb r3, [r0], #1 */
+		0xe0022003,		/* and r2, r2, r3    */
+		0xe2511001,		/* subs r1, r1, #1   */
+		0x1afffffb,		/* bne loop          */
+		/* end: */
+		0xe1200070,		/* bkpt #0 */
+	};
+
+	/* make sure we have a working area */
+	retval = target_alloc_working_area(target,
+			sizeof(check_code), &check_algorithm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* convert code into a buffer in target endianness */
+	for (i = 0; i < ARRAY_SIZE(check_code); i++) {
+		retval = target_write_u32(target,
+				check_algorithm->address
+				+ i * sizeof(uint32_t),
+				check_code[i]);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	arm_algo.common_magic = ARM_COMMON_MAGIC;
+	arm_algo.core_mode = ARM_MODE_SVC;
+	arm_algo.core_state = ARM_STATE_ARM;
+
+	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
+	buf_set_u32(reg_params[0].value, 0, 32, address);
+
+	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
+	buf_set_u32(reg_params[1].value, 0, 32, count);
+
+	init_reg_param(&reg_params[2], "r2", 32, PARAM_IN_OUT);
+	buf_set_u32(reg_params[2].value, 0, 32, 0xff);
+
+	/* armv4 must exit using a hardware breakpoint */
+	if (arm->is_armv4)
+		exit_var = check_algorithm->address + sizeof(check_code) - 4;
+
+	retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
+			check_algorithm->address,
+			exit_var,
+			10000, &arm_algo);
+	if (retval != ERROR_OK) {
+		destroy_reg_param(&reg_params[0]);
+		destroy_reg_param(&reg_params[1]);
+		destroy_reg_param(&reg_params[2]);
+		target_free_working_area(target, check_algorithm);
+		return retval;
+	}
+
+	*blank = buf_get_u32(reg_params[2].value, 0, 32);
+
+	destroy_reg_param(&reg_params[0]);
+	destroy_reg_param(&reg_params[1]);
+	destroy_reg_param(&reg_params[2]);
+
+	target_free_working_area(target, check_algorithm);
+
+	return ERROR_OK;
+}
+
+static int arm_full_context(struct target *target)
+{
+	struct arm *arm = target_to_arm(target);
+	unsigned num_regs = arm->core_cache->num_regs;
+	struct reg *reg = arm->core_cache->reg_list;
+	int retval = ERROR_OK;
+
+	for (; num_regs && retval == ERROR_OK; num_regs--, reg++) {
+		if (reg->valid)
+			continue;
+		retval = armv4_5_get_core_reg(reg);
+	}
+	return retval;
+}
+
+static int arm_default_mrc(struct target *target, int cpnum,
+	uint32_t op1, uint32_t op2,
+	uint32_t CRn, uint32_t CRm,
+	uint32_t *value)
+{
+	LOG_ERROR("%s doesn't implement MRC", target_type_name(target));
+	return ERROR_FAIL;
+}
+
+static int arm_default_mcr(struct target *target, int cpnum,
+	uint32_t op1, uint32_t op2,
+	uint32_t CRn, uint32_t CRm,
+	uint32_t value)
+{
+	LOG_ERROR("%s doesn't implement MCR", target_type_name(target));
+	return ERROR_FAIL;
+}
+
+int arm_init_arch_info(struct target *target, struct arm *arm)
+{
+	target->arch_info = arm;
+	arm->target = target;
+
+	arm->common_magic = ARM_COMMON_MAGIC;
+
+	/* core_type may be overridden by subtype logic */
+	if (arm->core_type != ARM_MODE_THREAD) {
+		arm->core_type = ARM_MODE_ANY;
+		arm_set_cpsr(arm, ARM_MODE_USR);
+	}
+
+	/* default full_context() has no core-specific optimizations */
+	if (!arm->full_context && arm->read_core_reg)
+		arm->full_context = arm_full_context;
+
+	if (!arm->mrc)
+		arm->mrc = arm_default_mrc;
+	if (!arm->mcr)
+		arm->mcr = arm_default_mcr;
+
+	return ERROR_OK;
+}
+#endif
diff --git a/src/target/armv8.h b/src/target/armv8.h
new file mode 100755
index 0000000..41c7a41
--- /dev/null
+++ b/src/target/armv8.h
@@ -0,0 +1,66 @@
+/* Modified from armv7a.h by Strong Qu. Refer to orignal code for license.
+ * Added ARMv8 specific define/declaration, include for ARMv8 dpm */
+
+#ifndef ARMV8_H
+#define ARMV8_H
+
+#include "arm_adi_v5.h"
+#include "arm.h"
+#include "armv4_5_mmu.h"
+#include "armv4_5_cache.h"
+#include "arm_dpm.h"
+
+#define EDESR		0x020
+#define EDECR		0x024
+#define EDWAR_L		0x030
+#define EDWAR_H		0x034
+#define DBGDTRRX_EL0 0x80
+#define EDSCR		0x088
+#define DBGDTRTX_EL0 0x8C
+#define EDRCR		0x090
+#define EDACR		0x094
+#define EDECCR		0x098
+#define OSLAR_EL1	0x300
+#define EDPRCR		0x310
+#define EDPRSR		0x314
+#define ESPSR_EL0
+#define CPUDBG_BVR_EL1_BASE 0x400
+#define CPUDBG_BCR_EL1_BASE 0x408
+#define CPUDBG_WVR_EL1_BASE 0x800
+#define CPUDBG_WCR_EL1_BASE 0x808
+#define ID_AA64DFR0_EL1_L	0xD28
+#define ID_AA64DFR0_EL1_H	0xD2C
+#define DBGAUTHSTATUS_EL1	0xFB8
+
+#define CTICONTROL 			0x000
+#define CTIINTACK 			0x010
+#define CTIAPPSET 			0x014
+#define CTIAPPCLEAR 		0x018
+#define CTIAPPPULSE 		0x01C
+#define CTIINEN(n) 			(0x020+4*n)
+#define CTIOUTEN(n)			(0x0A0+4*n)
+#define CTITRIGINSTATUS 	0x130
+#define CTITRIGOUTSTATUS 	0x134
+#define CTICHINSTATUS		0x138
+#define CTICHOUTSTATUS 		0x13C
+#define CTIGATE				0x140
+#define CTIDEVID			0xFC8
+/*ID1 and 2 are reserved
+#define CTIDEVID1			0xFC4
+#define CTIDEVID2			0xFC0*/
+
+#define CTIDBGCHAN_HALT		1
+#define CTIDBGCHAN_RESTART	2
+
+int armv8_get_gdb_reg_list(struct target *target,
+		struct reg **reg_list[], int *reg_list_size,
+		enum target_register_class reg_class);
+int armv8_dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode);
+int armv8_dpm_read_current_registers(struct arm_dpm *dpm);
+int armv8_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp);
+void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr);
+void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr);
+int armv8_dpm_setup(struct arm_dpm *dpm);
+int armv8_dpm_initialize(struct arm_dpm *dpm);
+
+#endif /* ARMV8_H */
diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
new file mode 100755
index 0000000..e58d868
--- /dev/null
+++ b/src/target/armv8_dpm.c
@@ -0,0 +1,1004 @@
+/*
+ * Modified from arm_dpm.c by Strong Qu. Refer to the original code for license
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "arm.h"
+#include "armv8.h"
+#include "arm_dpm.h"
+#include <jtag/jtag.h>
+#include "register.h"
+#include "breakpoints.h"
+#include "target_type.h"
+#include "arm_opcodes.h"
+
+/**
+ * @file
+ * Implements various ARM DPM operations using architectural debug registers.
+ * These routines layer over core-specific communication methods to cope with
+ * implementation differences between cores like ARM1136 and Cortex-A8.
+ *
+ * The "Debug Programmers' Model" (DPM) for ARMv6 and ARMv7 is defined by
+ * Part C (Debug Architecture) of the ARM Architecture Reference Manual,
+ * ARMv7-A and ARMv7-R edition (ARM DDI 0406B).  In OpenOCD, DPM operations
+ * are abstracted through internal programming interfaces to share code and
+ * to minimize needless differences in debug behavior between cores.
+ */
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Coprocessor support
+ */
+
+/* Read coprocessor */
+static int dpm_mrc(struct target *target, int cpnum,
+	uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm,
+	uint32_t *value)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_DEBUG("MRC p%d, %d, r0, c%d, c%d, %d", cpnum,
+		(int) op1, (int) CRn,
+		(int) CRm, (int) op2);
+
+	/* read coprocessor register into R0; return via DCC */
+	retval = dpm->instr_read_data_r0(dpm,
+			ARMV4_5_MRC(cpnum, op1, 0, CRn, CRm, op2),
+			value);
+
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+static int dpm_mcr(struct target *target, int cpnum,
+	uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm,
+	uint32_t value)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_DEBUG("MCR p%d, %d, r0, c%d, c%d, %d", cpnum,
+		(int) op1, (int) CRn,
+		(int) CRm, (int) op2);
+
+	/* read DCC into r0; then write coprocessor register from R0 */
+	retval = dpm->instr_write_data_r0(dpm,
+			ARMV4_5_MCR(cpnum, op1, 0, CRn, CRm, op2),
+			value);
+
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Register access utilities
+ */
+
+/* Toggles between recorded core mode (USR, SVC, etc) and a temporary one.
+ * Routines *must* restore the original mode before returning!!
+ */
+int armv8_dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode)
+{
+	int retval;
+	uint32_t cpsr;
+
+	/* restore previous mode */
+	if (mode == ARM_MODE_ANY)
+		cpsr = buf_get_u32(dpm->arm->cpsr->value, 0, 32);
+
+	/* else force to the specified mode */
+	else
+		cpsr = mode;
+
+	retval = dpm->instr_write_data_r0(dpm, ARMV4_5_MSR_GP(0, 0xf, 0), cpsr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (dpm->instr_cpsr_sync)
+		retval = dpm->instr_cpsr_sync(dpm);
+
+	return retval;
+}
+
+/* just read the register -- rely on the core mode being right */
+static int dpm_read_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
+{
+	uint32_t value;
+	int retval;
+
+	switch (regnum) {
+		case 0 ... 14:
+			/* return via DCC:  "MCR p14, 0, Rnum, c0, c5, 0" */
+			retval = dpm->instr_read_data_dcc(dpm,
+				ARMV4_5_MCR(14, 0, regnum, 0, 5, 0),
+				&value);
+			break;
+		case 15:/* PC
+			 * "MOV r0, pc"; then return via DCC */
+			retval = dpm->instr_read_data_r0(dpm, 0xe1a0000f, &value);
+
+			/* NOTE: this seems like a slightly awkward place to update
+			 * this value ... but if the PC gets written (the only way
+			 * to change what we compute), the arch spec says subsequent
+			 * reads return values which are "unpredictable".  So this
+			 * is always right except in those broken-by-intent cases.
+			 */
+			switch (dpm->arm->core_state) {
+				case ARM_STATE_ARM:
+					value -= 8;
+					break;
+				case ARM_STATE_THUMB:
+				case ARM_STATE_THUMB_EE:
+					value -= 4;
+					break;
+				case ARM_STATE_JAZELLE:
+					/* core-specific ... ? */
+					LOG_WARNING("Jazelle PC adjustment unknown");
+					break;
+			}
+			break;
+		default:
+			/* 16: "MRS r0, CPSR"; then return via DCC
+			 * 17: "MRS r0, SPSR"; then return via DCC
+			 */
+			retval = dpm->instr_read_data_r0(dpm,
+				ARMV4_5_MRS(0, regnum & 1),
+				&value);
+			break;
+	}
+
+	if (retval == ERROR_OK) {
+		buf_set_u32(r->value, 0, 32, value);
+		r->valid = true;
+		r->dirty = false;
+		LOG_DEBUG("READ: %s, %8.8x", r->name, (unsigned) value);
+	}
+
+	return retval;
+}
+
+/* just write the register -- rely on the core mode being right */
+static int dpm_write_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
+{
+	int retval;
+	uint32_t value = buf_get_u32(r->value, 0, 32);
+
+	switch (regnum) {
+		case 0 ... 14:
+			/* load register from DCC:  "MRC p14, 0, Rnum, c0, c5, 0" */
+			retval = dpm->instr_write_data_dcc(dpm,
+				ARMV4_5_MRC(14, 0, regnum, 0, 5, 0),
+				value);
+			break;
+		case 15:/* PC
+			 * read r0 from DCC; then "MOV pc, r0" */
+			retval = dpm->instr_write_data_r0(dpm, 0xe1a0f000, value);
+			break;
+		default:
+			/* 16: read r0 from DCC, then "MSR r0, CPSR_cxsf"
+			 * 17: read r0 from DCC, then "MSR r0, SPSR_cxsf"
+			 */
+			retval = dpm->instr_write_data_r0(dpm,
+				ARMV4_5_MSR_GP(0, 0xf, regnum & 1),
+				value);
+			if (retval != ERROR_OK)
+				return retval;
+
+			if (regnum == 16 && dpm->instr_cpsr_sync)
+				retval = dpm->instr_cpsr_sync(dpm);
+
+			break;
+	}
+
+	if (retval == ERROR_OK) {
+		r->dirty = false;
+		LOG_DEBUG("WRITE: %s, %8.8x", r->name, (unsigned) value);
+	}
+
+	return retval;
+}
+
+/**
+ * Read basic registers of the the current context:  R0 to R15, and CPSR;
+ * sets the core mode (such as USR or IRQ) and state (such as ARM or Thumb).
+ * In normal operation this is called on entry to halting debug state,
+ * possibly after some other operations supporting restore of debug state
+ * or making sure the CPU is fully idle (drain write buffer, etc).
+ */
+int armv8_dpm_read_current_registers(struct arm_dpm *dpm)
+{
+	struct arm *arm = dpm->arm;
+	uint32_t cpsr;
+	int retval;
+	struct reg *r;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* read R0 first (it's used for scratch), then CPSR */
+	r = arm->core_cache->reg_list + 0;
+	if (!r->valid) {
+		retval = dpm_read_reg(dpm, r, 0);
+		if (retval != ERROR_OK)
+			goto fail;
+	}
+	r->dirty = true;
+
+	retval = dpm->instr_read_data_r0(dpm, ARMV4_5_MRS(0, 0), &cpsr);
+	if (retval != ERROR_OK)
+		goto fail;
+
+	/* update core mode and state, plus shadow mapping for R8..R14 */
+	arm_set_cpsr(arm, cpsr);
+
+	/* REVISIT we can probably avoid reading R1..R14, saving time... */
+	for (unsigned i = 1; i < 16; i++) {
+		r = arm_reg_current(arm, i);
+		if (r->valid)
+			continue;
+
+		retval = dpm_read_reg(dpm, r, i);
+		if (retval != ERROR_OK)
+			goto fail;
+	}
+
+	/* NOTE: SPSR ignored (if it's even relevant). */
+
+	/* REVISIT the debugger can trigger various exceptions.  See the
+	 * ARMv7A architecture spec, section C5.7, for more info about
+	 * what defenses are needed; v6 debug has the most issues.
+	 */
+
+fail:
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+/* Avoid needless I/O ... leave breakpoints and watchpoints alone
+ * unless they're removed, or need updating because of single-stepping
+ * or running debugger code.
+ */
+static int dpm_maybe_update_bpwp(struct arm_dpm *dpm, bool bpwp,
+	struct dpm_bpwp *xp, int *set_p)
+{
+	int retval = ERROR_OK;
+	bool disable;
+
+	if (!set_p) {
+		if (!xp->dirty)
+			goto done;
+		xp->dirty = false;
+		/* removed or startup; we must disable it */
+		disable = true;
+	} else if (bpwp) {
+		if (!xp->dirty)
+			goto done;
+		/* disabled, but we must set it */
+		xp->dirty = disable = false;
+		*set_p = true;
+	} else {
+		if (!*set_p)
+			goto done;
+		/* set, but we must temporarily disable it */
+		xp->dirty = disable = true;
+		*set_p = false;
+	}
+
+	if (disable)
+		retval = dpm->bpwp_disable(dpm, xp->number);
+	else
+		retval = dpm->bpwp_enable(dpm, xp->number,
+				xp->address, xp->control);
+
+	if (retval != ERROR_OK)
+		LOG_ERROR("%s: can't %s HW %spoint %d",
+			disable ? "disable" : "enable",
+			target_name(dpm->arm->target),
+			(xp->number < 16) ? "break" : "watch",
+			xp->number & 0xf);
+done:
+	return retval;
+}
+
+static int dpm_add_breakpoint(struct target *target, struct breakpoint *bp);
+
+/**
+ * Writes all modified core registers for all processor modes.  In normal
+ * operation this is called on exit from halting debug state.
+ *
+ * @param dpm: represents the processor
+ * @param bpwp: true ensures breakpoints and watchpoints are set,
+ *	false ensures they are cleared
+ */
+int armv8_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
+{
+	struct arm *arm = dpm->arm;
+	struct reg_cache *cache = arm->core_cache;
+	int retval;
+	bool did_write;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		goto done;
+
+	/* If we're managing hardware breakpoints for this core, enable
+	 * or disable them as requested.
+	 *
+	 * REVISIT We don't yet manage them for ANY cores.  Eventually
+	 * we should be able to assume we handle them; but until then,
+	 * cope with the hand-crafted breakpoint code.
+	 */
+	if (arm->target->type->add_breakpoint == dpm_add_breakpoint) {
+		for (unsigned i = 0; i < dpm->nbp; i++) {
+			struct dpm_bp *dbp = dpm->dbp + i;
+			struct breakpoint *bp = dbp->bp;
+
+			retval = dpm_maybe_update_bpwp(dpm, bpwp, &dbp->bpwp,
+					bp ? &bp->set : NULL);
+			if (retval != ERROR_OK)
+				goto done;
+		}
+	}
+
+	/* enable/disable watchpoints */
+	for (unsigned i = 0; i < dpm->nwp; i++) {
+		struct dpm_wp *dwp = dpm->dwp + i;
+		struct watchpoint *wp = dwp->wp;
+
+		retval = dpm_maybe_update_bpwp(dpm, bpwp, &dwp->bpwp,
+				wp ? &wp->set : NULL);
+		if (retval != ERROR_OK)
+			goto done;
+	}
+
+	/* NOTE:  writes to breakpoint and watchpoint registers might
+	 * be queued, and need (efficient/batched) flushing later.
+	 */
+
+	/* Scan the registers until we find one that's both dirty and
+	 * eligible for flushing.  Flush that and everything else that
+	 * shares the same core mode setting.  Typically this won't
+	 * actually find anything to do...
+	 */
+	do {
+		enum arm_mode mode = ARM_MODE_ANY;
+
+		did_write = false;
+
+		/* check everything except our scratch register R0 */
+		for (unsigned i = 1; i < cache->num_regs; i++) {
+			struct arm_reg *r;
+			unsigned regnum;
+
+			/* also skip PC, CPSR, and non-dirty */
+			if (i == 15)
+				continue;
+			if (arm->cpsr == cache->reg_list + i)
+				continue;
+			if (!cache->reg_list[i].dirty)
+				continue;
+
+			r = cache->reg_list[i].arch_info;
+			regnum = r->num;
+
+			/* may need to pick and set a mode */
+			if (!did_write) {
+				enum arm_mode tmode;
+
+				did_write = true;
+				mode = tmode = r->mode;
+
+				/* cope with special cases */
+				switch (regnum) {
+					case 8 ... 12:
+						/* r8..r12 "anything but FIQ" case;
+						 * we "know" core mode is accurate
+						 * since we haven't changed it yet
+						 */
+						if (arm->core_mode == ARM_MODE_FIQ
+							&& ARM_MODE_ANY
+							!= mode)
+							tmode = ARM_MODE_USR;
+						break;
+					case 16:
+						/* SPSR */
+						regnum++;
+						break;
+				}
+
+				/* REVISIT error checks */
+				if (tmode != ARM_MODE_ANY) {
+					retval = armv8_dpm_modeswitch(dpm, tmode);
+					if (retval != ERROR_OK)
+						goto done;
+				}
+			}
+			if (r->mode != mode)
+				continue;
+
+			retval = dpm_write_reg(dpm,
+					&cache->reg_list[i],
+					regnum);
+			if (retval != ERROR_OK)
+				goto done;
+		}
+
+	} while (did_write);
+
+	/* Restore original CPSR ... assuming either that we changed it,
+	 * or it's dirty.  Must write PC to ensure the return address is
+	 * defined, and must not write it before CPSR.
+	 */
+	retval = armv8_dpm_modeswitch(dpm, ARM_MODE_ANY);
+	if (retval != ERROR_OK)
+		goto done;
+	arm->cpsr->dirty = false;
+
+	retval = dpm_write_reg(dpm, arm->pc, 15);
+	if (retval != ERROR_OK)
+		goto done;
+	arm->pc->dirty = false;
+
+	/* flush R0 -- it's *very* dirty by now */
+	retval = dpm_write_reg(dpm, &cache->reg_list[0], 0);
+	if (retval != ERROR_OK)
+		goto done;
+	cache->reg_list[0].dirty = false;
+
+	/* (void) */ dpm->finish(dpm);
+done:
+	return retval;
+}
+
+/* Returns ARM_MODE_ANY or temporary mode to use while reading the
+ * specified register ... works around flakiness from ARM core calls.
+ * Caller already filtered out SPSR access; mode is never MODE_SYS
+ * or MODE_ANY.
+ */
+static enum arm_mode dpm_mapmode(struct arm *arm,
+	unsigned num, enum arm_mode mode)
+{
+	enum arm_mode amode = arm->core_mode;
+
+	/* don't switch if the mode is already correct */
+	if (amode == ARM_MODE_SYS)
+		amode = ARM_MODE_USR;
+	if (mode == amode)
+		return ARM_MODE_ANY;
+
+	switch (num) {
+		/* don't switch for non-shadowed registers (r0..r7, r15/pc, cpsr) */
+		case 0 ... 7:
+		case 15:
+		case 16:
+			break;
+		/* r8..r12 aren't shadowed for anything except FIQ */
+		case 8 ... 12:
+			if (mode == ARM_MODE_FIQ)
+				return mode;
+			break;
+		/* r13/sp, and r14/lr are always shadowed */
+		case 13:
+		case 14:
+			return mode;
+		default:
+			LOG_WARNING("invalid register #%u", num);
+			break;
+	}
+	return ARM_MODE_ANY;
+}
+
+
+/*
+ * Standard ARM register accessors ... there are three methods
+ * in "struct arm", to support individual read/write and bulk read
+ * of registers.
+ */
+
+static int arm_dpm_read_core_reg(struct target *target, struct reg *r,
+	int regnum, enum arm_mode mode)
+{
+	struct arm_dpm *dpm = target_to_arm(target)->dpm;
+	int retval;
+
+	if (regnum < 0 || regnum > 16)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (regnum == 16) {
+		if (mode != ARM_MODE_ANY)
+			regnum = 17;
+	} else
+		mode = dpm_mapmode(dpm->arm, regnum, mode);
+
+	/* REVISIT what happens if we try to read SPSR in a core mode
+	 * which has no such register?
+	 */
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (mode != ARM_MODE_ANY) {
+		retval = armv8_dpm_modeswitch(dpm, mode);
+		if (retval != ERROR_OK)
+			goto fail;
+	}
+
+	retval = dpm_read_reg(dpm, r, regnum);
+	if (retval != ERROR_OK)
+		goto fail;
+	/* always clean up, regardless of error */
+
+	if (mode != ARM_MODE_ANY)
+		/* (void) */ armv8_dpm_modeswitch(dpm, ARM_MODE_ANY);
+
+fail:
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+static int arm_dpm_write_core_reg(struct target *target, struct reg *r,
+	int regnum, enum arm_mode mode, uint32_t value)
+{
+	struct arm_dpm *dpm = target_to_arm(target)->dpm;
+	int retval;
+
+
+	if (regnum < 0 || regnum > 16)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+
+	if (regnum == 16) {
+		if (mode != ARM_MODE_ANY)
+			regnum = 17;
+	} else
+		mode = dpm_mapmode(dpm->arm, regnum, mode);
+
+	/* REVISIT what happens if we try to write SPSR in a core mode
+	 * which has no such register?
+	 */
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (mode != ARM_MODE_ANY) {
+		retval = armv8_dpm_modeswitch(dpm, mode);
+		if (retval != ERROR_OK)
+			goto fail;
+	}
+
+	retval = dpm_write_reg(dpm, r, regnum);
+	/* always clean up, regardless of error */
+
+	if (mode != ARM_MODE_ANY)
+		/* (void) */ armv8_dpm_modeswitch(dpm, ARM_MODE_ANY);
+
+fail:
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+static int arm_dpm_full_context(struct target *target)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	struct reg_cache *cache = arm->core_cache;
+	int retval;
+	bool did_read;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		goto done;
+
+	do {
+		enum arm_mode mode = ARM_MODE_ANY;
+
+		did_read = false;
+
+		/* We "know" armv8_dpm_read_current_registers() was called so
+		 * the unmapped registers (R0..R7, PC, AND CPSR) and some
+		 * view of R8..R14 are current.  We also "know" oddities of
+		 * register mapping: special cases for R8..R12 and SPSR.
+		 *
+		 * Pick some mode with unread registers and read them all.
+		 * Repeat until done.
+		 */
+		for (unsigned i = 0; i < cache->num_regs; i++) {
+			struct arm_reg *r;
+
+			if (cache->reg_list[i].valid)
+				continue;
+			r = cache->reg_list[i].arch_info;
+
+			/* may need to pick a mode and set CPSR */
+			if (!did_read) {
+				did_read = true;
+				mode = r->mode;
+
+				/* For regular (ARM_MODE_ANY) R8..R12
+				 * in case we've entered debug state
+				 * in FIQ mode we need to patch mode.
+				 */
+				if (mode != ARM_MODE_ANY)
+					retval = armv8_dpm_modeswitch(dpm, mode);
+				else
+					retval = armv8_dpm_modeswitch(dpm, ARM_MODE_USR);
+
+				if (retval != ERROR_OK)
+					goto done;
+			}
+			if (r->mode != mode)
+				continue;
+
+			/* CPSR was read, so "R16" must mean SPSR */
+			retval = dpm_read_reg(dpm,
+					&cache->reg_list[i],
+					(r->num == 16) ? 17 : r->num);
+			if (retval != ERROR_OK)
+				goto done;
+		}
+
+	} while (did_read);
+
+	retval = armv8_dpm_modeswitch(dpm, ARM_MODE_ANY);
+	/* (void) */ dpm->finish(dpm);
+done:
+	return retval;
+}
+
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Breakpoint and Watchpoint support.
+ *
+ * Hardware {break,watch}points are usually left active, to minimize
+ * debug entry/exit costs.  When they are set or cleared, it's done in
+ * batches.  Also, DPM-conformant hardware can update debug registers
+ * regardless of whether the CPU is running or halted ... though that
+ * fact isn't currently leveraged.
+ */
+
+static int dpm_bpwp_setup(struct arm_dpm *dpm, struct dpm_bpwp *xp,
+	uint32_t addr, uint32_t length)
+{
+	uint32_t control;
+
+	control = (1 << 0)	/* enable */
+		| (3 << 1);	/* both user and privileged access */
+
+	/* Match 1, 2, or all 4 byte addresses in this word.
+	 *
+	 * FIXME:  v7 hardware allows lengths up to 2 GB for BP and WP.
+	 * Support larger length, when addr is suitably aligned.  In
+	 * particular, allow watchpoints on 8 byte "double" values.
+	 *
+	 * REVISIT allow watchpoints on unaligned 2-bit values; and on
+	 * v7 hardware, unaligned 4-byte ones too.
+	 */
+	switch (length) {
+		case 1:
+			control |= (1 << (addr & 3)) << 5;
+			break;
+		case 2:
+			/* require 2-byte alignment */
+			if (!(addr & 1)) {
+				control |= (3 << (addr & 2)) << 5;
+				break;
+			}
+		/* FALL THROUGH */
+		case 4:
+			/* require 4-byte alignment */
+			if (!(addr & 3)) {
+				control |= 0xf << 5;
+				break;
+			}
+		/* FALL THROUGH */
+		default:
+			LOG_ERROR("unsupported {break,watch}point length/alignment");
+			return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* other shared control bits:
+	 * bits 15:14 == 0 ... both secure and nonsecure states (v6.1+ only)
+	 * bit 20 == 0 ... not linked to a context ID
+	 * bit 28:24 == 0 ... not ignoring N LSBs (v7 only)
+	 */
+
+	xp->address = addr & ~3;
+	xp->control = control;
+	xp->dirty = true;
+
+	LOG_DEBUG("BPWP: addr %8.8" PRIx32 ", control %" PRIx32 ", number %d",
+		xp->address, control, xp->number);
+
+	/* hardware is updated in write_dirty_registers() */
+	return ERROR_OK;
+}
+
+static int dpm_add_breakpoint(struct target *target, struct breakpoint *bp)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+
+	if (bp->length < 2)
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	if (!dpm->bpwp_enable)
+		return retval;
+
+	/* FIXME we need a generic solution for software breakpoints. */
+	if (bp->type == BKPT_SOFT)
+		LOG_DEBUG("using HW bkpt, not SW...");
+
+	for (unsigned i = 0; i < dpm->nbp; i++) {
+		if (!dpm->dbp[i].bp) {
+			retval = dpm_bpwp_setup(dpm, &dpm->dbp[i].bpwp,
+					bp->address, bp->length);
+			if (retval == ERROR_OK)
+				dpm->dbp[i].bp = bp;
+			break;
+		}
+	}
+
+	return retval;
+}
+
+static int dpm_remove_breakpoint(struct target *target, struct breakpoint *bp)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+
+	for (unsigned i = 0; i < dpm->nbp; i++) {
+		if (dpm->dbp[i].bp == bp) {
+			dpm->dbp[i].bp = NULL;
+			dpm->dbp[i].bpwp.dirty = true;
+
+			/* hardware is updated in write_dirty_registers() */
+			retval = ERROR_OK;
+			break;
+		}
+	}
+
+	return retval;
+}
+
+static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index_t,
+	struct watchpoint *wp)
+{
+	int retval;
+	struct dpm_wp *dwp = dpm->dwp + index_t;
+	uint32_t control;
+
+	/* this hardware doesn't support data value matching or masking */
+	if (wp->value || wp->mask != ~(uint32_t)0) {
+		LOG_DEBUG("watchpoint values and masking not supported");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	retval = dpm_bpwp_setup(dpm, &dwp->bpwp, wp->address, wp->length);
+	if (retval != ERROR_OK)
+		return retval;
+
+	control = dwp->bpwp.control;
+	switch (wp->rw) {
+		case WPT_READ:
+			control |= 1 << 3;
+			break;
+		case WPT_WRITE:
+			control |= 2 << 3;
+			break;
+		case WPT_ACCESS:
+			control |= 3 << 3;
+			break;
+	}
+	dwp->bpwp.control = control;
+
+	dpm->dwp[index_t].wp = wp;
+
+	return retval;
+}
+
+static int dpm_add_watchpoint(struct target *target, struct watchpoint *wp)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+
+	if (dpm->bpwp_enable) {
+		for (unsigned i = 0; i < dpm->nwp; i++) {
+			if (!dpm->dwp[i].wp) {
+				retval = dpm_watchpoint_setup(dpm, i, wp);
+				break;
+			}
+		}
+	}
+
+	return retval;
+}
+
+static int dpm_remove_watchpoint(struct target *target, struct watchpoint *wp)
+{
+	struct arm *arm = target_to_arm(target);
+	struct arm_dpm *dpm = arm->dpm;
+	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+
+	for (unsigned i = 0; i < dpm->nwp; i++) {
+		if (dpm->dwp[i].wp == wp) {
+			dpm->dwp[i].wp = NULL;
+			dpm->dwp[i].bpwp.dirty = true;
+
+			/* hardware is updated in write_dirty_registers() */
+			retval = ERROR_OK;
+			break;
+		}
+	}
+
+	return retval;
+}
+
+void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr)
+{
+	switch (dpm->arm->core_state) {
+		case ARM_STATE_ARM:
+			addr -= 8;
+			break;
+		case ARM_STATE_THUMB:
+		case ARM_STATE_THUMB_EE:
+			addr -= 4;
+			break;
+		case ARM_STATE_JAZELLE:
+			/* ?? */
+			break;
+	}
+	dpm->wp_pc = addr;
+}
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Other debug and support utilities
+ */
+
+void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
+{
+	struct target *target = dpm->arm->target;
+
+	dpm->dscr = dscr;
+
+	/* Examine debug reason */
+	switch (DSCR_ENTRY(dscr)) {
+		case 6:	/* Data abort (v6 only) */
+		case 7:	/* Prefetch abort (v6 only) */
+		/* FALL THROUGH -- assume a v6 core in abort mode */
+		case 0:	/* HALT request from debugger */
+		case 4:	/* EDBGRQ */
+			target->debug_reason = DBG_REASON_DBGRQ;
+			break;
+		case 1:	/* HW breakpoint */
+		case 3:	/* SW BKPT */
+		case 5:	/* vector catch */
+			target->debug_reason = DBG_REASON_BREAKPOINT;
+			break;
+		case 2:	/* asynch watchpoint */
+		case 10:/* precise watchpoint */
+			target->debug_reason = DBG_REASON_WATCHPOINT;
+			break;
+		default:
+			target->debug_reason = DBG_REASON_UNDEFINED;
+			break;
+	}
+}
+
+/*----------------------------------------------------------------------*/
+
+/*
+ * Setup and management support.
+ */
+
+/**
+ * Hooks up this DPM to its associated target; call only once.
+ * Initially this only covers the register cache.
+ *
+ * Oh, and watchpoints.  Yeah.
+ */
+int armv8_dpm_setup(struct arm_dpm *dpm)
+{
+	struct arm *arm = dpm->arm;
+	struct target *target = arm->target;
+	struct reg_cache *cache;
+
+	arm->dpm = dpm;
+
+	/* register access setup */
+	arm->full_context = arm_dpm_full_context;
+	arm->read_core_reg = arm_dpm_read_core_reg;
+	arm->write_core_reg = arm_dpm_write_core_reg;
+
+	cache = armv8_build_reg_cache(target, arm);
+	if (!cache)
+		return ERROR_FAIL;
+
+	*register_get_last_cache_p(&target->reg_cache) = cache;
+
+	/* coprocessor access setup */
+	arm->mrc = dpm_mrc;
+	arm->mcr = dpm_mcr;
+
+	/* breakpoint setup -- optional until it works everywhere */
+	if (!target->type->add_breakpoint) {
+		target->type->add_breakpoint = dpm_add_breakpoint;
+		target->type->remove_breakpoint = dpm_remove_breakpoint;
+	}
+
+	/* watchpoint setup */
+	target->type->add_watchpoint = dpm_add_watchpoint;
+	target->type->remove_watchpoint = dpm_remove_watchpoint;
+
+	/* FIXME add vector catch support */
+
+	dpm->nbp = 1 + ((dpm->didr >> 24) & 0xf);
+	dpm->dbp = calloc(dpm->nbp, sizeof *dpm->dbp);
+
+	dpm->nwp = 1 + ((dpm->didr >> 28) & 0xf);
+	dpm->dwp = calloc(dpm->nwp, sizeof *dpm->dwp);
+
+	if (!dpm->dbp || !dpm->dwp) {
+		free(dpm->dbp);
+		free(dpm->dwp);
+		return ERROR_FAIL;
+	}
+
+	LOG_INFO("%s: hardware has %d breakpoints, %d watchpoints",
+		target_name(target), dpm->nbp, dpm->nwp);
+
+	/* REVISIT ... and some of those breakpoints could match
+	 * execution context IDs...
+	 */
+
+	return ERROR_OK;
+}
+
+/**
+ * Reinitializes DPM state at the beginning of a new debug session
+ * or after a reset which may have affected the debug module.
+ */
+int armv8_dpm_initialize(struct arm_dpm *dpm)
+{
+	/* Disable all breakpoints and watchpoints at startup. */
+	if (dpm->bpwp_disable) {
+		unsigned i;
+
+		for (i = 0; i < dpm->nbp; i++) {
+			dpm->dbp[i].bpwp.number = i;
+			(void) dpm->bpwp_disable(dpm, i);
+		}
+		for (i = 0; i < dpm->nwp; i++) {
+			dpm->dwp[i].bpwp.number = 16 + i;
+			(void) dpm->bpwp_disable(dpm, 16 + i);
+		}
+	} else
+		LOG_WARNING("%s: can't disable breakpoints and watchpoints",
+			target_name(dpm->arm->target));
+
+	return ERROR_OK;
+}
diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
old mode 100644
new mode 100755
index 0393a44..cde3aeb
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -173,6 +173,16 @@ static int cortex_a_init_debug_access(struct target *target)
 
 	LOG_DEBUG(" ");
 
+    /* Strong Qu: Write 0 to DBGOSLAR(OS Lock Access Register, FC33_0300) */
+    LOG_USER("Clear DBGOSLAR.");
+    retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_OSLAR, 0);
+    if (retval != ERROR_OK)
+    {
+        LOG_USER("Failed to clear DBGOSLAR.");
+        return retval;
+    }
+
 	/* Unlocking the debug registers for modification
 	 * The debugport might be uninitialised so try twice */
 	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
@@ -787,6 +797,7 @@ static int cortex_a_poll(struct target *target)
 	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	enum target_state prev_target_state = target->state;
+    dap_ap_select(swjdp, 1);  //swjdp->apsel=1;
 	/*  toggle to another core is done by gdb as follow */
 	/*  maint packet J core_id */
 	/*  continue */
@@ -2368,6 +2379,7 @@ static int cortex_a_examine_first(struct target *target)
 	/* We do one extra read to ensure DAP is configured,
 	 * we call ahbap_debugport_init(swjdp) instead
 	 */
+	dap_ap_select(swjdp, 1); //swjdp->apsel=1;
 	retval = ahbap_debugport_init(swjdp);
 	if (retval != ERROR_OK)
 		return retval;
@@ -2378,12 +2390,23 @@ static int cortex_a_examine_first(struct target *target)
 		LOG_ERROR("Could not find APB-AP for debug access");
 		return retval;
 	}
-	/* Search for the AHB-AB */
+	/* Search for the AHB-AP */
+	/* SQU: tricky here. For 8916 it has AXI_AP but not AHB_AP as port 0 for sys-mem.And port3 is AHB_AP but it is RPM/Cortex M3
+	 * So either hard coded the memory_ap as port 0 or search AXI_AP first, or check AP type variant. Will take option 3.
+	 */
 	retval = dap_find_ap(swjdp, AP_TYPE_AHB_AP, &armv7a->memory_ap);
 	if (retval != ERROR_OK) {
 		/* AHB-AP not found - use APB-AP */
-		LOG_DEBUG("Could not find AHB-AP - using APB-AP for memory access");
-		armv7a->memory_ap_available = false;
+		LOG_DEBUG("Could not find AHB-AP - Will try AXI-AP for memory access");
+		/* Search for the AXI-AP */
+		retval = dap_find_ap(swjdp, AP_TYPE_AXI_AP, &armv7a->memory_ap);
+		if (retval != ERROR_OK) {
+			/* AXI-AP not found - use APB-AP */
+			LOG_DEBUG("Could not find AXI/AHB-AP - using APB-AP for memory access");
+			armv7a->memory_ap_available = false;
+		} else {
+			armv7a->memory_ap_available = true;
+		}
 	} else {
 		armv7a->memory_ap_available = true;
 	}
@@ -2502,33 +2525,12 @@ static int cortex_a_init_target(struct command_context *cmd_ctx,
 }
 
 static int cortex_a_init_arch_info(struct target *target,
-	struct cortex_a_common *cortex_a, struct jtag_tap *tap)
+	struct cortex_a_common *cortex_a)
 {
 	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
-	struct adiv5_dap *dap = &armv7a->dap;
-
-	armv7a->arm.dap = dap;
 
 	/* Setup struct cortex_a_common */
 	cortex_a->common_magic = CORTEX_A_COMMON_MAGIC;
-	/*  tap has no dap initialized */
-	if (!tap->dap) {
-		armv7a->arm.dap = dap;
-		/* Setup struct cortex_a_common */
-
-		/* prepare JTAG information for the new target */
-		cortex_a->jtag_info.tap = tap;
-		cortex_a->jtag_info.scann_size = 4;
-
-		/* Leave (only) generic DAP stuff for debugport_init() */
-		dap->jtag_info = &cortex_a->jtag_info;
-
-		/* Number of bits for tar autoincrement, impl. dep. at least 10 */
-		dap->tar_autoincr_block = (1 << 10);
-		dap->memaccess_tck = 80;
-		tap->dap = dap;
-	} else
-		armv7a->arm.dap = tap->dap;
 
 	cortex_a->fast_reg_read = 0;
 
@@ -2551,13 +2553,30 @@ static int cortex_a_init_arch_info(struct target *target,
 	return ERROR_OK;
 }
 
+void cortex_a_connect_dap(struct target *target, struct adiv5_dap *dap)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+
+	dap->memaccess_tck = 8;
+	dap->tar_autoincr_block = (1 << 10);
+
+	armv7a->arm.dap = dap;
+}
+
 static int cortex_a_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct cortex_a_common *cortex_a = calloc(1, sizeof(struct cortex_a_common));
 
 	cortex_a->armv7a_common.is_armv7r = false;
+	cortex_a_init_arch_info(target, cortex_a);
 
-	return cortex_a_init_arch_info(target, cortex_a, target->tap);
+	/* If it's not set, assume transport select is not swd. Nothing sets up the JTAG DAP so we have to. */
+	if (!global_dap)
+		global_dap = adiv5_jtag_dap_new(target->tap);
+
+	cortex_a_connect_dap(target, global_dap);
+ 
+	return ERROR_OK;
 }
 
 static int cortex_r4_target_create(struct target *target, Jim_Interp *interp)
@@ -2566,7 +2585,7 @@ static int cortex_r4_target_create(struct target *target, Jim_Interp *interp)
 
 	cortex_a->armv7a_common.is_armv7r = true;
 
-	return cortex_a_init_arch_info(target, cortex_a, target->tap);
+	return cortex_a_init_arch_info(target, cortex_a);
 }
 
 
diff --git a/src/target/cortex_a.h b/src/target/cortex_a.h
index 7b56fea..fb113fe 100644
--- a/src/target/cortex_a.h
+++ b/src/target/cortex_a.h
@@ -55,7 +55,6 @@ struct cortex_a_brp {
 
 struct cortex_a_common {
 	int common_magic;
-	struct arm_jtag jtag_info;
 
 	/* Context information */
 	uint32_t cpudbg_dscr;
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
new file mode 100755
index 0000000..a590764
--- /dev/null
+++ b/src/target/cortex_a53.c
@@ -0,0 +1,3289 @@
+/***************************************************************************
+ * Modified from cotrex_a.c
+ *                                                                         *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "breakpoints.h"
+#include "cortex_a.h"
+#include "register.h"
+#include "target_request.h"
+#include "target_type.h"
+#include "arm_opcodes.h"
+#include "armv8.h"
+#include <helper/time_support.h>
+
+static int cortex_a53_poll(struct target *target);
+static int cortex_a53_debug_entry(struct target *target);
+static int cortex_a53_restore_context(struct target *target, bool bpwp);
+static int cortex_a53_set_breakpoint(struct target *target,
+	struct breakpoint *breakpoint, uint8_t matchmode);
+static int cortex_a53_set_context_breakpoint(struct target *target,
+	struct breakpoint *breakpoint, uint8_t matchmode);
+static int cortex_a53_set_hybrid_breakpoint(struct target *target,
+	struct breakpoint *breakpoint);
+static int cortex_a53_unset_breakpoint(struct target *target,
+	struct breakpoint *breakpoint);
+static int cortex_a53_dap_read_coreregister_u32(struct target *target,
+	uint32_t *value, int regnum);
+static int cortex_a53_dap_write_coreregister_u32(struct target *target,
+	uint32_t value, int regnum);
+static int cortex_a53_mmu(struct target *target, int *enabled);
+static int cortex_a53_virt2phys(struct target *target,
+	uint32_t virt, uint32_t *phys);
+static int cortex_a53_virt2phys_64(struct target *target,
+	uint64_t virt, uint64_t *phys);
+static int cortex_a53_read_apb_ab_memory(struct target *target,
+	uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+
+static int force2A32=0;
+static uint32_t DR_h;	//for 64bit reg, keep the high 32bits
+static uint32_t DLR_h=0;
+
+/* check whether it is in AArch32 or AArch64 through dscr. Only valid at debug state
+ * return: 1 for AArch64, 0 for AArch32, -1 for not in debug state
+ */
+static int isAArch64(uint32_t dscr)
+{
+	if (force2A32) return 0;
+	if(dscr & 1) {
+		//is in debug state
+		//LOG_DEBUG("dscr is 0x%x", dscr);
+		if(dscr & (1<<(((dscr&0x300)>>8)+10))) return 1;
+		else return 0;
+	}
+	else {
+		LOG_ERROR("SQU: Not in Debug State with DSCR=0x%x. Cannot check the execution state", dscr);
+		return -1;
+	}
+}
+
+static void cortex_a53_dbg_dump(struct target *target)
+{	//Strong Qu: dump several key dbg reg for debug purpose:
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	int retval;
+	uint32_t dummy;
+
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + EDPRSR, &dummy);
+	LOG_USER("Read %d EDPRSR 0x%08" PRIx32, retval, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + EDECR, &dummy);
+	LOG_USER("Read %d EDECR 0x%08" PRIx32, retval, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + EDESR, &dummy);
+	LOG_USER("Read %d EDESR 0x%08" PRIx32, retval, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + EDSCR, &dummy);
+	LOG_USER("Read %d EDSCR 0x%08" PRIx32, retval, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + OSLAR_EL1, &dummy);
+	LOG_USER("Read %d OSLAR_EL1 0x%08" PRIx32, retval, dummy);
+
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + EDRCR, &dummy);
+	LOG_USER("Read %d EDRCR 0x%08" PRIx32, retval, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + EDACR, &dummy);
+	LOG_USER("Read %d EDACR 0x%08" PRIx32, retval, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + EDECCR, &dummy);
+	LOG_USER("Read %d EDECCR 0x%08" PRIx32, retval, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + EDPRCR, &dummy);
+	LOG_USER("Read %d EDPRCR 0x%08" PRIx32, retval, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + DBGAUTHSTATUS_EL1, &dummy);
+	LOG_USER("Read %d DBGAUTHSTATUS_EL1 0x%08" PRIx32, retval, dummy);
+}
+
+static void cortex_a53_cti_dump(struct target *target)
+{	//Strong Qu: dump several key CTI reg for debug purpose:
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	int retval;
+	uint32_t dummy;
+
+	//retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, cti_base + CTIDEVID, &dummy);
+	//LOG_USER("Read %d CTIDEVID 0x%08" PRIx32, retval, dummy); //RO, for 8916 it is 0x1040800
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTICONTROL, &dummy);
+	LOG_USER("Read %d CTICONTROL 0x%08" PRIx32, retval, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIGATE, &dummy);
+	LOG_USER("Read %d CTIGATE 0x%08" PRIx32, retval, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINEN(0), &dummy);
+	LOG_USER("Read %d CTIINEN0 0x%08" PRIx32, retval, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIOUTEN(0), &dummy);
+	LOG_USER("Read %d CTIOUTEN0 0x%08" PRIx32, retval, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTITRIGOUTSTATUS, &dummy);
+	LOG_USER("Read %d CTITRIGOUTSTATUS 0x%08" PRIx32, retval, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIAPPPULSE, &dummy);
+	LOG_USER("Read %d CTIAPPPULSE 0x%08" PRIx32, retval, dummy);
+}
+
+
+/*  restore cp15_control_reg at resume */
+static int cortex_a53_restore_cp15_control_reg(struct target *target)
+{
+	int retval = ERROR_OK;
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+
+	if (cortex_a53->cp15_control_reg != cortex_a53->cp15_control_reg_curr) {
+		cortex_a53->cp15_control_reg_curr = cortex_a53->cp15_control_reg;
+		/* LOG_INFO("cp15_control_reg: %8.8" PRIx32, cortex_a53->cp15_control_reg); */
+		retval = armv7a->arm.mcr(target, 15,
+				0, 0,	/* op1, op2 */
+				1, 0,	/* CRn, CRm */
+				cortex_a53->cp15_control_reg);
+	}
+	return retval;
+}
+
+/*  check address before cortex_a53_apb read write access with mmu on
+ *  remove apb predictible data abort */
+static int cortex_a53_check_address(struct target *target, uint32_t address)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	uint32_t os_border = armv7a->armv7a_mmu.os_border;
+	if ((address < os_border) &&
+		(armv7a->arm.core_mode == ARM_MODE_SVC)) {
+		LOG_ERROR("%" PRIx32 " access in userspace and target in supervisor", address);
+		return ERROR_FAIL;
+	}
+	if ((address >= os_border) &&
+		(cortex_a53->curr_mode != ARM_MODE_SVC)) {
+		armv8_dpm_modeswitch(&armv7a->dpm, ARM_MODE_SVC);
+		cortex_a53->curr_mode = ARM_MODE_SVC;
+		LOG_INFO("%" PRIx32 " access in kernel space and target not in supervisor",
+			address);
+		return ERROR_OK;
+	}
+	if ((address < os_border) &&
+		(cortex_a53->curr_mode == ARM_MODE_SVC)) {
+		armv8_dpm_modeswitch(&armv7a->dpm, ARM_MODE_ANY);
+		cortex_a53->curr_mode = ARM_MODE_ANY;
+	}
+	return ERROR_OK;
+}
+/*  modify cp15_control_reg in order to enable or disable mmu for :
+ *  - virt2phys address conversion
+ *  - read or write memory in phys or virt address */
+static int cortex_a53_mmu_modify(struct target *target, int enable)
+{
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	int retval = ERROR_OK;
+	if (enable) {
+		/*  if mmu enabled at target stop and mmu not enable */
+		if (!(cortex_a53->cp15_control_reg & 0x1U)) {
+			LOG_ERROR("trying to enable mmu on target stopped with mmu disable");
+			return ERROR_FAIL;
+		}
+		if (!(cortex_a53->cp15_control_reg_curr & 0x1U)) {
+			cortex_a53->cp15_control_reg_curr |= 0x1U;
+			retval = armv7a->arm.mcr(target, 15,
+					0, 0,	/* op1, op2 */
+					1, 0,	/* CRn, CRm */
+					cortex_a53->cp15_control_reg_curr);
+		}
+	} else {
+		if (cortex_a53->cp15_control_reg_curr & 0x4U) {
+			/*  data cache is active */
+			cortex_a53->cp15_control_reg_curr &= ~0x4U;
+			/* flush data cache armv7 function to be called */
+			if (armv7a->armv7a_mmu.armv7a_cache.flush_all_data_cache)
+				armv7a->armv7a_mmu.armv7a_cache.flush_all_data_cache(target);
+		}
+		if ((cortex_a53->cp15_control_reg_curr & 0x1U)) {
+			cortex_a53->cp15_control_reg_curr &= ~0x1U;
+			retval = armv7a->arm.mcr(target, 15,
+					0, 0,	/* op1, op2 */
+					1, 0,	/* CRn, CRm */
+					cortex_a53->cp15_control_reg_curr);
+		}
+	}
+	return retval;
+}
+
+/*
+ * Cortex-A8 Basic debug access, very low level assumes state is saved
+ */
+static int cortex_a53_init_debug_access(struct target *target)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	int retval;
+	uint32_t dummy;
+
+	LOG_DEBUG(" ");
+
+	//cortex_a53_dbg_dump(target);
+	//cortex_a53_cti_dump(target);
+	/* For ARMv8, only way to halt/restart from external debug is through CTI trigger. To halt all with channel chan:
+	0. Set CTICONTROL.GLBEN
+	1. CTIGATE[chan] = 1, so that each CTI passes channel events on internal channel chan to the CTM
+	2. CTIINEN0[chan] = 1, so that each CTI generates a channel event on channel chan in response to a Cross halt trigger event
+	3. CTIOUTEN0[chan] = 1, so that each CTI generates a Debug Request trigger event in response to an channel event on channel chan.
+	Later, just set CTIAPPPULSE[chan]=1 to trigger.
+	For restart, it is similar but using CTIINEN1 and CTIOUTEN1.
+	*/
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTICONTROL, 1);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIGATE, &dummy);
+	dummy |= (1<<CTIDBGCHAN_HALT)|(1<<CTIDBGCHAN_RESTART);
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIGATE, dummy);
+
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINEN(0), &dummy);
+	dummy |= 1<<CTIDBGCHAN_HALT;
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINEN(0), dummy);
+
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIOUTEN(0), &dummy);
+	dummy |= 1<<CTIDBGCHAN_HALT;
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIOUTEN(0), dummy);
+
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINEN(1), &dummy);
+	dummy |= 1<<CTIDBGCHAN_RESTART;
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINEN(1), dummy);
+
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIOUTEN(1), &dummy);
+	dummy |= 1<<CTIDBGCHAN_RESTART;
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIOUTEN(1), dummy);
+
+	//set EDECCR for catching exception
+	/*dummy = 8; //2;
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECCR, dummy);*/
+
+	//set HDE(bit14) for enable BP, WP and Halt Instruction
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + EDSCR, &dummy);
+	dummy |= 1 << 14; //set HDE to enable halt
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + EDSCR, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + EDSCR, &dummy);
+	LOG_DEBUG("Read %d EDSCR after set HDE 0x%08" PRIx32, retval, dummy);
+
+	/* Strong Qu: Write 0 to DBGOSLAR(OS Lock Access Register, FC33_0300) */
+	LOG_DEBUG("Clear DBGOSLAR.");
+    retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_OSLAR, 0);
+	if (retval != ERROR_OK)
+    {
+		LOG_ERROR("Failed to clear DBGOSLAR.");
+        return retval;
+	}
+
+	/* Unlocking the debug registers for modification
+	 * The debugport might be uninitialised so try twice */
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+	if (retval != ERROR_OK) {
+		/* try again */
+		retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+		if (retval == ERROR_OK)
+			LOG_USER(
+				"Locking debug access failed on first, but succeeded on second try.");
+	}
+	if (retval != ERROR_OK)
+		return retval;
+	/* Clear Sticky Power Down status Bit in PRSR to enable access to
+	   the registers in the Core Power Domain */
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_PRSR, &dummy);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Enabling of instruction execution in debug mode is done in debug_entry code */
+
+	/* Resync breakpoint registers */
+
+	/* Since this is likely called from init or reset, update target state information*/
+	return cortex_a53_poll(target);
+}
+
+/* To reduce needless round-trips, pass in a pointer to the current
+ * DSCR value.  Initialize it to zero if you just need to know the
+ * value on return from this function; or DSCR_INSTR_COMP if you
+ * happen to know that no instruction is pending.
+ */
+static int cortex_a53_exec_opcode(struct target *target,
+	uint32_t opcode, uint32_t *dscr_p)
+{
+	uint32_t dscr;
+	int retval;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+
+	//SQU: why not just read it? dscr = dscr_p ? *dscr_p : 0;
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	LOG_DEBUG("exec opcode 0x%08" PRIx32, opcode);
+
+	/* Wait for InstrCompl bit to be set */
+	long long then = timeval_ms();
+	while ((dscr & DSCR_INSTR_COMP) == 0) {
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Could not read DSCR register, opcode = 0x%08" PRIx32, opcode);
+			return retval;
+		}
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for cortex_a53_exec_opcode");
+			return ERROR_FAIL;
+		}
+	}
+
+    //override opcode
+	if(opcode==0xE12FF000)
+	{//in case of ARMV4_5_MSR(0, 0) for setting CPSR
+		//LOG_USER("SQU: ARMv8: set CPSR");
+		if(isAArch64(dscr)) opcode=ARMV8_A64_MSR(3, 3, 4, 5, 0, 0); //MSR DSPSR_EL0, R0
+        else opcode=ARMV8_T32_MCR(15, 3, 0, 4, 5, 0);
+	}
+	else if(opcode==0xE1A0F000)
+	{//in case of MOV pc, r0
+		//LOG_USER("SQU: ARMv8: set pc ");
+        if(isAArch64(dscr)) opcode=ARMV8_A64_MSR(3, 3, 4, 5, 1, 0); //MSR DLR_EL0, R0
+        else opcode=ARMV8_T32_MCR(15, 3, 0, 4, 5, 1);
+	}
+	else if(opcode==0xE10F0000)
+	{//in case of ARMV4_5_MRS(0, 0) for reading CPSR
+		//LOG_USER("SQU: ARMv8: read CPSR");
+		if(isAArch64(dscr)) opcode=ARMV8_A64_MRS(3, 3, 4, 5, 0, 0); //MRS R0, DSPSR_EL0
+        else opcode=ARMV8_T32_MRC(15, 3, 0, 4, 5, 0); //change to read DSPSR
+	}
+	else if(opcode==0xE1A0000F)
+	{//in case of MOV r0, pc
+		//LOG_USER("SQU: ARMv8: read pc");
+        if(isAArch64(dscr)) opcode=ARMV8_A64_MRS(3, 3, 4, 5, 1, 0); //MRS R0, DLR_EL0
+        else opcode=ARMV8_T32_MRC(15, 3, 0, 4, 5, 1); //change to read DLR
+	}
+    else if((opcode&0xFF000000)==0xEE000000) //MRC/MCR
+    {
+        //LOG_USER("SQU: MCR/MRC L=%d cp=%d op1=%d CRn=%d CRm=%d op2=%d Rt=%d", (opcode&0x100000)>>20, (opcode&0xF00)>>8, (opcode&0xE00000)>>21, (opcode&0xF0000)>>16, opcode&0xF,(opcode&0xE0)>>5,(opcode&0xF000)>>12);
+        if(isAArch64(dscr)) //convert MCR/MRC to MSR/MRS
+        {
+            switch (opcode & 0xEF0FFF)
+        	{
+        	case 0xE15: //DTRTx/Rx
+                opcode=0xD5130500|((opcode&0x100000)<<1)|((opcode&0xF000)>>12);
+                break;
+        	case 0x10F10: //SCTLR
+            	opcode=0xD51E1000|((opcode&0x100000)<<1)|((opcode&0xF000)>>12);
+            	break;
+        	case 0x20F50: //TTBCR
+            	opcode=0xD51E2040|((opcode&0x100000)<<1)|((opcode&0xF000)>>12);
+            	break;
+        	case 0xFB0:	//MPIDR
+        	case 0x200F30: //CLIDR
+        	case 0x400F10: //CSSELR
+        	case 0x200F10: //CCSIDR
+        		//coding: MSR/MRS|			L			|		cp			 |			op1			|			CRn		  |		CRm			|	op2		  |  Xt
+        		opcode=0xD5100000|((opcode&0x100000)<<1)|((opcode&0x100)<<11)|((opcode&0xE00000)>>5)|((opcode&0xF0000)>>4)|((opcode&0xF)<<8)|(opcode&0xE0)|((opcode&0xF000)>>12);
+            	break;
+        	case 0x70F95: //CP15ISB
+        		opcode=0xD5033FDF; //ISB CRm=b'1111
+        		break;
+        	default:
+        		LOG_USER("SQU: Need to handle MCR/MRC opcode=0x%x", opcode);
+        		break;
+        	}
+        }
+        else opcode = (opcode>>16) | (opcode<<16);
+    }
+    else
+    {
+    	LOG_DEBUG("SQU: Assume AArch64 opcode=0x%x", opcode);
+    }
+
+    /*if(isAArch64(dpm->dscr)) return cortex_a53_instr_write_data_dcc(dpm, 0xD5330500+((opcode>>12)&0xF), data); //MRS
+	else return cortex_a53_instr_write_data_dcc(dpm, (opcode>>16)|(opcode<<16), data); //MRC
+	//MSR DBGDTRTX_EL0,X0 / MCR p14,0,R0,c0,c5,0
+	if(isAArch64(dpm->dscr)) return cortex_a53_instr_read_data_dcc(dpm, 0xD5130500+((opcode>>12)&0xF), data); //MSR
+	else return cortex_a53_instr_read_data_dcc(dpm, (opcode>>16)|(opcode<<16), data);   //MCR*/
+
+	retval = mem_ap_sel_write_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_ITR, opcode);
+	if (retval != ERROR_OK)
+		return retval;
+
+	then = timeval_ms();
+	do {
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Could not read DSCR register");
+			return retval;
+		}
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for cortex_a53_exec_opcode opcode = 0x%08" PRIx32, opcode);
+			return ERROR_FAIL;
+		}
+	} while ((dscr & DSCR_INSTR_COMP) == 0);	/* Wait for InstrCompl bit to be set */
+	if(dscr & 0x40)
+	{
+		LOG_ERROR("Err set for opcode = 0x%x, with DSCR=0x%x", opcode, dscr);
+		//clear the error
+		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDRCR, 1<<2); //set EDRCR.CSE to clear EDSCR.ERR
+	}
+	if (dscr_p)
+		*dscr_p = dscr;
+
+	return retval;
+}
+
+/**************************************************************************
+Read core register with very few exec_opcode, fast but needs work_area.
+This can cause problems with MMU active.
+**************************************************************************/
+static int cortex_a53_read_regs_through_mem(struct target *target, uint32_t address,
+	uint32_t *regfile)
+{
+	int retval = ERROR_OK;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+
+	retval = cortex_a53_dap_read_coreregister_u32(target, regfile, 0);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cortex_a53_dap_write_coreregister_u32(target, address, 0);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cortex_a53_exec_opcode(target, ARMV4_5_STMIA(0, 0xFFFE, 0, 0), NULL);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = mem_ap_sel_read_buf(swjdp, armv7a->memory_ap,
+			(uint8_t *)(&regfile[1]), 4, 15, address);
+
+	return retval;
+}
+
+static int cortex_a53_dap_read_coreregister_u32(struct target *target,
+	uint32_t *value, int regnum)
+{
+	int retval = ERROR_OK;
+	uint8_t reg = regnum&0xFF;
+	uint32_t dscr = 0;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+
+	if (reg > 17)
+		return retval;
+
+	if (reg < 15) {
+		/* Rn to DCCTX, "MCR p14, 0, Rn, c0, c5, 0"  0xEE00nE15 */
+		retval = cortex_a53_exec_opcode(target,
+				ARMV4_5_MCR(14, 0, reg, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+	} else if (reg == 15) {
+		/* "MOV r0, r15"; then move r0 to DCCTX */
+		retval = cortex_a53_exec_opcode(target, 0xE1A0000F, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a53_exec_opcode(target,
+				ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+	} else {
+		/* "MRS r0, CPSR" or "MRS r0, SPSR"
+		 * then move r0 to DCCTX
+		 */
+		retval = cortex_a53_exec_opcode(target, ARMV4_5_MRS(0, reg & 1), &dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a53_exec_opcode(target,
+				ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	/* Wait for DTRRXfull then read DTRRTX */
+	long long then = timeval_ms();
+	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for cortex_a53_exec_opcode");
+			return ERROR_FAIL;
+		}
+	}
+
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_DTRTX, value);
+	LOG_DEBUG("read DCC 0x%08" PRIx32, *value);
+
+	return retval;
+}
+
+static int cortex_a53_dap_write_coreregister_u32(struct target *target,
+	uint32_t value, int regnum)
+{
+	int retval = ERROR_OK;
+	uint8_t Rd = regnum&0xFF;
+	uint32_t dscr;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+
+	LOG_DEBUG("register %i, value 0x%08" PRIx32, regnum, value);
+
+	/* Check that DCCRX is not full */
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		return retval;
+	if (dscr & DSCR_DTR_RX_FULL) {
+		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
+		/* Clear DCCRX with MRC(p14, 0, Rd, c0, c5, 0), opcode  0xEE100E15 */
+		retval = cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	if (Rd > 17)
+		return retval;
+
+	/* Write DTRRX ... sets DSCR.DTRRXfull but exec_opcode() won't care */
+	LOG_DEBUG("write DCC 0x%08" PRIx32, value);
+	retval = mem_ap_sel_write_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_DTRRX, value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (Rd < 15) {
+		/* DCCRX to Rn, "MRC p14, 0, Rn, c0, c5, 0", 0xEE10nE15 */
+		retval = cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, Rd, 0, 5, 0),
+				&dscr);
+
+		if (retval != ERROR_OK)
+			return retval;
+	} else if (Rd == 15) {
+		/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15
+		 * then "mov r15, r0"
+		 */
+		retval = cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a53_exec_opcode(target, 0xE1A0F000, &dscr);
+		if (retval != ERROR_OK)
+			return retval;
+	} else {
+		/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15
+		 * then "MSR CPSR_cxsf, r0" or "MSR SPSR_cxsf, r0" (all fields)
+		 */
+		retval = cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = cortex_a53_exec_opcode(target, ARMV4_5_MSR_GP(0, 0xF, Rd & 1),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* "Prefetch flush" after modifying execution status in CPSR */
+		if (Rd == 16) {
+			retval = cortex_a53_exec_opcode(target,
+					ARMV4_5_MCR(15, 0, 0, 7, 5, 4),
+					&dscr);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+	}
+
+	return retval;
+}
+
+/* Write to memory mapped registers directly with no cache or mmu handling */
+static int cortex_a53_dap_write_memap_register_u32(struct target *target,
+	uint32_t address,
+	uint32_t value)
+{
+	int retval;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, address, value);
+
+	return retval;
+}
+
+/*
+ * Cortex-A8 implementation of Debug Programmer's Model
+ *
+ * NOTE the invariant:  these routines return with DSCR_INSTR_COMP set,
+ * so there's no need to poll for it before executing an instruction.
+ *
+ * NOTE that in several of these cases the "stall" mode might be useful.
+ * It'd let us queue a few operations together... prepare/finish might
+ * be the places to enable/disable that mode.
+ */
+
+static inline struct cortex_a_common *dpm_to_a8(struct arm_dpm *dpm)
+{
+	return container_of(dpm, struct cortex_a_common, armv7a_common.dpm);
+}
+
+static int cortex_a53_write_dcc(struct cortex_a_common *a8, uint32_t data)
+{
+	LOG_DEBUG("write DCC 0x%08" PRIx32, data);
+	if(isAArch64(a8->cpudbg_dscr))
+	{//assume high 32bit is zero
+		mem_ap_sel_write_u32(a8->armv7a_common.arm.dap,
+			a8->armv7a_common.debug_ap, a8->armv7a_common.debug_base + CPUDBG_DTRTX, 0);
+	}
+	return mem_ap_sel_write_u32(a8->armv7a_common.arm.dap,
+		a8->armv7a_common.debug_ap, a8->armv7a_common.debug_base + CPUDBG_DTRRX, data);
+}
+
+static int cortex_a53_read_dcc(struct cortex_a_common *a8, uint32_t *data,
+	uint32_t *dscr_p)
+{
+	struct adiv5_dap *swjdp = a8->armv7a_common.arm.dap;
+	uint32_t dscr = DSCR_INSTR_COMP;
+	int retval;
+
+	if (dscr_p)
+		dscr = *dscr_p;
+
+	/* Wait for DTRRXfull */
+	long long then = timeval_ms();
+	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
+		retval = mem_ap_sel_read_atomic_u32(swjdp, a8->armv7a_common.debug_ap,
+				a8->armv7a_common.debug_base + CPUDBG_DSCR,
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for read dcc");
+			return ERROR_FAIL;
+		}
+	}
+
+	retval = mem_ap_sel_read_atomic_u32(swjdp, a8->armv7a_common.debug_ap,
+			a8->armv7a_common.debug_base + CPUDBG_DTRTX, data);
+	if (retval != ERROR_OK)
+		return retval;
+	if(isAArch64(dscr))
+	{
+		mem_ap_sel_read_atomic_u32(swjdp, a8->armv7a_common.debug_ap,
+			a8->armv7a_common.debug_base + CPUDBG_DTRRX, &DR_h); //DTRRX holds high dword for 64bit data
+		LOG_DEBUG("SQU: 64bit read hd=0x%x", DR_h);
+	}
+	/* LOG_DEBUG("read DCC 0x%08" PRIx32, *data); */
+
+	if (dscr_p)
+		*dscr_p = dscr;
+
+	return retval;
+}
+
+static int cortex_a53_dpm_prepare(struct arm_dpm *dpm)
+{
+	struct cortex_a_common *a8 = dpm_to_a8(dpm);
+	struct adiv5_dap *swjdp = a8->armv7a_common.arm.dap;
+	uint32_t dscr;
+	int retval;
+
+	/* set up invariant:  INSTR_COMP is set after ever DPM operation */
+	long long then = timeval_ms();
+	for (;; ) {
+		retval = mem_ap_sel_read_atomic_u32(swjdp, a8->armv7a_common.debug_ap,
+				a8->armv7a_common.debug_base + CPUDBG_DSCR,
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+		if ((dscr & DSCR_INSTR_COMP) != 0)
+			break;
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for dpm prepare");
+			return ERROR_FAIL;
+		}
+	}
+
+	/* this "should never happen" ... */
+	if (dscr & DSCR_DTR_RX_FULL) {
+		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
+		/* Clear DCCRX */
+		retval = cortex_a53_exec_opcode(
+				a8->armv7a_common.arm.target,
+				ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
+				&dscr);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return retval;
+}
+
+static int cortex_a53_dpm_finish(struct arm_dpm *dpm)
+{
+	/* REVISIT what could be done here? */
+	return ERROR_OK;
+}
+
+static int cortex_a53_instr_write_data_dcc(struct arm_dpm *dpm,
+	uint32_t opcode, uint32_t data)
+{
+	struct cortex_a_common *a8 = dpm_to_a8(dpm);
+	int retval;
+	uint32_t dscr = DSCR_INSTR_COMP;
+
+	retval = cortex_a53_write_dcc(a8, data);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return cortex_a53_exec_opcode(
+			a8->armv7a_common.arm.target,
+			opcode,
+			&dscr);
+}
+
+static int cortex_a53_instr_write_data_r0(struct arm_dpm *dpm,
+	uint32_t opcode, uint32_t data)
+{
+	struct cortex_a_common *a8 = dpm_to_a8(dpm);
+	uint32_t dscr = DSCR_INSTR_COMP;
+	int retval;
+
+	retval = cortex_a53_write_dcc(a8, data);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15 */
+	retval = cortex_a53_exec_opcode(
+			a8->armv7a_common.arm.target,
+			ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
+			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* then the opcode, taking data from R0 */
+	retval = cortex_a53_exec_opcode(
+			a8->armv7a_common.arm.target,
+			opcode,
+			&dscr);
+
+	return retval;
+}
+
+static int cortex_a53_instr_cpsr_sync(struct arm_dpm *dpm)
+{
+	struct target *target = dpm->arm->target;
+	uint32_t dscr = DSCR_INSTR_COMP;
+
+	/* "Prefetch flush" after modifying execution status in CPSR */
+	return cortex_a53_exec_opcode(target,
+			ARMV4_5_MCR(15, 0, 0, 7, 5, 4),
+			&dscr);
+}
+
+static int cortex_a53_instr_read_data_dcc(struct arm_dpm *dpm,
+	uint32_t opcode, uint32_t *data)
+{
+	struct cortex_a_common *a8 = dpm_to_a8(dpm);
+	int retval;
+	uint32_t dscr = DSCR_INSTR_COMP;
+
+	/* the opcode, writing data to DCC */
+	retval = cortex_a53_exec_opcode(
+			a8->armv7a_common.arm.target,
+			opcode,
+			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return cortex_a53_read_dcc(a8, data, &dscr);
+}
+
+static int cortex_a53_instr_read_data_r0(struct arm_dpm *dpm,
+	uint32_t opcode, uint32_t *data)
+{
+	struct cortex_a_common *a8 = dpm_to_a8(dpm);
+	uint32_t dscr = DSCR_INSTR_COMP;
+	int retval;
+    uint32_t dtrtx;
+
+	/* the opcode, writing data to R0 */
+	retval = cortex_a53_exec_opcode(
+			a8->armv7a_common.arm.target,
+			opcode,
+			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write R0 to DCC */
+	retval = cortex_a53_exec_opcode(
+			a8->armv7a_common.arm.target,
+			ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
+			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+    retval = cortex_a53_read_dcc(a8, &dtrtx, &dscr);
+    if(opcode==0xE1A0000F)
+	{//in case of MOV r0, pc
+		if(isAArch64(dscr))
+		{
+			DLR_h=DR_h;
+			LOG_DEBUG("SQU: ARMv8: read 64bits pc= 0x%x%08x", DLR_h, dtrtx);
+		}
+		else
+		{
+			LOG_DEBUG("SQU: ARMv8: read pc= 0x%x", dtrtx);
+		}
+		if(dpm->arm->core_state==ARM_STATE_ARM) //SQU: adjust PC to make OOCD happy
+		{
+			dtrtx += 8;
+		}
+		else dtrtx += 4;
+    }
+    *data=dtrtx;
+	return retval;
+}
+
+static int cortex_a53_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
+	uint32_t addr, uint32_t control)
+{
+	struct cortex_a_common *a8 = dpm_to_a8(dpm);
+	uint32_t vr = a8->armv7a_common.debug_base;
+	uint32_t cr = a8->armv7a_common.debug_base;
+	int retval;
+
+	switch (index_t) {
+		case 0 ... 15:	/* breakpoints */
+			vr += CPUDBG_BVR_EL1_BASE;
+			cr += CPUDBG_BCR_EL1_BASE;
+			break;
+		case 16 ... 31:	/* watchpoints */
+			vr += CPUDBG_WVR_EL1_BASE;
+			cr += CPUDBG_WCR_EL1_BASE;
+			index_t -= 16;
+			break;
+		default:
+			return ERROR_FAIL;
+	}
+	vr += index_t<<4;
+	cr += index_t<<4;
+
+	LOG_DEBUG("A8: bpwp enable, vr %08x cr %08x",
+		(unsigned) vr, (unsigned) cr);
+
+	retval = cortex_a53_dap_write_memap_register_u32(dpm->arm->target,
+			vr, addr);
+	if (retval != ERROR_OK)
+		return retval;
+    //SQU: assume the addr is 32 bits for now. TODO: fix it
+	retval = cortex_a53_dap_write_memap_register_u32(dpm->arm->target,
+			vr+4, DLR_h);
+	retval = cortex_a53_dap_write_memap_register_u32(dpm->arm->target,
+			cr, control);
+	return retval;
+}
+
+static int cortex_a53_bpwp_disable(struct arm_dpm *dpm, unsigned index_t)
+{
+	struct cortex_a_common *a8 = dpm_to_a8(dpm);
+	uint32_t cr;
+
+	switch (index_t) {
+		case 0 ... 15:
+			cr = a8->armv7a_common.debug_base + CPUDBG_BCR_EL1_BASE;
+			break;
+		case 16 ... 31:
+			cr = a8->armv7a_common.debug_base + CPUDBG_WCR_EL1_BASE;
+			index_t -= 16;
+			break;
+		default:
+			return ERROR_FAIL;
+	}
+	cr += index_t<<4;
+
+	LOG_DEBUG("A8: bpwp disable, cr %08x", (unsigned) cr);
+
+	/* clear control register */
+	return cortex_a53_dap_write_memap_register_u32(dpm->arm->target, cr, 0);
+}
+
+static int cortex_a53_dpm_setup(struct cortex_a_common *a8, uint32_t dfr0)
+{
+	struct arm_dpm *dpm = &a8->armv7a_common.dpm;
+	int retval;
+
+	dpm->arm = &a8->armv7a_common.arm;
+	dpm->didr = (dfr0>>8&0xF00000)|(dfr0<<8&0xF0000000)|(dfr0<<12&0xF000000);
+
+	dpm->prepare = cortex_a53_dpm_prepare;
+	dpm->finish = cortex_a53_dpm_finish;
+
+	dpm->instr_write_data_dcc = cortex_a53_instr_write_data_dcc;
+	dpm->instr_write_data_r0 = cortex_a53_instr_write_data_r0;
+	dpm->instr_cpsr_sync = cortex_a53_instr_cpsr_sync;
+
+	dpm->instr_read_data_dcc = cortex_a53_instr_read_data_dcc;
+	dpm->instr_read_data_r0 = cortex_a53_instr_read_data_r0;
+
+	dpm->bpwp_enable = cortex_a53_bpwp_enable;
+	dpm->bpwp_disable = cortex_a53_bpwp_disable;
+
+	retval = armv8_dpm_setup(dpm);
+	if (retval == ERROR_OK)
+		retval = armv8_dpm_initialize(dpm);
+
+	return retval;
+}
+static struct target *get_cortex_a53(struct target *target, int32_t coreid)
+{
+	struct target_list *head;
+	struct target *curr;
+
+	head = target->head;
+	while (head != (struct target_list *)NULL) {
+		curr = head->target;
+		if ((curr->coreid == coreid) && (curr->state == TARGET_HALTED))
+			return curr;
+		head = head->next;
+	}
+	return target;
+}
+static int cortex_a53_halt(struct target *target);
+
+static int cortex_a53_halt_smp(struct target *target)
+{
+	int retval = 0;
+	struct target_list *head;
+	struct target *curr;
+	head = target->head;
+	while (head != (struct target_list *)NULL) {
+		curr = head->target;
+		if ((curr != target) && (curr->state != TARGET_HALTED))
+			retval += cortex_a53_halt(curr);
+		head = head->next;
+	}
+	return retval;
+}
+
+static int update_halt_gdb(struct target *target)
+{
+	int retval = 0;
+	if (target->gdb_service && target->gdb_service->core[0] == -1) {
+		target->gdb_service->target = target;
+		target->gdb_service->core[0] = target->coreid;
+		retval += cortex_a53_halt_smp(target);
+	}
+	return retval;
+}
+
+/*
+ * Cortex-A8 Run control
+ */
+
+static int cortex_a53_poll(struct target *target)
+{
+	int retval = ERROR_OK;
+	uint32_t dscr;
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	enum target_state prev_target_state = target->state;
+    dap_ap_select(swjdp, 1);  //swjdp->apsel=1;
+	/*  toggle to another core is done by gdb as follow */
+	/*  maint packet J core_id */
+	/*  continue */
+	/*  the next polling trigger an halt event sent to gdb */
+	if ((target->state == TARGET_HALTED) && (target->smp) &&
+		(target->gdb_service) &&
+		(target->gdb_service->target == NULL)) {
+		target->gdb_service->target =
+			get_cortex_a53(target, target->gdb_service->core[1]);
+		target_call_event_callbacks(target, TARGET_EVENT_HALTED);
+		return retval;
+	}
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		return retval;
+	cortex_a53->cpudbg_dscr = dscr;
+
+	if (DSCR_RUN_MODE(dscr) == (DSCR_CORE_HALTED | DSCR_CORE_RESTARTED)) {
+		if (prev_target_state != TARGET_HALTED) {
+			/* We have a halting debug event */
+			LOG_DEBUG("Target halted");
+			target->state = TARGET_HALTED;
+			if ((prev_target_state == TARGET_RUNNING)
+				|| (prev_target_state == TARGET_UNKNOWN)
+				|| (prev_target_state == TARGET_RESET)) {
+				retval = cortex_a53_debug_entry(target);
+				if (retval != ERROR_OK)
+					return retval;
+				if (target->smp) {
+					retval = update_halt_gdb(target);
+					if (retval != ERROR_OK)
+						return retval;
+				}
+				target_call_event_callbacks(target,
+					TARGET_EVENT_HALTED);
+			}
+			if (prev_target_state == TARGET_DEBUG_RUNNING) {
+				LOG_DEBUG(" ");
+
+				retval = cortex_a53_debug_entry(target);
+				if (retval != ERROR_OK)
+					return retval;
+				if (target->smp) {
+					retval = update_halt_gdb(target);
+					if (retval != ERROR_OK)
+						return retval;
+				}
+
+				target_call_event_callbacks(target,
+					TARGET_EVENT_DEBUG_HALTED);
+			}
+		}
+	} else if (DSCR_RUN_MODE(dscr) == DSCR_CORE_RESTARTED)
+		target->state = TARGET_RUNNING;
+	else {
+		LOG_DEBUG("Unknown target state dscr = 0x%08" PRIx32, dscr);
+		target->state = TARGET_UNKNOWN;
+	}
+
+	return retval;
+}
+
+static int cortex_a53_halt(struct target *target)
+{
+	int retval = ERROR_OK;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	uint32_t dummy;
+
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+					armv7a->debug_base + EDSCR, &dummy);
+	LOG_USER("Before halt EDSCR = 0x%08" PRIx32, dummy);
+	/*retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDPRSR, &dummy);
+	LOG_USER("And EDPRSR = 0x%08" PRIx32, dummy);
+	cortex_a53_dbg_dump(target);
+	cortex_a53_cti_dump(target);
+	LOG_USER("\n Now set CTIAPPULSE to request halt");*/
+
+	/*
+	 * Tell the core to be halted by set CTIAPPPULSE with right channel to trigger.
+	 * SS of EDECR and EDESR are for single step.
+	 * For ARMv7 it used to be setting 1 to CPUDBG_DRCR and read CPUDBG_DSCR
+	 */
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIAPPPULSE, 1<<CTIDBGCHAN_HALT); //trigger dbg req evt
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDSCR, &dummy);
+	LOG_USER("After CTI triggered: %d EDSCR 0x%08" PRIx32, retval, dummy);
+	//cortex_a53_cti_dump(target);
+
+	/*
+	 * enter halting debug mode
+	 */
+
+	long long then = timeval_ms();
+	for (;; ) {
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDPRSR, &dummy);
+		if (retval != ERROR_OK)
+			return retval;
+		if ((dummy & 0x10) == 0x10)
+			break;
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for halt");
+			cortex_a53_dbg_dump(target);
+			return ERROR_FAIL;
+		}
+	}
+	//LOG_USER("Halt success with EDPRSR = 0x%08" PRIx32, dummy);
+	//check DLR_EL0 and DSPSR_EL0
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDSCR, &dummy);
+	LOG_USER(" EDSCR = 0x%08" PRIx32, dummy);
+	if(isAArch64(dummy)) target->is_64b=true;
+	else target->is_64b=false;
+	/*remote below hack. Changing state should be a request from gdb client, but not forced here
+	if(isAArch64(dummy))
+	{
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 1, 1, 0, 0), &dummy); //read SCR_EL3 to X0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+		LOG_USER("Running in AArch64. SCR_EL3=0x%x",dummy);
+		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 6, 1, 1, 0, 0), &dummy); //SCR_EL3=X0
+		LOG_USER("DRPS");
+		cortex_a53_exec_opcode(target, 0xD6BF03E0, &dummy); //0x8F00F3DE=>ERET 0xD6BF03E0=>DRPS
+		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, 0);
+		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x1D0);
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 3, 4, 5, 0, 0), &dummy);
+		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, 0);
+		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0xFC010000); //0x100084 is for 8916
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 3, 4, 5, 1, 0), &dummy);
+		//send CTI ACK
+		retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINTACK, 1);
+		then = timeval_ms();
+		for (;; ) {
+			retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTITRIGOUTSTATUS, &dummy);
+			if (retval != ERROR_OK) return retval;
+			if ((dummy & 1) == 0) break;
+			if (timeval_ms() > then + 1000) {
+				LOG_ERROR("Timeout waiting for CTI ack");
+				return ERROR_FAIL;
+			}
+		}
+		//resume
+		retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIAPPPULSE, 1<<CTIDBGCHAN_RESTART); //restart
+		if (retval != ERROR_OK) 	return retval;
+		then = timeval_ms();
+		for (;; ) {
+			retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDPRSR, &dummy);
+			if (retval != ERROR_OK) return retval;
+			if ((dummy & (1<<11)) != 0) break;
+			if (timeval_ms() > then + 1000) {
+				LOG_ERROR("Timeout waiting for resume");
+				return ERROR_FAIL;
+			}
+		}
+		retval = cortex_a53_halt(target); //recursively request halt
+	}*/
+	if(isAArch64(dummy)) target->is_64b=false; //true;
+	else target->is_64b=false;
+	target->debug_reason = DBG_REASON_DBGRQ;
+
+	return retval;
+}
+
+static int cortex_a53_internal_restore(struct target *target, int current,
+	uint64_t *address, int handle_breakpoints, int debug_execution)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm *arm = &armv7a->arm;
+	int retval;
+	uint32_t resume_pc;
+
+	if (!debug_execution)
+		target_free_all_working_areas(target);
+
+#if 0
+	if (debug_execution) {
+		/* Disable interrupts */
+		/* We disable interrupts in the PRIMASK register instead of
+		 * masking with C_MASKINTS,
+		 * This is probably the same issue as Cortex-M3 Errata 377493:
+		 * C_MASKINTS in parallel with disabled interrupts can cause
+		 * local faults to not be taken. */
+		buf_set_u32(armv7m->core_cache->reg_list[ARMV7M_PRIMASK].value, 0, 32, 1);
+		armv7m->core_cache->reg_list[ARMV7M_PRIMASK].dirty = 1;
+		armv7m->core_cache->reg_list[ARMV7M_PRIMASK].valid = 1;
+
+		/* Make sure we are in Thumb mode */
+		buf_set_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0, 32,
+			buf_get_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0,
+			32) | (1 << 24));
+		armv7m->core_cache->reg_list[ARMV7M_xPSR].dirty = 1;
+		armv7m->core_cache->reg_list[ARMV7M_xPSR].valid = 1;
+	}
+#endif
+//SQUTODO: now address and PC are 64bits
+	/* current = 1: continue on current pc, otherwise continue at <address> */
+	resume_pc = buf_get_u32(arm->pc->value, 0, 32);
+	if (!current)
+		resume_pc = *address;
+	else
+		*address = resume_pc;
+
+	/* Make sure that the Armv7 gdb thumb fixups does not
+	 * kill the return address
+	 */
+	switch (arm->core_state) {
+		case ARM_STATE_ARM:
+			resume_pc &= 0xFFFFFFFC;
+			break;
+		case ARM_STATE_THUMB:
+		case ARM_STATE_THUMB_EE:
+			/* When the return address is loaded into PC
+			 * bit 0 must be 1 to stay in Thumb state
+			 */
+			resume_pc |= 0x1;
+			break;
+		case ARM_STATE_JAZELLE:
+			LOG_ERROR("How do I resume into Jazelle state??");
+			return ERROR_FAIL;
+	}
+	LOG_DEBUG("resume pc = 0x%08" PRIx32, resume_pc);
+	buf_set_u32(arm->pc->value, 0, 32, resume_pc);
+	arm->pc->dirty = 1;
+	arm->pc->valid = 1;
+	/* restore dpm_mode at system halt */
+	armv8_dpm_modeswitch(&armv7a->dpm, ARM_MODE_ANY);
+	/* called it now before restoring context because it uses cpu
+	 * register r0 for restoring cp15 control register */
+	retval = cortex_a53_restore_cp15_control_reg(target);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = cortex_a53_restore_context(target, handle_breakpoints);
+	if (retval != ERROR_OK)
+		return retval;
+	target->debug_reason = DBG_REASON_NOTHALTED;
+	target->state = TARGET_RUNNING;
+
+	/* registers are now invalid */
+	register_cache_invalidate(arm->core_cache);
+
+#if 0
+	/* the front-end may request us not to handle breakpoints */
+	if (handle_breakpoints) {
+		/* Single step past breakpoint at current address */
+		breakpoint = breakpoint_find(target, resume_pc);
+		if (breakpoint) {
+			LOG_DEBUG("unset breakpoint at 0x%8.8x", breakpoint->address);
+			cortex_m3_unset_breakpoint(target, breakpoint);
+			cortex_m3_single_step_core(target);
+			cortex_m3_set_breakpoint(target, breakpoint);
+		}
+	}
+
+#endif
+	return retval;
+}
+
+static int cortex_a53_internal_restart(struct target *target)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm *arm = &armv7a->arm;
+	struct adiv5_dap *swjdp = arm->dap;
+	int retval;
+	uint32_t dscr, dummy;
+
+	/*
+	 * * Restart core and wait for it to be started.  Clear ITRen and sticky
+	 * * exception flags: see ARMv7 ARM, C5.9.
+	 *
+	 * REVISIT: for single stepping, we probably want to
+	 * disable IRQs by default, with optional override...
+	 */
+    /* SQU: for ARMv8, need to do acknowledge halt event then trigger restart */
+	/*retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTITRIGOUTSTATUS, &dummy);
+	LOG_USER("Before CTI ACK: DSCR= 0x%x  CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);*/
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINTACK, 1);
+
+	long long then = timeval_ms();
+	for (;; ) {
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTITRIGOUTSTATUS, &dummy);
+		if (retval != ERROR_OK)
+			return retval;
+		if ((dummy & 1) == 0)
+			break;
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for CTI ack");
+			return ERROR_FAIL;
+		}
+	}
+	//cortex_a53_exec_opcode(target, 0x8F00F3DE, &dscr); //DRPS/ERET
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		return retval;
+	//LOG_USER("After CTI ACK: DSCR= 0x%x; CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);
+
+	if ((dscr & DSCR_INSTR_COMP) == 0)
+		LOG_ERROR("DSCR InstrCompl must be set before leaving debug!");
+
+	/*retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDPRSR, &dummy);
+	LOG_USER("Before restart: EDPRSR= 0x%" PRIx32, dummy);*/
+
+	//set EDECCR after restart but before restart, then always trigger halt after restart?
+	/*dummy = 8;
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECCR, dummy);*/
+
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIAPPPULSE, 1<<CTIDBGCHAN_RESTART);
+	if (retval != ERROR_OK)
+		return retval;
+
+	//set EDECCR after restart but before check, might still too late
+	/*dummy = 8;
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECCR, dummy);*/
+
+	then = timeval_ms();
+	for (;; ) {
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + EDPRSR, &dummy);
+		if (retval != ERROR_OK)
+			return retval;
+		if ((dummy & (1<<11)) != 0)
+			break;
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for resume");
+			return ERROR_FAIL;
+		}
+	}
+	/*retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDPRSR, &dummy);
+	LOG_USER("After restart: DSCR= 0x%x EDPRSR= 0x%" PRIx32, dscr, dummy);*/
+	//for AArch32: dump DFSR, HSR, DFAR, HDAR, HPFAR
+	//HSR: MRC p15,4,<Rt>,c5,c2,0
+	/*retval = armv7a->arm.mrc(target, 15, 4, 0, 5, 2, &dummy);
+	LOG_USER("HSR= 0x%x", dummy);*/
+	//DFSR: MRC p15,0,<Rt>,c5,c0,0
+	/*retval = armv7a->arm.mrc(target, 15, 0, 0, 5, 0, &dummy);
+	LOG_USER("DFSR= 0x%x", dummy);
+	retval = armv7a->arm.mrc(target, 14, 0, 2, 0, 2, &dummy); //DBGDSCRext
+	LOG_USER("DBGDSCRext= 0x%x", dummy);
+	retval = armv7a->arm.mrc(target, 14, 0, 0, 0, 1, &dummy); //DBGDSCRint
+	LOG_USER("DBGDSCRint= 0x%x", dummy);*/
+
+	//set EDECCR after restart. Might be too late ?!
+	/*dummy = 8;
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECCR, dummy);*/
+
+	target->debug_reason = DBG_REASON_NOTHALTED;
+	target->state = TARGET_RUNNING;
+
+	/* registers are now invalid */
+	register_cache_invalidate(arm->core_cache);
+
+	return ERROR_OK;
+}
+
+static int cortex_a53_restore_smp(struct target *target, int handle_breakpoints)
+{
+	int retval = 0;
+	struct target_list *head;
+	struct target *curr;
+	uint32_t address;
+	head = target->head;
+	while (head != (struct target_list *)NULL) {
+		curr = head->target;
+		if ((curr != target) && (curr->state != TARGET_RUNNING)) {
+			/*  resume current address , not in step mode */
+			retval += cortex_a53_internal_restore(curr, 1, &address,
+					handle_breakpoints, 0);
+			retval += cortex_a53_internal_restart(curr);
+		}
+		head = head->next;
+
+	}
+	return retval;
+}
+
+static int cortex_a53_resume_64(struct target *target, int current,
+	uint64_t address, int handle_breakpoints, int debug_execution)
+{
+	int retval = 0;
+	/* dummy resume for smp toggle in order to reduce gdb impact  */
+	if ((target->smp) && (target->gdb_service->core[1] != -1)) {
+		/*   simulate a start and halt of target */
+		target->gdb_service->target = NULL;
+		target->gdb_service->core[0] = target->gdb_service->core[1];
+		/*  fake resume at next poll we play the  target core[1], see poll*/
+		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+		return 0;
+	}
+	cortex_a53_internal_restore(target, current, &address, handle_breakpoints, debug_execution);
+	if (target->smp) {
+		target->gdb_service->core[0] = -1;
+		retval = cortex_a53_restore_smp(target, handle_breakpoints);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+	cortex_a53_internal_restart(target);
+
+	if (!debug_execution) {
+		target->state = TARGET_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
+		LOG_DEBUG("target resumed at 0x%" PRIx64, address);
+	} else {
+		target->state = TARGET_DEBUG_RUNNING;
+		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
+		LOG_DEBUG("target debug resumed at 0x%" PRIx64, address);
+	}
+
+	return ERROR_OK;
+}
+
+static int cortex_a53_resume(struct target *target, int current,
+	uint32_t address, int handle_breakpoints, int debug_execution)
+{
+	return cortex_a53_resume_64(target, current, (uint64_t)address, handle_breakpoints, debug_execution);
+}
+
+static int cortex_a53_debug_entry(struct target *target)
+{
+	int i;
+	uint32_t regfile[16], cpsr, dscr, dummy;
+	int retval = ERROR_OK;
+	struct working_area *regfile_working_area = NULL;
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm *arm = &armv7a->arm;
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	struct reg *reg;
+
+	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a53->cpudbg_dscr);
+
+	/* REVISIT surely we should not re-read DSCR !! */
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		return retval;
+	/* REVISIT see A8 TRM 12.11.4 steps 2..3 -- make sure that any
+	 * imprecise data aborts get discarded by issuing a Data
+	 * Synchronization Barrier:  ARMV4_5_MCR(15, 0, 0, 7, 10, 4).
+	 */
+
+	/*SQU: ARMv8 does not have DSCR_ITR_EN(bit13). Should disable IRQ? Need to revisit*/
+	/*dscr |= 3<<22; //INTdis=b'11
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, dscr);
+	if (retval != ERROR_OK) return retval;*/
+
+	/* disable exception. Cannot do it in init as dpm might not ready?
+	MCR p15,0,<Rt>,c1,c3,1 ; Write Rt to SDCR
+	MCR p15,0,<Rt>,c1,c1,1 ; Write Rt to SDER */
+	/*retval = armv7a->arm.mrc(target, 15, 0, 1, 1, 3, &dummy);
+	LOG_USER("SDCR is 0x%x. Will edit it", dummy);
+	dummy |= 0x8000;
+	dummy &= 0xFFFFDFFF;
+	retval = armv7a->arm.mcr(target, 15, 0, 1, 1, 3, dummy);
+	retval = armv7a->arm.mrc(target, 15, 0, 1, 1, 1, &dummy);
+	LOG_USER("SDER is 0x%x. Will edit it", dummy);
+	dummy=0;
+	retval = armv7a->arm.mcr(target, 15, 0, 1, 1, 1, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);*/
+	/*retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECCR, &dummy);
+	LOG_DEBUG("DSCR= 0x%x  EDECCR=0x%x => reset", dscr, dummy);
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECCR, 0);*/
+	/*dummy=0x11223344;
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + DBGDTRTX_EL0, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	dummy = 0;
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + DBGDTRTX_EL0, &dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);*/
+
+	/*dummy=0x5A5A55AA;
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + DBGDTRRX_EL0, dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	dummy = 0;
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + DBGDTRRX_EL0, &dummy);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);*/
+	mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDPRSR, &dummy);
+
+	/* Examine debug reason */
+	armv8_dpm_report_dscr(&armv7a->dpm, cortex_a53->cpudbg_dscr);
+	/* Override the result from arm_dpm.c::armv8_dpm_report_dscr() for ARMv8. Need to re-visit*/
+	switch(cortex_a53->cpudbg_dscr & 0x3F)
+	{
+	case 0x37:
+		LOG_USER("SQU: Exception trigger halt");
+		break;
+	case 0x1B:
+	case 0x1F:
+	case 0x3B:
+		target->debug_reason = DBG_REASON_BREAKPOINT;
+		break;
+	default:
+		break;
+	}
+	/* save address of instruction that triggered the watchpoint? */
+	if (target->debug_reason == DBG_REASON_WATCHPOINT) {
+		uint32_t wfar;
+
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_WFAR,
+				&wfar);
+		if (retval != ERROR_OK)
+			return retval;
+		armv8_dpm_report_wfar(&armv7a->dpm, wfar);
+	}
+
+	/* REVISIT fast_reg_read is never set ... */
+
+	/* Examine target state and mode */
+	if (cortex_a53->fast_reg_read)
+		target_alloc_working_area(target, 64, &regfile_working_area);
+
+	/* First load register acessible through core debug port*/
+	if (!regfile_working_area)
+		retval = armv8_dpm_read_current_registers(&armv7a->dpm);
+	else {
+		retval = cortex_a53_read_regs_through_mem(target,
+				regfile_working_area->address, regfile);
+
+		target_free_working_area(target, regfile_working_area);
+		if (retval != ERROR_OK)
+			return retval;
+
+#if 0
+		//SQU: need more investigation on below code
+		if(isAArch64(dscr))
+		{
+			/* SQU: Since there are many works to support AArch64,
+			 * and our jsdcc.elf is running in AArch32,
+			 * here will force it return to EL0/AArch32 by edit SPSR_EL3
+			 */
+			retval = cortex_a53_instr_read_data_r0(&armv7a->dpm, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);
+			LOG_USER("SQU: SPSR_EL3 = 0x%x", dummy);
+			//dummy &=0xFFFFFFF0;
+			//retval = cortex_a53_instr_write_data_r0(&armv7a->dpm, ARMV8_A64_MSR(3, 6, 4, 0, 0, 0), dummy);
+			retval = cortex_a53_exec_opcode(target, 0xD6BF03E0, &dscr); //do DRPS
+			LOG_USER("ret=0x%x and dscr=0x%x", retval, dscr);
+			force2A32=1;
+			//read cpsr
+		}
+#endif
+
+		/* read Current PSR */
+		retval = cortex_a53_dap_read_coreregister_u32(target, &cpsr, 16);
+		/*  store current cpsr */
+		if (retval != ERROR_OK)
+			return retval;
+
+		LOG_DEBUG("cpsr: %8.8" PRIx32, cpsr);
+
+		arm_set_cpsr(arm, cpsr);
+
+		/* update cache */
+		for (i = 0; i <= ARM_PC; i++) {
+			reg = arm_reg_current(arm, i);
+
+			buf_set_u32(reg->value, 0, 32, regfile[i]);
+			reg->valid = 1;
+			reg->dirty = 0;
+		}
+
+		/* Fixup PC Resume Address */
+		if (cpsr & (1 << 5)) {
+			/* T bit set for Thumb or ThumbEE state */
+			regfile[ARM_PC] -= 4;
+		} else {
+			/* ARM state */
+			regfile[ARM_PC] -= 8;
+		}
+
+		reg = arm->pc;
+		buf_set_u32(reg->value, 0, 32, regfile[ARM_PC]);
+		reg->dirty = reg->valid;
+	}
+
+#if 0
+/* TODO, Move this */
+	uint32_t cp15_control_register, cp15_cacr, cp15_nacr;
+	cortex_a53_read_cp(target, &cp15_control_register, 15, 0, 1, 0, 0);
+	LOG_DEBUG("cp15_control_register = 0x%08x", cp15_control_register);
+
+	cortex_a53_read_cp(target, &cp15_cacr, 15, 0, 1, 0, 2);
+	LOG_DEBUG("cp15 Coprocessor Access Control Register = 0x%08x", cp15_cacr);
+
+	cortex_a53_read_cp(target, &cp15_nacr, 15, 0, 1, 1, 2);
+	LOG_DEBUG("cp15 Nonsecure Access Control Register = 0x%08x", cp15_nacr);
+#endif
+
+	/* Are we in an exception handler */
+/*	armv4_5->exception_number = 0; */
+	if (armv7a->post_debug_entry) {
+		retval = armv7a->post_debug_entry(target);
+		if (retval != ERROR_OK)
+			return retval;
+	}
+
+	return retval;
+}
+
+static int cortex_a53_post_debug_entry(struct target *target)
+{
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
+	int retval;
+
+	/* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
+	retval = armv7a->arm.mrc(target, 15,
+			0, 0,	/* op1, op2 */
+			1, 0,	/* CRn, CRm */
+			&cortex_a53->cp15_control_reg);
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32, cortex_a53->cp15_control_reg);
+	if(cortex_a53->cp15_control_reg & 0x1U)
+	{//SQU: disable MMU and D/I cache by set SCTLR. TODO: revisit later
+		//retval = armv7a->arm.mcr(target, 15, 0, 0, 1, 0, cortex_a53->cp15_control_reg&0xFFFFEFFA);
+		retval = armv7a->arm.mcr(target, 15, 0, 0, 1, 0, 0xC55878); //SQU: this is T32 setting
+		retval = armv7a->arm.mrc(target, 15, 0, 0, 1, 0, &cortex_a53->cp15_control_reg);
+		if (retval != ERROR_OK)
+			return retval;
+		LOG_USER("SQU: override to disable cache => SCTLR=0x%x", cortex_a53->cp15_control_reg);
+	}
+	cortex_a53->cp15_control_reg_curr = cortex_a53->cp15_control_reg;
+
+	if (armv7a->armv7a_mmu.armv7a_cache.ctype == -1)
+		armv7a_identify_cache(target);
+
+	if (armv7a->is_armv7r) {
+		armv7a->armv7a_mmu.mmu_enabled = 0;
+	} else {
+		armv7a->armv7a_mmu.mmu_enabled =
+			(cortex_a53->cp15_control_reg & 0x1U) ? 1 : 0;
+	}
+	armv7a->armv7a_mmu.armv7a_cache.d_u_cache_enabled =
+		(cortex_a53->cp15_control_reg & 0x4U) ? 1 : 0;
+	armv7a->armv7a_mmu.armv7a_cache.i_cache_enabled =
+		(cortex_a53->cp15_control_reg & 0x1000U) ? 1 : 0;
+	cortex_a53->curr_mode = armv7a->arm.core_mode;
+
+	return ERROR_OK;
+}
+
+static int cortex_a53_step_64(struct target *target, int current, uint64_t address,
+	int handle_breakpoints)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm *arm = &armv7a->arm;
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	struct breakpoint *breakpoint = NULL;
+	struct breakpoint stepbreakpoint;
+	struct reg *r;
+	int retval;
+	//uint32_t dummy,dummy1;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	/* current = 1: continue on current pc, otherwise continue at <address> */
+	//SQUTODO: change to 64bit pc
+	r = arm->pc;
+	if (!current)
+		buf_set_u32(r->value, 0, 32, address);
+	else
+		address = buf_get_u32(r->value, 0, 32);
+
+	/* The front-end may request us not to handle breakpoints.
+	 * But since Cortex-A8 uses breakpoint for single step,
+	 * we MUST handle breakpoints.
+	 */
+	handle_breakpoints = 1;
+	//SQUTODO: update for 64b address
+	if (handle_breakpoints) {
+		breakpoint = breakpoint_find(target, address);
+		if (breakpoint)
+			cortex_a53_unset_breakpoint(target, breakpoint);
+	}
+
+/* set EDECR.SS=1
+ * exit debug state
+ * wait until EDESR.SS is set
+ * clear EDECR.SS
+ */
+	target->debug_reason = DBG_REASON_SINGLESTEP;
+
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECR, 1<<2); //set EDECR.SS
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = cortex_a53_resume(target, 1, address, 0, 0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	long long then = timeval_ms();
+	while (target->state != TARGET_HALTED) {
+		retval = cortex_a53_poll(target);
+		if (retval != ERROR_OK)
+			return retval;
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("timeout waiting for target halt");
+			return ERROR_FAIL;
+		}
+	}
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECR, 0); //clr EDECR.SS
+	if (retval != ERROR_OK)
+		return retval;
+
+	target->debug_reason = DBG_REASON_BREAKPOINT;
+
+	if (breakpoint)
+		cortex_a53_set_breakpoint(target, breakpoint, 0);
+
+	if (target->state != TARGET_HALTED)
+		LOG_DEBUG("target stepped");
+
+	return ERROR_OK;
+}
+
+static int cortex_a53_step(struct target *target, int current, uint32_t address,
+	int handle_breakpoints)
+{
+	return cortex_a53_step_64(target, current, (uint64_t)address, handle_breakpoints);
+}
+
+static int cortex_a53_restore_context(struct target *target, bool bpwp)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+
+	LOG_DEBUG(" ");
+
+	if (armv7a->pre_restore_context)
+		armv7a->pre_restore_context(target);
+
+	return armv8_dpm_write_dirty_registers(&armv7a->dpm, bpwp);
+}
+
+/*
+ * Cortex-A8 Breakpoint and watchpoint functions
+ */
+
+/* Setup hardware Breakpoint Register Pair */
+static int cortex_a53_set_breakpoint(struct target *target,
+	struct breakpoint *breakpoint, uint8_t matchmode)
+{
+	int retval;
+	int brp_i = 0;
+	uint32_t control;
+	uint8_t byte_addr_select = 0x0F;
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
+	struct cortex_a_brp *brp_list = cortex_a53->brp_list;
+
+	if (breakpoint->set) {
+		LOG_WARNING("breakpoint already set");
+		return ERROR_OK;
+	}
+
+	/*if (breakpoint->type == BKPT_SOFT) {
+		LOG_USER("SQU: force to HARD BP for now, until we find a solution.");
+		breakpoint->type = BKPT_HARD;
+	}*/
+	if (breakpoint->type == BKPT_HARD) {
+		while (brp_list[brp_i].used && (brp_i < cortex_a53->brp_num))
+			brp_i++;
+		if (brp_i >= cortex_a53->brp_num) {
+			LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
+			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+		}
+		breakpoint->set = brp_i + 1;
+		if (breakpoint->length == 2)
+			byte_addr_select = (3 << (breakpoint->address & 0x02));
+		control = ((matchmode & 0x7) << 20)
+			| (byte_addr_select << 5)
+			| (3 << 1) | 1;
+		brp_list[brp_i].used = 1;
+		brp_list[brp_i].value = (breakpoint->address & 0xFFFFFFFC);
+		brp_list[brp_i].control = control;
+		retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+				+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
+				brp_list[brp_i].value);
+		if (retval != ERROR_OK)
+			return retval;
+        //SQU: assume DLR_h hold high 32bits addr. TODO: fix it
+		retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+				+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn + 4,
+				DLR_h);
+		retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+				+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
+				brp_list[brp_i].control);
+		if (retval != ERROR_OK)
+			return retval;
+		LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
+			brp_list[brp_i].control,
+			brp_list[brp_i].value);
+	} else if (breakpoint->type == BKPT_SOFT) {
+		uint8_t code[4];
+		if (breakpoint->length == 2)
+			buf_set_u32(code, 0, 32, ARMV8_T_HLT(0x11)); //ARMV5_T_BKPT(0x11)
+		else
+			buf_set_u32(code, 0, 32, ARMV8_A32_HLT(0x11)); //ARMV5_BKPT(0x11)
+		retval = target_read_memory(target,
+				breakpoint->address & 0xFFFFFFFE,
+				breakpoint->length, 1,
+				breakpoint->orig_instr);
+		if (retval != ERROR_OK)
+			return retval;
+		retval = target_write_memory(target,
+				breakpoint->address & 0xFFFFFFFE,
+				breakpoint->length, 1, code);
+		if (retval != ERROR_OK)
+			return retval;
+		//SQU: read back to verfiy
+		/*control=0; //in case of T32
+		retval = target_read_memory(target,
+						breakpoint->address & 0xFFFFFFFE,
+						breakpoint->length, 1,
+						&control);
+		if (breakpoint->length == 2) LOG_USER("T32 BKPT readback as 0x%x, expect=>0xbe11", control);
+		else LOG_USER("A32 BKPT readback as 0x%x, expect=>0xe1200171", control);*/
+		//set EDECCR only for s/w BP
+		//retval = mem_ap_sel_write_atomic_u32(armv7a->arm.dap, armv7a->debug_ap, armv7a->debug_base + EDECCR, 8);
+
+		breakpoint->set = 0x11;	/* Any nice value but 0 */
+	}
+
+	return ERROR_OK;
+}
+
+static int cortex_a53_set_context_breakpoint(struct target *target,
+	struct breakpoint *breakpoint, uint8_t matchmode)
+{
+	int retval = ERROR_FAIL;
+	int brp_i = 0;
+	uint32_t control;
+	uint8_t byte_addr_select = 0x0F;
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
+	struct cortex_a_brp *brp_list = cortex_a53->brp_list;
+
+	if (breakpoint->set) {
+		LOG_WARNING("breakpoint already set");
+		return retval;
+	}
+	/*check available context BRPs*/
+	while ((brp_list[brp_i].used ||
+		(brp_list[brp_i].type != BRP_CONTEXT)) && (brp_i < cortex_a53->brp_num))
+		brp_i++;
+
+	if (brp_i >= cortex_a53->brp_num) {
+		LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
+		return ERROR_FAIL;
+	}
+
+	breakpoint->set = brp_i + 1;
+	control = ((matchmode & 0x7) << 20)
+		| (byte_addr_select << 5)
+		| (3 << 1) | 1;
+	brp_list[brp_i].used = 1;
+	brp_list[brp_i].value = (breakpoint->asid);
+	brp_list[brp_i].control = control;
+	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
+			brp_list[brp_i].value);
+	if (retval != ERROR_OK)
+		return retval;
+    //SQU: assume the addr is 32bits. TODO: fix it
+	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn + 4,
+			DLR_h);
+
+	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+			+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
+			brp_list[brp_i].control);
+	if (retval != ERROR_OK)
+		return retval;
+	LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
+		brp_list[brp_i].control,
+		brp_list[brp_i].value);
+	return ERROR_OK;
+
+}
+
+static int cortex_a53_set_hybrid_breakpoint(struct target *target, struct breakpoint *breakpoint)
+{
+	int retval = ERROR_FAIL;
+	int brp_1 = 0;	/* holds the contextID pair */
+	int brp_2 = 0;	/* holds the IVA pair */
+	uint32_t control_CTX, control_IVA;
+	uint8_t CTX_byte_addr_select = 0x0F;
+	uint8_t IVA_byte_addr_select = 0x0F;
+	uint8_t CTX_machmode = 0x03;
+	uint8_t IVA_machmode = 0x01;
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
+	struct cortex_a_brp *brp_list = cortex_a53->brp_list;
+
+	if (breakpoint->set) {
+		LOG_WARNING("breakpoint already set");
+		return retval;
+	}
+	/*check available context BRPs*/
+	while ((brp_list[brp_1].used ||
+		(brp_list[brp_1].type != BRP_CONTEXT)) && (brp_1 < cortex_a53->brp_num))
+		brp_1++;
+
+	printf("brp(CTX) found num: %d\n", brp_1);
+	if (brp_1 >= cortex_a53->brp_num) {
+		LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
+		return ERROR_FAIL;
+	}
+
+	while ((brp_list[brp_2].used ||
+		(brp_list[brp_2].type != BRP_NORMAL)) && (brp_2 < cortex_a53->brp_num))
+		brp_2++;
+
+	printf("brp(IVA) found num: %d\n", brp_2);
+	if (brp_2 >= cortex_a53->brp_num) {
+		LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
+		return ERROR_FAIL;
+	}
+
+	breakpoint->set = brp_1 + 1;
+	breakpoint->linked_BRP = brp_2;
+	control_CTX = ((CTX_machmode & 0x7) << 20)
+		| (brp_2 << 16)
+		| (0 << 14)
+		| (CTX_byte_addr_select << 5)
+		| (3 << 1) | 1;
+	brp_list[brp_1].used = 1;
+	brp_list[brp_1].value = (breakpoint->asid);
+	brp_list[brp_1].control = control_CTX;
+	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_1].BRPn,
+			brp_list[brp_1].value);
+	if (retval != ERROR_OK)
+		return retval;
+    //SQU: assume addr is 32bit. TODO: fix it
+	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_1].BRPn + 4,
+			DLR_h);
+	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+			+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_1].BRPn,
+			brp_list[brp_1].control);
+	if (retval != ERROR_OK)
+		return retval;
+
+	control_IVA = ((IVA_machmode & 0x7) << 20)
+		| (brp_1 << 16)
+		| (IVA_byte_addr_select << 5)
+		| (3 << 1) | 1;
+	brp_list[brp_2].used = 1;
+	brp_list[brp_2].value = (breakpoint->address & 0xFFFFFFFC);
+	brp_list[brp_2].control = control_IVA;
+	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_2].BRPn,
+			brp_list[brp_2].value);
+	if (retval != ERROR_OK)
+		return retval;
+    //SQU assume 32bit. TODO: fix it
+	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_2].BRPn + 4,
+			DLR_h);
+
+	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+			+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_2].BRPn,
+			brp_list[brp_2].control);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return ERROR_OK;
+}
+
+static int cortex_a53_unset_breakpoint(struct target *target, struct breakpoint *breakpoint)
+{
+	int retval;
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
+	struct cortex_a_brp *brp_list = cortex_a53->brp_list;
+
+	if (!breakpoint->set) {
+		LOG_WARNING("breakpoint not set");
+		return ERROR_OK;
+	}
+
+	if (breakpoint->type == BKPT_HARD) {
+		if ((breakpoint->address != 0) && (breakpoint->asid != 0)) {
+			int brp_i = breakpoint->set - 1;
+			int brp_j = breakpoint->linked_BRP;
+			if ((brp_i < 0) || (brp_i >= cortex_a53->brp_num)) {
+				LOG_DEBUG("Invalid BRP number in breakpoint");
+				return ERROR_OK;
+			}
+			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
+				brp_list[brp_i].control, brp_list[brp_i].value);
+			brp_list[brp_i].used = 0;
+			brp_list[brp_i].value = 0;
+			brp_list[brp_i].control = 0;
+			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
+					brp_list[brp_i].control);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
+					brp_list[brp_i].value);
+			if (retval != ERROR_OK)
+				return retval;
+            //SQU: assume 32bit addr. TODO: fix it
+			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn + 4,
+					DLR_h);
+			if ((brp_j < 0) || (brp_j >= cortex_a53->brp_num)) {
+				LOG_DEBUG("Invalid BRP number in breakpoint");
+				return ERROR_OK;
+			}
+			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_j,
+				brp_list[brp_j].control, brp_list[brp_j].value);
+			brp_list[brp_j].used = 0;
+			brp_list[brp_j].value = 0;
+			brp_list[brp_j].control = 0;
+			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_j].BRPn,
+					brp_list[brp_j].control);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_j].BRPn,
+					brp_list[brp_j].value);
+			if (retval != ERROR_OK)
+				return retval;
+            //SQU: assume 32bit addr. TODO: fix it
+			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_j].BRPn + 4,
+					DLR_h);
+			breakpoint->linked_BRP = 0;
+			breakpoint->set = 0;
+			return ERROR_OK;
+
+		} else {
+			int brp_i = breakpoint->set - 1;
+			if ((brp_i < 0) || (brp_i >= cortex_a53->brp_num)) {
+				LOG_DEBUG("Invalid BRP number in breakpoint");
+				return ERROR_OK;
+			}
+			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
+				brp_list[brp_i].control, brp_list[brp_i].value);
+			brp_list[brp_i].used = 0;
+			brp_list[brp_i].value = 0;
+			brp_list[brp_i].control = 0;
+			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
+					brp_list[brp_i].control);
+			if (retval != ERROR_OK)
+				return retval;
+			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
+					brp_list[brp_i].value);
+			if (retval != ERROR_OK)
+				return retval;
+            //SQU: assume 32bit addr. TODO: fix it
+			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
+					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn + 4,
+					DLR_h);
+
+            breakpoint->set = 0;
+			return ERROR_OK;
+		}
+	} else {
+		/* restore original instruction (kept in target endianness) */
+		if (breakpoint->length == 4) {
+			retval = target_write_memory(target,
+					breakpoint->address & 0xFFFFFFFE,
+					4, 1, breakpoint->orig_instr);
+			if (retval != ERROR_OK)
+				return retval;
+		} else {
+			retval = target_write_memory(target,
+					breakpoint->address & 0xFFFFFFFE,
+					2, 1, breakpoint->orig_instr);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+	}
+	breakpoint->set = 0;
+
+	return ERROR_OK;
+}
+
+static int cortex_a53_add_breakpoint(struct target *target,
+	struct breakpoint *breakpoint)
+{
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+
+	if ((breakpoint->type == BKPT_HARD) && (cortex_a53->brp_num_available < 1)) {
+		LOG_INFO("no hardware breakpoint available");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	if (breakpoint->type == BKPT_HARD)
+		cortex_a53->brp_num_available--;
+
+	return cortex_a53_set_breakpoint(target, breakpoint, 0x00);	/* Exact match */
+}
+
+static int cortex_a53_add_context_breakpoint(struct target *target,
+	struct breakpoint *breakpoint)
+{
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+
+	if ((breakpoint->type == BKPT_HARD) && (cortex_a53->brp_num_available < 1)) {
+		LOG_INFO("no hardware breakpoint available");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	if (breakpoint->type == BKPT_HARD)
+		cortex_a53->brp_num_available--;
+
+	return cortex_a53_set_context_breakpoint(target, breakpoint, 0x02);	/* asid match */
+}
+
+static int cortex_a53_add_hybrid_breakpoint(struct target *target,
+	struct breakpoint *breakpoint)
+{
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+
+	if ((breakpoint->type == BKPT_HARD) && (cortex_a53->brp_num_available < 1)) {
+		LOG_INFO("no hardware breakpoint available");
+		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
+	}
+
+	if (breakpoint->type == BKPT_HARD)
+		cortex_a53->brp_num_available--;
+
+	return cortex_a53_set_hybrid_breakpoint(target, breakpoint);	/* ??? */
+}
+
+
+static int cortex_a53_remove_breakpoint(struct target *target, struct breakpoint *breakpoint)
+{
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+
+#if 0
+/* It is perfectly possible to remove breakpoints while the target is running */
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+#endif
+
+	if (breakpoint->set) {
+		cortex_a53_unset_breakpoint(target, breakpoint);
+		if (breakpoint->type == BKPT_HARD)
+			cortex_a53->brp_num_available++;
+	}
+
+	return ERROR_OK;
+}
+
+/*
+ * Cortex-A8 Reset functions
+ */
+
+static int cortex_a53_assert_reset(struct target *target)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+
+	LOG_DEBUG(" ");
+
+	/* FIXME when halt is requested, make it work somehow... */
+
+	/* Issue some kind of warm reset. */
+	if (target_has_event_action(target, TARGET_EVENT_RESET_ASSERT))
+		target_handle_event(target, TARGET_EVENT_RESET_ASSERT);
+	else if (jtag_get_reset_config() & RESET_HAS_SRST) {
+		/* REVISIT handle "pulls" cases, if there's
+		 * hardware that needs them to work.
+		 */
+		jtag_add_reset(0, 1);
+	} else {
+		LOG_ERROR("%s: how to reset?", target_name(target));
+		return ERROR_FAIL;
+	}
+
+	/* registers are now invalid */
+	register_cache_invalidate(armv7a->arm.core_cache);
+
+	target->state = TARGET_RESET;
+
+	return ERROR_OK;
+}
+
+static int cortex_a53_deassert_reset(struct target *target)
+{
+	int retval;
+
+	LOG_DEBUG(" ");
+
+	/* be certain SRST is off */
+	jtag_add_reset(0, 0);
+
+	retval = cortex_a53_poll(target);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (target->reset_halt) {
+		if (target->state != TARGET_HALTED) {
+			LOG_WARNING("%s: ran after reset and before halt ...",
+				target_name(target));
+			retval = target_halt(target);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+	}
+
+	return ERROR_OK;
+}
+
+static int cortex_a53_write_apb_ab_memory(struct target *target,
+	uint32_t address, uint32_t size,
+	uint32_t count, const uint8_t *buffer)
+{
+	/* write memory through APB-AP */
+
+	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm *arm = &armv7a->arm;
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	int total_bytes = count * size;
+	int total_u32;
+	int start_byte = address & 0x3;
+	int end_byte   = (address + total_bytes) & 0x3;
+	struct reg *reg;
+	uint32_t dscr;
+	uint8_t *tmp_buff = NULL;
+
+	LOG_DEBUG("Writing APB-AP memory address 0x%" PRIx32 " size %"  PRIu32 " count%"  PRIu32,
+			  address, size, count);
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	total_u32 = DIV_ROUND_UP((address & 3) + total_bytes, 4);
+
+	/* Mark register R0 as dirty, as it will be used
+	 * for transferring the data.
+	 * It will be restored automatically when exiting
+	 * debug mode
+	 */
+	reg = arm_reg_current(arm, 0);
+	reg->dirty = true;
+
+	/*  clear any abort  */
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DRCR, 1<<2);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* This algorithm comes from either :
+	 * Cortex-A8 TRM Example 12-25
+	 * Cortex-R4 TRM Example 11-26
+	 * (slight differences)
+	 */
+
+	/* The algorithm only copies 32 bit words, so the buffer
+	 * should be expanded to include the words at either end.
+	 * The first and last words will be read first to avoid
+	 * corruption if needed.
+	 */
+	tmp_buff = malloc(total_u32 * 4);
+
+	if ((start_byte != 0) && (total_u32 > 1)) {
+		/* First bytes not aligned - read the 32 bit word to avoid corrupting
+		 * the other bytes in the word.
+		 */
+		retval = cortex_a53_read_apb_ab_memory(target, (address & ~0x3), 4, 1, tmp_buff);
+		if (retval != ERROR_OK)
+			goto error_free_buff_w;
+	}
+
+	/* If end of write is not aligned, or the write is less than 4 bytes */
+	if ((end_byte != 0) ||
+		((total_u32 == 1) && (total_bytes != 4))) {
+
+		/* Read the last word to avoid corruption during 32 bit write */
+		int mem_offset = (total_u32-1) * 4;
+		retval = cortex_a53_read_apb_ab_memory(target, (address & ~0x3) + mem_offset, 4, 1, &tmp_buff[mem_offset]);
+		if (retval != ERROR_OK)
+			goto error_free_buff_w;
+	}
+
+	/* Copy the write buffer over the top of the temporary buffer */
+	memcpy(&tmp_buff[start_byte], buffer, total_bytes);
+
+	/* We now have a 32 bit aligned buffer that can be written */
+
+	/* Read DSCR */
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		goto error_free_buff_w;
+
+	/* Set DTR mode to Fast (2) */
+	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_FAST_MODE;
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_DSCR, dscr);
+	if (retval != ERROR_OK)
+		goto error_free_buff_w;
+
+	/* Copy the destination address into R0 */
+	/*  - pend an instruction  MRC p14, 0, R0, c5, c0 */
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_ITR, ARMV4_5_MRC(14, 0, 0, 0, 5, 0));
+	if (retval != ERROR_OK)
+		goto error_unset_dtr_w;
+	/* Write address into DTRRX, which triggers previous instruction */
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_DTRRX, address & (~0x3));
+	if (retval != ERROR_OK)
+		goto error_unset_dtr_w;
+
+	/* Write the data transfer instruction into the ITR
+	 * (STC p14, c5, [R0], 4)
+	 */
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_ITR, ARMV4_5_STC(0, 1, 0, 1, 14, 5, 0, 4));
+	if (retval != ERROR_OK)
+		goto error_unset_dtr_w;
+
+	/* Do the write */
+	retval = mem_ap_sel_write_buf_noincr(swjdp, armv7a->debug_ap,
+					tmp_buff, 4, total_u32, armv7a->debug_base + CPUDBG_DTRRX);
+	if (retval != ERROR_OK)
+		goto error_unset_dtr_w;
+
+
+	/* Switch DTR mode back to non-blocking (0) */
+	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
+	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_DSCR, dscr);
+	if (retval != ERROR_OK)
+		goto error_unset_dtr_w;
+
+    /* Check for sticky abort flags in the DSCR */
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		goto error_free_buff_w;
+	if (dscr & (DSCR_STICKY_ABORT_PRECISE | DSCR_STICKY_ABORT_IMPRECISE)) {
+		/* Abort occurred - clear it and exit */
+		LOG_ERROR("abort occurred - dscr = 0x%08" PRIx32, dscr);
+		mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+					armv7a->debug_base + CPUDBG_DRCR, 1<<2);
+		goto error_free_buff_w;
+	}
+
+	/* Done */
+	free(tmp_buff);
+	return ERROR_OK;
+
+error_unset_dtr_w:
+	/* Unset DTR mode */
+	mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
+	mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_DSCR, dscr);
+error_free_buff_w:
+	LOG_ERROR("error");
+	free(tmp_buff);
+	return ERROR_FAIL;
+}
+
+static int cortex_a53_read_apb_ab_memory(struct target *target,
+	uint32_t address, uint32_t size,
+	uint32_t count, uint8_t *buffer)
+{
+	/* read memory through APB-AP */
+
+	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	struct arm *arm = &armv7a->arm;
+	int total_bytes = count * size;
+	int total_u32;
+	int start_byte = address & 0x3;
+	int end_byte   = (address + total_bytes) & 0x3;
+	struct reg *reg;
+	uint32_t dscr;
+	uint8_t *tmp_buff = NULL;
+	uint8_t buf[8];
+	uint8_t *u8buf_ptr;
+
+	LOG_DEBUG("Reading APB-AP memory address 0x%" PRIx32 " size %"  PRIu32 " count%"  PRIu32,
+			  address, size, count);
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+
+	total_u32 = DIV_ROUND_UP((address & 3) + total_bytes, 4);
+	/* Mark register R0 as dirty, as it will be used
+	 * for transferring the data.
+	 * It will be restored automatically when exiting
+	 * debug mode
+	 */
+	reg = arm_reg_current(arm, 0);
+	reg->dirty = true;
+
+	/*  clear any abort  */
+	retval =
+		mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DRCR, 1<<2);
+	if (retval != ERROR_OK)
+		goto error_free_buff_r;
+
+	/* Read DSCR */
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+
+	/* This algorithm comes from either :
+	 * Cortex-A8 TRM Example 12-24
+	 * Cortex-R4 TRM Example 11-25
+	 * (slight differences)
+	 */
+
+	/* Set DTR access mode to stall mode b01  */
+	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_STALL_MODE;
+	retval +=  mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_DSCR, dscr);
+
+	/* Write R0 with value 'address' using write procedure for stall mode */
+	/*   - Write the address for read access into DTRRX */
+	retval += mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_DTRRX, address & ~0x3);
+	/*  - Copy value from DTRRX to R0 using instruction mrc p14, 0, r0, c5, c0 */
+	cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dscr);
+
+	/* Write the data transfer instruction (ldc p14, c5, [r0],4)
+	 * and the DTR mode setting to fast mode
+	 * in one combined write (since they are adjacent registers)
+	 */
+	u8buf_ptr = buf;
+	target_buffer_set_u32(target, u8buf_ptr, ARMV4_5_LDC(0, 1, 0, 1, 14, 5, 0, 4));
+	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_FAST_MODE;
+	target_buffer_set_u32(target, u8buf_ptr + 4, dscr);
+	/*  group the 2 access CPUDBG_ITR 0x84 and CPUDBG_DSCR 0x88 */
+	retval += mem_ap_sel_write_buf(swjdp, armv7a->debug_ap, u8buf_ptr, 4, 2,
+			armv7a->debug_base + CPUDBG_ITR);
+	if (retval != ERROR_OK)
+		goto error_unset_dtr_r;
+
+	/* Optimize the read as much as we can, either way we read in a single pass  */
+	if ((start_byte) || (end_byte)) {
+		/* The algorithm only copies 32 bit words, so the buffer
+		 * should be expanded to include the words at either end.
+		 * The first and last words will be read into a temp buffer
+		 * to avoid corruption
+		 */
+		tmp_buff = malloc(total_u32 * 4);
+		if (!tmp_buff)
+			goto error_unset_dtr_r;
+
+		/* use the tmp buffer to read the entire data */
+		u8buf_ptr = tmp_buff;
+	} else
+		/* address and read length are aligned so read directely into the passed buffer */
+		u8buf_ptr = buffer;
+
+	/* Read the data - Each read of the DTRTX register causes the instruction to be reissued
+	 * Abort flags are sticky, so can be read at end of transactions
+	 *
+	 * This data is read in aligned to 32 bit boundary.
+	 */
+	retval = mem_ap_sel_read_buf_noincr(swjdp, armv7a->debug_ap, u8buf_ptr, 4, total_u32,
+									armv7a->debug_base + CPUDBG_DTRTX);
+	if (retval != ERROR_OK)
+			goto error_unset_dtr_r;
+
+	/* set DTR access mode back to non blocking b00  */
+	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
+	retval =  mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+					armv7a->debug_base + CPUDBG_DSCR, dscr);
+	if (retval != ERROR_OK)
+		goto error_free_buff_r;
+
+	/* Wait for the final read instruction to finish */
+	do {
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+					armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		if (retval != ERROR_OK)
+			goto error_free_buff_r;
+	} while ((dscr & DSCR_INSTR_COMP) == 0);
+
+	/* Check for sticky abort flags in the DSCR */
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	if (retval != ERROR_OK)
+		goto error_free_buff_r;
+	if (dscr & (DSCR_STICKY_ABORT_PRECISE | DSCR_STICKY_ABORT_IMPRECISE)) {
+		/* Abort occurred - clear it and exit */
+		LOG_ERROR("abort occurred - dscr = 0x%08" PRIx32, dscr);
+		mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+					armv7a->debug_base + CPUDBG_DRCR, 1<<2);
+		goto error_free_buff_r;
+	}
+
+	/* check if we need to copy aligned data by applying any shift necessary */
+	if (tmp_buff) {
+		memcpy(buffer, tmp_buff + start_byte, total_bytes);
+		free(tmp_buff);
+	}
+
+	/* Done */
+	return ERROR_OK;
+
+error_unset_dtr_r:
+	/* Unset DTR mode */
+	mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
+	mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_DSCR, dscr);
+error_free_buff_r:
+	LOG_ERROR("error");
+	free(tmp_buff);
+	return ERROR_FAIL;
+}
+
+
+/*
+ * Cortex-A8 Memory access
+ *
+ * This is same Cortex M3 but we must also use the correct
+ * ap number for every access.
+ */
+
+static int cortex_a53_read_phys_memory_64(struct target *target,
+	uint64_t address, uint64_t size,
+	uint64_t count, uint8_t *buffer)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+	uint8_t apsel = swjdp->apsel;
+	LOG_DEBUG("Reading memory at real address 0x%" PRIx64 "; size %" PRId64 "; count %" PRId64,
+		address, size, count);
+
+	if (count && buffer) {
+
+		if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
+			if(address==0)
+			{
+				LOG_ERROR("SQU: trying to read @0x0 will cause exception. Return error directly for now to avoid handling exception");
+				return -107;
+			}
+			/* read memory through AHB-AP */
+			retval = mem_ap_sel_read_buf(swjdp, armv7a->memory_ap, buffer, size, count, address);
+		} else {
+
+			/* read memory through APB-AP */
+			if (!armv7a->is_armv7r) {
+				/*  disable mmu */
+				retval = cortex_a53_mmu_modify(target, 0);
+				if (retval != ERROR_OK)
+					return retval;
+			}
+			retval = cortex_a53_read_apb_ab_memory(target, address, size, count, buffer);
+		}
+	}
+	return retval;
+}
+
+static int cortex_a53_read_phys_memory(struct target *target,
+	uint32_t address, uint32_t size,
+	uint32_t count, uint8_t *buffer)
+{
+	return cortex_a53_read_phys_memory_64(target, address, size, count, buffer);
+}
+
+static int cortex_a53_read_memory_64(struct target *target, uint64_t address,
+	uint64_t size, uint64_t count, uint8_t *buffer)
+{
+	int mmu_enabled = 0;
+	uint64_t virt, phys;
+	int retval;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	uint8_t apsel = swjdp->apsel;
+
+	/* cortex_a53 handles unaligned memory access */
+	LOG_DEBUG("Reading memory at address 0x%" PRIx64 "; size %" PRId64 "; count %" PRId64, address,
+		size, count);
+
+	/* determine if MMU was enabled on target stop */
+	retval = cortex_a53_mmu(target, &mmu_enabled);
+	if (retval != ERROR_OK)
+	{
+		//return retval;
+		/*SQU: the mmu check will return error if CPU wasn't halted. However, why should we care?
+		 * We can read memory through MEM-AP0, which should not need CPU involved.
+		 * So let's ignore the error and just assume mmu is disable and access phy_addr
+		 */
+		mmu_enabled=0;
+	}
+	//SQUTODO: change to 64b
+	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
+		if (mmu_enabled) {
+			virt = address;
+			retval = cortex_a53_virt2phys_64(target, virt, &phys);
+			if (retval != ERROR_OK)
+				return retval;
+
+			LOG_DEBUG("Reading at virtual address. Translating v:0x%" PRIx64 " to r:0x%" PRIx64,
+				  virt, phys);
+			address = phys;
+		}
+		retval = cortex_a53_read_phys_memory_64(target, address, size, count, buffer);
+	} else {
+		if (mmu_enabled) {
+			retval = cortex_a53_check_address(target, address);
+			if (retval != ERROR_OK)
+				return retval;
+			/* enable MMU as we could have disabled it for phys access */
+			retval = cortex_a53_mmu_modify(target, 1);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+		retval = cortex_a53_read_apb_ab_memory(target, address, size, count, buffer);
+	}
+	return retval;
+}
+
+static int cortex_a53_read_memory(struct target *target, uint32_t address,
+	uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	return cortex_a53_read_memory_64(target, address, size, count, buffer);
+}
+
+static int cortex_a53_read_buffer_64(struct target *target, uint64_t address, uint64_t size, uint8_t *buffer)
+{
+	return cortex_a53_read_memory_64(target, address, size, 1, buffer);
+}
+
+static int cortex_a53_write_phys_memory_64(struct target *target,
+	uint64_t address, uint64_t size,
+	uint64_t count, const uint8_t *buffer)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+	uint8_t apsel = swjdp->apsel;
+
+	LOG_DEBUG("Writing memory to real address 0x%" PRIx64 "; size %" PRId64 "; count %" PRId64, address,
+		size, count);
+
+	if (count && buffer) {
+
+		if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
+
+			/* write memory through AHB-AP */
+			retval = mem_ap_sel_write_buf(swjdp, armv7a->memory_ap, buffer, size, count, address);
+		} else {
+
+			/* write memory through APB-AP */
+			if (!armv7a->is_armv7r) {
+				retval = cortex_a53_mmu_modify(target, 0);
+				if (retval != ERROR_OK)
+					return retval;
+			}
+			return cortex_a53_write_apb_ab_memory(target, address, size, count, buffer);
+		}
+	}
+
+
+	/* REVISIT this op is generic ARMv7-A/R stuff */
+	if (retval == ERROR_OK && target->state == TARGET_HALTED) {
+		struct arm_dpm *dpm = armv7a->arm.dpm;
+
+		retval = dpm->prepare(dpm);
+		if (retval != ERROR_OK)
+			return retval;
+
+		/* The Cache handling will NOT work with MMU active, the
+		 * wrong addresses will be invalidated!
+		 *
+		 * For both ICache and DCache, walk all cache lines in the
+		 * address range. Cortex-A8 has fixed 64 byte line length.
+		 *
+		 * REVISIT per ARMv7, these may trigger watchpoints ...
+		 */
+
+		/* invalidate I-Cache */
+		if (armv7a->armv7a_mmu.armv7a_cache.i_cache_enabled) {
+			/* ICIMVAU - Invalidate Cache single entry
+			 * with MVA to PoU
+			 *      MCR p15, 0, r0, c7, c5, 1
+			 */
+			for (uint32_t cacheline = address;
+				cacheline < address + size * count;
+				cacheline += 64) {
+				retval = dpm->instr_write_data_r0(dpm,
+						ARMV4_5_MCR(15, 0, 0, 7, 5, 1),
+						cacheline);
+				if (retval != ERROR_OK)
+					return retval;
+			}
+		}
+
+		/* invalidate D-Cache */
+		if (armv7a->armv7a_mmu.armv7a_cache.d_u_cache_enabled) {
+			/* DCIMVAC - Invalidate data Cache line
+			 * with MVA to PoC
+			 *      MCR p15, 0, r0, c7, c6, 1
+			 */
+			for (uint32_t cacheline = address;
+				cacheline < address + size * count;
+				cacheline += 64) {
+				retval = dpm->instr_write_data_r0(dpm,
+						ARMV4_5_MCR(15, 0, 0, 7, 6, 1),
+						cacheline);
+				if (retval != ERROR_OK)
+					return retval;
+			}
+		}
+
+		/* (void) */ dpm->finish(dpm);
+	}
+
+	return retval;
+}
+
+static int cortex_a53_write_phys_memory(struct target *target,
+	uint32_t address, uint32_t size,
+	uint32_t count, const uint8_t *buffer)
+{
+	return cortex_a53_write_phys_memory_64(target, address, size, count, buffer);
+}
+
+static int cortex_a53_write_memory_64(struct target *target, uint64_t address,
+	uint64_t size, uint64_t count, const uint8_t *buffer)
+{
+	int mmu_enabled = 0;
+	uint64_t virt, phys;
+	int retval;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	uint8_t apsel = swjdp->apsel;
+
+	/* cortex_a53 handles unaligned memory access */
+	LOG_DEBUG("Writing memory at address 0x%" PRIx64 "; size %" PRId64 "; count %" PRId64, address,
+		size, count);
+
+	/* determine if MMU was enabled on target stop */
+	retval = cortex_a53_mmu(target, &mmu_enabled);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
+		LOG_DEBUG("Writing memory to address 0x%" PRIx64 "; size %" PRId64 "; count %" PRId64, address, size,
+			count);
+		if (mmu_enabled) {
+			virt = address;
+			retval = cortex_a53_virt2phys_64(target, virt, &phys);
+			if (retval != ERROR_OK)
+				return retval;
+
+			LOG_DEBUG("Writing to virtual address. Translating v:0x%" PRIx64 " to r:0x%" PRIx64,
+				  virt,
+				  phys);
+			address = phys;
+		}
+		retval = cortex_a53_write_phys_memory(target, address, size,
+				count, buffer);
+	} else {
+		if (mmu_enabled) {
+			retval = cortex_a53_check_address(target, address);
+			if (retval != ERROR_OK)
+				return retval;
+			/* enable MMU as we could have disabled it for phys access */
+			retval = cortex_a53_mmu_modify(target, 1);
+			if (retval != ERROR_OK)
+				return retval;
+		}
+		retval = cortex_a53_write_apb_ab_memory(target, address, size, count, buffer);
+	}
+	return retval;
+}
+
+static int cortex_a53_write_memory(struct target *target, uint32_t address,
+	uint32_t size, uint32_t count, const uint8_t *buffer)
+{
+	return cortex_a53_write_memory_64(target, address, size, count, buffer);
+}
+
+static int cortex_a53_write_buffer_64(struct target *target, uint64_t address, uint64_t size, const uint8_t *buffer)
+{
+	return cortex_a53_write_memory(target, address, size, 1, buffer);
+}
+
+static int cortex_a53_handle_target_request(void *priv)
+{
+	struct target *target = priv;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	int retval;
+
+	if (!target_was_examined(target))
+		return ERROR_OK;
+	if (!target->dbg_msg_enabled)
+		return ERROR_OK;
+
+	if (target->state == TARGET_RUNNING) {
+		uint32_t request;
+		uint32_t dscr;
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+
+		/* check if we have data */
+		while ((dscr & DSCR_DTR_TX_FULL) && (retval == ERROR_OK)) {
+			retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+					armv7a->debug_base + CPUDBG_DTRTX, &request);
+			if (retval == ERROR_OK) {
+				target_request(target, request);
+				retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+						armv7a->debug_base + CPUDBG_DSCR, &dscr);
+			}
+		}
+	}
+
+	return ERROR_OK;
+}
+
+/*
+ * Cortex-A8 target information and configuration
+ */
+
+static int cortex_a53_examine_first(struct target *target)
+{
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	int i;
+	int retval = ERROR_OK;
+	uint32_t dfr0, cpuid;
+
+	/* We do one extra read to ensure DAP is configured,
+	 * we call ahbap_debugport_init(swjdp) instead
+	 */
+	dap_ap_select(swjdp, 1); //swjdp->apsel=1;
+	retval = ahbap_debugport_init(swjdp);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Search for the APB-AB - it is needed for access to debug registers */
+	retval = dap_find_ap(swjdp, AP_TYPE_APB_AP, &armv7a->debug_ap);
+	if (retval != ERROR_OK) {
+		LOG_ERROR("Could not find APB-AP for debug access");
+		return retval;
+	}
+	/* Search for the AHB-AP */
+	/* SQU: tricky here. For 8916 it has AXI_AP but not AHB_AP as port 0 for sys-mem.And port3 is AHB_AP but it is RPM/Cortex M3
+	 * So either hard coded the memory_ap as port 0 or search AXI_AP first, or check AP type variant. Will take option 3.
+	 */
+	retval = dap_find_ap(swjdp, AP_TYPE_AHB_AP, &armv7a->memory_ap);
+	if (retval != ERROR_OK) {
+		/* AHB-AP not found - use APB-AP */
+		LOG_DEBUG("Could not find AHB-AP - Will try AXI-AP for memory access");
+		/* Search for the AXI-AP */
+		retval = dap_find_ap(swjdp, AP_TYPE_AXI_AP, &armv7a->memory_ap);
+		if (retval != ERROR_OK) {
+			/* AXI-AP not found - use APB-AP */
+			LOG_DEBUG("Could not find AXI/AHB-AP - using APB-AP for memory access");
+			armv7a->memory_ap_available = false;
+		} else {
+			armv7a->memory_ap_available = true;
+		}
+	} else {
+		armv7a->memory_ap_available = true;
+	}
+
+
+	if (!target->dbgbase_set) {
+		uint32_t dbgbase;
+		/* Get ROM Table base */
+		uint32_t apid;
+		int32_t coreidx = target->coreid;
+		LOG_DEBUG("%s's dbgbase is not set, trying to detect using the ROM table",
+			  target->cmd_name);
+        
+		retval = dap_get_debugbase(swjdp, 1, &dbgbase, &apid);
+		if (retval != ERROR_OK)
+			return retval;
+		/* Lookup 0x15 -- Processor DAP */
+		retval = dap_lookup_cs_component(swjdp, 1, dbgbase, 0x15,
+				&armv7a->debug_base, &coreidx);
+		if (retval != ERROR_OK)
+			return retval;
+		LOG_DEBUG("Detected core %" PRId32 " dbgbase: %08" PRIx32,
+			  coreidx, armv7a->debug_base);
+	} else
+		armv7a->debug_base = target->dbgbase;
+	armv7a->cti_base = target->ctibase;
+
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_CPUID, &cpuid);
+	if (retval != ERROR_OK)
+		return retval;
+    //if(cpuid==0x410FD030) => 8916
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_CPUID, &cpuid);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("Examine %s failed", "CPUID");
+		return retval;
+	}
+
+	/* Now CPUDBG_CYTPR @0xD04, CPUDBG_TTYPR @0xD0C, CPUDBUG_DIDR @0x0 are not accessible through mapped address.
+	 * Access those register might return error.
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_CTYPR, &ctypr);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("Examine %s failed", "CTYPR");
+		return retval;
+	}
+
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_TTYPR, &ttypr);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("Examine %s failed", "TTYPR");
+		return retval;
+	}
+
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + CPUDBG_DIDR, &didr);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("Examine %s failed", "DIDR");
+		return retval;
+	}*/
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
+			armv7a->debug_base + ID_AA64DFR0_EL1_L, &dfr0);
+	if (retval != ERROR_OK) {
+		LOG_DEBUG("Examine %s failed", "ID_AA64DFR0_EL1");
+		return retval;
+	}
+	//didr=0x3556F020; //hard coded
+	LOG_DEBUG("cpuid = 0x%08" PRIx32, cpuid);
+	/*LOG_DEBUG("ctypr = 0x%08" PRIx32, ctypr);
+	LOG_DEBUG("ttypr = 0x%08" PRIx32, ttypr);*/
+	LOG_DEBUG("didr = 0x%08" PRIx32, dfr0);
+	armv7a->arm.is_armv8 = true;
+	armv7a->arm.core_type = ARM_MODE_MON;
+	retval = cortex_a53_dpm_setup(cortex_a53, dfr0);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* Setup Breakpoint Register Pairs */
+	cortex_a53->brp_num = ((dfr0 >> 12) & 0x0F) + 1;
+	cortex_a53->brp_num_context = ((dfr0 >> 28) & 0x0F) + 1;
+	cortex_a53->brp_num_available = cortex_a53->brp_num;
+	cortex_a53->brp_list = calloc(cortex_a53->brp_num, sizeof(struct cortex_a_brp));
+/*	cortex_a53->brb_enabled = ????; */
+	for (i = 0; i < cortex_a53->brp_num; i++) {
+		cortex_a53->brp_list[i].used = 0;
+		if (i < (cortex_a53->brp_num-cortex_a53->brp_num_context))
+			cortex_a53->brp_list[i].type = BRP_NORMAL;
+		else
+			cortex_a53->brp_list[i].type = BRP_CONTEXT;
+		cortex_a53->brp_list[i].value = 0;
+		cortex_a53->brp_list[i].control = 0;
+		cortex_a53->brp_list[i].BRPn = i;
+	}
+
+	LOG_DEBUG("Configured %i hw breakpoints", cortex_a53->brp_num);
+
+	target_set_examined(target);
+	return ERROR_OK;
+}
+
+static int cortex_a53_examine(struct target *target)
+{
+	int retval = ERROR_OK;
+
+	/* don't re-probe hardware after each reset */
+	if (!target_was_examined(target))
+		retval = cortex_a53_examine_first(target);
+
+	/* Configure core debug access */
+	if (retval == ERROR_OK)
+		retval = cortex_a53_init_debug_access(target);
+
+	return retval;
+}
+
+/*
+ *	Cortex-A8 target creation and initialization
+ */
+
+static int cortex_a53_init_target(struct command_context *cmd_ctx,
+	struct target *target)
+{
+	/* examine_first() does a bunch of this */
+	return ERROR_OK;
+}
+
+static int cortex_a53_init_arch_info(struct target *target,
+	struct cortex_a_common *cortex_a53)
+{
+	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
+
+	/* Setup struct cortex_a_common */
+	cortex_a53->common_magic = CORTEX_A_COMMON_MAGIC;
+
+	cortex_a53->fast_reg_read = 0;
+
+	/* register arch-specific functions */
+	armv7a->examine_debug_reason = NULL;
+
+	armv7a->post_debug_entry = cortex_a53_post_debug_entry;
+
+	armv7a->pre_restore_context = NULL;
+
+	armv7a->armv7a_mmu.read_physical_memory = cortex_a53_read_phys_memory;
+
+
+/*	arm7_9->handle_target_request = cortex_a53_handle_target_request; */
+
+	/* REVISIT v7a setup should be in a v7a-specific routine */
+	armv7a_init_arch_info(target, armv7a);
+	target_register_timer_callback(cortex_a53_handle_target_request, 1, 1, target);
+
+	return ERROR_OK;
+}
+
+void cortex_a53_connect_dap(struct target *target, struct adiv5_dap *dap)
+{
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+
+	dap->memaccess_tck = 8;
+	dap->tar_autoincr_block = (1 << 10);
+
+	armv7a->arm.dap = dap;
+}
+
+static int cortex_a53_target_create(struct target *target, Jim_Interp *interp)
+{
+	struct cortex_a_common *cortex_a53 = calloc(1, sizeof(struct cortex_a_common));
+
+	cortex_a53->armv7a_common.is_armv7r = false;
+	cortex_a53_init_arch_info(target, cortex_a53);
+
+    /* If it's not set, assume transport select is not swd. Nothing sets up the JTAG DAP so we have to. */
+	if (!global_dap)
+		global_dap = adiv5_jtag_dap_new(target->tap);
+
+	cortex_a53_connect_dap(target, global_dap);
+
+    return ERROR_OK;
+}
+
+static int cortex_a53_mmu(struct target *target, int *enabled)
+{
+	if (target->state != TARGET_HALTED) {
+		LOG_ERROR("%s: target not halted", __func__);
+		return ERROR_TARGET_INVALID;
+	}
+
+	*enabled = target_to_cortex_a(target)->armv7a_common.armv7a_mmu.mmu_enabled;
+	return ERROR_OK;
+}
+
+static int cortex_a53_virt2phys_64(struct target *target,
+	uint64_t virt, uint64_t *phys)
+{
+	int retval = ERROR_FAIL;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	uint8_t apsel = swjdp->apsel;
+	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
+		uint32_t ret;
+		retval = armv7a_mmu_translate_va(target,
+				virt, &ret);
+		if (retval != ERROR_OK)
+			goto done;
+		*phys = ret;
+	} else {/*  use this method if armv7a->memory_ap not selected
+		 *  mmu must be enable in order to get a correct translation */
+		retval = cortex_a53_mmu_modify(target, 1);
+		if (retval != ERROR_OK)
+			goto done;
+		retval = armv7a_mmu_translate_va_pa(target, virt,  phys, 1);
+	}
+done:
+	return retval;
+}
+
+static int cortex_a53_virt2phys(struct target *target,
+	uint32_t virt, uint32_t *phys)
+{
+	return cortex_a53_virt2phys_64(target, virt, phys);
+}
+
+COMMAND_HANDLER(cortex_a53_handle_cache_info_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+
+	return armv7a_handle_cache_info_command(CMD_CTX,
+			&armv7a->armv7a_mmu.armv7a_cache);
+}
+
+
+COMMAND_HANDLER(cortex_a53_handle_dbginit_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	if (!target_was_examined(target)) {
+		LOG_ERROR("target not examined yet");
+		return ERROR_FAIL;
+	}
+
+	return cortex_a53_init_debug_access(target);
+}
+COMMAND_HANDLER(cortex_a53_handle_smp_off_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	/* check target is an smp target */
+	struct target_list *head;
+	struct target *curr;
+	head = target->head;
+	target->smp = 0;
+	if (head != (struct target_list *)NULL) {
+		while (head != (struct target_list *)NULL) {
+			curr = head->target;
+			curr->smp = 0;
+			head = head->next;
+		}
+		/*  fixes the target display to the debugger */
+		target->gdb_service->target = target;
+	}
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(cortex_a53_handle_smp_on_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct target_list *head;
+	struct target *curr;
+	head = target->head;
+	if (head != (struct target_list *)NULL) {
+		target->smp = 1;
+		while (head != (struct target_list *)NULL) {
+			curr = head->target;
+			curr->smp = 1;
+			head = head->next;
+		}
+	}
+	return ERROR_OK;
+}
+
+COMMAND_HANDLER(cortex_a53_handle_smp_gdb_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	int retval = ERROR_OK;
+	struct target_list *head;
+	head = target->head;
+	if (head != (struct target_list *)NULL) {
+		if (CMD_ARGC == 1) {
+			int coreid = 0;
+			COMMAND_PARSE_NUMBER(int, CMD_ARGV[0], coreid);
+			if (ERROR_OK != retval)
+				return retval;
+			target->gdb_service->core[1] = coreid;
+
+		}
+		command_print(CMD_CTX, "gdb coreid  %" PRId32 " -> %" PRId32, target->gdb_service->core[0]
+			, target->gdb_service->core[1]);
+	}
+	return ERROR_OK;
+}
+
+static const struct command_registration cortex_a53_exec_command_handlers[] = {
+	{
+		.name = "cache_info",
+		.handler = cortex_a53_handle_cache_info_command,
+		.mode = COMMAND_EXEC,
+		.help = "display information about target caches",
+		.usage = "",
+	},
+	{
+		.name = "dbginit",
+		.handler = cortex_a53_handle_dbginit_command,
+		.mode = COMMAND_EXEC,
+		.help = "Initialize core debug",
+		.usage = "",
+	},
+	{   .name = "smp_off",
+	    .handler = cortex_a53_handle_smp_off_command,
+	    .mode = COMMAND_EXEC,
+	    .help = "Stop smp handling",
+	    .usage = "",},
+	{
+		.name = "smp_on",
+		.handler = cortex_a53_handle_smp_on_command,
+		.mode = COMMAND_EXEC,
+		.help = "Restart smp handling",
+		.usage = "",
+	},
+	{
+		.name = "smp_gdb",
+		.handler = cortex_a53_handle_smp_gdb_command,
+		.mode = COMMAND_EXEC,
+		.help = "display/fix current core played to gdb",
+		.usage = "",
+	},
+
+
+	COMMAND_REGISTRATION_DONE
+};
+static const struct command_registration cortex_a53_command_handlers[] = {
+	{
+		.chain = arm_command_handlers,
+	},
+	{
+		.chain = armv7a_command_handlers,
+	},
+	{
+		.name = "cortex_a53",
+		.mode = COMMAND_ANY,
+		.help = "Cortex-A53 64bit command group",
+		.usage = "",
+		.chain = cortex_a53_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+struct target_type cortexa53_target = {
+	.name = "cortex_a53",
+	.deprecated_name = "cortex_a",
+
+	.poll = cortex_a53_poll,
+	.arch_state = armv7a_arch_state,
+
+	.halt = cortex_a53_halt,
+	.resume = cortex_a53_resume,
+	.resume_64 = cortex_a53_resume_64,
+	.step = cortex_a53_step,
+	.step_64 = cortex_a53_step_64,
+
+	.assert_reset = cortex_a53_assert_reset,
+	.deassert_reset = cortex_a53_deassert_reset,
+
+	.get_gdb_reg_list = armv8_get_gdb_reg_list,
+
+	.read_memory = cortex_a53_read_memory,
+	.read_memory_64 = cortex_a53_read_memory_64,
+	.write_memory = cortex_a53_write_memory,
+	.write_memory_64 = cortex_a53_write_memory_64,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+
+	.add_breakpoint = cortex_a53_add_breakpoint,
+	.add_context_breakpoint = cortex_a53_add_context_breakpoint,
+	.add_hybrid_breakpoint = cortex_a53_add_hybrid_breakpoint,
+	.remove_breakpoint = cortex_a53_remove_breakpoint,
+	.add_watchpoint = NULL,
+	.remove_watchpoint = NULL,
+
+	.commands = cortex_a53_command_handlers,
+	.target_create = cortex_a53_target_create,
+	.init_target = cortex_a53_init_target,
+	.examine = cortex_a53_examine,
+
+	.read_phys_memory = cortex_a53_read_phys_memory,
+	.read_phys_memory_64 = cortex_a53_read_phys_memory_64,
+	.write_phys_memory = cortex_a53_write_phys_memory,
+	.write_phys_memory_64 = cortex_a53_write_phys_memory_64,
+	.read_buffer_64 = cortex_a53_read_buffer_64,
+	.write_buffer_64 = cortex_a53_write_buffer_64,
+	.mmu = cortex_a53_mmu,
+	.virt2phys = cortex_a53_virt2phys,
+	.virt2phys_64 = cortex_a53_virt2phys_64,
+};
+
diff --git a/src/target/cortex_m.c b/src/target/cortex_m.c
old mode 100644
new mode 100755
index a5230b7..4e2dad5
--- a/src/target/cortex_m.c
+++ b/src/target/cortex_m.c
@@ -493,6 +493,7 @@ static int cortex_m_poll(struct target *target)
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 	struct adiv5_dap *swjdp = cortex_m->armv7m.arm.dap;
 
+    dap_ap_select(swjdp, 3); //swjdp->apsel=3;
 	/* Read from Debug Halting Control and Status Register */
 	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m->dcb_dhcsr);
 	if (retval != ERROR_OK) {
@@ -1799,6 +1800,7 @@ int cortex_m_examine(struct target *target)
 	/* stlink shares the examine handler but does not support
 	 * all its calls */
 	if (!armv7m->stlink) {
+		dap_ap_select(swjdp, 3);//swjdp->apsel=3;
 		retval = ahbap_debugport_init(swjdp);
 		if (retval != ERROR_OK)
 			return retval;
@@ -1835,7 +1837,7 @@ int cortex_m_examine(struct target *target)
 
 		if (i == 4 || i == 3) {
 			/* Cortex-M3/M4 has 4096 bytes autoincrement range */
-			armv7m->dap.tar_autoincr_block = (1 << 12);
+			armv7m->arm.dap->tar_autoincr_block = (1 << 12);
 		}
 
 		/* NOTE: FPB and DWT are both optional. */
@@ -1962,32 +1964,16 @@ static int cortex_m_handle_target_request(void *priv)
 }
 
 static int cortex_m_init_arch_info(struct target *target,
-	struct cortex_m_common *cortex_m, struct jtag_tap *tap)
+	struct cortex_m_common *cortex_m)
 {
-	int retval;
 	struct armv7m_common *armv7m = &cortex_m->armv7m;
 
 	armv7m_init_arch_info(target, armv7m);
 
-	/* prepare JTAG information for the new target */
-	cortex_m->jtag_info.tap = tap;
-	cortex_m->jtag_info.scann_size = 4;
-
 	/* default reset mode is to use srst if fitted
 	 * if not it will use CORTEX_M3_RESET_VECTRESET */
 	cortex_m->soft_reset_config = CORTEX_M_RESET_VECTRESET;
 
-	armv7m->arm.dap = &armv7m->dap;
-
-	/* Leave (only) generic DAP stuff for debugport_init(); */
-	armv7m->dap.jtag_info = &cortex_m->jtag_info;
-	armv7m->dap.memaccess_tck = 8;
-
-	/* Cortex-M3/M4 has 4096 bytes autoincrement range
-	 * but set a safe default to 1024 to support Cortex-M0
-	 * this will be changed in cortex_m3_examine if a M3/M4 is detected */
-	armv7m->dap.tar_autoincr_block = (1 << 10);
-
 	/* register arch-specific functions */
 	armv7m->examine_debug_reason = cortex_m_examine_debug_reason;
 
@@ -2000,19 +1986,36 @@ static int cortex_m_init_arch_info(struct target *target,
 
 	target_register_timer_callback(cortex_m_handle_target_request, 1, 1, target);
 
-	retval = arm_jtag_setup_connection(&cortex_m->jtag_info);
-	if (retval != ERROR_OK)
-		return retval;
-
 	return ERROR_OK;
 }
 
+void cortex_m_connect_dap(struct target *target, struct adiv5_dap *dap)
+{
+	struct armv7m_common *armv7m = target_to_armv7m(target);
+
+	/* Leave (only) generic DAP stuff for debugport_init(); */
+	dap->memaccess_tck = 8;
+
+	/* Cortex-M3/M4 has 4096 bytes autoincrement range
+	 * but set a safe default to 1024 to support Cortex-M0
+	 * this will be changed in cortex_m3_examine if a M3/M4 is detected */
+	dap->tar_autoincr_block = (1 << 10);
+
+	armv7m->arm.dap = dap;
+}
+
 static int cortex_m_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct cortex_m_common *cortex_m = calloc(1, sizeof(struct cortex_m_common));
 
 	cortex_m->common_magic = CORTEX_M_COMMON_MAGIC;
-	cortex_m_init_arch_info(target, cortex_m, target->tap);
+	cortex_m_init_arch_info(target, cortex_m);
+
+	/* If it's not set, assume transport select is not swd. Nothing sets up the JTAG DAP so we have to. */
+	if (!global_dap)
+		global_dap = adiv5_jtag_dap_new(target->tap);
+
+	cortex_m_connect_dap(target, global_dap);
 
 	return ERROR_OK;
 }
@@ -2200,6 +2203,43 @@ COMMAND_HANDLER(handle_cortex_m_reset_config_command)
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(handle_cortex_m_connect_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+	struct cortex_m_common *cortex_m = target_to_cm(target);
+	int retval;
+	char *reset_config;
+
+	retval = cortex_m_verify_pointer(CMD_CTX, cortex_m);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if (CMD_ARGC > 0) {
+		if (strcmp(*CMD_ARGV, "sysresetreq") == 0)
+			cortex_m->soft_reset_config = CORTEX_M_RESET_SYSRESETREQ;
+		else if (strcmp(*CMD_ARGV, "vectreset") == 0)
+			cortex_m->soft_reset_config = CORTEX_M_RESET_VECTRESET;
+	}
+
+	switch (cortex_m->soft_reset_config) {
+		case CORTEX_M_RESET_SYSRESETREQ:
+			reset_config = "sysresetreq";
+			break;
+
+		case CORTEX_M_RESET_VECTRESET:
+			reset_config = "vectreset";
+			break;
+
+		default:
+			reset_config = "unknown";
+			break;
+	}
+
+	command_print(CMD_CTX, "cortex_m reset_config %s", reset_config);
+
+	return ERROR_OK;
+}
+
 static const struct command_registration cortex_m_exec_command_handlers[] = {
 	{
 		.name = "maskisr",
@@ -2222,6 +2262,13 @@ static const struct command_registration cortex_m_exec_command_handlers[] = {
 		.help = "configure software reset handling",
 		.usage = "['srst'|'sysresetreq'|'vectreset']",
 	},
+	{
+		.name = "connect",
+		.handler = handle_cortex_m_connect_command,
+		.mode = COMMAND_ANY,
+		.help = "connect target to a debug access port",
+		.usage = "dap",
+	},
 	COMMAND_REGISTRATION_DONE
 };
 static const struct command_registration cortex_m_command_handlers[] = {
diff --git a/src/target/cortex_m.h b/src/target/cortex_m.h
index 8a284bd..046426d 100644
--- a/src/target/cortex_m.h
+++ b/src/target/cortex_m.h
@@ -163,7 +163,6 @@ enum cortex_m_isrmasking_mode {
 
 struct cortex_m_common {
 	int common_magic;
-	struct arm_jtag jtag_info;
 
 	/* Context information */
 	uint32_t dcb_dhcsr;
diff --git a/src/target/target.c b/src/target/target.c
index d7a2c48..c0c9c0c 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -91,6 +91,7 @@ extern struct target_type xscale_target;
 extern struct target_type cortexm_target;
 extern struct target_type cortexa_target;
 extern struct target_type cortexr4_target;
+extern struct target_type cortexa53_target;
 extern struct target_type arm11_target;
 extern struct target_type mips_m4k_target;
 extern struct target_type avr_target;
@@ -120,6 +121,7 @@ static struct target_type *target_types[] = {
 	&cortexm_target,
 	&cortexa_target,
 	&cortexr4_target,
+	&cortexa53_target,
 	&arm11_target,
 	&mips_m4k_target,
 	&avr_target,
@@ -565,7 +567,7 @@ int target_halt(struct target *target)
  * hand the infrastructure for running such helpers might use this
  * procedure but rely on hardware breakpoint to detect termination.)
  */
-int target_resume(struct target *target, int current, uint32_t address, int handle_breakpoints, int debug_execution)
+int target_resume(struct target *target, int current, uint64_t address, int handle_breakpoints, int debug_execution)
 {
 	int retval;
 
@@ -581,7 +583,10 @@ int target_resume(struct target *target, int current, uint32_t address, int hand
 	 * we poll. The CPU can even halt at the current PC as a result of
 	 * a software breakpoint being inserted by (a bug?) the application.
 	 */
-	retval = target->type->resume(target, current, address, handle_breakpoints, debug_execution);
+	if(target->is_64b)
+		retval = target->type->resume_64(target, current, address, handle_breakpoints, debug_execution);
+	else
+		retval = target->type->resume(target, current, (uint32_t)address, handle_breakpoints, debug_execution);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -991,43 +996,55 @@ int target_run_flash_async_algorithm(struct target *target,
 }
 
 int target_read_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+		uint64_t address, uint64_t size, uint64_t count, uint8_t *buffer)
 {
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
 		return ERROR_FAIL;
 	}
-	return target->type->read_memory(target, address, size, count, buffer);
+	if(target->is_64b)
+		return target->type->read_memory_64(target, address, size, count, buffer);
+	else
+		return target->type->read_memory(target, (uint32_t)address, (uint32_t)size, (uint32_t)count, buffer);
 }
 
 int target_read_phys_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer)
+		uint64_t address, uint64_t size, uint64_t count, uint8_t *buffer)
 {
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
 		return ERROR_FAIL;
 	}
-	return target->type->read_phys_memory(target, address, size, count, buffer);
+	if(target->is_64b)
+		return target->type->read_phys_memory_64(target, address, size, count, buffer);
+	else
+		return target->type->read_phys_memory(target, (uint32_t)address, (uint32_t)size, (uint32_t)count, buffer);
 }
 
 int target_write_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
+		uint64_t address, uint64_t size, uint64_t count, const uint8_t *buffer)
 {
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
 		return ERROR_FAIL;
 	}
-	return target->type->write_memory(target, address, size, count, buffer);
+	if(target->is_64b)
+		return target->type->write_memory_64(target, address, size, count, buffer);
+	else
+		return target->type->write_memory(target, (uint32_t)address, (uint32_t)size, (uint32_t)count, buffer);
 }
 
 int target_write_phys_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer)
+		uint64_t address, uint64_t size, uint64_t count, const uint8_t *buffer)
 {
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
 		return ERROR_FAIL;
 	}
-	return target->type->write_phys_memory(target, address, size, count, buffer);
+	if(target->is_64b)
+		return target->type->write_phys_memory_64(target, address, size, count, buffer);
+	else
+		return target->type->write_phys_memory(target, (uint32_t)address, (uint32_t)size, (uint32_t)count, buffer);
 }
 
 int target_add_breakpoint(struct target *target,
@@ -1105,9 +1122,12 @@ int target_get_gdb_reg_list(struct target *target,
 	return target->type->get_gdb_reg_list(target, reg_list, reg_list_size, reg_class);
 }
 int target_step(struct target *target,
-		int current, uint32_t address, int handle_breakpoints)
+		int current, uint64_t address, int handle_breakpoints)
 {
-	return target->type->step(target, current, address, handle_breakpoints);
+	if(target->is_64b)
+		return target->type->step_64(target, current, address, handle_breakpoints);
+	else
+		return target->type->step(target, current, (uint32_t)address, handle_breakpoints);
 }
 
 int target_get_gdb_fileio_info(struct target *target, struct gdb_fileio_info *fileio_info)
@@ -1853,10 +1873,10 @@ static int target_profiling_default(struct target *target, uint32_t *samples,
  * mode respectively, otherwise data is handled as quickly as
  * possible
  */
-int target_write_buffer(struct target *target, uint32_t address, uint32_t size, const uint8_t *buffer)
+int target_write_buffer(struct target *target, uint64_t address, uint64_t size, const uint8_t *buffer)
 {
-	LOG_DEBUG("writing buffer of %i byte at 0x%8.8x",
-			(int)size, (unsigned)address);
+	LOG_DEBUG("writing buffer of %" PRIu64 " byte at 0x%" PRIx64,
+			size, address);
 
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
@@ -1868,13 +1888,15 @@ int target_write_buffer(struct target *target, uint32_t address, uint32_t size,
 
 	if ((address + size - 1) < address) {
 		/* GDB can request this when e.g. PC is 0xfffffffc*/
-		LOG_ERROR("address + size wrapped(0x%08x, 0x%08x)",
-				  (unsigned)address,
-				  (unsigned)size);
+		LOG_ERROR("address + size wrapped(0x%" PRIx64 ", 0x%" PRIx64 ")",
+				  address,
+				  size);
 		return ERROR_FAIL;
 	}
-
-	return target->type->write_buffer(target, address, size, buffer);
+	if(target->is_64b)
+		return target->type->write_buffer_64(target, address, size, buffer);
+	else
+		return target->type->write_buffer(target, (uint32_t)address, (uint32_t)size, buffer);
 }
 
 static int target_write_buffer_default(struct target *target, uint32_t address, uint32_t count, const uint8_t *buffer)
@@ -1914,10 +1936,10 @@ static int target_write_buffer_default(struct target *target, uint32_t address,
  * mode respectively, otherwise data is handled as quickly as
  * possible
  */
-int target_read_buffer(struct target *target, uint32_t address, uint32_t size, uint8_t *buffer)
+int target_read_buffer(struct target *target, uint64_t address, uint64_t size, uint8_t *buffer)
 {
-	LOG_DEBUG("reading buffer of %i byte at 0x%8.8x",
-			  (int)size, (unsigned)address);
+	LOG_DEBUG("reading buffer of %" PRIu64 " byte at 0x%" PRIx64,
+			  size, address);
 
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
@@ -1929,13 +1951,15 @@ int target_read_buffer(struct target *target, uint32_t address, uint32_t size, u
 
 	if ((address + size - 1) < address) {
 		/* GDB can request this when e.g. PC is 0xfffffffc*/
-		LOG_ERROR("address + size wrapped(0x%08" PRIx32 ", 0x%08" PRIx32 ")",
+		LOG_ERROR("address + size wrapped(0x%" PRIx64 ", 0x%" PRIx64 ")",
 				  address,
 				  size);
 		return ERROR_FAIL;
 	}
-
-	return target->type->read_buffer(target, address, size, buffer);
+	if(target->is_64b)
+		return target->type->read_buffer_64(target, address, size, buffer);
+	else
+		return target->type->read_buffer(target, (uint32_t)address, (uint32_t)size, buffer);
 }
 
 static int target_read_buffer_default(struct target *target, uint32_t address, uint32_t count, uint8_t *buffer)
@@ -2812,7 +2836,7 @@ COMMAND_HANDLER(handle_md_command)
 
 	bool physical = strcmp(CMD_ARGV[0], "phys") == 0;
 	int (*fn)(struct target *target,
-			uint32_t address, uint32_t size_value, uint32_t count, uint8_t *buffer);
+			uint64_t address, uint64_t size_value, uint64_t count, uint8_t *buffer);
 	if (physical) {
 		CMD_ARGC--;
 		CMD_ARGV++;
@@ -4118,6 +4142,7 @@ enum target_cfg_param {
 	TCFG_COREID,
 	TCFG_CHAIN_POSITION,
 	TCFG_DBGBASE,
+	TCFG_CTIBASE,
 	TCFG_RTOS,
 };
 
@@ -4132,6 +4157,7 @@ static Jim_Nvp nvp_config_opts[] = {
 	{ .name = "-coreid",           .value = TCFG_COREID },
 	{ .name = "-chain-position",   .value = TCFG_CHAIN_POSITION },
 	{ .name = "-dbgbase",          .value = TCFG_DBGBASE },
+	{ .name = "-ctibase",          .value = TCFG_CTIBASE },
 	{ .name = "-rtos",             .value = TCFG_RTOS },
 	{ .name = NULL, .value = -1 }
 };
@@ -4397,6 +4423,19 @@ no_params:
 			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->dbgbase));
 			/* loop for more */
 			break;
+		case TCFG_CTIBASE:
+			if (goi->isconfigure) {
+				e = Jim_GetOpt_Wide(goi, &w);
+				if (e != JIM_OK)
+					return e;
+				target->ctibase = (uint32_t)w;
+			} else {
+				if (goi->argc != 0)
+					goto no_params;
+			}
+			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->ctibase));
+			/* loop for more */
+			break;
 
 		case TCFG_RTOS:
 			/* RTOS */
@@ -4539,7 +4578,7 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	}
 
 	int (*fn)(struct target *target,
-			uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+			uint64_t address, uint64_t size, uint64_t count, uint8_t *buffer);
 	fn = target_read_memory;
 
 	int e;
diff --git a/src/target/target.h b/src/target/target.h
index 0552b8f..8c5b3b7 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -181,6 +181,8 @@ struct target {
 	uint32_t dbgbase;					/* Really a Cortex-A specific option, but there is no
 										 * system in place to support target specific options
 										 * currently. */
+	uint32_t ctibase;					/* added to support ARMv8 by SQU*/
+	bool is_64b;						/* added to support 64bit architecture by SQU */
 	struct rtos *rtos;					/* Instance of Real Time Operating System support */
 	bool rtos_auto_detect;				/* A flag that indicates that the RTOS has been specified as "auto"
 										 * and must be detected when symbols are offered */
@@ -316,7 +318,7 @@ int target_unregister_event_callback(
  * yet it is possible to detect error conditions.
  */
 int target_poll(struct target *target);
-int target_resume(struct target *target, int current, uint32_t address,
+int target_resume(struct target *target, int current, uint64_t address,
 		int handle_breakpoints, int debug_execution);
 int target_halt(struct target *target);
 int target_call_event_callbacks(struct target *target, enum target_event event);
@@ -434,7 +436,7 @@ int target_get_gdb_reg_list(struct target *target,
  * This routine is a wrapper for target->type->step.
  */
 int target_step(struct target *target,
-		int current, uint32_t address, int handle_breakpoints);
+		int current, uint64_t address, int handle_breakpoints);
 /**
  * Run an algorithm on the @a target given.
  *
@@ -487,9 +489,10 @@ int target_run_flash_async_algorithm(struct target *target,
  * This routine is a wrapper for target->type->read_memory.
  */
 int target_read_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+		uint64_t address, uint64_t size, uint64_t count, uint8_t *buffer);
 int target_read_phys_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+		uint64_t address, uint64_t size, uint64_t count, uint8_t *buffer);
+
 /**
  * Write @a count items of @a size bytes to the memory of @a target at
  * the @a address given. @a address must be aligned to @a size
@@ -508,9 +511,9 @@ int target_read_phys_memory(struct target *target,
  * This routine is wrapper for target->type->write_memory.
  */
 int target_write_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
+		uint64_t address, uint64_t size, uint64_t count, const uint8_t *buffer);
 int target_write_phys_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
+		uint64_t address, uint64_t size, uint64_t count, const uint8_t *buffer);
 
 /*
  * Write to target memory using the virtual address.
@@ -537,9 +540,9 @@ int target_write_phys_memory(struct target *target,
  * peripheral registers which do not support byte operations.
  */
 int target_write_buffer(struct target *target,
-		uint32_t address, uint32_t size, const uint8_t *buffer);
+		uint64_t address, uint64_t size, const uint8_t *buffer);
 int target_read_buffer(struct target *target,
-		uint32_t address, uint32_t size, uint8_t *buffer);
+		uint64_t address, uint64_t size, uint8_t *buffer);
 int target_checksum_memory(struct target *target,
 		uint32_t address, uint32_t size, uint32_t *crc);
 int target_blank_check_memory(struct target *target,
diff --git a/src/target/target_type.h b/src/target/target_type.h
index cf3c864..3df999c 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -57,8 +57,12 @@ struct target_type {
 	int (*halt)(struct target *target);
 	int (*resume)(struct target *target, int current, uint32_t address,
 			int handle_breakpoints, int debug_execution);
+	int (*resume_64)(struct target *target, int current, uint64_t address,
+			int handle_breakpoints, int debug_execution);
 	int (*step)(struct target *target, int current, uint32_t address,
 			int handle_breakpoints);
+	int (*step_64)(struct target *target, int current, uint64_t address,
+			int handle_breakpoints);
 
 	/* target reset control. assert reset can be invoked when OpenOCD and
 	 * the target is out of sync.
@@ -115,20 +119,28 @@ struct target_type {
 	 */
 	int (*read_memory)(struct target *target, uint32_t address,
 			uint32_t size, uint32_t count, uint8_t *buffer);
+	int (*read_memory_64)(struct target *target, uint32_t address,
+			uint32_t size, uint32_t count, uint8_t *buffer);
 	/**
 	 * Target memory write callback.  Do @b not call this function
 	 * directly, use target_write_memory() instead.
 	 */
 	int (*write_memory)(struct target *target, uint32_t address,
 			uint32_t size, uint32_t count, const uint8_t *buffer);
+	int (*write_memory_64)(struct target *target, uint64_t address,
+			uint64_t size, uint64_t count, const uint8_t *buffer);
 
 	/* Default implementation will do some fancy alignment to improve performance, target can override */
 	int (*read_buffer)(struct target *target, uint32_t address,
 			uint32_t size, uint8_t *buffer);
+	int (*read_buffer_64)(struct target *target, uint64_t address,
+			uint64_t size, uint8_t *buffer);
 
 	/* Default implementation will do some fancy alignment to improve performance, target can override */
 	int (*write_buffer)(struct target *target, uint32_t address,
 			uint32_t size, const uint8_t *buffer);
+	int (*write_buffer_64)(struct target *target, uint64_t address,
+			uint64_t size, const uint8_t *buffer);
 
 	int (*checksum_memory)(struct target *target, uint32_t address,
 			uint32_t count, uint32_t *checksum);
@@ -229,6 +241,7 @@ struct target_type {
 	 * no-op(i.e. virtual==physical).
 	 */
 	int (*virt2phys)(struct target *target, uint32_t address, uint32_t *physical);
+	int (*virt2phys_64)(struct target *target, uint64_t address, uint64_t *physical);
 
 	/* read directly from physical memory. caches are bypassed and untouched.
 	 *
@@ -240,12 +253,16 @@ struct target_type {
 	 */
 	int (*read_phys_memory)(struct target *target, uint32_t phys_address,
 			uint32_t size, uint32_t count, uint8_t *buffer);
+	int (*read_phys_memory_64)(struct target *target, uint64_t phys_address,
+			uint64_t size, uint64_t count, uint8_t *buffer);
 
 	/*
 	 * same as read_phys_memory, except that it writes...
 	 */
 	int (*write_phys_memory)(struct target *target, uint32_t phys_address,
 			uint32_t size, uint32_t count, const uint8_t *buffer);
+	int (*write_phys_memory_64)(struct target *target, uint64_t phys_address,
+			uint64_t size, uint64_t count, const uint8_t *buffer);
 
 	int (*mmu)(struct target *target, int *enabled);
 
-- 
1.9.1


From 856cd6b2b89f43aa4d6b36faf87763aad5ed13a2 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 02/94] Update dpm for supporting AArch32

---
 src/target/armv8.c     | 10 +++++-----
 src/target/armv8_dpm.c |  5 +++++
 2 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/src/target/armv8.c b/src/target/armv8.c
index bfc09fe..a93daa7 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -555,9 +555,8 @@ struct reg_cache *armv8_build_reg_cache(struct target *target, struct arm *arm)
 		    break;
 		}
 
-		/* let GDB shows banked registers only in "info all-reg" */
 		reg_list[i].feature = malloc(sizeof(struct reg_feature));
-		reg_list[i].feature->name = "org.gnu.gdb.arm.core";
+		reg_list[i].feature->name = "org.gnu.gdb.aarch64.core";
 		reg_list[i].group = "general";
 
 		cache->num_regs++;
@@ -565,6 +564,7 @@ struct reg_cache *armv8_build_reg_cache(struct target *target, struct arm *arm)
 
 	arm->pc = reg_list + 32;
 	arm->cpsr = reg_list + 33;
+	arm->cpsr->reg_data_type->type = REG_TYPE_UINT32;
 	arm->core_cache = cache;
 	return cache;
 }
@@ -1032,7 +1032,7 @@ int armv8_get_gdb_reg_list(struct target *target,
 	struct arm *arm = target_to_arm(target);
 	unsigned int i;
 
-	//if(!target->is_64b) return arm_get_gdb_reg_list(target, reg_list, reg_list_size, reg_class);
+	if(!target->is_64b) return arm_get_gdb_reg_list(target, reg_list, reg_list_size, reg_class);
 	if (!is_arm_mode(arm->core_mode)) {
 		LOG_ERROR("not a valid arm core mode - communication failure?");
 		return ERROR_FAIL;
@@ -1041,9 +1041,9 @@ int armv8_get_gdb_reg_list(struct target *target,
 	switch (reg_class) {
 	case REG_CLASS_GENERAL:
 	case REG_CLASS_ALL:
-		*reg_list_size = 33;
+		*reg_list_size = 34;
 		*reg_list = malloc(sizeof(struct reg *) * (*reg_list_size));
-		for (i = 0; i < 33; i++)
+		for (i = 0; i < 34; i++)
 			(*reg_list)[i] = arm->core_cache->reg_list+i; //no mapping needed for ARMv8: armv8_reg_current(arm, i);
 		return ERROR_OK;
 		break;
diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index e58d868..6e5dd92 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -927,6 +927,7 @@ int armv8_dpm_setup(struct arm_dpm *dpm)
 	struct target *target = arm->target;
 	struct reg_cache *cache;
 
+	if(!target->is_64b) return arm_dpm_setup(dpm);
 	arm->dpm = dpm;
 
 	/* register access setup */
@@ -984,6 +985,10 @@ int armv8_dpm_setup(struct arm_dpm *dpm)
  */
 int armv8_dpm_initialize(struct arm_dpm *dpm)
 {
+	struct arm *arm = dpm->arm;
+	struct target *target = arm->target;
+
+	if(!target->is_64b) return arm_dpm_initialize(dpm);
 	/* Disable all breakpoints and watchpoints at startup. */
 	if (dpm->bpwp_disable) {
 		unsigned i;
-- 
1.9.1


From 3f2508dbfbaed948760ecd435090f688b8c2eaec Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 03/94] update aarch64 dpm for AArch64 state setting and query

---
 src/target/arm.h   |   8 --
 src/target/armv8.c | 334 ++++++++++++-----------------------------------------
 src/target/armv8.h |  12 ++
 3 files changed, 87 insertions(+), 267 deletions(-)

diff --git a/src/target/arm.h b/src/target/arm.h
index 5bea751..28977bd 100644
--- a/src/target/arm.h
+++ b/src/target/arm.h
@@ -67,14 +67,6 @@ enum arm_mode {
 	ARM_MODE_USER_THREAD = 1,
 	ARM_MODE_HANDLER = 2,
 
-	//ARM_MODE_EL0t = 0, same as ARM_MODE_THREAD
-	ARM_MODE_EL1t = 4,
-	ARM_MODE_EL1h = 5,
-	ARM_MODE_EL2t = 8,
-	ARM_MODE_EL2h = 9,
-	ARM_MODE_EL3t = 12,
-	ARM_MODE_EL3h = 13,
-
 	ARM_MODE_ANY = -1
 };
 
diff --git a/src/target/armv8.c b/src/target/armv8.c
index a93daa7..1d8e0ad 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -16,45 +16,6 @@
 
 #define keep_old_code 0
 
-/* offsets into armv4_5 core register cache */
-enum {
-/*	ARMV4_5_CPSR = 31, */
-	ARMV4_5_SPSR_FIQ = 32,
-	ARMV4_5_SPSR_IRQ = 33,
-	ARMV4_5_SPSR_SVC = 34,
-	ARMV4_5_SPSR_ABT = 35,
-	ARMV4_5_SPSR_UND = 36,
-	ARM_SPSR_MON = 41,
-};
-
-static const uint8_t arm_usr_indices[17] = {
-	0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, ARMV4_5_CPSR,
-};
-
-static const uint8_t arm_fiq_indices[8] = {
-	16, 17, 18, 19, 20, 21, 22, ARMV4_5_SPSR_FIQ,
-};
-
-static const uint8_t arm_irq_indices[3] = {
-	23, 24, ARMV4_5_SPSR_IRQ,
-};
-
-static const uint8_t arm_svc_indices[3] = {
-	25, 26, ARMV4_5_SPSR_SVC,
-};
-
-static const uint8_t arm_abt_indices[3] = {
-	27, 28, ARMV4_5_SPSR_ABT,
-};
-
-static const uint8_t arm_und_indices[3] = {
-	29, 30, ARMV4_5_SPSR_UND,
-};
-
-static const uint8_t arm_mon_indices[3] = {
-	39, 40, ARM_SPSR_MON,
-};
-
 static const struct {
 	const char *name;
 	unsigned short psr;
@@ -64,111 +25,38 @@ static const struct {
 	unsigned short n_indices;
 	const uint8_t *indices;
 } arm_mode_data[] = {
-	/* Seven modes are standard from ARM7 on. "System" and "User" share
-	 * the same registers; other modes shadow from 3 to 8 registers.
-	 */
-	{
-		.name = "User",
-		.psr = ARM_MODE_USR,
-		.n_indices = ARRAY_SIZE(arm_usr_indices),
-		.indices = arm_usr_indices,
-	},
-	{
-		.name = "FIQ",
-		.psr = ARM_MODE_FIQ,
-		.n_indices = ARRAY_SIZE(arm_fiq_indices),
-		.indices = arm_fiq_indices,
-	},
-	{
-		.name = "Supervisor",
-		.psr = ARM_MODE_SVC,
-		.n_indices = ARRAY_SIZE(arm_svc_indices),
-		.indices = arm_svc_indices,
-	},
-	{
-		.name = "Abort",
-		.psr = ARM_MODE_ABT,
-		.n_indices = ARRAY_SIZE(arm_abt_indices),
-		.indices = arm_abt_indices,
-	},
-	{
-		.name = "IRQ",
-		.psr = ARM_MODE_IRQ,
-		.n_indices = ARRAY_SIZE(arm_irq_indices),
-		.indices = arm_irq_indices,
-	},
-	{
-		.name = "Undefined instruction",
-		.psr = ARM_MODE_UND,
-		.n_indices = ARRAY_SIZE(arm_und_indices),
-		.indices = arm_und_indices,
-	},
-	{
-		.name = "System",
-		.psr = ARM_MODE_SYS,
-		.n_indices = ARRAY_SIZE(arm_usr_indices),
-		.indices = arm_usr_indices,
-	},
-	/* TrustZone "Security Extensions" add a secure monitor mode.
-	 * This is distinct from a "debug monitor" which can support
-	 * non-halting debug, in conjunction with some debuggers.
-	 */
-	{
-		.name = "Secure Monitor",
-		.psr = ARM_MODE_MON,
-		.n_indices = ARRAY_SIZE(arm_mon_indices),
-		.indices = arm_mon_indices,
-	},
-
-	/* These special modes are currently only supported
-	 * by ARMv6M and ARMv7M profiles */
-	{
-		.name = "Thread/EL0t",
-		.psr = ARM_MODE_THREAD,
-	},
-	{
-		.name = "Thread (User)",
-		.psr = ARM_MODE_USER_THREAD,
-	},
-	{
-		.name = "Handler",
-		.psr = ARM_MODE_HANDLER,
-	},
-
-	/* EL0t treated same as ARM_MODE_THREAD
     {
 		.name = "EL0t",
-		.psr = ARM_MODE_EL0t,
-	},*/
+		.psr = AARCH64_MODE_EL0t,
+	},
 	{
 		.name = "EL1t",
-		.psr = ARM_MODE_EL1t,
+		.psr = AARCH64_MODE_EL1t,
 	},
 	{
 		.name = "EL1h",
-		.psr = ARM_MODE_EL1h,
+		.psr = AARCH64_MODE_EL1h,
 	},
 	{
 		.name = "EL2t",
-		.psr = ARM_MODE_EL2t,
+		.psr = AARCH64_MODE_EL2t,
 	},
 	{
 		.name = "EL2h",
-		.psr = ARM_MODE_EL2h,
+		.psr = AARCH64_MODE_EL2h,
 	},
 	{
 		.name = "EL3t",
-		.psr = ARM_MODE_EL3t,
+		.psr = AARCH64_MODE_EL3t,
 	},
 	{
 		.name = "EL3h",
-		.psr = ARM_MODE_EL3h,
+		.psr = AARCH64_MODE_EL3h,
 	},
 };
 
-#if keep_old_code
 /** Map PSR mode bits to the name of an ARM processor operating mode. */
-const char *arm_mode_name(unsigned psr_mode)
+const char *aarch64_mode_name(unsigned psr_mode)
 {
 	for (unsigned i = 0; i < ARRAY_SIZE(arm_mode_data); i++) {
 		if (arm_mode_data[i].psr == psr_mode)
@@ -179,7 +67,7 @@ const char *arm_mode_name(unsigned psr_mode)
 }
 
 /** Return true iff the parameter denotes a valid ARM processor mode. */
-bool is_arm_mode(unsigned psr_mode)
+bool is_aarch64_mode(unsigned psr_mode)
 {
 	for (unsigned i = 0; i < ARRAY_SIZE(arm_mode_data); i++) {
 		if (arm_mode_data[i].psr == psr_mode)
@@ -189,27 +77,25 @@ bool is_arm_mode(unsigned psr_mode)
 }
 
 /** Map PSR mode bits to linear number indexing armv4_5_core_reg_map */
-int arm_mode_to_number(enum arm_mode mode)
+int aarch64_mode_to_number(enum aarch64_mode mode)
 {
 	switch (mode) {
-		case ARM_MODE_ANY:
-		/* map MODE_ANY to user mode */
-		case ARM_MODE_USR:
+		case AARCH64_MODE_ANY:
+		/* map AARCH64_MODE_ANY to EL0t */
+		case AARCH64_MODE_EL0t:
 			return 0;
-		case ARM_MODE_FIQ:
-			return 1;
-		case ARM_MODE_IRQ:
-			return 2;
-		case ARM_MODE_SVC:
-			return 3;
-		case ARM_MODE_ABT:
+		case AARCH64_MODE_EL1t:
 			return 4;
-		case ARM_MODE_UND:
+		case AARCH64_MODE_EL1h:
 			return 5;
-		case ARM_MODE_SYS:
-			return 6;
-		case ARM_MODE_MON:
-			return 7;
+		case AARCH64_MODE_EL2t:
+			return 8;
+		case AARCH64_MODE_EL2h:
+			return 9;
+		case AARCH64_MODE_EL3t:
+			return 12;
+		case AARCH64_MODE_EL3h:
+			return 13;
 		default:
 			LOG_ERROR("invalid mode value encountered %d", mode);
 			return -1;
@@ -217,36 +103,29 @@ int arm_mode_to_number(enum arm_mode mode)
 }
 
 /** Map linear number indexing armv4_5_core_reg_map to PSR mode bits. */
-enum arm_mode armv4_5_number_to_mode(int number)
+enum aarch64_mode aarch64_number_to_mode(int number)
 {
 	switch (number) {
 		case 0:
-			return ARM_MODE_USR;
-		case 1:
-			return ARM_MODE_FIQ;
-		case 2:
-			return ARM_MODE_IRQ;
-		case 3:
-			return ARM_MODE_SVC;
+			return AARCH64_MODE_EL0t;
 		case 4:
-			return ARM_MODE_ABT;
+			return AARCH64_MODE_EL1t;
 		case 5:
-			return ARM_MODE_UND;
-		case 6:
-			return ARM_MODE_SYS;
-		case 7:
-			return ARM_MODE_MON;
+			return AARCH64_MODE_EL1h;
+		case 8:
+			return AARCH64_MODE_EL2t;
+		case 9:
+			return AARCH64_MODE_EL2h;
+		case 12:
+			return AARCH64_MODE_EL3t;
+		case 13:
+			return AARCH64_MODE_EL3h;
 		default:
 			LOG_ERROR("mode index out of bounds %d", number);
-			return ARM_MODE_ANY;
+			return AARCH64_MODE_ANY;
 	}
 }
 
-static const char *arm_state_strings[] = {
-	"ARM", "Thumb", "Jazelle", "ThumbEE",
-};
-#endif
-
 /* Templates for ARM core registers.
  *
  * NOTE:  offsets in this table are coupled to the arm_mode_data
@@ -270,78 +149,49 @@ static const struct {
 	 */
 	unsigned cookie;
 	unsigned gdb_index;
-	enum arm_mode mode;
+	enum aarch64_mode mode;
 } arm_core_regs[] = {
 	/* IMPORTANT:  we guarantee that the first eight cached registers
 	 * correspond to r0..r7, and the fifteenth to PC, so that callers
 	 * don't need to map them.
 	 */
-	{ .name = "x0", .cookie = 0, .mode = ARM_MODE_ANY, .gdb_index = 0, },
-	{ .name = "x1", .cookie = 1, .mode = ARM_MODE_ANY, .gdb_index = 1, },
-	{ .name = "x2", .cookie = 2, .mode = ARM_MODE_ANY, .gdb_index = 2, },
-	{ .name = "x3", .cookie = 3, .mode = ARM_MODE_ANY, .gdb_index = 3, },
-	{ .name = "x4", .cookie = 4, .mode = ARM_MODE_ANY, .gdb_index = 4, },
-	{ .name = "x5", .cookie = 5, .mode = ARM_MODE_ANY, .gdb_index = 5, },
-	{ .name = "x6", .cookie = 6, .mode = ARM_MODE_ANY, .gdb_index = 6, },
-	{ .name = "x7", .cookie = 7, .mode = ARM_MODE_ANY, .gdb_index = 7, },
-	{ .name = "x8", .cookie = 8, .mode = ARM_MODE_ANY, .gdb_index = 8, },
-	{ .name = "x9", .cookie = 9, .mode = ARM_MODE_ANY, .gdb_index = 9, },
-	{ .name = "x10", .cookie = 10, .mode = ARM_MODE_ANY, .gdb_index = 10, },
-	{ .name = "x11", .cookie = 11, .mode = ARM_MODE_ANY, .gdb_index = 11, },
-	{ .name = "x12", .cookie = 12, .mode = ARM_MODE_ANY, .gdb_index = 12, },
-	{ .name = "x13", .cookie = 13, .mode = ARM_MODE_ANY, .gdb_index = 13, },
-	{ .name = "x14", .cookie = 14, .mode = ARM_MODE_ANY, .gdb_index = 14, },
-	{ .name = "x15", .cookie = 15, .mode = ARM_MODE_ANY, .gdb_index = 15, },
-	{ .name = "x16", .cookie = 16, .mode = ARM_MODE_ANY, .gdb_index = 16, },
-	{ .name = "x17", .cookie = 17, .mode = ARM_MODE_ANY, .gdb_index = 17, },
-	{ .name = "x18", .cookie = 18, .mode = ARM_MODE_ANY, .gdb_index = 18, },
-	{ .name = "x19", .cookie = 19, .mode = ARM_MODE_ANY, .gdb_index = 19, },
-	{ .name = "x20", .cookie = 20, .mode = ARM_MODE_ANY, .gdb_index = 20, },
-	{ .name = "x21", .cookie = 21, .mode = ARM_MODE_ANY, .gdb_index = 21, },
-	{ .name = "x22", .cookie = 22, .mode = ARM_MODE_ANY, .gdb_index = 22, },
-	{ .name = "x23", .cookie = 23, .mode = ARM_MODE_ANY, .gdb_index = 23, },
-	{ .name = "x24", .cookie = 24, .mode = ARM_MODE_ANY, .gdb_index = 24, },
-	{ .name = "x25", .cookie = 25, .mode = ARM_MODE_ANY, .gdb_index = 25, },
-	{ .name = "x26", .cookie = 26, .mode = ARM_MODE_ANY, .gdb_index = 26, },
-	{ .name = "x27", .cookie = 27, .mode = ARM_MODE_ANY, .gdb_index = 27, },
-	{ .name = "x28", .cookie = 28, .mode = ARM_MODE_ANY, .gdb_index = 28, },
-	{ .name = "x29", .cookie = 29, .mode = ARM_MODE_ANY, .gdb_index = 29, },
-	{ .name = "x30", .cookie = 30, .mode = ARM_MODE_ANY, .gdb_index = 30, },
-	{ .name = "x31", .cookie = 31, .mode = ARM_MODE_ANY, .gdb_index = 31, },
-	{ .name = "pc", .cookie = 32, .mode = ARM_MODE_ANY, .gdb_index = 32, },
-	{ .name = "cpsr", .cookie = 33, .mode = ARM_MODE_ANY, .gdb_index = 33, },
+	{ .name = "x0", .cookie = 0, .mode = AARCH64_MODE_ANY, .gdb_index = 0, },
+	{ .name = "x1", .cookie = 1, .mode = AARCH64_MODE_ANY, .gdb_index = 1, },
+	{ .name = "x2", .cookie = 2, .mode = AARCH64_MODE_ANY, .gdb_index = 2, },
+	{ .name = "x3", .cookie = 3, .mode = AARCH64_MODE_ANY, .gdb_index = 3, },
+	{ .name = "x4", .cookie = 4, .mode = AARCH64_MODE_ANY, .gdb_index = 4, },
+	{ .name = "x5", .cookie = 5, .mode = AARCH64_MODE_ANY, .gdb_index = 5, },
+	{ .name = "x6", .cookie = 6, .mode = AARCH64_MODE_ANY, .gdb_index = 6, },
+	{ .name = "x7", .cookie = 7, .mode = AARCH64_MODE_ANY, .gdb_index = 7, },
+	{ .name = "x8", .cookie = 8, .mode = AARCH64_MODE_ANY, .gdb_index = 8, },
+	{ .name = "x9", .cookie = 9, .mode = AARCH64_MODE_ANY, .gdb_index = 9, },
+	{ .name = "x10", .cookie = 10, .mode = AARCH64_MODE_ANY, .gdb_index = 10, },
+	{ .name = "x11", .cookie = 11, .mode = AARCH64_MODE_ANY, .gdb_index = 11, },
+	{ .name = "x12", .cookie = 12, .mode = AARCH64_MODE_ANY, .gdb_index = 12, },
+	{ .name = "x13", .cookie = 13, .mode = AARCH64_MODE_ANY, .gdb_index = 13, },
+	{ .name = "x14", .cookie = 14, .mode = AARCH64_MODE_ANY, .gdb_index = 14, },
+	{ .name = "x15", .cookie = 15, .mode = AARCH64_MODE_ANY, .gdb_index = 15, },
+	{ .name = "x16", .cookie = 16, .mode = AARCH64_MODE_ANY, .gdb_index = 16, },
+	{ .name = "x17", .cookie = 17, .mode = AARCH64_MODE_ANY, .gdb_index = 17, },
+	{ .name = "x18", .cookie = 18, .mode = AARCH64_MODE_ANY, .gdb_index = 18, },
+	{ .name = "x19", .cookie = 19, .mode = AARCH64_MODE_ANY, .gdb_index = 19, },
+	{ .name = "x20", .cookie = 20, .mode = AARCH64_MODE_ANY, .gdb_index = 20, },
+	{ .name = "x21", .cookie = 21, .mode = AARCH64_MODE_ANY, .gdb_index = 21, },
+	{ .name = "x22", .cookie = 22, .mode = AARCH64_MODE_ANY, .gdb_index = 22, },
+	{ .name = "x23", .cookie = 23, .mode = AARCH64_MODE_ANY, .gdb_index = 23, },
+	{ .name = "x24", .cookie = 24, .mode = AARCH64_MODE_ANY, .gdb_index = 24, },
+	{ .name = "x25", .cookie = 25, .mode = AARCH64_MODE_ANY, .gdb_index = 25, },
+	{ .name = "x26", .cookie = 26, .mode = AARCH64_MODE_ANY, .gdb_index = 26, },
+	{ .name = "x27", .cookie = 27, .mode = AARCH64_MODE_ANY, .gdb_index = 27, },
+	{ .name = "x28", .cookie = 28, .mode = AARCH64_MODE_ANY, .gdb_index = 28, },
+	{ .name = "x29", .cookie = 29, .mode = AARCH64_MODE_ANY, .gdb_index = 29, },
+	{ .name = "x30", .cookie = 30, .mode = AARCH64_MODE_ANY, .gdb_index = 30, },
+	{ .name = "x31", .cookie = 31, .mode = AARCH64_MODE_ANY, .gdb_index = 31, },
+	{ .name = "pc", .cookie = 32, .mode = AARCH64_MODE_ANY, .gdb_index = 32, },
+	{ .name = "cpsr", .cookie = 33, .mode = AARCH64_MODE_ANY, .gdb_index = 33, },
 };
 
 #if use_old_code
-/* map core mode (USR, FIQ, ...) and register number to
- * indices into the register cache
- */
-const int armv4_5_core_reg_map[8][17] = {
-	{	/* USR */
-		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 31
-	},
-	{	/* FIQ (8 shadows of USR, vs normal 3) */
-		0, 1, 2, 3, 4, 5, 6, 7, 16, 17, 18, 19, 20, 21, 22, 15, 32
-	},
-	{	/* IRQ */
-		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 23, 24, 15, 33
-	},
-	{	/* SVC */
-		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 25, 26, 15, 34
-	},
-	{	/* ABT */
-		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 27, 28, 15, 35
-	},
-	{	/* UND */
-		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 29, 30, 15, 36
-	},
-	{	/* SYS (same registers as USR) */
-		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 31
-	},
-	{	/* MON */
-		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 37, 38, 15, 39,
-	}
-};
 
 /**
  * Configures host-side ARM records to reflect the specified CPSR.
@@ -401,42 +251,6 @@ void arm_set_cpsr(struct arm *arm, uint32_t cpsr)
 }
 #endif
 
-/**
- * Returns handle to the register currently mapped to a given number.
- * Someone must have called arm_set_cpsr() before.
- *
- * \param arm This core's state and registers are used.
- * \param regnum From 0..15 corresponding to R0..R14 and PC.
- *	Note that R0..R7 don't require mapping; you may access those
- *	as the first eight entries in the register cache.  Likewise
- *	R15 (PC) doesn't need mapping; you may also access it directly.
- *	However, R8..R14, and SPSR (arm->spsr) *must* be mapped.
- *	CPSR (arm->cpsr) is also not mapped.
- */
-struct reg *armv8_reg_current(struct arm *arm, unsigned regnum)
-{
-	struct reg *r;
-
-	if (regnum > 33)
-		return NULL;
-
-	if (!arm->map) {
-		LOG_ERROR("Register map is not available yet, the target is not fully initialized");
-		r = arm->core_cache->reg_list + regnum;
-	} else
-		r = arm->core_cache->reg_list + arm->map[regnum];
-
-	/* e.g. invalid CPSR said "secure monitor" mode on a core
-	 * that doesn't support it...
-	 */
-	if (!r) {
-		LOG_ERROR("Invalid CPSR mode");
-		r = arm->core_cache->reg_list + regnum;
-	}
-
-	return r;
-}
-
 static int armv8_get_core_reg(struct reg *reg)
 {
 	int retval;
@@ -550,6 +364,9 @@ struct reg_cache *armv8_build_reg_cache(struct target *target, struct arm *arm)
 		case 32: //pc
 			reg_list[i].reg_data_type->type = REG_TYPE_CODE_PTR;
 		    break;
+		case 33: //cpsr
+			reg_list[i].reg_data_type->type = REG_TYPE_UINT32;
+			break;
 		default:
 			reg_list[i].reg_data_type->type = REG_TYPE_UINT64;
 		    break;
@@ -564,7 +381,6 @@ struct reg_cache *armv8_build_reg_cache(struct target *target, struct arm *arm)
 
 	arm->pc = reg_list + 32;
 	arm->cpsr = reg_list + 33;
-	arm->cpsr->reg_data_type->type = REG_TYPE_UINT32;
 	arm->core_cache = cache;
 	return cache;
 }
diff --git a/src/target/armv8.h b/src/target/armv8.h
index 41c7a41..f82af6a 100755
--- a/src/target/armv8.h
+++ b/src/target/armv8.h
@@ -52,6 +52,18 @@
 #define CTIDBGCHAN_HALT		1
 #define CTIDBGCHAN_RESTART	2
 
+//co-exist with arm_mode, aarch64_mode is for AArch64 state
+enum aarch64_mode {
+	AARCH64_MODE_EL0t = 0,
+	AARCH64_MODE_EL1t = 4,
+	AARCH64_MODE_EL1h = 5,
+	AARCH64_MODE_EL2t = 8,
+	AARCH64_MODE_EL2h = 9,
+	AARCH64_MODE_EL3t = 12,
+	AARCH64_MODE_EL3h = 13,
+	AARCH64_MODE_ANY = -1
+};
+
 int armv8_get_gdb_reg_list(struct target *target,
 		struct reg **reg_list[], int *reg_list_size,
 		enum target_register_class reg_class);
-- 
1.9.1


From ddc0abe9b0a6c6ed40e0bf5b40ef51280cc6d7e7 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 04/94] Update dpm code for ARMv8 architecture. Added
 armv8_common struct to hold all data for armv8. This struct contains the
 legacy cortex_a struct and a armv8 dpm struct. In this way it can re-use
 general ARM code, and also has the data for AArch64 architecutre

---
 src/target/armv8.h      |  22 +++---
 src/target/armv8_dpm.c  |  82 ++++++++++---------
 src/target/armv8_dpm.h  | 189 ++++++++++++++++++++++++++++++++++++++++++++
 src/target/cortex_a53.c | 203 ++++++++++++++++++++++++++++--------------------
 4 files changed, 357 insertions(+), 139 deletions(-)
 create mode 100755 src/target/armv8_dpm.h

diff --git a/src/target/armv8.h b/src/target/armv8.h
index f82af6a..398f2e9 100755
--- a/src/target/armv8.h
+++ b/src/target/armv8.h
@@ -8,7 +8,9 @@
 #include "arm.h"
 #include "armv4_5_mmu.h"
 #include "armv4_5_cache.h"
+#include "cortex_a.h"
 #include "arm_dpm.h"
+#include "armv8_dpm.h"
 
 #define EDESR		0x020
 #define EDECR		0x024
@@ -64,15 +66,15 @@ enum aarch64_mode {
 	AARCH64_MODE_ANY = -1
 };
 
-int armv8_get_gdb_reg_list(struct target *target,
-		struct reg **reg_list[], int *reg_list_size,
-		enum target_register_class reg_class);
-int armv8_dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode);
-int armv8_dpm_read_current_registers(struct arm_dpm *dpm);
-int armv8_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp);
-void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr);
-void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr);
-int armv8_dpm_setup(struct arm_dpm *dpm);
-int armv8_dpm_initialize(struct arm_dpm *dpm);
+struct armv8_common {
+	struct cortex_a_common cortex_a_common;
+	struct armv8_dpm armv8_dpm;
+};
+
+static inline struct armv8_common *
+cortex_a_to_armv8(struct cortex_a_common *cortex_a)
+{
+	return container_of(cortex_a, struct armv8_common, cortex_a_common);
+}
 
 #endif /* ARMV8_H */
diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index 6e5dd92..2eaa29b 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -9,6 +9,7 @@
 #include "arm.h"
 #include "armv8.h"
 #include "arm_dpm.h"
+#include "armv8_dpm.h"
 #include <jtag/jtag.h>
 #include "register.h"
 #include "breakpoints.h"
@@ -118,19 +119,19 @@ int armv8_dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode)
 }
 
 /* just read the register -- rely on the core mode being right */
-static int dpm_read_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
+static int aarch64_dpm_read_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
 {
-	uint32_t value;
+	uint64_t value;
 	int retval;
 
 	switch (regnum) {
-		case 0 ... 14:
+		case 0 ... 31:
 			/* return via DCC:  "MCR p14, 0, Rnum, c0, c5, 0" */
 			retval = dpm->instr_read_data_dcc(dpm,
 				ARMV4_5_MCR(14, 0, regnum, 0, 5, 0),
 				&value);
 			break;
-		case 15:/* PC
+		case 32:/* PC
 			 * "MOV r0, pc"; then return via DCC */
 			retval = dpm->instr_read_data_r0(dpm, 0xe1a0000f, &value);
 
@@ -154,57 +155,50 @@ static int dpm_read_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
 					break;
 			}
 			break;
+		case 33: //cpsr
+			break;
 		default:
-			/* 16: "MRS r0, CPSR"; then return via DCC
-			 * 17: "MRS r0, SPSR"; then return via DCC
-			 */
-			retval = dpm->instr_read_data_r0(dpm,
-				ARMV4_5_MRS(0, regnum & 1),
-				&value);
+			/* something wrong */
 			break;
 	}
 
 	if (retval == ERROR_OK) {
-		buf_set_u32(r->value, 0, 32, value);
+		if(regnum!=33)
+			buf_set_u64(r->value, 0, 64, value);
+		else buf_set_u32(r->value, 0, 32, value);
 		r->valid = true;
 		r->dirty = false;
-		LOG_DEBUG("READ: %s, %8.8x", r->name, (unsigned) value);
+		LOG_DEBUG("READ: %s, 0x%" PRIx64, r->name, value);
 	}
 
 	return retval;
 }
 
 /* just write the register -- rely on the core mode being right */
-static int dpm_write_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
+static int aarch64_dpm_write_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
 {
 	int retval;
-	uint32_t value = buf_get_u32(r->value, 0, 32);
+	uint64_t value = buf_get_u64(r->value, 0, 64);
 
 	switch (regnum) {
-		case 0 ... 14:
+		case 0 ... 31:
 			/* load register from DCC:  "MRC p14, 0, Rnum, c0, c5, 0" */
 			retval = dpm->instr_write_data_dcc(dpm,
 				ARMV4_5_MRC(14, 0, regnum, 0, 5, 0),
 				value);
 			break;
-		case 15:/* PC
+		case 32:/* PC
 			 * read r0 from DCC; then "MOV pc, r0" */
 			retval = dpm->instr_write_data_r0(dpm, 0xe1a0f000, value);
 			break;
-		default:
-			/* 16: read r0 from DCC, then "MSR r0, CPSR_cxsf"
-			 * 17: read r0 from DCC, then "MSR r0, SPSR_cxsf"
-			 */
-			retval = dpm->instr_write_data_r0(dpm,
-				ARMV4_5_MSR_GP(0, 0xf, regnum & 1),
-				value);
-			if (retval != ERROR_OK)
-				return retval;
-
+		case 33: //cpsr
 			if (regnum == 16 && dpm->instr_cpsr_sync)
 				retval = dpm->instr_cpsr_sync(dpm);
 
 			break;
+		default:
+			/* something wrong */
+			break;
 	}
 
 	if (retval == ERROR_OK) {
@@ -236,7 +230,7 @@ int armv8_dpm_read_current_registers(struct arm_dpm *dpm)
 	/* read R0 first (it's used for scratch), then CPSR */
 	r = arm->core_cache->reg_list + 0;
 	if (!r->valid) {
-		retval = dpm_read_reg(dpm, r, 0);
+		retval = aarch64_dpm_read_reg(dpm, r, 0);
 		if (retval != ERROR_OK)
 			goto fail;
 	}
@@ -255,7 +249,7 @@ int armv8_dpm_read_current_registers(struct arm_dpm *dpm)
 		if (r->valid)
 			continue;
 
-		retval = dpm_read_reg(dpm, r, i);
+		retval = aarch64_dpm_read_reg(dpm, r, i);
 		if (retval != ERROR_OK)
 			goto fail;
 	}
@@ -434,7 +428,7 @@ int armv8_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 			if (r->mode != mode)
 				continue;
 
-			retval = dpm_write_reg(dpm,
+			retval = aarch64_dpm_write_reg(dpm,
 					&cache->reg_list[i],
 					regnum);
 			if (retval != ERROR_OK)
@@ -452,13 +446,13 @@ int armv8_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 		goto done;
 	arm->cpsr->dirty = false;
 
-	retval = dpm_write_reg(dpm, arm->pc, 15);
+	retval = aarch64_dpm_write_reg(dpm, arm->pc, 15);
 	if (retval != ERROR_OK)
 		goto done;
 	arm->pc->dirty = false;
 
 	/* flush R0 -- it's *very* dirty by now */
-	retval = dpm_write_reg(dpm, &cache->reg_list[0], 0);
+	retval = aarch64_dpm_write_reg(dpm, &cache->reg_list[0], 0);
 	if (retval != ERROR_OK)
 		goto done;
 	cache->reg_list[0].dirty = false;
@@ -513,7 +507,7 @@ static enum arm_mode dpm_mapmode(struct arm *arm,
  * of registers.
  */
 
-static int arm_dpm_read_core_reg(struct target *target, struct reg *r,
+static int armv8_dpm_read_core_reg(struct target *target, struct reg *r,
 	int regnum, enum arm_mode mode)
 {
 	struct arm_dpm *dpm = target_to_arm(target)->dpm;
@@ -542,7 +536,7 @@ static int arm_dpm_read_core_reg(struct target *target, struct reg *r,
 			goto fail;
 	}
 
-	retval = dpm_read_reg(dpm, r, regnum);
+	retval = aarch64_dpm_read_reg(dpm, r, regnum);
 	if (retval != ERROR_OK)
 		goto fail;
 	/* always clean up, regardless of error */
@@ -555,8 +549,8 @@ fail:
 	return retval;
 }
 
-static int arm_dpm_write_core_reg(struct target *target, struct reg *r,
-	int regnum, enum arm_mode mode, uint32_t value)
+static int armv8_dpm_write_core_reg(struct target *target, struct reg *r,
+	int regnum, enum arm_mode mode, uint64_t value)
 {
 	struct arm_dpm *dpm = target_to_arm(target)->dpm;
 	int retval;
@@ -585,7 +579,7 @@ static int arm_dpm_write_core_reg(struct target *target, struct reg *r,
 			goto fail;
 	}
 
-	retval = dpm_write_reg(dpm, r, regnum);
+	retval = aarch64_dpm_write_reg(dpm, r, regnum);
 	/* always clean up, regardless of error */
 
 	if (mode != ARM_MODE_ANY)
@@ -596,7 +590,7 @@ fail:
 	return retval;
 }
 
-static int arm_dpm_full_context(struct target *target)
+static int armv8_dpm_full_context(struct target *target)
 {
 	struct arm *arm = target_to_arm(target);
 	struct arm_dpm *dpm = arm->dpm;
@@ -649,7 +643,7 @@ static int arm_dpm_full_context(struct target *target)
 				continue;
 
 			/* CPSR was read, so "R16" must mean SPSR */
-			retval = dpm_read_reg(dpm,
+			retval = aarch64_dpm_read_reg(dpm,
 					&cache->reg_list[i],
 					(r->num == 16) ? 17 : r->num);
 			if (retval != ERROR_OK)
@@ -921,8 +915,9 @@ void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
  *
  * Oh, and watchpoints.  Yeah.
  */
-int armv8_dpm_setup(struct arm_dpm *dpm)
+int armv8_dpm_setup(struct armv8_dpm * armv8_dpm)
 {
+	struct arm_dpm *dpm=armv8_dpm->arm_dpm;
 	struct arm *arm = dpm->arm;
 	struct target *target = arm->target;
 	struct reg_cache *cache;
@@ -931,9 +926,9 @@ int armv8_dpm_setup(struct arm_dpm *dpm)
 	arm->dpm = dpm;
 
 	/* register access setup */
-	arm->full_context = arm_dpm_full_context;
-	arm->read_core_reg = arm_dpm_read_core_reg;
-	arm->write_core_reg = arm_dpm_write_core_reg;
+	armv8_dpm->full_context = armv8_dpm_full_context;
+	armv8_dpm->read_core_reg = armv8_dpm_read_core_reg;
+	armv8_dpm->write_core_reg = armv8_dpm_write_core_reg;
 
 	cache = armv8_build_reg_cache(target, arm);
 	if (!cache)
@@ -983,8 +978,9 @@ int armv8_dpm_setup(struct arm_dpm *dpm)
  * Reinitializes DPM state at the beginning of a new debug session
  * or after a reset which may have affected the debug module.
  */
-int armv8_dpm_initialize(struct arm_dpm *dpm)
+int armv8_dpm_initialize(struct armv8_dpm * armv8_dpm)
 {
+	struct arm_dpm* dpm=armv8_dpm->arm_dpm;
 	struct arm *arm = dpm->arm;
 	struct target *target = arm->target;
 
diff --git a/src/target/armv8_dpm.h b/src/target/armv8_dpm.h
new file mode 100755
index 0000000..a3083c7
--- /dev/null
+++ b/src/target/armv8_dpm.h
@@ -0,0 +1,189 @@
+/* modified from arm_dpm.h by Strong Qu */
+#ifndef __ARMV8_DPM_H
+#define __ARMV8_DPM_H
+
+/**
+ * @file
+ * This is the interface to the Debug Programmers Model for ARMv6 and
+ * ARMv7 processors.  ARMv6 processors (such as ARM11xx implementations)
+ * introduced a model which became part of the ARMv7-AR architecture
+ * which is most familiar through the Cortex-A series parts.  While
+ * specific details differ (like how to write the instruction register),
+ * the high level models easily support shared code because those
+ * registers are compatible.
+ */
+
+struct aarch64_dpm_bpwp {
+	unsigned number;
+	uint64_t address;
+	uint32_t control;
+	/* true if hardware state needs flushing */
+	bool dirty;
+};
+
+struct aarch64_dpm_bp {
+	struct breakpoint *bp;
+	struct aarch64_dpm_bpwp bpwp;
+};
+
+struct aarch64_dpm_wp {
+	struct watchpoint *wp;
+	struct aarch64_dpm_bpwp bpwp;
+};
+
+/**
+ * This wraps an implementation of DPM primitives.  Each interface
+ * provider supplies a structure like this, which is the glue between
+ * upper level code and the lower level hardware access.
+ *
+ * It is a PRELIMINARY AND INCOMPLETE set of primitives, starting with
+ * support for CPU register access.
+ */
+struct armv8_dpm {
+	struct arm_dpm* arm_dpm; //pointer to legacy dpm
+
+	/** Invoke before a series of instruction operations */
+	int (*prepare)(struct armv8_dpm *);
+
+	/** Invoke after a series of instruction operations */
+	int (*finish)(struct armv8_dpm *);
+
+	/* WRITE TO CPU */
+
+	/** Runs one instruction, writing data to DCC before execution. */
+	int (*instr_write_data64_dcc)(struct armv8_dpm *,
+			uint32_t opcode, uint64_t data);
+
+	/** Runs one instruction, writing data to R0 before execution. */
+	int (*instr_write_data64_r0)(struct armv8_dpm *,
+			uint32_t opcode, uint64_t data);
+
+	/** Optional core-specific operation invoked after CPSR writes. */
+	int (*instr_cpsr_sync)(struct armv8_dpm *dpm);
+
+	/* READ FROM CPU */
+
+	/** Runs one instruction, reading data from dcc after execution. */
+	int (*instr_read_data64_dcc)(struct armv8_dpm *,
+			uint32_t opcode, uint64_t *data);
+
+	/** Runs one instruction, reading data from r0 after execution. */
+	int (*instr_read_data64_r0)(struct armv8_dpm *,
+			uint32_t opcode, uint64_t *data);
+
+	/* BREAKPOINT/WATCHPOINT SUPPORT */
+
+	/**
+	 * Enables one breakpoint or watchpoint by writing to the
+	 * hardware registers.  The specified breakpoint/watchpoint
+	 * must currently be disabled.  Indices 0..15 are used for
+	 * breakpoints; indices 16..31 are for watchpoints.
+	 */
+	int (*aarch64_bpwp_enable)(struct armv8_dpm *, unsigned index_value,
+			uint64_t addr, uint32_t control);
+
+	/**
+	 * Disables one breakpoint or watchpoint by clearing its
+	 * hardware control registers.  Indices are the same ones
+	 * accepted by bpwp_enable().
+	 */
+	int (*aarch64_bpwp_disable)(struct armv8_dpm *, unsigned index_value);
+
+	/* The breakpoint and watchpoint arrays are private to the
+	 * DPM infrastructure.  There are nbp indices in the dbp
+	 * array.  There are nwp indices in the dwp array.
+	 */
+
+	unsigned nbp;
+	unsigned nwp;
+	struct aarch64_dpm_bp *dbp;
+	struct aarch64_dpm_wp *dwp;
+
+	/** Address of the instruction which triggered a watchpoint. */
+	uint64_t wp_pc;
+	int (*full_context)(struct target *target);
+	int (*read_core_reg)(struct target *target, struct reg *r, int regnum, enum arm_mode mode);
+	int (*write_core_reg)(struct target *target, struct reg *r,	int regnum, enum arm_mode mode, uint64_t value);
+};
+
+int armv8_get_gdb_reg_list(struct target *target,
+		struct reg **reg_list[], int *reg_list_size,
+		enum target_register_class reg_class);
+int armv8_dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode);
+int armv8_dpm_read_current_registers(struct arm_dpm *dpm);
+int armv8_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp);
+void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr);
+void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr);
+int armv8_dpm_setup(struct armv8_dpm * armv8_dpm);
+int armv8_dpm_initialize(struct armv8_dpm * armv8_dpm);
+
+#if 0
+int arm_dpm_setup(struct arm_dpm *dpm);
+int arm_dpm_initialize(struct arm_dpm *dpm);
+
+int arm_dpm_read_current_registers(struct arm_dpm *);
+int dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode);
+
+
+int arm_dpm_write_dirty_registers(struct arm_dpm *, bool bpwp);
+
+void arm_dpm_report_wfar(struct arm_dpm *, uint32_t wfar);
+
+/* DSCR bits; see ARMv7a arch spec section C10.3.1.
+ * Not all v7 bits are valid in v6.
+ */
+#define DSCR_CORE_HALTED            (0x1 <<  0)
+#define DSCR_CORE_RESTARTED         (0x1 <<  1)
+#define DSCR_ENTRY_MASK             (0xF <<  2)
+#define DSCR_STICKY_ABORT_PRECISE   (0x1 <<  6)
+#define DSCR_STICKY_ABORT_IMPRECISE (0x1 <<  7)
+#define DSCR_STICKY_UNDEFINED       (0x1 <<  8)
+#define DSCR_DBG_NOPWRDWN           (0x1 <<  9) /* v6 only */
+#define DSCR_DBG_ACK                (0x1 << 10)
+#define DSCR_INT_DIS                (0x1 << 11)
+#define DSCR_CP14_USR_COMMS         (0x1 << 12)
+#define DSCR_ITR_EN                 (0x1 << 13)
+#define DSCR_HALT_DBG_MODE          (0x1 << 14)
+#define DSCR_MON_DBG_MODE           (0x1 << 15)
+#define DSCR_SEC_PRIV_INVASV_DIS    (0x1 << 16)
+#define DSCR_SEC_PRIV_NINVASV_DIS   (0x1 << 17)
+#define DSCR_NON_SECURE             (0x1 << 18)
+#define DSCR_DSCRD_IMPRECISE_ABORT  (0x1 << 19)
+#define DSCR_EXT_DCC_MASK           (0x3 << 20) /* DTR mode */  /* bits 22, 23 are reserved */
+#define DSCR_INSTR_COMP             (0x1 << 24)
+#define DSCR_PIPE_ADVANCE           (0x1 << 25)
+#define DSCR_DTRTX_FULL_LATCHED     (0x1 << 26)
+#define DSCR_DTRRX_FULL_LATCHED     (0x1 << 27) /* bit 28 is reserved */
+#define DSCR_DTR_TX_FULL            (0x1 << 29)
+#define DSCR_DTR_RX_FULL            (0x1 << 30) /* bit 31 is reserved */
+
+#define DSCR_ENTRY(dscr)            (((dscr) >> 2) & 0xf)
+#define DSCR_RUN_MODE(dscr)         ((dscr) & (DSCR_CORE_HALTED | DSCR_CORE_RESTARTED))
+
+
+/* Methods of entry into debug mode */
+#define DSCR_ENTRY_HALT_REQ           (0x0 << 2)
+#define DSCR_ENTRY_BREAKPOINT         (0x1 << 2)
+#define DSCR_ENTRY_IMPRECISE_WATCHPT  (0x2 << 2)
+#define DSCR_ENTRY_BKPT_INSTR         (0x3 << 2)
+#define DSCR_ENTRY_EXT_DBG_REQ        (0x4 << 2)
+#define DSCR_ENTRY_VECT_CATCH         (0x5 << 2)
+#define DSCR_ENTRY_D_SIDE_ABORT       (0x6 << 2)  /* v6 only */
+#define DSCR_ENTRY_I_SIDE_ABORT       (0x7 << 2)  /* v6 only */
+#define DSCR_ENTRY_OS_UNLOCK          (0x8 << 2)
+#define DSCR_ENTRY_PRECISE_WATCHPT    (0xA << 2)
+
+/* DTR modes */
+#define DSCR_EXT_DCC_NON_BLOCKING     (0x0 << 20)
+#define DSCR_EXT_DCC_STALL_MODE       (0x1 << 20)
+#define DSCR_EXT_DCC_FAST_MODE        (0x2 << 20)  /* bits 22, 23 are reserved */
+
+
+/* DRCR (debug run control register) bits */
+#define DRCR_HALT				(1 << 0)
+#define DRCR_RESTART			(1 << 1)
+#define DRCR_CLEAR_EXCEPTIONS	(1 << 2)
+
+void arm_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dcsr);
+#endif
+#endif /* __ARMV8_DPM_H */
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index a590764..197a97a 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -631,29 +631,30 @@ static int cortex_a53_dap_write_memap_register_u32(struct target *target,
  * be the places to enable/disable that mode.
  */
 
-static inline struct cortex_a_common *dpm_to_a8(struct arm_dpm *dpm)
+static inline struct cortex_a_common *dpm_to_a(struct arm_dpm *dpm)
 {
 	return container_of(dpm, struct cortex_a_common, armv7a_common.dpm);
 }
 
-static int cortex_a53_write_dcc(struct cortex_a_common *a8, uint32_t data)
+static int cortex_a53_write_dcc(struct cortex_a_common *a, uint64_t data)
 {
-	LOG_DEBUG("write DCC 0x%08" PRIx32, data);
-	if(isAArch64(a8->cpudbg_dscr))
-	{//assume high 32bit is zero
-		mem_ap_sel_write_u32(a8->armv7a_common.arm.dap,
-			a8->armv7a_common.debug_ap, a8->armv7a_common.debug_base + CPUDBG_DTRTX, 0);
+	LOG_DEBUG("write DCC 0x%" PRIx64, data);
+	if(isAArch64(a->cpudbg_dscr))
+	{
+		mem_ap_sel_write_u32(a->armv7a_common.arm.dap,
+			a->armv7a_common.debug_ap, a->armv7a_common.debug_base + CPUDBG_DTRTX, data>>32);
 	}
-	return mem_ap_sel_write_u32(a8->armv7a_common.arm.dap,
-		a8->armv7a_common.debug_ap, a8->armv7a_common.debug_base + CPUDBG_DTRRX, data);
+	return mem_ap_sel_write_u32(a->armv7a_common.arm.dap,
+		a->armv7a_common.debug_ap, a->armv7a_common.debug_base + CPUDBG_DTRRX, (uint32_t)data);
 }
 
-static int cortex_a53_read_dcc(struct cortex_a_common *a8, uint32_t *data,
+static int cortex_a53_read_dcc(struct cortex_a_common *a, uint64_t *data,
 	uint32_t *dscr_p)
 {
-	struct adiv5_dap *swjdp = a8->armv7a_common.arm.dap;
+	struct adiv5_dap *swjdp = a->armv7a_common.arm.dap;
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
+	uint32_t *pdw=(uint32_t*)data;
 
 	if (dscr_p)
 		dscr = *dscr_p;
@@ -661,8 +662,8 @@ static int cortex_a53_read_dcc(struct cortex_a_common *a8, uint32_t *data,
 	/* Wait for DTRRXfull */
 	long long then = timeval_ms();
 	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, a8->armv7a_common.debug_ap,
-				a8->armv7a_common.debug_base + CPUDBG_DSCR,
+		retval = mem_ap_sel_read_atomic_u32(swjdp, a->armv7a_common.debug_ap,
+				a->armv7a_common.debug_base + CPUDBG_DSCR,
 				&dscr);
 		if (retval != ERROR_OK)
 			return retval;
@@ -672,16 +673,15 @@ static int cortex_a53_read_dcc(struct cortex_a_common *a8, uint32_t *data,
 		}
 	}
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, a8->armv7a_common.debug_ap,
-			a8->armv7a_common.debug_base + CPUDBG_DTRTX, data);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, a->armv7a_common.debug_ap,
+			a->armv7a_common.debug_base + CPUDBG_DTRTX, pdw);
 	if (retval != ERROR_OK)
 		return retval;
 	if(isAArch64(dscr))
 	{
-		mem_ap_sel_read_atomic_u32(swjdp, a8->armv7a_common.debug_ap,
-			a8->armv7a_common.debug_base + CPUDBG_DTRRX, &DR_h); //DTRRX holds high dword for 64bit data
-		LOG_DEBUG("SQU: 64bit read hd=0x%x", DR_h);
-	}
+		mem_ap_sel_read_atomic_u32(swjdp, a->armv7a_common.debug_ap,
+			a->armv7a_common.debug_base + CPUDBG_DTRRX, pdw+1); //DTRRX holds high dword for 64bit data
+	} else *(pdw+1)=0;
 	/* LOG_DEBUG("read DCC 0x%08" PRIx32, *data); */
 
 	if (dscr_p)
@@ -692,16 +692,16 @@ static int cortex_a53_read_dcc(struct cortex_a_common *a8, uint32_t *data,
 
 static int cortex_a53_dpm_prepare(struct arm_dpm *dpm)
 {
-	struct cortex_a_common *a8 = dpm_to_a8(dpm);
-	struct adiv5_dap *swjdp = a8->armv7a_common.arm.dap;
+	struct cortex_a_common *a = dpm_to_a(dpm);
+	struct adiv5_dap *swjdp = a->armv7a_common.arm.dap;
 	uint32_t dscr;
 	int retval;
 
 	/* set up invariant:  INSTR_COMP is set after ever DPM operation */
 	long long then = timeval_ms();
 	for (;; ) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, a8->armv7a_common.debug_ap,
-				a8->armv7a_common.debug_base + CPUDBG_DSCR,
+		retval = mem_ap_sel_read_atomic_u32(swjdp, a->armv7a_common.debug_ap,
+				a->armv7a_common.debug_base + CPUDBG_DSCR,
 				&dscr);
 		if (retval != ERROR_OK)
 			return retval;
@@ -718,7 +718,7 @@ static int cortex_a53_dpm_prepare(struct arm_dpm *dpm)
 		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
 		/* Clear DCCRX */
 		retval = cortex_a53_exec_opcode(
-				a8->armv7a_common.arm.target,
+				a->armv7a_common.arm.target,
 				ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 				&dscr);
 		if (retval != ERROR_OK)
@@ -734,37 +734,43 @@ static int cortex_a53_dpm_finish(struct arm_dpm *dpm)
 	return ERROR_OK;
 }
 
-static int cortex_a53_instr_write_data_dcc(struct arm_dpm *dpm,
-	uint32_t opcode, uint32_t data)
+static int cortex_a53_instr_write_data64_dcc(struct arm_dpm *dpm,
+	uint32_t opcode, uint64_t data)
 {
-	struct cortex_a_common *a8 = dpm_to_a8(dpm);
+	struct cortex_a_common *a = dpm_to_a(dpm);
 	int retval;
 	uint32_t dscr = DSCR_INSTR_COMP;
 
-	retval = cortex_a53_write_dcc(a8, data);
+	retval = cortex_a53_write_dcc(a, data);
 	if (retval != ERROR_OK)
 		return retval;
 
 	return cortex_a53_exec_opcode(
-			a8->armv7a_common.arm.target,
+			a->armv7a_common.arm.target,
 			opcode,
 			&dscr);
 }
 
-static int cortex_a53_instr_write_data_r0(struct arm_dpm *dpm,
+static int cortex_a53_instr_write_data_dcc(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t data)
 {
-	struct cortex_a_common *a8 = dpm_to_a8(dpm);
+	return cortex_a53_instr_write_data_dcc(dpm, opcode, (uint64_t)data);
+}
+
+static int cortex_a53_instr_write_data64_r0(struct arm_dpm *dpm,
+	uint32_t opcode, uint64_t data)
+{
+	struct cortex_a_common *a = dpm_to_a(dpm);
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
-	retval = cortex_a53_write_dcc(a8, data);
+	retval = cortex_a53_write_dcc(a, data);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15 */
 	retval = cortex_a53_exec_opcode(
-			a8->armv7a_common.arm.target,
+			a->armv7a_common.arm.target,
 			ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 			&dscr);
 	if (retval != ERROR_OK)
@@ -772,13 +778,19 @@ static int cortex_a53_instr_write_data_r0(struct arm_dpm *dpm,
 
 	/* then the opcode, taking data from R0 */
 	retval = cortex_a53_exec_opcode(
-			a8->armv7a_common.arm.target,
+			a->armv7a_common.arm.target,
 			opcode,
 			&dscr);
 
 	return retval;
 }
 
+static int cortex_a53_instr_write_data_r0(struct arm_dpm *dpm,
+	uint32_t opcode, uint32_t data)
+{
+	return cortex_a53_instr_write_data64_r0(dpm, opcode, (uint64_t)data);
+}
+
 static int cortex_a53_instr_cpsr_sync(struct arm_dpm *dpm)
 {
 	struct target *target = dpm->arm->target;
@@ -790,35 +802,44 @@ static int cortex_a53_instr_cpsr_sync(struct arm_dpm *dpm)
 			&dscr);
 }
 
-static int cortex_a53_instr_read_data_dcc(struct arm_dpm *dpm,
-	uint32_t opcode, uint32_t *data)
+static int cortex_a53_instr_read_data64_dcc(struct arm_dpm *dpm,
+	uint32_t opcode, uint64_t *data)
 {
-	struct cortex_a_common *a8 = dpm_to_a8(dpm);
+	struct cortex_a_common *a = dpm_to_a(dpm);
 	int retval;
 	uint32_t dscr = DSCR_INSTR_COMP;
 
 	/* the opcode, writing data to DCC */
 	retval = cortex_a53_exec_opcode(
-			a8->armv7a_common.arm.target,
+			a->armv7a_common.arm.target,
 			opcode,
 			&dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
-	return cortex_a53_read_dcc(a8, data, &dscr);
+	return cortex_a53_read_dcc(a, data, &dscr);
 }
 
-static int cortex_a53_instr_read_data_r0(struct arm_dpm *dpm,
+static int cortex_a53_instr_read_data_dcc(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t *data)
 {
-	struct cortex_a_common *a8 = dpm_to_a8(dpm);
+	uint64_t tmp;
+	int result=cortex_a53_instr_read_data64_dcc(dpm, opcode, &tmp);
+	*data=(uint32_t)tmp;
+	return result;
+}
+
+static int cortex_a53_instr_read_data64_r0(struct arm_dpm *dpm,
+	uint32_t opcode, uint64_t *data)
+{
+	struct cortex_a_common *a = dpm_to_a(dpm);
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
-    uint32_t dtrtx;
+    uint64_t tmp;
 
 	/* the opcode, writing data to R0 */
 	retval = cortex_a53_exec_opcode(
-			a8->armv7a_common.arm.target,
+			a->armv7a_common.arm.target,
 			opcode,
 			&dscr);
 	if (retval != ERROR_OK)
@@ -826,40 +847,42 @@ static int cortex_a53_instr_read_data_r0(struct arm_dpm *dpm,
 
 	/* write R0 to DCC */
 	retval = cortex_a53_exec_opcode(
-			a8->armv7a_common.arm.target,
+			a->armv7a_common.arm.target,
 			ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
 			&dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
-    retval = cortex_a53_read_dcc(a8, &dtrtx, &dscr);
+    retval = cortex_a53_read_dcc(a, &tmp, &dscr);
     if(opcode==0xE1A0000F)
 	{//in case of MOV r0, pc
-		if(isAArch64(dscr))
-		{
-			DLR_h=DR_h;
-			LOG_DEBUG("SQU: ARMv8: read 64bits pc= 0x%x%08x", DLR_h, dtrtx);
-		}
-		else
-		{
-			LOG_DEBUG("SQU: ARMv8: read pc= 0x%x", dtrtx);
-		}
+		LOG_DEBUG("SQU: ARMv8: read pc= 0x%" PRIx64, tmp);
 		if(dpm->arm->core_state==ARM_STATE_ARM) //SQU: adjust PC to make OOCD happy
 		{
-			dtrtx += 8;
+			tmp += 8;
 		}
-		else dtrtx += 4;
+		else tmp += 4;
     }
-    *data=dtrtx;
+    *data=tmp;
 	return retval;
 }
 
+static int cortex_a53_instr_read_data_r0(struct arm_dpm *dpm,
+	uint32_t opcode, uint32_t *data)
+{
+	uint64_t tmp;
+	int result;
+	result = cortex_a53_instr_read_data_r0(dpm, opcode, &tmp);
+	*data=(uint32_t)tmp;
+	return result;
+}
+
 static int cortex_a53_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
 	uint32_t addr, uint32_t control)
 {
-	struct cortex_a_common *a8 = dpm_to_a8(dpm);
-	uint32_t vr = a8->armv7a_common.debug_base;
-	uint32_t cr = a8->armv7a_common.debug_base;
+	struct cortex_a_common *a = dpm_to_a(dpm);
+	uint32_t vr = a->armv7a_common.debug_base;
+	uint32_t cr = a->armv7a_common.debug_base;
 	int retval;
 
 	switch (index_t) {
@@ -895,15 +918,15 @@ static int cortex_a53_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
 
 static int cortex_a53_bpwp_disable(struct arm_dpm *dpm, unsigned index_t)
 {
-	struct cortex_a_common *a8 = dpm_to_a8(dpm);
+	struct cortex_a_common *a = dpm_to_a(dpm);
 	uint32_t cr;
 
 	switch (index_t) {
 		case 0 ... 15:
-			cr = a8->armv7a_common.debug_base + CPUDBG_BCR_EL1_BASE;
+			cr = a->armv7a_common.debug_base + CPUDBG_BCR_EL1_BASE;
 			break;
 		case 16 ... 31:
-			cr = a8->armv7a_common.debug_base + CPUDBG_WCR_EL1_BASE;
+			cr = a->armv7a_common.debug_base + CPUDBG_WCR_EL1_BASE;
 			index_t -= 16;
 			break;
 		default:
@@ -917,12 +940,14 @@ static int cortex_a53_bpwp_disable(struct arm_dpm *dpm, unsigned index_t)
 	return cortex_a53_dap_write_memap_register_u32(dpm->arm->target, cr, 0);
 }
 
-static int cortex_a53_dpm_setup(struct cortex_a_common *a8, uint32_t dfr0)
+static int cortex_a53_dpm_setup(struct armv8_common *armv8,uint32_t dfr0)
 {
-	struct arm_dpm *dpm = &a8->armv7a_common.dpm;
+	struct cortex_a_common *a = &armv8->cortex_a_common;
+	struct arm_dpm *dpm = &a->armv7a_common.dpm;
+	struct armv8_dpm *armv8_dpm = &armv8->armv8_dpm;
 	int retval;
 
-	dpm->arm = &a8->armv7a_common.arm;
+	dpm->arm = &a->armv7a_common.arm;
 	dpm->didr = (dfr0>>8&0xF00000)|(dfr0<<8&0xF0000000)|(dfr0<<12&0xF000000);
 
 	dpm->prepare = cortex_a53_dpm_prepare;
@@ -938,7 +963,12 @@ static int cortex_a53_dpm_setup(struct cortex_a_common *a8, uint32_t dfr0)
 	dpm->bpwp_enable = cortex_a53_bpwp_enable;
 	dpm->bpwp_disable = cortex_a53_bpwp_disable;
 
-	retval = armv8_dpm_setup(dpm);
+	armv8_dpm->instr_write_data64_dcc = cortex_a53_instr_write_data64_dcc;
+	armv8_dpm->instr_write_data64_r0 = cortex_a53_instr_write_data64_r0;
+	armv8_dpm->instr_read_data64_dcc = cortex_a53_instr_write_data64_dcc;
+	armv8_dpm->instr_read_data64_r0 = cortex_a53_instr_read_data64_r0;
+
+	retval = armv8_dpm_setup(armv8_dpm);
 	if (retval == ERROR_OK)
 		retval = armv8_dpm_initialize(dpm);
 
@@ -2841,8 +2871,9 @@ static int cortex_a53_handle_target_request(void *priv)
 
 static int cortex_a53_examine_first(struct target *target)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
+	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
+	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a);
+	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	int i;
 	int retval = ERROR_OK;
@@ -2883,7 +2914,6 @@ static int cortex_a53_examine_first(struct target *target)
 		armv7a->memory_ap_available = true;
 	}
 
-
 	if (!target->dbgbase_set) {
 		uint32_t dbgbase;
 		/* Get ROM Table base */
@@ -2953,28 +2983,28 @@ static int cortex_a53_examine_first(struct target *target)
 	LOG_DEBUG("didr = 0x%08" PRIx32, dfr0);
 	armv7a->arm.is_armv8 = true;
 	armv7a->arm.core_type = ARM_MODE_MON;
-	retval = cortex_a53_dpm_setup(cortex_a53, dfr0);
+	retval = cortex_a53_dpm_setup(armv8, dfr0);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* Setup Breakpoint Register Pairs */
-	cortex_a53->brp_num = ((dfr0 >> 12) & 0x0F) + 1;
-	cortex_a53->brp_num_context = ((dfr0 >> 28) & 0x0F) + 1;
-	cortex_a53->brp_num_available = cortex_a53->brp_num;
-	cortex_a53->brp_list = calloc(cortex_a53->brp_num, sizeof(struct cortex_a_brp));
-/*	cortex_a53->brb_enabled = ????; */
-	for (i = 0; i < cortex_a53->brp_num; i++) {
-		cortex_a53->brp_list[i].used = 0;
-		if (i < (cortex_a53->brp_num-cortex_a53->brp_num_context))
-			cortex_a53->brp_list[i].type = BRP_NORMAL;
+	cortex_a->brp_num = ((dfr0 >> 12) & 0x0F) + 1;
+	cortex_a->brp_num_context = ((dfr0 >> 28) & 0x0F) + 1;
+	cortex_a->brp_num_available = cortex_a->brp_num;
+	cortex_a->brp_list = calloc(cortex_a->brp_num, sizeof(struct cortex_a_brp));
+/*	cortex_a->brb_enabled = ????; */
+	for (i = 0; i < cortex_a->brp_num; i++) {
+		cortex_a->brp_list[i].used = 0;
+		if (i < (cortex_a->brp_num-cortex_a->brp_num_context))
+			cortex_a->brp_list[i].type = BRP_NORMAL;
 		else
-			cortex_a53->brp_list[i].type = BRP_CONTEXT;
-		cortex_a53->brp_list[i].value = 0;
-		cortex_a53->brp_list[i].control = 0;
-		cortex_a53->brp_list[i].BRPn = i;
+			cortex_a->brp_list[i].type = BRP_CONTEXT;
+		cortex_a->brp_list[i].value = 0;
+		cortex_a->brp_list[i].control = 0;
+		cortex_a->brp_list[i].BRPn = i;
 	}
 
-	LOG_DEBUG("Configured %i hw breakpoints", cortex_a53->brp_num);
+	LOG_DEBUG("Configured %i hw breakpoints", cortex_a->brp_num);
 
 	target_set_examined(target);
 	return ERROR_OK;
@@ -3047,7 +3077,8 @@ void cortex_a53_connect_dap(struct target *target, struct adiv5_dap *dap)
 
 static int cortex_a53_target_create(struct target *target, Jim_Interp *interp)
 {
-	struct cortex_a_common *cortex_a53 = calloc(1, sizeof(struct cortex_a_common));
+	struct armv8_common* a53_armv8_common = calloc(1, sizeof(struct armv8_common));
+	struct cortex_a_common *cortex_a53 = &a53_armv8_common->cortex_a_common;
 
 	cortex_a53->armv7a_common.is_armv7r = false;
 	cortex_a53_init_arch_info(target, cortex_a53);
-- 
1.9.1


From 63957a28ae680ba68d008fef3f914d6679131853 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 05/94] update dpm code for ARMv8. If running in AArch32, will
 call legacy ARM DPM API. Otherwise, calling AArch64 DPM APIs(not completed
 yet)

---
 src/target/armv8_dpm.c  |  7 +++++--
 src/target/armv8_dpm.h  |  7 ++++---
 src/target/cortex_a53.c | 12 +++++++-----
 3 files changed, 16 insertions(+), 10 deletions(-)

diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index 2eaa29b..f819453 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -216,12 +216,14 @@ static int aarch64_dpm_write_reg(struct arm_dpm *dpm, struct reg *r, unsigned re
  * possibly after some other operations supporting restore of debug state
  * or making sure the CPU is fully idle (drain write buffer, etc).
  */
-int armv8_dpm_read_current_registers(struct arm_dpm *dpm)
+int armv8_dpm_read_current_registers(struct armv8_dpm *armv8_dpm)
 {
+	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
 	struct arm *arm = dpm->arm;
 	uint32_t cpsr;
 	int retval;
 	struct reg *r;
+	if(!arm->target->is_64b) return arm_dpm_read_current_registers(dpm);
 
 	retval = dpm->prepare(dpm);
 	if (retval != ERROR_OK)
@@ -236,7 +238,7 @@ int armv8_dpm_read_current_registers(struct arm_dpm *dpm)
 	}
 	r->dirty = true;
 
-	retval = dpm->instr_read_data_r0(dpm, ARMV4_5_MRS(0, 0), &cpsr);
+	retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV4_5_MRS(0, 0), &cpsr);
 	if (retval != ERROR_OK)
 		goto fail;
 
@@ -263,6 +265,7 @@ int armv8_dpm_read_current_registers(struct arm_dpm *dpm)
 
 fail:
 	/* (void) */ dpm->finish(dpm);
+
 	return retval;
 }
 
diff --git a/src/target/armv8_dpm.h b/src/target/armv8_dpm.h
index a3083c7..79606a6 100755
--- a/src/target/armv8_dpm.h
+++ b/src/target/armv8_dpm.h
@@ -39,14 +39,15 @@ struct aarch64_dpm_wp {
  * It is a PRELIMINARY AND INCOMPLETE set of primitives, starting with
  * support for CPU register access.
  */
+//some method could re-use arm_dpm code, such as prepare and finsh
 struct armv8_dpm {
 	struct arm_dpm* arm_dpm; //pointer to legacy dpm
 
 	/** Invoke before a series of instruction operations */
-	int (*prepare)(struct armv8_dpm *);
+	//int (*prepare)(struct armv8_dpm *);
 
 	/** Invoke after a series of instruction operations */
-	int (*finish)(struct armv8_dpm *);
+	//int (*finish)(struct armv8_dpm *);
 
 	/* WRITE TO CPU */
 
@@ -110,7 +111,7 @@ int armv8_get_gdb_reg_list(struct target *target,
 		struct reg **reg_list[], int *reg_list_size,
 		enum target_register_class reg_class);
 int armv8_dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode);
-int armv8_dpm_read_current_registers(struct arm_dpm *dpm);
+int armv8_dpm_read_current_registers(struct armv8_dpm *dpm);
 int armv8_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp);
 void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr);
 void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr);
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 197a97a..c911367 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -697,7 +697,7 @@ static int cortex_a53_dpm_prepare(struct arm_dpm *dpm)
 	uint32_t dscr;
 	int retval;
 
-	/* set up invariant:  INSTR_COMP is set after ever DPM operation */
+	/* set up invariant:  INSTR_COMP is set after every DPM operation */
 	long long then = timeval_ms();
 	for (;; ) {
 		retval = mem_ap_sel_read_atomic_u32(swjdp, a->armv7a_common.debug_ap,
@@ -754,7 +754,7 @@ static int cortex_a53_instr_write_data64_dcc(struct arm_dpm *dpm,
 static int cortex_a53_instr_write_data_dcc(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t data)
 {
-	return cortex_a53_instr_write_data_dcc(dpm, opcode, (uint64_t)data);
+	return cortex_a53_instr_write_data64_dcc(dpm, opcode, (uint64_t)data);
 }
 
 static int cortex_a53_instr_write_data64_r0(struct arm_dpm *dpm,
@@ -872,7 +872,7 @@ static int cortex_a53_instr_read_data_r0(struct arm_dpm *dpm,
 {
 	uint64_t tmp;
 	int result;
-	result = cortex_a53_instr_read_data_r0(dpm, opcode, &tmp);
+	result = cortex_a53_instr_read_data64_r0(dpm, opcode, &tmp);
 	*data=(uint32_t)tmp;
 	return result;
 }
@@ -963,6 +963,7 @@ static int cortex_a53_dpm_setup(struct armv8_common *armv8,uint32_t dfr0)
 	dpm->bpwp_enable = cortex_a53_bpwp_enable;
 	dpm->bpwp_disable = cortex_a53_bpwp_disable;
 
+	armv8_dpm->arm_dpm = dpm;
 	armv8_dpm->instr_write_data64_dcc = cortex_a53_instr_write_data64_dcc;
 	armv8_dpm->instr_write_data64_r0 = cortex_a53_instr_write_data64_r0;
 	armv8_dpm->instr_read_data64_dcc = cortex_a53_instr_write_data64_dcc;
@@ -970,7 +971,7 @@ static int cortex_a53_dpm_setup(struct armv8_common *armv8,uint32_t dfr0)
 
 	retval = armv8_dpm_setup(armv8_dpm);
 	if (retval == ERROR_OK)
-		retval = armv8_dpm_initialize(dpm);
+		retval = armv8_dpm_initialize(armv8_dpm);
 
 	return retval;
 }
@@ -1457,6 +1458,7 @@ static int cortex_a53_debug_entry(struct target *target)
 	int retval = ERROR_OK;
 	struct working_area *regfile_working_area = NULL;
 	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+   	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *arm = &armv7a->arm;
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
@@ -1546,7 +1548,7 @@ static int cortex_a53_debug_entry(struct target *target)
 
 	/* First load register acessible through core debug port*/
 	if (!regfile_working_area)
-		retval = armv8_dpm_read_current_registers(&armv7a->dpm);
+		retval = armv8_dpm_read_current_registers(&armv8->armv8_dpm); //&armv7a->dpm);
 	else {
 		retval = cortex_a53_read_regs_through_mem(target,
 				regfile_working_area->address, regfile);
-- 
1.9.1


From 20bfba0927175de0c36bf6307cf278e920898ab6 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 06/94] test

---
 src/openocd.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/openocd.c b/src/openocd.c
index 758febb..de30e0c 100644
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -23,7 +23,7 @@
  *   Free Software Foundation, Inc.,                                       *
  *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
  ***************************************************************************/
-
+ 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
-- 
1.9.1


From cb36fa97f25e627b941422331b014c15498f24de Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 07/94] commit changes before re-struct armv8 structure

---
 src/target/armv8.c      |  2 +-
 src/target/armv8_dpm.c  | 86 +++++++++++++++++++++++++------------------------
 src/target/armv8_dpm.h  | 12 +++----
 src/target/cortex_a53.c |  6 ++--
 4 files changed, 53 insertions(+), 53 deletions(-)

diff --git a/src/target/armv8.c b/src/target/armv8.c
index 1d8e0ad..cfe1aa4 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -849,7 +849,7 @@ int armv8_get_gdb_reg_list(struct target *target,
 	unsigned int i;
 
 	if(!target->is_64b) return arm_get_gdb_reg_list(target, reg_list, reg_list_size, reg_class);
-	if (!is_arm_mode(arm->core_mode)) {
+	if (!is_aarch64_mode(arm->core_mode)) {
 		LOG_ERROR("not a valid arm core mode - communication failure?");
 		return ERROR_FAIL;
 	}
diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index f819453..8f1555d 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -119,28 +119,21 @@ int armv8_dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode)
 }
 
 /* just read the register -- rely on the core mode being right */
-static int aarch64_dpm_read_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
+static int aarch64_dpm_read_reg(struct armv8_dpm *armv8_dpm, struct reg *r, unsigned regnum)
 {
 	uint64_t value;
 	int retval;
+	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
 
 	switch (regnum) {
 		case 0 ... 31:
-			/* return via DCC:  "MCR p14, 0, Rnum, c0, c5, 0" */
-			retval = dpm->instr_read_data_dcc(dpm,
-				ARMV4_5_MCR(14, 0, regnum, 0, 5, 0),
-				&value);
+			/* return via DCC:  "MSR DBGDTRTX_EL0, Xn" */
+			retval = armv8_dpm->instr_read_data64_dcc(dpm, ARMV8_A64_MSR(2, 3, 0, 5, 0, regnum), &value);
 			break;
 		case 32:/* PC
-			 * "MOV r0, pc"; then return via DCC */
-			retval = dpm->instr_read_data_r0(dpm, 0xe1a0000f, &value);
-
-			/* NOTE: this seems like a slightly awkward place to update
-			 * this value ... but if the PC gets written (the only way
-			 * to change what we compute), the arch spec says subsequent
-			 * reads return values which are "unpredictable".  So this
-			 * is always right except in those broken-by-intent cases.
-			 */
+			 * "MSR X0, DLR_EL0"; then return via DCC */
+			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 5, 1, 0), &value);
+
 			switch (dpm->arm->core_state) {
 				case ARM_STATE_ARM:
 					value -= 8;
@@ -175,8 +168,9 @@ static int aarch64_dpm_read_reg(struct arm_dpm *dpm, struct reg *r, unsigned reg
 }
 
 /* just write the register -- rely on the core mode being right */
-static int aarch64_dpm_write_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
+static int aarch64_dpm_write_reg(struct armv8_dpm *armv8_dpm, struct reg *r, unsigned regnum)
 {
+	struct arm_dpm *dpm=armv8_dpm->arm_dpm;
 	int retval;
 	uint64_t value = buf_get_u64(r->value, 0, 64);
 
@@ -232,37 +226,42 @@ int armv8_dpm_read_current_registers(struct armv8_dpm *armv8_dpm)
 	/* read R0 first (it's used for scratch), then CPSR */
 	r = arm->core_cache->reg_list + 0;
 	if (!r->valid) {
-		retval = aarch64_dpm_read_reg(dpm, r, 0);
+		retval = aarch64_dpm_read_reg(armv8_dpm, r, 0);
 		if (retval != ERROR_OK)
 			goto fail;
 	}
 	r->dirty = true;
 
-	retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV4_5_MRS(0, 0), &cpsr);
+	retval = dpm->instr_read_data_r0(dpm, ARMV8_A64_MRS(3,3,4,5,0,0), &cpsr); //cpsr is 32bit
 	if (retval != ERROR_OK)
 		goto fail;
 
-	/* update core mode and state, plus shadow mapping for R8..R14 */
-	arm_set_cpsr(arm, cpsr);
+	/* NOTE:  this may be called very early, before the register
+	 * cache is set up.  We can't defend against many errors, in
+	 * particular against CPSRs that aren't valid *here* ...
+	 */
+	if (arm->cpsr) {
+		buf_set_u32(arm->cpsr->value, 0, 32, cpsr);
+		arm->cpsr->valid = 1;
+		arm->cpsr->dirty = 0;
+	}
+
+	arm->core_mode = cpsr & 0x1f;
+
+	arm->spsr =  arm->core_cache->reg_list + 34;
+	arm->core_state = ARM_STATE_ARM;
 
 	/* REVISIT we can probably avoid reading R1..R14, saving time... */
-	for (unsigned i = 1; i < 16; i++) {
-		r = arm_reg_current(arm, i);
+	for (unsigned i = 1; i < 33; i++) {
+		r = arm->core_cache->reg_list + i;
 		if (r->valid)
 			continue;
 
-		retval = aarch64_dpm_read_reg(dpm, r, i);
+		retval = aarch64_dpm_read_reg(armv8_dpm, r, i);
 		if (retval != ERROR_OK)
 			goto fail;
 	}
 
-	/* NOTE: SPSR ignored (if it's even relevant). */
-
-	/* REVISIT the debugger can trigger various exceptions.  See the
-	 * ARMv7A architecture spec, section C5.7, for more info about
-	 * what defenses are needed; v6 debug has the most issues.
-	 */
-
 fail:
 	/* (void) */ dpm->finish(dpm);
 
@@ -513,17 +512,15 @@ static enum arm_mode dpm_mapmode(struct arm *arm,
 static int armv8_dpm_read_core_reg(struct target *target, struct reg *r,
 	int regnum, enum arm_mode mode)
 {
-	struct arm_dpm *dpm = target_to_arm(target)->dpm;
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
+	struct armv8_dpm *armv8_dpm = &armv8->armv8_dpm;
+	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
 	int retval;
-
-	if (regnum < 0 || regnum > 16)
+	if (regnum < 0 || regnum > 32)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	if (regnum == 16) {
-		if (mode != ARM_MODE_ANY)
-			regnum = 17;
-	} else
-		mode = dpm_mapmode(dpm->arm, regnum, mode);
+	mode = dpm_mapmode(dpm->arm, regnum, mode);
 
 	/* REVISIT what happens if we try to read SPSR in a core mode
 	 * which has no such register?
@@ -539,7 +536,7 @@ static int armv8_dpm_read_core_reg(struct target *target, struct reg *r,
 			goto fail;
 	}
 
-	retval = aarch64_dpm_read_reg(dpm, r, regnum);
+	retval = aarch64_dpm_read_reg(armv8_dpm, r, regnum);
 	if (retval != ERROR_OK)
 		goto fail;
 	/* always clean up, regardless of error */
@@ -555,10 +552,12 @@ fail:
 static int armv8_dpm_write_core_reg(struct target *target, struct reg *r,
 	int regnum, enum arm_mode mode, uint64_t value)
 {
-	struct arm_dpm *dpm = target_to_arm(target)->dpm;
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
+	struct armv8_dpm *armv8_dpm = &armv8->armv8_dpm;
+	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
 	int retval;
 
-
 	if (regnum < 0 || regnum > 16)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
@@ -582,7 +581,7 @@ static int armv8_dpm_write_core_reg(struct target *target, struct reg *r,
 			goto fail;
 	}
 
-	retval = aarch64_dpm_write_reg(dpm, r, regnum);
+	retval = aarch64_dpm_write_reg(armv8_dpm, r, regnum);
 	/* always clean up, regardless of error */
 
 	if (mode != ARM_MODE_ANY)
@@ -595,6 +594,9 @@ fail:
 
 static int armv8_dpm_full_context(struct target *target)
 {
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
+	struct armv8_dpm *armv8_dpm = &armv8->armv8_dpm;
 	struct arm *arm = target_to_arm(target);
 	struct arm_dpm *dpm = arm->dpm;
 	struct reg_cache *cache = arm->core_cache;
@@ -646,7 +648,7 @@ static int armv8_dpm_full_context(struct target *target)
 				continue;
 
 			/* CPSR was read, so "R16" must mean SPSR */
-			retval = aarch64_dpm_read_reg(dpm,
+			retval = aarch64_dpm_read_reg(armv8_dpm,
 					&cache->reg_list[i],
 					(r->num == 16) ? 17 : r->num);
 			if (retval != ERROR_OK)
diff --git a/src/target/armv8_dpm.h b/src/target/armv8_dpm.h
index 79606a6..f8cc36c 100755
--- a/src/target/armv8_dpm.h
+++ b/src/target/armv8_dpm.h
@@ -52,24 +52,24 @@ struct armv8_dpm {
 	/* WRITE TO CPU */
 
 	/** Runs one instruction, writing data to DCC before execution. */
-	int (*instr_write_data64_dcc)(struct armv8_dpm *,
+	int (*instr_write_data64_dcc)(struct arm_dpm *,
 			uint32_t opcode, uint64_t data);
 
 	/** Runs one instruction, writing data to R0 before execution. */
-	int (*instr_write_data64_r0)(struct armv8_dpm *,
+	int (*instr_write_data64_r0)(struct arm_dpm *,
 			uint32_t opcode, uint64_t data);
 
 	/** Optional core-specific operation invoked after CPSR writes. */
-	int (*instr_cpsr_sync)(struct armv8_dpm *dpm);
+	int (*instr_cpsr_sync)(struct arm_dpm *dpm);
 
 	/* READ FROM CPU */
 
 	/** Runs one instruction, reading data from dcc after execution. */
-	int (*instr_read_data64_dcc)(struct armv8_dpm *,
+	int (*instr_read_data64_dcc)(struct arm_dpm *,
 			uint32_t opcode, uint64_t *data);
 
 	/** Runs one instruction, reading data from r0 after execution. */
-	int (*instr_read_data64_r0)(struct armv8_dpm *,
+	int (*instr_read_data64_r0)(struct arm_dpm *,
 			uint32_t opcode, uint64_t *data);
 
 	/* BREAKPOINT/WATCHPOINT SUPPORT */
@@ -103,7 +103,7 @@ struct armv8_dpm {
 	/** Address of the instruction which triggered a watchpoint. */
 	uint64_t wp_pc;
 	int (*full_context)(struct target *target);
-	int (*read_core_reg)(struct target *target, struct reg *r, int regnum, enum arm_mode mode);
+	uint64_t (*read_core_reg)(struct target *target, struct reg *r, int regnum, enum arm_mode mode);
 	int (*write_core_reg)(struct target *target, struct reg *r,	int regnum, enum arm_mode mode, uint64_t value);
 };
 
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index c911367..08f0af0 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -966,7 +966,7 @@ static int cortex_a53_dpm_setup(struct armv8_common *armv8,uint32_t dfr0)
 	armv8_dpm->arm_dpm = dpm;
 	armv8_dpm->instr_write_data64_dcc = cortex_a53_instr_write_data64_dcc;
 	armv8_dpm->instr_write_data64_r0 = cortex_a53_instr_write_data64_r0;
-	armv8_dpm->instr_read_data64_dcc = cortex_a53_instr_write_data64_dcc;
+	armv8_dpm->instr_read_data64_dcc = cortex_a53_instr_read_data64_dcc;
 	armv8_dpm->instr_read_data64_r0 = cortex_a53_instr_read_data64_r0;
 
 	retval = armv8_dpm_setup(armv8_dpm);
@@ -1143,7 +1143,7 @@ static int cortex_a53_halt(struct target *target)
 	if(isAArch64(dummy)) target->is_64b=true;
 	else target->is_64b=false;
 	/*remote below hack. Changing state should be a request from gdb client, but not forced here
-	if(isAArch64(dummy))
+	if(target->is_64b)
 	{
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 1, 1, 0, 0), &dummy); //read SCR_EL3 to X0
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
@@ -1189,8 +1189,6 @@ static int cortex_a53_halt(struct target *target)
 		}
 		retval = cortex_a53_halt(target); //recursively request halt
 	}*/
-	if(isAArch64(dummy)) target->is_64b=false; //true;
-	else target->is_64b=false;
 	target->debug_reason = DBG_REASON_DBGRQ;
 
 	return retval;
-- 
1.9.1


From 0476e67047475493a902cad0285e83d1dc98da1f Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 08/94] Add new armv8 as member of armv8_common for supporting
 core register cache

---
 src/target/armv8.c      | 10 +++---
 src/target/armv8.h      | 11 ++++++-
 src/target/armv8_dpm.c  | 84 +++++++------------------------------------------
 src/target/armv8_dpm.h  |  3 +-
 src/target/cortex_a53.c |  7 +++--
 5 files changed, 34 insertions(+), 81 deletions(-)

diff --git a/src/target/armv8.c b/src/target/armv8.c
index cfe1aa4..717f352 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -317,7 +317,7 @@ static const struct reg_arch_type armv8_reg_type = {
 	.set = armv8_set_core_reg,
 };
 
-struct reg_cache *armv8_build_reg_cache(struct target *target, struct arm *arm)
+struct reg_cache *armv8_build_reg_cache(struct target *target, struct armv8 *armv8)
 {
 	int num_regs = ARRAY_SIZE(arm_core_regs);
 	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
@@ -341,7 +341,7 @@ struct reg_cache *armv8_build_reg_cache(struct target *target, struct arm *arm)
 		reg_arch_info[i].num = arm_core_regs[i].cookie;
 		reg_arch_info[i].mode = arm_core_regs[i].mode;
 		reg_arch_info[i].target = target;
-		reg_arch_info[i].arm = arm;
+		reg_arch_info[i].arm = armv8->arm;
 
 		reg_list[i].name = (char *) arm_core_regs[i].name;
 		reg_list[i].number = arm_core_regs[i].gdb_index;
@@ -379,9 +379,9 @@ struct reg_cache *armv8_build_reg_cache(struct target *target, struct arm *arm)
 		cache->num_regs++;
 	}
 
-	arm->pc = reg_list + 32;
-	arm->cpsr = reg_list + 33;
-	arm->core_cache = cache;
+	armv8->pc = reg_list + 32;
+	armv8->cpsr = reg_list + 33;
+	armv8->core_cache = cache;
 	return cache;
 }
 
diff --git a/src/target/armv8.h b/src/target/armv8.h
index 398f2e9..9c4725d 100755
--- a/src/target/armv8.h
+++ b/src/target/armv8.h
@@ -66,9 +66,18 @@ enum aarch64_mode {
 	AARCH64_MODE_ANY = -1
 };
 
+struct armv8	//struct for armv8 core
+{
+	struct arm* arm; //pointer to legacy arm struct
+	struct armv8_dpm armv8_dpm;
+	struct reg_cache *core_cache;
+	struct reg *pc;
+	struct reg *cpsr;
+};
+
 struct armv8_common {
 	struct cortex_a_common cortex_a_common;
-	struct armv8_dpm armv8_dpm;
+	struct armv8 armv8;
 };
 
 static inline struct armv8_common *
diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index 8f1555d..5de4b2b 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -32,63 +32,6 @@
 /*----------------------------------------------------------------------*/
 
 /*
- * Coprocessor support
- */
-
-/* Read coprocessor */
-static int dpm_mrc(struct target *target, int cpnum,
-	uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm,
-	uint32_t *value)
-{
-	struct arm *arm = target_to_arm(target);
-	struct arm_dpm *dpm = arm->dpm;
-	int retval;
-
-	retval = dpm->prepare(dpm);
-	if (retval != ERROR_OK)
-		return retval;
-
-	LOG_DEBUG("MRC p%d, %d, r0, c%d, c%d, %d", cpnum,
-		(int) op1, (int) CRn,
-		(int) CRm, (int) op2);
-
-	/* read coprocessor register into R0; return via DCC */
-	retval = dpm->instr_read_data_r0(dpm,
-			ARMV4_5_MRC(cpnum, op1, 0, CRn, CRm, op2),
-			value);
-
-	/* (void) */ dpm->finish(dpm);
-	return retval;
-}
-
-static int dpm_mcr(struct target *target, int cpnum,
-	uint32_t op1, uint32_t op2, uint32_t CRn, uint32_t CRm,
-	uint32_t value)
-{
-	struct arm *arm = target_to_arm(target);
-	struct arm_dpm *dpm = arm->dpm;
-	int retval;
-
-	retval = dpm->prepare(dpm);
-	if (retval != ERROR_OK)
-		return retval;
-
-	LOG_DEBUG("MCR p%d, %d, r0, c%d, c%d, %d", cpnum,
-		(int) op1, (int) CRn,
-		(int) CRm, (int) op2);
-
-	/* read DCC into r0; then write coprocessor register from R0 */
-	retval = dpm->instr_write_data_r0(dpm,
-			ARMV4_5_MCR(cpnum, op1, 0, CRn, CRm, op2),
-			value);
-
-	/* (void) */ dpm->finish(dpm);
-	return retval;
-}
-
-/*----------------------------------------------------------------------*/
-
-/*
  * Register access utilities
  */
 
@@ -324,8 +267,9 @@ static int dpm_add_breakpoint(struct target *target, struct breakpoint *bp);
  * @param bpwp: true ensures breakpoints and watchpoints are set,
  *	false ensures they are cleared
  */
-int armv8_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
+int armv8_dpm_write_dirty_registers(struct armv8_dpm *armv8_dpm, bool bpwp)
 {
+	struct arm_dpm *dpm=armv8_dpm->arm_dpm;
 	struct arm *arm = dpm->arm;
 	struct reg_cache *cache = arm->core_cache;
 	int retval;
@@ -430,7 +374,7 @@ int armv8_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 			if (r->mode != mode)
 				continue;
 
-			retval = aarch64_dpm_write_reg(dpm,
+			retval = aarch64_dpm_write_reg(armv8_dpm,
 					&cache->reg_list[i],
 					regnum);
 			if (retval != ERROR_OK)
@@ -448,13 +392,13 @@ int armv8_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 		goto done;
 	arm->cpsr->dirty = false;
 
-	retval = aarch64_dpm_write_reg(dpm, arm->pc, 15);
+	retval = aarch64_dpm_write_reg(armv8_dpm, arm->pc, 15);
 	if (retval != ERROR_OK)
 		goto done;
 	arm->pc->dirty = false;
 
 	/* flush R0 -- it's *very* dirty by now */
-	retval = aarch64_dpm_write_reg(dpm, &cache->reg_list[0], 0);
+	retval = aarch64_dpm_write_reg(armv8_dpm, &cache->reg_list[0], 0);
 	if (retval != ERROR_OK)
 		goto done;
 	cache->reg_list[0].dirty = false;
@@ -514,7 +458,7 @@ static int armv8_dpm_read_core_reg(struct target *target, struct reg *r,
 {
 	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
 	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
-	struct armv8_dpm *armv8_dpm = &armv8->armv8_dpm;
+	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
 	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
 	int retval;
 	if (regnum < 0 || regnum > 32)
@@ -554,7 +498,7 @@ static int armv8_dpm_write_core_reg(struct target *target, struct reg *r,
 {
 	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
 	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
-	struct armv8_dpm *armv8_dpm = &armv8->armv8_dpm;
+	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
 	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
 	int retval;
 
@@ -596,7 +540,7 @@ static int armv8_dpm_full_context(struct target *target)
 {
 	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
 	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
-	struct armv8_dpm *armv8_dpm = &armv8->armv8_dpm;
+	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
 	struct arm *arm = target_to_arm(target);
 	struct arm_dpm *dpm = arm->dpm;
 	struct reg_cache *cache = arm->core_cache;
@@ -927,23 +871,19 @@ int armv8_dpm_setup(struct armv8_dpm * armv8_dpm)
 	struct target *target = arm->target;
 	struct reg_cache *cache;
 
-	if(!target->is_64b) return arm_dpm_setup(dpm);
-	arm->dpm = dpm;
+	arm_dpm_setup(dpm);
 
 	/* register access setup */
 	armv8_dpm->full_context = armv8_dpm_full_context;
 	armv8_dpm->read_core_reg = armv8_dpm_read_core_reg;
 	armv8_dpm->write_core_reg = armv8_dpm_write_core_reg;
 
-	cache = armv8_build_reg_cache(target, arm);
+	cache = armv8_build_reg_cache(target, armv8_dpm->armv8);
 	if (!cache)
 		return ERROR_FAIL;
 
 	*register_get_last_cache_p(&target->reg_cache) = cache;
 
-	/* coprocessor access setup */
-	arm->mrc = dpm_mrc;
-	arm->mcr = dpm_mcr;
 
 	/* breakpoint setup -- optional until it works everywhere */
 	if (!target->type->add_breakpoint) {
@@ -957,7 +897,7 @@ int armv8_dpm_setup(struct armv8_dpm * armv8_dpm)
 
 	/* FIXME add vector catch support */
 
-	dpm->nbp = 1 + ((dpm->didr >> 24) & 0xf);
+	/*dpm->nbp = 1 + ((dpm->didr >> 24) & 0xf);
 	dpm->dbp = calloc(dpm->nbp, sizeof *dpm->dbp);
 
 	dpm->nwp = 1 + ((dpm->didr >> 28) & 0xf);
@@ -970,7 +910,7 @@ int armv8_dpm_setup(struct armv8_dpm * armv8_dpm)
 	}
 
 	LOG_INFO("%s: hardware has %d breakpoints, %d watchpoints",
-		target_name(target), dpm->nbp, dpm->nwp);
+		target_name(target), dpm->nbp, dpm->nwp);*/
 
 	/* REVISIT ... and some of those breakpoints could match
 	 * execution context IDs...
diff --git a/src/target/armv8_dpm.h b/src/target/armv8_dpm.h
index f8cc36c..1d4a826 100755
--- a/src/target/armv8_dpm.h
+++ b/src/target/armv8_dpm.h
@@ -42,6 +42,7 @@ struct aarch64_dpm_wp {
 //some method could re-use arm_dpm code, such as prepare and finsh
 struct armv8_dpm {
 	struct arm_dpm* arm_dpm; //pointer to legacy dpm
+	struct armv8* armv8; //pointer to armv8 core struct
 
 	/** Invoke before a series of instruction operations */
 	//int (*prepare)(struct armv8_dpm *);
@@ -112,7 +113,7 @@ int armv8_get_gdb_reg_list(struct target *target,
 		enum target_register_class reg_class);
 int armv8_dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode);
 int armv8_dpm_read_current_registers(struct armv8_dpm *dpm);
-int armv8_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp);
+int armv8_dpm_write_dirty_registers(struct armv8_dpm *dpm, bool bpwp);
 void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr);
 void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr);
 int armv8_dpm_setup(struct armv8_dpm * armv8_dpm);
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 08f0af0..6744cc8 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -944,7 +944,7 @@ static int cortex_a53_dpm_setup(struct armv8_common *armv8,uint32_t dfr0)
 {
 	struct cortex_a_common *a = &armv8->cortex_a_common;
 	struct arm_dpm *dpm = &a->armv7a_common.dpm;
-	struct armv8_dpm *armv8_dpm = &armv8->armv8_dpm;
+	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
 	int retval;
 
 	dpm->arm = &a->armv7a_common.arm;
@@ -964,6 +964,7 @@ static int cortex_a53_dpm_setup(struct armv8_common *armv8,uint32_t dfr0)
 	dpm->bpwp_disable = cortex_a53_bpwp_disable;
 
 	armv8_dpm->arm_dpm = dpm;
+	armv8_dpm->armv8 = &armv8->armv8;
 	armv8_dpm->instr_write_data64_dcc = cortex_a53_instr_write_data64_dcc;
 	armv8_dpm->instr_write_data64_r0 = cortex_a53_instr_write_data64_r0;
 	armv8_dpm->instr_read_data64_dcc = cortex_a53_instr_read_data64_dcc;
@@ -975,6 +976,7 @@ static int cortex_a53_dpm_setup(struct armv8_common *armv8,uint32_t dfr0)
 
 	return retval;
 }
+
 static struct target *get_cortex_a53(struct target *target, int32_t coreid)
 {
 	struct target_list *head;
@@ -1546,7 +1548,7 @@ static int cortex_a53_debug_entry(struct target *target)
 
 	/* First load register acessible through core debug port*/
 	if (!regfile_working_area)
-		retval = armv8_dpm_read_current_registers(&armv8->armv8_dpm); //&armv7a->dpm);
+		retval = armv8_dpm_read_current_registers(&armv8->armv8.armv8_dpm); //&armv7a->dpm);
 	else {
 		retval = cortex_a53_read_regs_through_mem(target,
 				regfile_working_area->address, regfile);
@@ -3082,6 +3084,7 @@ static int cortex_a53_target_create(struct target *target, Jim_Interp *interp)
 
 	cortex_a53->armv7a_common.is_armv7r = false;
 	cortex_a53_init_arch_info(target, cortex_a53);
+	a53_armv8_common->armv8.arm=&cortex_a53->armv7a_common.arm; //set the pointer to legacy arm core struct
 
     /* If it's not set, assume transport select is not swd. Nothing sets up the JTAG DAP so we have to. */
 	if (!global_dap)
-- 
1.9.1


From 99465dbe9120b15cb0bb73b95c54fcce6f26cf71 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 09/94] Remove arm_v8 from ARMv7 common struct. Remove
 cortex_a53 DAP reg read/write as fastmode has never been enabled and might
 need many changes to support it. Add armv8 to armv8 common struct and add
 extra cache specifically for ARMv8 core

---
 src/target/arm.h        |   3 -
 src/target/armv8_dpm.c  |   4 +-
 src/target/cortex_a53.c | 261 +++++++++++++-----------------------------------
 3 files changed, 73 insertions(+), 195 deletions(-)

diff --git a/src/target/arm.h b/src/target/arm.h
index 28977bd..88b5902 100644
--- a/src/target/arm.h
+++ b/src/target/arm.h
@@ -128,9 +128,6 @@ struct arm {
 	/** Flag reporting armv6m based core. */
 	bool is_armv6m;
 
-	/** Flag reporting armv6m based core. */
-	bool is_armv8;
-
 	/** Flag reporting whether semihosting is active. */
 	bool is_semihosting;
 
diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index 5de4b2b..85dac9a 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -167,7 +167,7 @@ int armv8_dpm_read_current_registers(struct armv8_dpm *armv8_dpm)
 		return retval;
 
 	/* read R0 first (it's used for scratch), then CPSR */
-	r = arm->core_cache->reg_list + 0;
+	r = armv8_dpm->armv8->core_cache->reg_list + 0;
 	if (!r->valid) {
 		retval = aarch64_dpm_read_reg(armv8_dpm, r, 0);
 		if (retval != ERROR_OK)
@@ -196,7 +196,7 @@ int armv8_dpm_read_current_registers(struct armv8_dpm *armv8_dpm)
 
 	/* REVISIT we can probably avoid reading R1..R14, saving time... */
 	for (unsigned i = 1; i < 33; i++) {
-		r = arm->core_cache->reg_list + i;
+		r = armv8_dpm->armv8->core_cache->reg_list + i;
 		if (r->valid)
 			continue;
 
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 6744cc8..394a5e3 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -27,10 +27,12 @@ static int cortex_a53_set_hybrid_breakpoint(struct target *target,
 	struct breakpoint *breakpoint);
 static int cortex_a53_unset_breakpoint(struct target *target,
 	struct breakpoint *breakpoint);
+#if 0
 static int cortex_a53_dap_read_coreregister_u32(struct target *target,
 	uint32_t *value, int regnum);
 static int cortex_a53_dap_write_coreregister_u32(struct target *target,
 	uint32_t value, int regnum);
+#endif
 static int cortex_a53_mmu(struct target *target, int *enabled);
 static int cortex_a53_virt2phys(struct target *target,
 	uint32_t virt, uint32_t *phys);
@@ -39,16 +41,12 @@ static int cortex_a53_virt2phys_64(struct target *target,
 static int cortex_a53_read_apb_ab_memory(struct target *target,
 	uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 
-static int force2A32=0;
-static uint32_t DR_h;	//for 64bit reg, keep the high 32bits
-static uint32_t DLR_h=0;
 
 /* check whether it is in AArch32 or AArch64 through dscr. Only valid at debug state
  * return: 1 for AArch64, 0 for AArch32, -1 for not in debug state
  */
 static int isAArch64(uint32_t dscr)
 {
-	if (force2A32) return 0;
 	if(dscr & 1) {
 		//is in debug state
 		//LOG_DEBUG("dscr is 0x%x", dscr);
@@ -338,7 +336,7 @@ static int cortex_a53_exec_opcode(struct target *target,
 		}
 	}
 
-    //override opcode
+    //override opcode. SQU TODO: instead of hack here, might need to change to caller to use right opcode for right state
 	if(opcode==0xE12FF000)
 	{//in case of ARMV4_5_MSR(0, 0) for setting CPSR
 		//LOG_USER("SQU: ARMv8: set CPSR");
@@ -401,12 +399,6 @@ static int cortex_a53_exec_opcode(struct target *target,
     	LOG_DEBUG("SQU: Assume AArch64 opcode=0x%x", opcode);
     }
 
-    /*if(isAArch64(dpm->dscr)) return cortex_a53_instr_write_data_dcc(dpm, 0xD5330500+((opcode>>12)&0xF), data); //MRS
-	else return cortex_a53_instr_write_data_dcc(dpm, (opcode>>16)|(opcode<<16), data); //MRC
-	//MSR DBGDTRTX_EL0,X0 / MCR p14,0,R0,c0,c5,0
-	if(isAArch64(dpm->dscr)) return cortex_a53_instr_read_data_dcc(dpm, 0xD5130500+((opcode>>12)&0xF), data); //MSR
-	else return cortex_a53_instr_read_data_dcc(dpm, (opcode>>16)|(opcode<<16), data);   //MCR*/
-
 	retval = mem_ap_sel_write_u32(swjdp, armv7a->debug_ap,
 			armv7a->debug_base + CPUDBG_ITR, opcode);
 	if (retval != ERROR_OK)
@@ -437,6 +429,7 @@ static int cortex_a53_exec_opcode(struct target *target,
 	return retval;
 }
 
+#if 0
 /**************************************************************************
 Read core register with very few exec_opcode, fast but needs work_area.
 This can cause problems with MMU active.
@@ -448,6 +441,8 @@ static int cortex_a53_read_regs_through_mem(struct target *target, uint32_t addr
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
 
+    LOG_ERROR("SQU: current code might have issue to handle STMIA");
+
 	retval = cortex_a53_dap_read_coreregister_u32(target, regfile, 0);
 	if (retval != ERROR_OK)
 		return retval;
@@ -473,40 +468,46 @@ static int cortex_a53_dap_read_coreregister_u32(struct target *target,
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
 
-	if (reg > 17)
-		return retval;
-
-	if (reg < 15) {
-		/* Rn to DCCTX, "MCR p14, 0, Rn, c0, c5, 0"  0xEE00nE15 */
-		retval = cortex_a53_exec_opcode(target,
-				ARMV4_5_MCR(14, 0, reg, 0, 5, 0),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	} else if (reg == 15) {
-		/* "MOV r0, r15"; then move r0 to DCCTX */
-		retval = cortex_a53_exec_opcode(target, 0xE1A0000F, &dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a53_exec_opcode(target,
-				ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	} else {
-		/* "MRS r0, CPSR" or "MRS r0, SPSR"
-		 * then move r0 to DCCTX
-		 */
-		retval = cortex_a53_exec_opcode(target, ARMV4_5_MRS(0, reg & 1), &dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a53_exec_opcode(target,
-				ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
+    if(!target->is_64b)
+    {
+	    if (reg > 17)
+		    return retval;
+
+	    if (reg < 15) {
+		    /* Rn to DCCTX, "MCR p14, 0, Rn, c0, c5, 0"  0xEE00nE15 */
+		    retval = cortex_a53_exec_opcode(target,
+				    ARMV4_5_MCR(14, 0, reg, 0, 5, 0),
+				    &dscr);
+		    if (retval != ERROR_OK)
+			    return retval;
+	    } else if (reg == 15) {
+		    /* "MOV r0, r15"; then move r0 to DCCTX */
+		    retval = cortex_a53_exec_opcode(target, 0xE1A0000F, &dscr);
+		    if (retval != ERROR_OK)
+			    return retval;
+		    retval = cortex_a53_exec_opcode(target,
+				    ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
+				    &dscr);
+		    if (retval != ERROR_OK)
+			    return retval;
+	    } else {
+		    /* "MRS r0, CPSR" or "MRS r0, SPSR"
+		     * then move r0 to DCCTX
+		     */
+		    retval = cortex_a53_exec_opcode(target, ARMV4_5_MRS(0, reg & 1), &dscr);
+		    if (retval != ERROR_OK)
+			    return retval;
+		    retval = cortex_a53_exec_opcode(target,
+				    ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
+				    &dscr);
+		    if (retval != ERROR_OK)
+			    return retval;
+	    }
+    }
+    else //AArch64
+    {
+        add code
+    }
 	/* Wait for DTRRXfull then read DTRRTX */
 	long long then = timeval_ms();
 	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
@@ -605,6 +606,7 @@ static int cortex_a53_dap_write_coreregister_u32(struct target *target,
 
 	return retval;
 }
+#endif
 
 /* Write to memory mapped registers directly with no cache or mmu handling */
 static int cortex_a53_dap_write_memap_register_u32(struct target *target,
@@ -910,7 +912,7 @@ static int cortex_a53_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
 		return retval;
     //SQU: assume the addr is 32 bits for now. TODO: fix it
 	retval = cortex_a53_dap_write_memap_register_u32(dpm->arm->target,
-			vr+4, DLR_h);
+			vr+4, 0);
 	retval = cortex_a53_dap_write_memap_register_u32(dpm->arm->target,
 			cr, control);
 	return retval;
@@ -1207,26 +1209,6 @@ static int cortex_a53_internal_restore(struct target *target, int current,
 	if (!debug_execution)
 		target_free_all_working_areas(target);
 
-#if 0
-	if (debug_execution) {
-		/* Disable interrupts */
-		/* We disable interrupts in the PRIMASK register instead of
-		 * masking with C_MASKINTS,
-		 * This is probably the same issue as Cortex-M3 Errata 377493:
-		 * C_MASKINTS in parallel with disabled interrupts can cause
-		 * local faults to not be taken. */
-		buf_set_u32(armv7m->core_cache->reg_list[ARMV7M_PRIMASK].value, 0, 32, 1);
-		armv7m->core_cache->reg_list[ARMV7M_PRIMASK].dirty = 1;
-		armv7m->core_cache->reg_list[ARMV7M_PRIMASK].valid = 1;
-
-		/* Make sure we are in Thumb mode */
-		buf_set_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0, 32,
-			buf_get_u32(armv7m->core_cache->reg_list[ARMV7M_xPSR].value, 0,
-			32) | (1 << 24));
-		armv7m->core_cache->reg_list[ARMV7M_xPSR].dirty = 1;
-		armv7m->core_cache->reg_list[ARMV7M_xPSR].valid = 1;
-	}
-#endif
 //SQUTODO: now address and PC are 64bits
 	/* current = 1: continue on current pc, otherwise continue at <address> */
 	resume_pc = buf_get_u32(arm->pc->value, 0, 32);
@@ -1273,20 +1255,6 @@ static int cortex_a53_internal_restore(struct target *target, int current,
 	/* registers are now invalid */
 	register_cache_invalidate(arm->core_cache);
 
-#if 0
-	/* the front-end may request us not to handle breakpoints */
-	if (handle_breakpoints) {
-		/* Single step past breakpoint at current address */
-		breakpoint = breakpoint_find(target, resume_pc);
-		if (breakpoint) {
-			LOG_DEBUG("unset breakpoint at 0x%8.8x", breakpoint->address);
-			cortex_m3_unset_breakpoint(target, breakpoint);
-			cortex_m3_single_step_core(target);
-			cortex_m3_set_breakpoint(target, breakpoint);
-		}
-	}
-
-#endif
 	return retval;
 }
 
@@ -1540,15 +1508,16 @@ static int cortex_a53_debug_entry(struct target *target)
 		armv8_dpm_report_wfar(&armv7a->dpm, wfar);
 	}
 
-	/* REVISIT fast_reg_read is never set ... */
+	/* REVISIT fast_reg_read is never set in original cortex_a code. And many changes needed for support. So just take the code out */
 
 	/* Examine target state and mode */
-	if (cortex_a53->fast_reg_read)
-		target_alloc_working_area(target, 64, &regfile_working_area);
+	/*if (cortex_a53->fast_reg_read)
+		target_alloc_working_area(target, 64, &regfile_working_area);*/
 
 	/* First load register acessible through core debug port*/
-	if (!regfile_working_area)
-		retval = armv8_dpm_read_current_registers(&armv8->armv8.armv8_dpm); //&armv7a->dpm);
+	//if (!regfile_working_area)
+		retval = armv8_dpm_read_current_registers(&armv8->armv8.armv8_dpm);
+#if 0
 	else {
 		retval = cortex_a53_read_regs_through_mem(target,
 				regfile_working_area->address, regfile);
@@ -1557,25 +1526,6 @@ static int cortex_a53_debug_entry(struct target *target)
 		if (retval != ERROR_OK)
 			return retval;
 
-#if 0
-		//SQU: need more investigation on below code
-		if(isAArch64(dscr))
-		{
-			/* SQU: Since there are many works to support AArch64,
-			 * and our jsdcc.elf is running in AArch32,
-			 * here will force it return to EL0/AArch32 by edit SPSR_EL3
-			 */
-			retval = cortex_a53_instr_read_data_r0(&armv7a->dpm, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);
-			LOG_USER("SQU: SPSR_EL3 = 0x%x", dummy);
-			//dummy &=0xFFFFFFF0;
-			//retval = cortex_a53_instr_write_data_r0(&armv7a->dpm, ARMV8_A64_MSR(3, 6, 4, 0, 0, 0), dummy);
-			retval = cortex_a53_exec_opcode(target, 0xD6BF03E0, &dscr); //do DRPS
-			LOG_USER("ret=0x%x and dscr=0x%x", retval, dscr);
-			force2A32=1;
-			//read cpsr
-		}
-#endif
-
 		/* read Current PSR */
 		retval = cortex_a53_dap_read_coreregister_u32(target, &cpsr, 16);
 		/*  store current cpsr */
@@ -1608,22 +1558,8 @@ static int cortex_a53_debug_entry(struct target *target)
 		buf_set_u32(reg->value, 0, 32, regfile[ARM_PC]);
 		reg->dirty = reg->valid;
 	}
-
-#if 0
-/* TODO, Move this */
-	uint32_t cp15_control_register, cp15_cacr, cp15_nacr;
-	cortex_a53_read_cp(target, &cp15_control_register, 15, 0, 1, 0, 0);
-	LOG_DEBUG("cp15_control_register = 0x%08x", cp15_control_register);
-
-	cortex_a53_read_cp(target, &cp15_cacr, 15, 0, 1, 0, 2);
-	LOG_DEBUG("cp15 Coprocessor Access Control Register = 0x%08x", cp15_cacr);
-
-	cortex_a53_read_cp(target, &cp15_nacr, 15, 0, 1, 1, 2);
-	LOG_DEBUG("cp15 Nonsecure Access Control Register = 0x%08x", cp15_nacr);
 #endif
-
 	/* Are we in an exception handler */
-/*	armv4_5->exception_number = 0; */
 	if (armv7a->post_debug_entry) {
 		retval = armv7a->post_debug_entry(target);
 		if (retval != ERROR_OK)
@@ -1641,9 +1577,9 @@ static int cortex_a53_post_debug_entry(struct target *target)
 
 	/* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
 	retval = armv7a->arm.mrc(target, 15,
-			0, 0,	/* op1, op2 */
-			1, 0,	/* CRn, CRm */
-			&cortex_a53->cp15_control_reg);
+		0, 0,	/* op1, op2 */
+		1, 0,	/* CRn, CRm */
+		&cortex_a53->cp15_control_reg);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1653,9 +1589,9 @@ static int cortex_a53_post_debug_entry(struct target *target)
 		//retval = armv7a->arm.mcr(target, 15, 0, 0, 1, 0, cortex_a53->cp15_control_reg&0xFFFFEFFA);
 		retval = armv7a->arm.mcr(target, 15, 0, 0, 1, 0, 0xC55878); //SQU: this is T32 setting
 		retval = armv7a->arm.mrc(target, 15, 0, 0, 1, 0, &cortex_a53->cp15_control_reg);
-		if (retval != ERROR_OK)
-			return retval;
-		LOG_USER("SQU: override to disable cache => SCTLR=0x%x", cortex_a53->cp15_control_reg);
+        if (retval != ERROR_OK)
+		    return retval;
+	    LOG_USER("SQU: override to disable cache => SCTLR=0x%x", cortex_a53->cp15_control_reg);
 	}
 	cortex_a53->cp15_control_reg_curr = cortex_a53->cp15_control_reg;
 
@@ -1793,10 +1729,6 @@ static int cortex_a53_set_breakpoint(struct target *target,
 		return ERROR_OK;
 	}
 
-	/*if (breakpoint->type == BKPT_SOFT) {
-		LOG_USER("SQU: force to HARD BP for now, until we find a solution.");
-		breakpoint->type = BKPT_HARD;
-	}*/
 	if (breakpoint->type == BKPT_HARD) {
 		while (brp_list[brp_i].used && (brp_i < cortex_a53->brp_num))
 			brp_i++;
@@ -1818,10 +1750,10 @@ static int cortex_a53_set_breakpoint(struct target *target,
 				brp_list[brp_i].value);
 		if (retval != ERROR_OK)
 			return retval;
-        //SQU: assume DLR_h hold high 32bits addr. TODO: fix it
+        //SQU: assume 0 hold high 32bits addr. TODO: fix it
 		retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
 				+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn + 4,
-				DLR_h);
+				0);
 		retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
 				+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
 				brp_list[brp_i].control);
@@ -1847,16 +1779,6 @@ static int cortex_a53_set_breakpoint(struct target *target,
 				breakpoint->length, 1, code);
 		if (retval != ERROR_OK)
 			return retval;
-		//SQU: read back to verfiy
-		/*control=0; //in case of T32
-		retval = target_read_memory(target,
-						breakpoint->address & 0xFFFFFFFE,
-						breakpoint->length, 1,
-						&control);
-		if (breakpoint->length == 2) LOG_USER("T32 BKPT readback as 0x%x, expect=>0xbe11", control);
-		else LOG_USER("A32 BKPT readback as 0x%x, expect=>0xe1200171", control);*/
-		//set EDECCR only for s/w BP
-		//retval = mem_ap_sel_write_atomic_u32(armv7a->arm.dap, armv7a->debug_ap, armv7a->debug_base + EDECCR, 8);
 
 		breakpoint->set = 0x11;	/* Any nice value but 0 */
 	}
@@ -1904,7 +1826,7 @@ static int cortex_a53_set_context_breakpoint(struct target *target,
     //SQU: assume the addr is 32bits. TODO: fix it
 	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
 			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn + 4,
-			DLR_h);
+			0);
 
 	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
 			+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
@@ -1975,7 +1897,7 @@ static int cortex_a53_set_hybrid_breakpoint(struct target *target, struct breakp
     //SQU: assume addr is 32bit. TODO: fix it
 	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
 			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_1].BRPn + 4,
-			DLR_h);
+			0);
 	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
 			+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_1].BRPn,
 			brp_list[brp_1].control);
@@ -1997,7 +1919,7 @@ static int cortex_a53_set_hybrid_breakpoint(struct target *target, struct breakp
     //SQU assume 32bit. TODO: fix it
 	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
 			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_2].BRPn + 4,
-			DLR_h);
+			0);
 
 	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
 			+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_2].BRPn,
@@ -2046,7 +1968,7 @@ static int cortex_a53_unset_breakpoint(struct target *target, struct breakpoint
             //SQU: assume 32bit addr. TODO: fix it
 			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
 					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn + 4,
-					DLR_h);
+					0);
 			if ((brp_j < 0) || (brp_j >= cortex_a53->brp_num)) {
 				LOG_DEBUG("Invalid BRP number in breakpoint");
 				return ERROR_OK;
@@ -2069,7 +1991,7 @@ static int cortex_a53_unset_breakpoint(struct target *target, struct breakpoint
             //SQU: assume 32bit addr. TODO: fix it
 			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
 					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_j].BRPn + 4,
-					DLR_h);
+					0);
 			breakpoint->linked_BRP = 0;
 			breakpoint->set = 0;
 			return ERROR_OK;
@@ -2098,7 +2020,7 @@ static int cortex_a53_unset_breakpoint(struct target *target, struct breakpoint
             //SQU: assume 32bit addr. TODO: fix it
 			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
 					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn + 4,
-					DLR_h);
+					0);
 
             breakpoint->set = 0;
 			return ERROR_OK;
@@ -2177,14 +2099,6 @@ static int cortex_a53_remove_breakpoint(struct target *target, struct breakpoint
 {
 	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
 
-#if 0
-/* It is perfectly possible to remove breakpoints while the target is running */
-	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-#endif
-
 	if (breakpoint->set) {
 		cortex_a53_unset_breakpoint(target, breakpoint);
 		if (breakpoint->type == BKPT_HARD)
@@ -2950,40 +2864,14 @@ static int cortex_a53_examine_first(struct target *target)
 		return retval;
 	}
 
-	/* Now CPUDBG_CYTPR @0xD04, CPUDBG_TTYPR @0xD0C, CPUDBUG_DIDR @0x0 are not accessible through mapped address.
-	 * Access those register might return error.
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_CTYPR, &ctypr);
-	if (retval != ERROR_OK) {
-		LOG_DEBUG("Examine %s failed", "CTYPR");
-		return retval;
-	}
-
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_TTYPR, &ttypr);
-	if (retval != ERROR_OK) {
-		LOG_DEBUG("Examine %s failed", "TTYPR");
-		return retval;
-	}
-
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DIDR, &didr);
-	if (retval != ERROR_OK) {
-		LOG_DEBUG("Examine %s failed", "DIDR");
-		return retval;
-	}*/
 	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
 			armv7a->debug_base + ID_AA64DFR0_EL1_L, &dfr0);
 	if (retval != ERROR_OK) {
 		LOG_DEBUG("Examine %s failed", "ID_AA64DFR0_EL1");
 		return retval;
 	}
-	//didr=0x3556F020; //hard coded
 	LOG_DEBUG("cpuid = 0x%08" PRIx32, cpuid);
-	/*LOG_DEBUG("ctypr = 0x%08" PRIx32, ctypr);
-	LOG_DEBUG("ttypr = 0x%08" PRIx32, ttypr);*/
 	LOG_DEBUG("didr = 0x%08" PRIx32, dfr0);
-	armv7a->arm.is_armv8 = true;
 	armv7a->arm.core_type = ARM_MODE_MON;
 	retval = cortex_a53_dpm_setup(armv8, dfr0);
 	if (retval != ERROR_OK)
@@ -3028,7 +2916,7 @@ static int cortex_a53_examine(struct target *target)
 }
 
 /*
- *	Cortex-A8 target creation and initialization
+ *	Cortex-A53 target creation and initialization
  */
 
 static int cortex_a53_init_target(struct command_context *cmd_ctx,
@@ -3045,21 +2933,14 @@ static int cortex_a53_init_arch_info(struct target *target,
 
 	/* Setup struct cortex_a_common */
 	cortex_a53->common_magic = CORTEX_A_COMMON_MAGIC;
-
 	cortex_a53->fast_reg_read = 0;
 
 	/* register arch-specific functions */
 	armv7a->examine_debug_reason = NULL;
-
 	armv7a->post_debug_entry = cortex_a53_post_debug_entry;
-
 	armv7a->pre_restore_context = NULL;
-
 	armv7a->armv7a_mmu.read_physical_memory = cortex_a53_read_phys_memory;
 
-
-/*	arm7_9->handle_target_request = cortex_a53_handle_target_request; */
-
 	/* REVISIT v7a setup should be in a v7a-specific routine */
 	armv7a_init_arch_info(target, armv7a);
 	target_register_timer_callback(cortex_a53_handle_target_request, 1, 1, target);
@@ -3263,7 +3144,7 @@ static const struct command_registration cortex_a53_command_handlers[] = {
 	{
 		.name = "cortex_a53",
 		.mode = COMMAND_ANY,
-		.help = "Cortex-A53 64bit command group",
+		.help = "Cortex-A53 ARMv8 command group",
 		.usage = "",
 		.chain = cortex_a53_exec_command_handlers,
 	},
@@ -3272,7 +3153,7 @@ static const struct command_registration cortex_a53_command_handlers[] = {
 
 struct target_type cortexa53_target = {
 	.name = "cortex_a53",
-	.deprecated_name = "cortex_a",
+	//.deprecated_name = "cortex_a",
 
 	.poll = cortex_a53_poll,
 	.arch_state = armv7a_arch_state,
-- 
1.9.1


From c84ebe688f9246232c3364d08241cec7a15b3eb5 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 10/94] Add code to properly print AArch64 mode and PC info.
 Fix ARMv8 code to pick the right register cache for AArch64

---
 src/target/armv8.c      | 44 ++++++++++++++++++++++++--------------------
 src/target/armv8.h      |  5 +++--
 src/target/cortex_a53.c | 12 ++++++++++--
 3 files changed, 37 insertions(+), 24 deletions(-)

diff --git a/src/target/armv8.c b/src/target/armv8.c
index 717f352..86aaeff 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -24,7 +24,7 @@ static const struct {
 	 */
 	unsigned short n_indices;
 	const uint8_t *indices;
-} arm_mode_data[] = {
+} aarch64_mode_data[] = {
     {
 		.name = "EL0t",
 		.psr = AARCH64_MODE_EL0t,
@@ -58,9 +58,9 @@ static const struct {
 /** Map PSR mode bits to the name of an ARM processor operating mode. */
 const char *aarch64_mode_name(unsigned psr_mode)
 {
-	for (unsigned i = 0; i < ARRAY_SIZE(arm_mode_data); i++) {
-		if (arm_mode_data[i].psr == psr_mode)
-			return arm_mode_data[i].name;
+	for (unsigned i = 0; i < ARRAY_SIZE(aarch64_mode_data); i++) {
+		if (aarch64_mode_data[i].psr == psr_mode)
+			return aarch64_mode_data[i].name;
 	}
 	LOG_ERROR("unrecognized psr mode: %#02x", psr_mode);
 	return "UNRECOGNIZED";
@@ -69,8 +69,8 @@ const char *aarch64_mode_name(unsigned psr_mode)
 /** Return true iff the parameter denotes a valid ARM processor mode. */
 bool is_aarch64_mode(unsigned psr_mode)
 {
-	for (unsigned i = 0; i < ARRAY_SIZE(arm_mode_data); i++) {
-		if (arm_mode_data[i].psr == psr_mode)
+	for (unsigned i = 0; i < ARRAY_SIZE(aarch64_mode_data); i++) {
+		if (aarch64_mode_data[i].psr == psr_mode)
 			return true;
 	}
 	return false;
@@ -247,7 +247,7 @@ void arm_set_cpsr(struct arm *arm, uint32_t cpsr)
 
 	LOG_DEBUG("set CPSR %#8.8x: %s mode, %s state", (unsigned) cpsr,
 		arm_mode_name(mode),
-		arm_state_strings[arm->core_state]);
+		"AArch64");
 }
 #endif
 
@@ -385,28 +385,30 @@ struct reg_cache *armv8_build_reg_cache(struct target *target, struct armv8 *arm
 	return cache;
 }
 
-#if use_old_code
-int arm_arch_state(struct target *target)
+int armv8_arch_state(struct target *target)
 {
-	struct arm *arm = target_to_arm(target);
-
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+    struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a53);
+    struct armv8 *armv8 = &armv8_common->armv8;
+	struct arm *arm = armv8->arm;
+	if(!target->is_64b) return arm_arch_state(target);
 	if (arm->common_magic != ARM_COMMON_MAGIC) {
 		LOG_ERROR("BUG: called for a non-ARM target");
 		return ERROR_FAIL;
 	}
 
-	LOG_USER("target halted in %s state due to %s, current mode: %s\n"
-		"cpsr: 0x%8.8" PRIx32 " pc: 0x%8.8" PRIx32 "%s",
-		arm_state_strings[arm->core_state],
+	LOG_USER("target halted in AArch64 state due to %s, current mode: %s\n"
+		"cpsr: 0x%8.8" PRIx32 " pc: 0x%" PRIx64 "%s",
 		debug_reason_name(target),
-		arm_mode_name(arm->core_mode),
-		buf_get_u32(arm->cpsr->value, 0, 32),
-		buf_get_u32(arm->pc->value, 0, 32),
+		aarch64_mode_name(arm->core_mode),
+		buf_get_u32(armv8->cpsr->value, 0, 32),
+		buf_get_u64(armv8->pc->value, 0, 64),
 		arm->is_semihosting ? ", semihosting" : "");
 
 	return ERROR_OK;
 }
 
+#if use_old_code
 #define ARMV4_5_CORE_REG_MODENUM(cache, mode, num) \
 	(cache->reg_list[armv4_5_core_reg_map[mode][num]])
 
@@ -845,11 +847,13 @@ int armv8_get_gdb_reg_list(struct target *target,
 		struct reg **reg_list[], int *reg_list_size,
 		enum target_register_class reg_class)
 {
-	struct arm *arm = target_to_arm(target);
+	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
+	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a);
+	struct armv8 *armv8 = &armv8_common->armv8;
 	unsigned int i;
 
 	if(!target->is_64b) return arm_get_gdb_reg_list(target, reg_list, reg_list_size, reg_class);
-	if (!is_aarch64_mode(arm->core_mode)) {
+	if (!is_aarch64_mode(armv8->arm->core_mode)) {
 		LOG_ERROR("not a valid arm core mode - communication failure?");
 		return ERROR_FAIL;
 	}
@@ -860,7 +864,7 @@ int armv8_get_gdb_reg_list(struct target *target,
 		*reg_list_size = 34;
 		*reg_list = malloc(sizeof(struct reg *) * (*reg_list_size));
 		for (i = 0; i < 34; i++)
-			(*reg_list)[i] = arm->core_cache->reg_list+i; //no mapping needed for ARMv8: armv8_reg_current(arm, i);
+			(*reg_list)[i] = armv8->core_cache->reg_list+i; //no mapping needed for ARMv8: armv8_reg_current(arm, i);
 		return ERROR_OK;
 		break;
 
diff --git a/src/target/armv8.h b/src/target/armv8.h
index 9c4725d..4605b27 100755
--- a/src/target/armv8.h
+++ b/src/target/armv8.h
@@ -80,10 +80,11 @@ struct armv8_common {
 	struct armv8 armv8;
 };
 
-static inline struct armv8_common *
-cortex_a_to_armv8(struct cortex_a_common *cortex_a)
+static inline struct armv8_common* cortex_a_to_armv8(struct cortex_a_common *cortex_a)
 {
 	return container_of(cortex_a, struct armv8_common, cortex_a_common);
 }
 
+int armv8_arch_state(struct target *target);
+
 #endif /* ARMV8_H */
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 394a5e3..f7518b2 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -1144,8 +1144,16 @@ static int cortex_a53_halt(struct target *target)
 	//check DLR_EL0 and DSPSR_EL0
 	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDSCR, &dummy);
 	LOG_USER(" EDSCR = 0x%08" PRIx32, dummy);
-	if(isAArch64(dummy)) target->is_64b=true;
-	else target->is_64b=false;
+	if(isAArch64(dummy))
+	{
+		target->is_64b=true;
+		target->type->arch_state=armv8_arch_state;
+	}
+	else
+	{
+		target->is_64b=false;
+		target->type->arch_state=armv7a_arch_state;
+	}
 	/*remote below hack. Changing state should be a request from gdb client, but not forced here
 	if(target->is_64b)
 	{
-- 
1.9.1


From 9ee79e899a9b13bd4631016fe58bbbeb79c7cb5f Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 11/94] Add fp registers support for ARMv8 to satisfy Linaro
 gdb client

---
 src/target/armv8.c      | 94 ++++++++++++++++++++++++++++++++++++++++---------
 src/target/armv8_dpm.c  | 90 ++++++++++++++++++++++++++--------------------
 src/target/armv8_dpm.h  |  2 +-
 src/target/cortex_a53.c | 14 --------
 4 files changed, 130 insertions(+), 70 deletions(-)

diff --git a/src/target/armv8.c b/src/target/armv8.c
index 86aaeff..cca8b74 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -150,7 +150,7 @@ static const struct {
 	unsigned cookie;
 	unsigned gdb_index;
 	enum aarch64_mode mode;
-} arm_core_regs[] = {
+} armv8_core_regs[] = {
 	/* IMPORTANT:  we guarantee that the first eight cached registers
 	 * correspond to r0..r7, and the fifteenth to PC, so that callers
 	 * don't need to map them.
@@ -185,10 +185,44 @@ static const struct {
 	{ .name = "x27", .cookie = 27, .mode = AARCH64_MODE_ANY, .gdb_index = 27, },
 	{ .name = "x28", .cookie = 28, .mode = AARCH64_MODE_ANY, .gdb_index = 28, },
 	{ .name = "x29", .cookie = 29, .mode = AARCH64_MODE_ANY, .gdb_index = 29, },
-	{ .name = "x30", .cookie = 30, .mode = AARCH64_MODE_ANY, .gdb_index = 30, },
-	{ .name = "x31", .cookie = 31, .mode = AARCH64_MODE_ANY, .gdb_index = 31, },
+	{ .name = "lr", .cookie = 30, .mode = AARCH64_MODE_ANY, .gdb_index = 30, },
+	{ .name = "sp", .cookie = 31, .mode = AARCH64_MODE_ANY, .gdb_index = 31, },
 	{ .name = "pc", .cookie = 32, .mode = AARCH64_MODE_ANY, .gdb_index = 32, },
 	{ .name = "cpsr", .cookie = 33, .mode = AARCH64_MODE_ANY, .gdb_index = 33, },
+	{ .name = "v0", .cookie = 34, .mode = AARCH64_MODE_ANY, .gdb_index = 34, },
+	{ .name = "v1", .cookie = 35, .mode = AARCH64_MODE_ANY, .gdb_index = 35, },
+	{ .name = "v2", .cookie = 36, .mode = AARCH64_MODE_ANY, .gdb_index = 36, },
+	{ .name = "v3", .cookie = 37, .mode = AARCH64_MODE_ANY, .gdb_index = 37, },
+	{ .name = "v4", .cookie = 38, .mode = AARCH64_MODE_ANY, .gdb_index = 38, },
+	{ .name = "v5", .cookie = 39, .mode = AARCH64_MODE_ANY, .gdb_index = 39, },
+	{ .name = "v6", .cookie = 40, .mode = AARCH64_MODE_ANY, .gdb_index = 40, },
+	{ .name = "v7", .cookie = 41, .mode = AARCH64_MODE_ANY, .gdb_index = 41, },
+	{ .name = "v8", .cookie = 42, .mode = AARCH64_MODE_ANY, .gdb_index = 42, },
+	{ .name = "v9", .cookie = 43, .mode = AARCH64_MODE_ANY, .gdb_index = 43, },
+	{ .name = "v10", .cookie = 44, .mode = AARCH64_MODE_ANY, .gdb_index = 44, },
+	{ .name = "v11", .cookie = 45, .mode = AARCH64_MODE_ANY, .gdb_index = 45, },
+	{ .name = "v12", .cookie = 46, .mode = AARCH64_MODE_ANY, .gdb_index = 46, },
+	{ .name = "v13", .cookie = 47, .mode = AARCH64_MODE_ANY, .gdb_index = 47, },
+	{ .name = "v14", .cookie = 48, .mode = AARCH64_MODE_ANY, .gdb_index = 48, },
+	{ .name = "v15", .cookie = 49, .mode = AARCH64_MODE_ANY, .gdb_index = 49, },
+	{ .name = "v16", .cookie = 50, .mode = AARCH64_MODE_ANY, .gdb_index = 50, },
+	{ .name = "v17", .cookie = 51, .mode = AARCH64_MODE_ANY, .gdb_index = 51, },
+	{ .name = "v18", .cookie = 52, .mode = AARCH64_MODE_ANY, .gdb_index = 52, },
+	{ .name = "v19", .cookie = 53, .mode = AARCH64_MODE_ANY, .gdb_index = 53, },
+	{ .name = "v20", .cookie = 54, .mode = AARCH64_MODE_ANY, .gdb_index = 54, },
+	{ .name = "v21", .cookie = 55, .mode = AARCH64_MODE_ANY, .gdb_index = 55, },
+	{ .name = "v22", .cookie = 56, .mode = AARCH64_MODE_ANY, .gdb_index = 56, },
+	{ .name = "v23", .cookie = 57, .mode = AARCH64_MODE_ANY, .gdb_index = 57, },
+	{ .name = "v24", .cookie = 58, .mode = AARCH64_MODE_ANY, .gdb_index = 58, },
+	{ .name = "v25", .cookie = 59, .mode = AARCH64_MODE_ANY, .gdb_index = 59, },
+	{ .name = "v26", .cookie = 60, .mode = AARCH64_MODE_ANY, .gdb_index = 60, },
+	{ .name = "v27", .cookie = 61, .mode = AARCH64_MODE_ANY, .gdb_index = 61, },
+	{ .name = "v28", .cookie = 62, .mode = AARCH64_MODE_ANY, .gdb_index = 62, },
+	{ .name = "v29", .cookie = 63, .mode = AARCH64_MODE_ANY, .gdb_index = 63, },
+	{ .name = "v30", .cookie = 64, .mode = AARCH64_MODE_ANY, .gdb_index = 64, },
+	{ .name = "v31", .cookie = 65, .mode = AARCH64_MODE_ANY, .gdb_index = 65, },
+	{ .name = "fpsr", .cookie = 66, .mode = AARCH64_MODE_ANY, .gdb_index = 66, },
+	{ .name = "fpcr", .cookie = 67, .mode = AARCH64_MODE_ANY, .gdb_index = 67, },
 };
 
 #if use_old_code
@@ -319,7 +353,7 @@ static const struct reg_arch_type armv8_reg_type = {
 
 struct reg_cache *armv8_build_reg_cache(struct target *target, struct armv8 *armv8)
 {
-	int num_regs = ARRAY_SIZE(arm_core_regs);
+	int num_regs = ARRAY_SIZE(armv8_core_regs);
 	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
 	struct reg *reg_list = calloc(num_regs, sizeof(struct reg));
 	struct arm_reg *reg_arch_info = calloc(num_regs, sizeof(struct arm_reg));
@@ -338,25 +372,40 @@ struct reg_cache *armv8_build_reg_cache(struct target *target, struct armv8 *arm
 	cache->num_regs = 0;
 
 	for (i = 0; i < num_regs; i++) {
-		reg_arch_info[i].num = arm_core_regs[i].cookie;
-		reg_arch_info[i].mode = arm_core_regs[i].mode;
+		reg_arch_info[i].num = armv8_core_regs[i].cookie;
+		reg_arch_info[i].mode = armv8_core_regs[i].mode;
 		reg_arch_info[i].target = target;
 		reg_arch_info[i].arm = armv8->arm;
 
-		reg_list[i].name = (char *) arm_core_regs[i].name;
-		reg_list[i].number = arm_core_regs[i].gdb_index;
-		reg_list[i].size = 64;
+		reg_list[i].name = (char *) armv8_core_regs[i].name;
+		reg_list[i].number = armv8_core_regs[i].gdb_index;
 		reg_list[i].value = &reg_arch_info[i].value;
 		reg_list[i].type = &armv8_reg_type;
 		reg_list[i].arch_info = &reg_arch_info[i];
 		reg_list[i].exist = true;
+		if(reg_arch_info[i].num<33)
+		{
+			reg_list[i].size = 64;
+		}
+		else if(reg_arch_info[i].num==33) //cpsr
+		{
+			reg_list[i].size = 32;
+		}
+		else if(reg_arch_info[i].num<66)
+		{
+			reg_list[i].size = 128;
+		}
+		else reg_list[i].size = 32; //fpcr and fpsr
 
 		/* This really depends on the calling convention in use */
 		reg_list[i].caller_save = false;
 
 		/* Registers data type, as used by GDB target description */
 		reg_list[i].reg_data_type = malloc(sizeof(struct reg_data_type));
-		switch (arm_core_regs[i].cookie) {
+		switch (armv8_core_regs[i].cookie) {
+		case 0 ... 29:
+			reg_list[i].reg_data_type->type = REG_TYPE_UINT64;
+			break;
 		case 31: //sp
 			reg_list[i].reg_data_type->type = REG_TYPE_DATA_PTR;
 			break;
@@ -365,16 +414,30 @@ struct reg_cache *armv8_build_reg_cache(struct target *target, struct armv8 *arm
 			reg_list[i].reg_data_type->type = REG_TYPE_CODE_PTR;
 		    break;
 		case 33: //cpsr
+		case 66: //fpsr
+		case 67: //fpcr
 			reg_list[i].reg_data_type->type = REG_TYPE_UINT32;
 			break;
+		case 34 ... 65:
+			reg_list[i].reg_data_type->type = REG_TYPE_UINT128; //REG_TYPE_FLOAT?
+			break;
 		default:
-			reg_list[i].reg_data_type->type = REG_TYPE_UINT64;
+			//should not be here
+			reg_list[i].reg_data_type->type = REG_TYPE_UINT32;
 		    break;
 		}
 
 		reg_list[i].feature = malloc(sizeof(struct reg_feature));
-		reg_list[i].feature->name = "org.gnu.gdb.aarch64.core";
-		reg_list[i].group = "general";
+		if(reg_arch_info[i].num<34)
+		{
+			reg_list[i].feature->name = "org.gnu.gdb.aarch64.core";
+			reg_list[i].group = "general";
+		}
+		else
+		{
+			reg_list[i].feature->name = "org.gnu.gdb.aarch64.fpu";
+			reg_list[i].group = "fpu";
+		}
 
 		cache->num_regs++;
 	}
@@ -861,13 +924,12 @@ int armv8_get_gdb_reg_list(struct target *target,
 	switch (reg_class) {
 	case REG_CLASS_GENERAL:
 	case REG_CLASS_ALL:
-		*reg_list_size = 34;
+		*reg_list_size = ARRAY_SIZE(armv8_core_regs);
 		*reg_list = malloc(sizeof(struct reg *) * (*reg_list_size));
-		for (i = 0; i < 34; i++)
+		for (i = 0; i < *reg_list_size; i++)
 			(*reg_list)[i] = armv8->core_cache->reg_list+i; //no mapping needed for ARMv8: armv8_reg_current(arm, i);
 		return ERROR_OK;
 		break;
-
 	default:
 		LOG_ERROR("not a valid register class type in query.");
 		return ERROR_FAIL;
diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index 85dac9a..3c77b2f 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -69,10 +69,14 @@ static int aarch64_dpm_read_reg(struct armv8_dpm *armv8_dpm, struct reg *r, unsi
 	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
 
 	switch (regnum) {
-		case 0 ... 31:
+		case 0 ... 30:
 			/* return via DCC:  "MSR DBGDTRTX_EL0, Xn" */
 			retval = armv8_dpm->instr_read_data64_dcc(dpm, ARMV8_A64_MSR(2, 3, 0, 5, 0, regnum), &value);
 			break;
+		case 31:
+			//SP
+			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 6, 4, 1, 0, 0), &value);//SP_EL2
+			break;
 		case 32:/* PC
 			 * "MSR X0, DLR_EL0"; then return via DCC */
 			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 5, 1, 0), &value);
@@ -91,15 +95,24 @@ static int aarch64_dpm_read_reg(struct armv8_dpm *armv8_dpm, struct reg *r, unsi
 					break;
 			}
 			break;
-		case 33: //cpsr
+		case 33: //cpsr, read from DSPSR
+			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 5, 0, 0), &value);
+			break;
+		case 66: //FPSR
+			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 4, 1, 0), &value);
+			break;
+		case 67: //FPCR
+			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 4, 0, 0), &value);
 			break;
 		default:
-			/* something wrong */
+			LOG_ERROR("SQU: Reading invalid or not supported reg %d. Will set value to 0xDEADBEEF", regnum);
+			value=0xDEADBEEF;
+			retval=-1;
 			break;
 	}
 
 	if (retval == ERROR_OK) {
-		if(regnum!=33)
+		if(regnum<33)
 			buf_set_u64(r->value, 0, 64, value);
 		else buf_set_u32(r->value, 0, 32, value);
 		r->valid = true;
@@ -115,26 +128,33 @@ static int aarch64_dpm_write_reg(struct armv8_dpm *armv8_dpm, struct reg *r, uns
 {
 	struct arm_dpm *dpm=armv8_dpm->arm_dpm;
 	int retval;
-	uint64_t value = buf_get_u64(r->value, 0, 64);
+	uint64_t value;
+	if(regnum<33) value = buf_get_u64(r->value, 0, 64);
+	else value = buf_get_u32(r->value, 0, 32);
 
 	switch (regnum) {
-		case 0 ... 31:
-			/* load register from DCC:  "MRC p14, 0, Rnum, c0, c5, 0" */
-			retval = dpm->instr_write_data_dcc(dpm,
-				ARMV4_5_MRC(14, 0, regnum, 0, 5, 0),
-				value);
+		case 0 ... 30:
+			/* write via DCC:  "MRS DBGDTRTX_EL0, Xn" */
+			retval = armv8_dpm->instr_write_data64_dcc(dpm, ARMV8_A64_MRS(2, 3, 0, 5, 0, regnum), value);
 			break;
-		case 32:/* PC
-			 * read r0 from DCC; then "MOV pc, r0" */
-			retval = dpm->instr_write_data_r0(dpm, 0xe1a0f000, value);
+		case 31:
+			//SP
+			retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 6, 4, 1, 0, 0), value);//SP_EL2
 			break;
-		case 33: //cpsr
-			if (regnum == 16 && dpm->instr_cpsr_sync)
-				retval = dpm->instr_cpsr_sync(dpm);
-
+		case 32: //PC, "MSR X0, DLR_EL0"
+			retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 5, 1, 0), value);
+		case 33: //cpsr, write to DSPSR
+			retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 5, 0, 0), value);
+			break;
+		case 66: //FPSR
+			retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 4, 1, 0), value);
+			break;
+		case 67: //FPCR
+			retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 4, 0, 0), value);
 			break;
 		default:
-			/* something wrong */
+			LOG_ERROR("SQU: Writing invalid or not supported reg %d. Ignored", regnum);
+			retval=-1;
 			break;
 	}
 
@@ -821,7 +841,6 @@ void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr)
 /*
  * Other debug and support utilities
  */
-
 void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
 {
 	struct target *target = dpm->arm->target;
@@ -829,26 +848,19 @@ void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
 	dpm->dscr = dscr;
 
 	/* Examine debug reason */
-	switch (DSCR_ENTRY(dscr)) {
-		case 6:	/* Data abort (v6 only) */
-		case 7:	/* Prefetch abort (v6 only) */
-		/* FALL THROUGH -- assume a v6 core in abort mode */
-		case 0:	/* HALT request from debugger */
-		case 4:	/* EDBGRQ */
-			target->debug_reason = DBG_REASON_DBGRQ;
-			break;
-		case 1:	/* HW breakpoint */
-		case 3:	/* SW BKPT */
-		case 5:	/* vector catch */
-			target->debug_reason = DBG_REASON_BREAKPOINT;
-			break;
-		case 2:	/* asynch watchpoint */
-		case 10:/* precise watchpoint */
-			target->debug_reason = DBG_REASON_WATCHPOINT;
-			break;
-		default:
-			target->debug_reason = DBG_REASON_UNDEFINED;
-			break;
+	/* Override the result from arm_dpm.c::armv8_dpm_report_dscr() for ARMv8. Need to re-visit*/
+	switch(dscr & 0x3F)
+	{
+	case 0x37:
+		LOG_USER("SQU: Exception trigger halt");
+		break;
+	case 0x1B:
+	case 0x1F:
+	case 0x3B:
+		target->debug_reason = DBG_REASON_BREAKPOINT;
+		break;
+	default:
+		break;
 	}
 }
 
diff --git a/src/target/armv8_dpm.h b/src/target/armv8_dpm.h
index 1d4a826..26d6a8b 100755
--- a/src/target/armv8_dpm.h
+++ b/src/target/armv8_dpm.h
@@ -118,6 +118,7 @@ void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr);
 void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr);
 int armv8_dpm_setup(struct armv8_dpm * armv8_dpm);
 int armv8_dpm_initialize(struct armv8_dpm * armv8_dpm);
+void arm_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dcsr);
 
 #if 0
 int arm_dpm_setup(struct arm_dpm *dpm);
@@ -186,6 +187,5 @@ void arm_dpm_report_wfar(struct arm_dpm *, uint32_t wfar);
 #define DRCR_RESTART			(1 << 1)
 #define DRCR_CLEAR_EXCEPTIONS	(1 << 2)
 
-void arm_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dcsr);
 #endif
 #endif /* __ARMV8_DPM_H */
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index f7518b2..71fa3ba 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -1490,20 +1490,6 @@ static int cortex_a53_debug_entry(struct target *target)
 
 	/* Examine debug reason */
 	armv8_dpm_report_dscr(&armv7a->dpm, cortex_a53->cpudbg_dscr);
-	/* Override the result from arm_dpm.c::armv8_dpm_report_dscr() for ARMv8. Need to re-visit*/
-	switch(cortex_a53->cpudbg_dscr & 0x3F)
-	{
-	case 0x37:
-		LOG_USER("SQU: Exception trigger halt");
-		break;
-	case 0x1B:
-	case 0x1F:
-	case 0x3B:
-		target->debug_reason = DBG_REASON_BREAKPOINT;
-		break;
-	default:
-		break;
-	}
 	/* save address of instruction that triggered the watchpoint? */
 	if (target->debug_reason == DBG_REASON_WATCHPOINT) {
 		uint32_t wfar;
-- 
1.9.1


From 0ddf3f7c1fec262cdef513191a79300dd6dbf68b Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 12/94] update dpm and ARMv8 code for correctly query
 registers. Update AArch64 DPSR report API to output more readable info

---
 src/target/armv8_dpm.c  | 156 +++++++++++++++++++++++-------------------------
 src/target/armv8_dpm.h  |   7 +--
 src/target/cortex_a53.c | 105 ++++++++++++++++++++------------
 3 files changed, 147 insertions(+), 121 deletions(-)

diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index 3c77b2f..cf92bec 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -38,56 +38,70 @@
 /* Toggles between recorded core mode (USR, SVC, etc) and a temporary one.
  * Routines *must* restore the original mode before returning!!
  */
-int armv8_dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode)
+int armv8_dpm_modeswitch(struct armv8_dpm *armv8_dpm, enum arm_mode mode)
 {
 	int retval;
 	uint32_t cpsr;
+	struct arm_dpm* dpm=armv8_dpm->arm_dpm;
 
-	/* restore previous mode */
-	if (mode == ARM_MODE_ANY)
-		cpsr = buf_get_u32(dpm->arm->cpsr->value, 0, 32);
+	if(!dpm->arm->target->is_64b)
+	{
+		/* restore previous mode */
+		if (mode == ARM_MODE_ANY)
+			cpsr = buf_get_u32(dpm->arm->cpsr->value, 0, 32);
 
-	/* else force to the specified mode */
-	else
-		cpsr = mode;
+		/* else force to the specified mode */
+		else
+			cpsr = mode;
 
-	retval = dpm->instr_write_data_r0(dpm, ARMV4_5_MSR_GP(0, 0xf, 0), cpsr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (dpm->instr_cpsr_sync)
-		retval = dpm->instr_cpsr_sync(dpm);
+		retval = dpm->instr_write_data_r0(dpm, ARMV4_5_MSR_GP(0, 0xf, 0), cpsr);
+		if (retval != ERROR_OK)
+			return retval;
 
+		if (dpm->instr_cpsr_sync)
+			retval = dpm->instr_cpsr_sync(dpm);
+	}
+	else
+	{
+		if (mode == ARM_MODE_ANY) cpsr = buf_get_u32(armv8_dpm->armv8->cpsr->value, 0, 32);
+		else cpsr = mode;
+	 	retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 5, 0, 0), cpsr);
+		if (retval != ERROR_OK)	return retval;
+	}
 	return retval;
 }
 
 /* just read the register -- rely on the core mode being right */
 static int aarch64_dpm_read_reg(struct armv8_dpm *armv8_dpm, struct reg *r, unsigned regnum)
 {
-	uint64_t value;
+	uint64_t v64;
+	uint32_t v32;
 	int retval;
 	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
 
 	switch (regnum) {
 		case 0 ... 30:
 			/* return via DCC:  "MSR DBGDTRTX_EL0, Xn" */
-			retval = armv8_dpm->instr_read_data64_dcc(dpm, ARMV8_A64_MSR(2, 3, 0, 5, 0, regnum), &value);
+			retval = armv8_dpm->instr_read_data64_dcc(dpm, ARMV8_A64_MSR(2, 3, 0, 5, 0, regnum), &v64);
 			break;
 		case 31:
 			//SP
-			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 6, 4, 1, 0, 0), &value);//SP_EL2
+			/*SQU: problem for read SPSel with below code, will get error in EDSCR:
+			retval = dpm->instr_read_data_r0(dpm, ARMV8_A64_MRS(3, 0, 4, 2, 0, 0), &v32);//SPSel is 32bit
+			LOG_USER("SQU: SPSel=0x%x", v32);*/
+			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 0, 4, 1, 0, 0), &v64);//SP_EL0
 			break;
 		case 32:/* PC
 			 * "MSR X0, DLR_EL0"; then return via DCC */
-			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 5, 1, 0), &value);
+			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 5, 1, 0), &v64);
 
 			switch (dpm->arm->core_state) {
 				case ARM_STATE_ARM:
-					value -= 8;
+					v64 -= 8;
 					break;
 				case ARM_STATE_THUMB:
 				case ARM_STATE_THUMB_EE:
-					value -= 4;
+					v64 -= 4;
 					break;
 				case ARM_STATE_JAZELLE:
 					/* core-specific ... ? */
@@ -96,28 +110,34 @@ static int aarch64_dpm_read_reg(struct armv8_dpm *armv8_dpm, struct reg *r, unsi
 			}
 			break;
 		case 33: //cpsr, read from DSPSR
-			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 5, 0, 0), &value);
+			retval = dpm->instr_read_data_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 5, 0, 0), &v32);
 			break;
 		case 66: //FPSR
-			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 4, 1, 0), &value);
+			retval = dpm->instr_read_data_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 4, 1, 0), &v32);
 			break;
 		case 67: //FPCR
-			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 4, 0, 0), &value);
+			retval = dpm->instr_read_data_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 4, 0, 0), &v32);
 			break;
 		default:
 			LOG_ERROR("SQU: Reading invalid or not supported reg %d. Will set value to 0xDEADBEEF", regnum);
-			value=0xDEADBEEF;
+			v64=v32=0xDEADBEEF;
 			retval=-1;
 			break;
 	}
 
 	if (retval == ERROR_OK) {
 		if(regnum<33)
-			buf_set_u64(r->value, 0, 64, value);
-		else buf_set_u32(r->value, 0, 32, value);
+		{
+			buf_set_u64(r->value, 0, 64, v64);
+			LOG_DEBUG("READ: %s, 0x%" PRIx64, r->name, v64);
+		}
+		else
+		{
+			buf_set_u32(r->value, 0, 32, v32);
+			LOG_DEBUG("READ: %s, 0x%" PRIx32, r->name, v32);
+		}
 		r->valid = true;
 		r->dirty = false;
-		LOG_DEBUG("READ: %s, 0x%" PRIx64, r->name, value);
 	}
 
 	return retval;
@@ -139,18 +159,19 @@ static int aarch64_dpm_write_reg(struct armv8_dpm *armv8_dpm, struct reg *r, uns
 			break;
 		case 31:
 			//SP
-			retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 6, 4, 1, 0, 0), value);//SP_EL2
+			retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 0, 4, 1, 0, 0), value);//SP_EL0
 			break;
 		case 32: //PC, "MSR X0, DLR_EL0"
 			retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 5, 1, 0), value);
+			break;
 		case 33: //cpsr, write to DSPSR
-			retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 5, 0, 0), value);
+			retval = dpm->instr_write_data_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 5, 0, 0), value);
 			break;
 		case 66: //FPSR
-			retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 4, 1, 0), value);
+			retval = dpm->instr_write_data_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 4, 1, 0), value);
 			break;
 		case 67: //FPCR
-			retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 4, 0, 0), value);
+			retval = dpm->instr_write_data_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 4, 0, 0), value);
 			break;
 		default:
 			LOG_ERROR("SQU: Writing invalid or not supported reg %d. Ignored", regnum);
@@ -291,10 +312,11 @@ int armv8_dpm_write_dirty_registers(struct armv8_dpm *armv8_dpm, bool bpwp)
 {
 	struct arm_dpm *dpm=armv8_dpm->arm_dpm;
 	struct arm *arm = dpm->arm;
-	struct reg_cache *cache = arm->core_cache;
+	struct reg_cache *cache = armv8_dpm->armv8->core_cache;
 	int retval;
 	bool did_write;
 
+	if(!arm->target->is_64b) return arm_dpm_write_dirty_registers(dpm, bpwp);
 	retval = dpm->prepare(dpm);
 	if (retval != ERROR_OK)
 		goto done;
@@ -339,8 +361,6 @@ int armv8_dpm_write_dirty_registers(struct armv8_dpm *armv8_dpm, bool bpwp)
 	 * actually find anything to do...
 	 */
 	do {
-		enum arm_mode mode = ARM_MODE_ANY;
-
 		did_write = false;
 
 		/* check everything except our scratch register R0 */
@@ -349,9 +369,9 @@ int armv8_dpm_write_dirty_registers(struct armv8_dpm *armv8_dpm, bool bpwp)
 			unsigned regnum;
 
 			/* also skip PC, CPSR, and non-dirty */
-			if (i == 15)
+			if (i == 32)
 				continue;
-			if (arm->cpsr == cache->reg_list + i)
+			if (armv8_dpm->armv8->cpsr == cache->reg_list + i)
 				continue;
 			if (!cache->reg_list[i].dirty)
 				continue;
@@ -359,41 +379,6 @@ int armv8_dpm_write_dirty_registers(struct armv8_dpm *armv8_dpm, bool bpwp)
 			r = cache->reg_list[i].arch_info;
 			regnum = r->num;
 
-			/* may need to pick and set a mode */
-			if (!did_write) {
-				enum arm_mode tmode;
-
-				did_write = true;
-				mode = tmode = r->mode;
-
-				/* cope with special cases */
-				switch (regnum) {
-					case 8 ... 12:
-						/* r8..r12 "anything but FIQ" case;
-						 * we "know" core mode is accurate
-						 * since we haven't changed it yet
-						 */
-						if (arm->core_mode == ARM_MODE_FIQ
-							&& ARM_MODE_ANY
-							!= mode)
-							tmode = ARM_MODE_USR;
-						break;
-					case 16:
-						/* SPSR */
-						regnum++;
-						break;
-				}
-
-				/* REVISIT error checks */
-				if (tmode != ARM_MODE_ANY) {
-					retval = armv8_dpm_modeswitch(dpm, tmode);
-					if (retval != ERROR_OK)
-						goto done;
-				}
-			}
-			if (r->mode != mode)
-				continue;
-
 			retval = aarch64_dpm_write_reg(armv8_dpm,
 					&cache->reg_list[i],
 					regnum);
@@ -407,12 +392,12 @@ int armv8_dpm_write_dirty_registers(struct armv8_dpm *armv8_dpm, bool bpwp)
 	 * or it's dirty.  Must write PC to ensure the return address is
 	 * defined, and must not write it before CPSR.
 	 */
-	retval = armv8_dpm_modeswitch(dpm, ARM_MODE_ANY);
+	retval = armv8_dpm_modeswitch(armv8_dpm, ARM_MODE_ANY);
 	if (retval != ERROR_OK)
 		goto done;
 	arm->cpsr->dirty = false;
 
-	retval = aarch64_dpm_write_reg(armv8_dpm, arm->pc, 15);
+	retval = aarch64_dpm_write_reg(armv8_dpm, armv8_dpm->armv8->pc, 32);
 	if (retval != ERROR_OK)
 		goto done;
 	arm->pc->dirty = false;
@@ -495,7 +480,7 @@ static int armv8_dpm_read_core_reg(struct target *target, struct reg *r,
 		return retval;
 
 	if (mode != ARM_MODE_ANY) {
-		retval = armv8_dpm_modeswitch(dpm, mode);
+		retval = armv8_dpm_modeswitch(armv8_dpm, mode);
 		if (retval != ERROR_OK)
 			goto fail;
 	}
@@ -506,7 +491,7 @@ static int armv8_dpm_read_core_reg(struct target *target, struct reg *r,
 	/* always clean up, regardless of error */
 
 	if (mode != ARM_MODE_ANY)
-		/* (void) */ armv8_dpm_modeswitch(dpm, ARM_MODE_ANY);
+		/* (void) */ armv8_dpm_modeswitch(armv8_dpm, ARM_MODE_ANY);
 
 fail:
 	/* (void) */ dpm->finish(dpm);
@@ -540,7 +525,7 @@ static int armv8_dpm_write_core_reg(struct target *target, struct reg *r,
 		return retval;
 
 	if (mode != ARM_MODE_ANY) {
-		retval = armv8_dpm_modeswitch(dpm, mode);
+		retval = armv8_dpm_modeswitch(armv8_dpm, mode);
 		if (retval != ERROR_OK)
 			goto fail;
 	}
@@ -549,7 +534,7 @@ static int armv8_dpm_write_core_reg(struct target *target, struct reg *r,
 	/* always clean up, regardless of error */
 
 	if (mode != ARM_MODE_ANY)
-		/* (void) */ armv8_dpm_modeswitch(dpm, ARM_MODE_ANY);
+		/* (void) */ armv8_dpm_modeswitch(armv8_dpm, ARM_MODE_ANY);
 
 fail:
 	/* (void) */ dpm->finish(dpm);
@@ -601,9 +586,9 @@ static int armv8_dpm_full_context(struct target *target)
 				 * in FIQ mode we need to patch mode.
 				 */
 				if (mode != ARM_MODE_ANY)
-					retval = armv8_dpm_modeswitch(dpm, mode);
+					retval = armv8_dpm_modeswitch(armv8_dpm, mode);
 				else
-					retval = armv8_dpm_modeswitch(dpm, ARM_MODE_USR);
+					retval = armv8_dpm_modeswitch(armv8_dpm, ARM_MODE_USR);
 
 				if (retval != ERROR_OK)
 					goto done;
@@ -621,7 +606,7 @@ static int armv8_dpm_full_context(struct target *target)
 
 	} while (did_read);
 
-	retval = armv8_dpm_modeswitch(dpm, ARM_MODE_ANY);
+	retval = armv8_dpm_modeswitch(armv8_dpm, ARM_MODE_ANY);
 	/* (void) */ dpm->finish(dpm);
 done:
 	return retval;
@@ -853,15 +838,26 @@ void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
 	{
 	case 0x37:
 		LOG_USER("SQU: Exception trigger halt");
+		target->debug_reason = DBG_REASON_UNDEFINED;
+		break;
+	case 0x7:
+		LOG_USER("SQU: Bpt trigger halt");
+		target->debug_reason = DBG_REASON_BREAKPOINT;
+		break;
+	case 0x13:
+		LOG_USER("SQU: Ext debug req trigger halt");
+		target->debug_reason = DBG_REASON_DBGRQ;
 		break;
 	case 0x1B:
 	case 0x1F:
 	case 0x3B:
-		target->debug_reason = DBG_REASON_BREAKPOINT;
+		LOG_USER("SQU: SingleStep trigger halt");
+		target->debug_reason = DBG_REASON_SINGLESTEP;
 		break;
 	default:
 		break;
 	}
+	LOG_USER("SQU: EL=%d, AArch64=%d", (dscr&0x300)>>8, (dscr>>((dscr&0x300)>>8))&1);
 }
 
 /*----------------------------------------------------------------------*/
diff --git a/src/target/armv8_dpm.h b/src/target/armv8_dpm.h
index 26d6a8b..ad87d22 100755
--- a/src/target/armv8_dpm.h
+++ b/src/target/armv8_dpm.h
@@ -111,14 +111,13 @@ struct armv8_dpm {
 int armv8_get_gdb_reg_list(struct target *target,
 		struct reg **reg_list[], int *reg_list_size,
 		enum target_register_class reg_class);
-int armv8_dpm_modeswitch(struct arm_dpm *dpm, enum arm_mode mode);
-int armv8_dpm_read_current_registers(struct armv8_dpm *dpm);
-int armv8_dpm_write_dirty_registers(struct armv8_dpm *dpm, bool bpwp);
+int armv8_dpm_modeswitch(struct armv8_dpm *armv8_dpm, enum arm_mode mode);
+int armv8_dpm_read_current_registers(struct armv8_dpm *armv8_dpm);
+int armv8_dpm_write_dirty_registers(struct armv8_dpm *armv8_dpm, bool bpwp);
 void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr);
 void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr);
 int armv8_dpm_setup(struct armv8_dpm * armv8_dpm);
 int armv8_dpm_initialize(struct armv8_dpm * armv8_dpm);
-void arm_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dcsr);
 
 #if 0
 int arm_dpm_setup(struct arm_dpm *dpm);
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 71fa3ba..dda9a6c 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -145,8 +145,11 @@ static int cortex_a53_restore_cp15_control_reg(struct target *target)
  *  remove apb predictible data abort */
 static int cortex_a53_check_address(struct target *target, uint32_t address)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a53);
+	struct armv8_dpm *armv8_dpm = &armv8_common->armv8.armv8_dpm;
+	struct armv7a_common *armv7a = target_to_armv7a(target);
+
 	uint32_t os_border = armv7a->armv7a_mmu.os_border;
 	if ((address < os_border) &&
 		(armv7a->arm.core_mode == ARM_MODE_SVC)) {
@@ -155,7 +158,7 @@ static int cortex_a53_check_address(struct target *target, uint32_t address)
 	}
 	if ((address >= os_border) &&
 		(cortex_a53->curr_mode != ARM_MODE_SVC)) {
-		armv8_dpm_modeswitch(&armv7a->dpm, ARM_MODE_SVC);
+		armv8_dpm_modeswitch(armv8_dpm, ARM_MODE_SVC);
 		cortex_a53->curr_mode = ARM_MODE_SVC;
 		LOG_INFO("%" PRIx32 " access in kernel space and target not in supervisor",
 			address);
@@ -163,7 +166,7 @@ static int cortex_a53_check_address(struct target *target, uint32_t address)
 	}
 	if ((address < os_border) &&
 		(cortex_a53->curr_mode == ARM_MODE_SVC)) {
-		armv8_dpm_modeswitch(&armv7a->dpm, ARM_MODE_ANY);
+		armv8_dpm_modeswitch(armv8_dpm, ARM_MODE_ANY);
 		cortex_a53->curr_mode = ARM_MODE_ANY;
 	}
 	return ERROR_OK;
@@ -1209,46 +1212,71 @@ static int cortex_a53_halt(struct target *target)
 static int cortex_a53_internal_restore(struct target *target, int current,
 	uint64_t *address, int handle_breakpoints, int debug_execution)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
+	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a);
+	struct armv8 *armv8 = &armv8_common->armv8;
+	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 	struct arm *arm = &armv7a->arm;
 	int retval;
-	uint32_t resume_pc;
 
-	if (!debug_execution)
-		target_free_all_working_areas(target);
+	if(!target->is_64b)
+	{
+		uint32_t resume_pc;
+		if (!debug_execution)
+			target_free_all_working_areas(target);
+
+		/* current = 1: continue on current pc, otherwise continue at <address> */
+		resume_pc = buf_get_u32(arm->pc->value, 0, 32);
+		if (!current)
+			resume_pc = *address;
+		else
+			*address = resume_pc;
 
-//SQUTODO: now address and PC are 64bits
-	/* current = 1: continue on current pc, otherwise continue at <address> */
-	resume_pc = buf_get_u32(arm->pc->value, 0, 32);
-	if (!current)
-		resume_pc = *address;
+		/* Make sure that the Armv7 gdb thumb fixups does not
+		 * kill the return address
+		 */
+		switch (arm->core_state) {
+			case ARM_STATE_ARM:
+				resume_pc &= 0xFFFFFFFC;
+				break;
+			case ARM_STATE_THUMB:
+			case ARM_STATE_THUMB_EE:
+				/* When the return address is loaded into PC
+				 * bit 0 must be 1 to stay in Thumb state
+				 */
+				resume_pc |= 0x1;
+				break;
+			case ARM_STATE_JAZELLE:
+				LOG_ERROR("How do I resume into Jazelle state??");
+				return ERROR_FAIL;
+		}
+		LOG_DEBUG("resume pc = 0x%08" PRIx32, resume_pc);
+		buf_set_u32(arm->pc->value, 0, 32, resume_pc);
+		arm->pc->dirty = 1;
+		arm->pc->valid = 1;
+	}
 	else
-		*address = resume_pc;
+	{
+		//for AArch64 restore
+		uint64_t resume_pc;
+		if (!debug_execution)
+			target_free_all_working_areas(target);
+
+		/* current = 1: continue on current pc, otherwise continue at <address> */
+		resume_pc = buf_get_u64(armv8->pc->value, 0, 64);
+		if (!current)
+			resume_pc = *address;
+		else
+			*address = resume_pc;
 
-	/* Make sure that the Armv7 gdb thumb fixups does not
-	 * kill the return address
-	 */
-	switch (arm->core_state) {
-		case ARM_STATE_ARM:
-			resume_pc &= 0xFFFFFFFC;
-			break;
-		case ARM_STATE_THUMB:
-		case ARM_STATE_THUMB_EE:
-			/* When the return address is loaded into PC
-			 * bit 0 must be 1 to stay in Thumb state
-			 */
-			resume_pc |= 0x1;
-			break;
-		case ARM_STATE_JAZELLE:
-			LOG_ERROR("How do I resume into Jazelle state??");
-			return ERROR_FAIL;
+		LOG_DEBUG("resume pc = 0x%" PRIx64, resume_pc);
+		buf_set_u64(armv8->pc->value, 0, 64, resume_pc);
+		armv8->pc->dirty = 1;
+		armv8->pc->valid = 1;
 	}
-	LOG_DEBUG("resume pc = 0x%08" PRIx32, resume_pc);
-	buf_set_u32(arm->pc->value, 0, 32, resume_pc);
-	arm->pc->dirty = 1;
-	arm->pc->valid = 1;
+
 	/* restore dpm_mode at system halt */
-	armv8_dpm_modeswitch(&armv7a->dpm, ARM_MODE_ANY);
+	armv8_dpm_modeswitch(&armv8_common->armv8.armv8_dpm, ARM_MODE_ANY);
 	/* called it now before restoring context because it uses cpu
 	 * register r0 for restoring cp15 control register */
 	retval = cortex_a53_restore_cp15_control_reg(target);
@@ -1262,6 +1290,7 @@ static int cortex_a53_internal_restore(struct target *target, int current,
 
 	/* registers are now invalid */
 	register_cache_invalidate(arm->core_cache);
+	register_cache_invalidate(armv8->core_cache);
 
 	return retval;
 }
@@ -1692,14 +1721,16 @@ static int cortex_a53_step(struct target *target, int current, uint32_t address,
 
 static int cortex_a53_restore_context(struct target *target, bool bpwp)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
+	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a);
+	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 
 	LOG_DEBUG(" ");
 
 	if (armv7a->pre_restore_context)
 		armv7a->pre_restore_context(target);
 
-	return armv8_dpm_write_dirty_registers(&armv7a->dpm, bpwp);
+	return armv8_dpm_write_dirty_registers(&armv8_common->armv8.armv8_dpm, bpwp);
 }
 
 /*
-- 
1.9.1


From d29fbde26131299efa7d59a2e2acb6c523db7977 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 13/94] fixed a bug for read/write 64bit reg in dpm: should use
 DBGDTR instead of DBGDTRRX and DBGDTRTX.\nSingle step is confirmed working.

---
 src/target/armv8_dpm.c  | 37 +++++++++++-------------------------
 src/target/cortex_a53.c | 50 ++++---------------------------------------------
 2 files changed, 15 insertions(+), 72 deletions(-)

diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index cf92bec..017ff3f 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -65,7 +65,7 @@ int armv8_dpm_modeswitch(struct armv8_dpm *armv8_dpm, enum arm_mode mode)
 	{
 		if (mode == ARM_MODE_ANY) cpsr = buf_get_u32(armv8_dpm->armv8->cpsr->value, 0, 32);
 		else cpsr = mode;
-	 	retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 5, 0, 0), cpsr);
+	 	retval = dpm->instr_write_data_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 5, 0, 0), cpsr);
 		if (retval != ERROR_OK)	return retval;
 	}
 	return retval;
@@ -82,32 +82,18 @@ static int aarch64_dpm_read_reg(struct armv8_dpm *armv8_dpm, struct reg *r, unsi
 	switch (regnum) {
 		case 0 ... 30:
 			/* return via DCC:  "MSR DBGDTRTX_EL0, Xn" */
-			retval = armv8_dpm->instr_read_data64_dcc(dpm, ARMV8_A64_MSR(2, 3, 0, 5, 0, regnum), &v64);
+			retval = armv8_dpm->instr_read_data64_dcc(dpm, ARMV8_A64_MSR(2, 3, 0, 4, 0, regnum), &v64);
 			break;
 		case 31:
 			//SP
 			/*SQU: problem for read SPSel with below code, will get error in EDSCR:
 			retval = dpm->instr_read_data_r0(dpm, ARMV8_A64_MRS(3, 0, 4, 2, 0, 0), &v32);//SPSel is 32bit
-			LOG_USER("SQU: SPSel=0x%x", v32);*/
+			LOG_USER("SQU: SPSel=0x%x", v32); //*/
 			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 0, 4, 1, 0, 0), &v64);//SP_EL0
 			break;
 		case 32:/* PC
 			 * "MSR X0, DLR_EL0"; then return via DCC */
 			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 5, 1, 0), &v64);
-
-			switch (dpm->arm->core_state) {
-				case ARM_STATE_ARM:
-					v64 -= 8;
-					break;
-				case ARM_STATE_THUMB:
-				case ARM_STATE_THUMB_EE:
-					v64 -= 4;
-					break;
-				case ARM_STATE_JAZELLE:
-					/* core-specific ... ? */
-					LOG_WARNING("Jazelle PC adjustment unknown");
-					break;
-			}
 			break;
 		case 33: //cpsr, read from DSPSR
 			retval = dpm->instr_read_data_r0(dpm, ARMV8_A64_MRS(3, 3, 4, 5, 0, 0), &v32);
@@ -155,7 +141,7 @@ static int aarch64_dpm_write_reg(struct armv8_dpm *armv8_dpm, struct reg *r, uns
 	switch (regnum) {
 		case 0 ... 30:
 			/* write via DCC:  "MRS DBGDTRTX_EL0, Xn" */
-			retval = armv8_dpm->instr_write_data64_dcc(dpm, ARMV8_A64_MRS(2, 3, 0, 5, 0, regnum), value);
+			retval = armv8_dpm->instr_write_data64_dcc(dpm, ARMV8_A64_MRS(2, 3, 0, 4, 0, regnum), value);
 			break;
 		case 31:
 			//SP
@@ -224,16 +210,15 @@ int armv8_dpm_read_current_registers(struct armv8_dpm *armv8_dpm)
 	 * cache is set up.  We can't defend against many errors, in
 	 * particular against CPSRs that aren't valid *here* ...
 	 */
-	if (arm->cpsr) {
-		buf_set_u32(arm->cpsr->value, 0, 32, cpsr);
-		arm->cpsr->valid = 1;
-		arm->cpsr->dirty = 0;
+	if (armv8_dpm->armv8->cpsr) {
+		buf_set_u32(armv8_dpm->armv8->cpsr->value, 0, 32, cpsr);
+		armv8_dpm->armv8->cpsr->valid = 1;
+		armv8_dpm->armv8->cpsr->dirty = 0;
 	}
 
-	arm->core_mode = cpsr & 0x1f;
-
+	/*arm->core_mode = cpsr & 0x1f;
 	arm->spsr =  arm->core_cache->reg_list + 34;
-	arm->core_state = ARM_STATE_ARM;
+	arm->core_state = ARM_STATE_ARM;*/
 
 	/* REVISIT we can probably avoid reading R1..R14, saving time... */
 	for (unsigned i = 1; i < 33; i++) {
@@ -857,7 +842,7 @@ void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
 	default:
 		break;
 	}
-	LOG_USER("SQU: EL=%d, AArch64=%d", (dscr&0x300)>>8, (dscr>>((dscr&0x300)>>8))&1);
+	LOG_USER("SQU: EL=%d, AArch64=%d", (dscr&0x300)>>8, (dscr>>(((dscr&0x300)>>8)+10))&1);
 }
 
 /*----------------------------------------------------------------------*/
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index dda9a6c..9142918 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -367,7 +367,8 @@ static int cortex_a53_exec_opcode(struct target *target,
     else if((opcode&0xFF000000)==0xEE000000) //MRC/MCR
     {
         //LOG_USER("SQU: MCR/MRC L=%d cp=%d op1=%d CRn=%d CRm=%d op2=%d Rt=%d", (opcode&0x100000)>>20, (opcode&0xF00)>>8, (opcode&0xE00000)>>21, (opcode&0xF0000)>>16, opcode&0xF,(opcode&0xE0)>>5,(opcode&0xF000)>>12);
-        if(isAArch64(dscr)) //convert MCR/MRC to MSR/MRS
+        //if(isAArch64(dscr)) //convert MCR/MRC to MSR/MRS
+    	if(target->is_64b)
         {
             switch (opcode & 0xEF0FFF)
         	{
@@ -399,7 +400,7 @@ static int cortex_a53_exec_opcode(struct target *target,
     }
     else
     {
-    	LOG_DEBUG("SQU: Assume AArch64 opcode=0x%x", opcode);
+    	if(!target->is_64b) LOG_ERROR("SQU: Exec AArch64 opcode=0x%x for AArch32 state", opcode);
     }
 
 	retval = mem_ap_sel_write_u32(swjdp, armv7a->debug_ap,
@@ -1538,50 +1539,7 @@ static int cortex_a53_debug_entry(struct target *target)
 		target_alloc_working_area(target, 64, &regfile_working_area);*/
 
 	/* First load register acessible through core debug port*/
-	//if (!regfile_working_area)
-		retval = armv8_dpm_read_current_registers(&armv8->armv8.armv8_dpm);
-#if 0
-	else {
-		retval = cortex_a53_read_regs_through_mem(target,
-				regfile_working_area->address, regfile);
-
-		target_free_working_area(target, regfile_working_area);
-		if (retval != ERROR_OK)
-			return retval;
-
-		/* read Current PSR */
-		retval = cortex_a53_dap_read_coreregister_u32(target, &cpsr, 16);
-		/*  store current cpsr */
-		if (retval != ERROR_OK)
-			return retval;
-
-		LOG_DEBUG("cpsr: %8.8" PRIx32, cpsr);
-
-		arm_set_cpsr(arm, cpsr);
-
-		/* update cache */
-		for (i = 0; i <= ARM_PC; i++) {
-			reg = arm_reg_current(arm, i);
-
-			buf_set_u32(reg->value, 0, 32, regfile[i]);
-			reg->valid = 1;
-			reg->dirty = 0;
-		}
-
-		/* Fixup PC Resume Address */
-		if (cpsr & (1 << 5)) {
-			/* T bit set for Thumb or ThumbEE state */
-			regfile[ARM_PC] -= 4;
-		} else {
-			/* ARM state */
-			regfile[ARM_PC] -= 8;
-		}
-
-		reg = arm->pc;
-		buf_set_u32(reg->value, 0, 32, regfile[ARM_PC]);
-		reg->dirty = reg->valid;
-	}
-#endif
+	retval = armv8_dpm_read_current_registers(&armv8->armv8.armv8_dpm);
 	/* Are we in an exception handler */
 	if (armv7a->post_debug_entry) {
 		retval = armv7a->post_debug_entry(target);
-- 
1.9.1


From 5ef52bd3d13ff302ab39bbd0b22d99c32f2ff6ae Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 14/94] previous commit also has a fix for removing the hack
 for fetching PC value. This commit adds back a comment of TODO to mark the
 necessary hack in cortex_a53 code for AArch32

---
 src/target/cortex_a53.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 9142918..3643a8e 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -363,6 +363,7 @@ static int cortex_a53_exec_opcode(struct target *target,
 		//LOG_USER("SQU: ARMv8: read pc");
         if(isAArch64(dscr)) opcode=ARMV8_A64_MRS(3, 3, 4, 5, 1, 0); //MRS R0, DLR_EL0
         else opcode=ARMV8_T32_MRC(15, 3, 0, 4, 5, 1); //change to read DLR
+        //SQU: TODO: might need some hack here to make OpenOCD happy, because of hack in arm_dpm.c::dpm_read_reg
 	}
     else if((opcode&0xFF000000)==0xEE000000) //MRC/MCR
     {
-- 
1.9.1


From 973f276cc83978e18d0fb7c2268c24fe64a37c82 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 15/94] Remvoe ARM mode code for AArch64. AArch64 does not have
 mode for SVC and so on. AArch32 ARM mode is handled in legacy ARM code
 already.

---
 src/target/armv8_dpm.c  | 144 +-----------------------------------------------
 src/target/armv8_dpm.h  |   1 -
 src/target/cortex_a53.c |  20 +++----
 3 files changed, 11 insertions(+), 154 deletions(-)

diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index 017ff3f..4553734 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -35,42 +35,6 @@
  * Register access utilities
  */
 
-/* Toggles between recorded core mode (USR, SVC, etc) and a temporary one.
- * Routines *must* restore the original mode before returning!!
- */
-int armv8_dpm_modeswitch(struct armv8_dpm *armv8_dpm, enum arm_mode mode)
-{
-	int retval;
-	uint32_t cpsr;
-	struct arm_dpm* dpm=armv8_dpm->arm_dpm;
-
-	if(!dpm->arm->target->is_64b)
-	{
-		/* restore previous mode */
-		if (mode == ARM_MODE_ANY)
-			cpsr = buf_get_u32(dpm->arm->cpsr->value, 0, 32);
-
-		/* else force to the specified mode */
-		else
-			cpsr = mode;
-
-		retval = dpm->instr_write_data_r0(dpm, ARMV4_5_MSR_GP(0, 0xf, 0), cpsr);
-		if (retval != ERROR_OK)
-			return retval;
-
-		if (dpm->instr_cpsr_sync)
-			retval = dpm->instr_cpsr_sync(dpm);
-	}
-	else
-	{
-		if (mode == ARM_MODE_ANY) cpsr = buf_get_u32(armv8_dpm->armv8->cpsr->value, 0, 32);
-		else cpsr = mode;
-	 	retval = dpm->instr_write_data_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 5, 0, 0), cpsr);
-		if (retval != ERROR_OK)	return retval;
-	}
-	return retval;
-}
-
 /* just read the register -- rely on the core mode being right */
 static int aarch64_dpm_read_reg(struct armv8_dpm *armv8_dpm, struct reg *r, unsigned regnum)
 {
@@ -377,9 +341,6 @@ int armv8_dpm_write_dirty_registers(struct armv8_dpm *armv8_dpm, bool bpwp)
 	 * or it's dirty.  Must write PC to ensure the return address is
 	 * defined, and must not write it before CPSR.
 	 */
-	retval = armv8_dpm_modeswitch(armv8_dpm, ARM_MODE_ANY);
-	if (retval != ERROR_OK)
-		goto done;
 	arm->cpsr->dirty = false;
 
 	retval = aarch64_dpm_write_reg(armv8_dpm, armv8_dpm->armv8->pc, 32);
@@ -398,45 +359,6 @@ done:
 	return retval;
 }
 
-/* Returns ARM_MODE_ANY or temporary mode to use while reading the
- * specified register ... works around flakiness from ARM core calls.
- * Caller already filtered out SPSR access; mode is never MODE_SYS
- * or MODE_ANY.
- */
-static enum arm_mode dpm_mapmode(struct arm *arm,
-	unsigned num, enum arm_mode mode)
-{
-	enum arm_mode amode = arm->core_mode;
-
-	/* don't switch if the mode is already correct */
-	if (amode == ARM_MODE_SYS)
-		amode = ARM_MODE_USR;
-	if (mode == amode)
-		return ARM_MODE_ANY;
-
-	switch (num) {
-		/* don't switch for non-shadowed registers (r0..r7, r15/pc, cpsr) */
-		case 0 ... 7:
-		case 15:
-		case 16:
-			break;
-		/* r8..r12 aren't shadowed for anything except FIQ */
-		case 8 ... 12:
-			if (mode == ARM_MODE_FIQ)
-				return mode;
-			break;
-		/* r13/sp, and r14/lr are always shadowed */
-		case 13:
-		case 14:
-			return mode;
-		default:
-			LOG_WARNING("invalid register #%u", num);
-			break;
-	}
-	return ARM_MODE_ANY;
-}
-
-
 /*
  * Standard ARM register accessors ... there are three methods
  * in "struct arm", to support individual read/write and bulk read
@@ -454,30 +376,15 @@ static int armv8_dpm_read_core_reg(struct target *target, struct reg *r,
 	if (regnum < 0 || regnum > 32)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	mode = dpm_mapmode(dpm->arm, regnum, mode);
-
-	/* REVISIT what happens if we try to read SPSR in a core mode
-	 * which has no such register?
-	 */
-
 	retval = dpm->prepare(dpm);
 	if (retval != ERROR_OK)
 		return retval;
 
-	if (mode != ARM_MODE_ANY) {
-		retval = armv8_dpm_modeswitch(armv8_dpm, mode);
-		if (retval != ERROR_OK)
-			goto fail;
-	}
-
 	retval = aarch64_dpm_read_reg(armv8_dpm, r, regnum);
 	if (retval != ERROR_OK)
 		goto fail;
 	/* always clean up, regardless of error */
 
-	if (mode != ARM_MODE_ANY)
-		/* (void) */ armv8_dpm_modeswitch(armv8_dpm, ARM_MODE_ANY);
-
 fail:
 	/* (void) */ dpm->finish(dpm);
 	return retval;
@@ -492,35 +399,16 @@ static int armv8_dpm_write_core_reg(struct target *target, struct reg *r,
 	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
 	int retval;
 
-	if (regnum < 0 || regnum > 16)
+	if (regnum < 0 || regnum > 33)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	if (regnum == 16) {
-		if (mode != ARM_MODE_ANY)
-			regnum = 17;
-	} else
-		mode = dpm_mapmode(dpm->arm, regnum, mode);
-
-	/* REVISIT what happens if we try to write SPSR in a core mode
-	 * which has no such register?
-	 */
-
 	retval = dpm->prepare(dpm);
 	if (retval != ERROR_OK)
 		return retval;
 
-	if (mode != ARM_MODE_ANY) {
-		retval = armv8_dpm_modeswitch(armv8_dpm, mode);
-		if (retval != ERROR_OK)
-			goto fail;
-	}
-
 	retval = aarch64_dpm_write_reg(armv8_dpm, r, regnum);
 	/* always clean up, regardless of error */
 
-	if (mode != ARM_MODE_ANY)
-		/* (void) */ armv8_dpm_modeswitch(armv8_dpm, ARM_MODE_ANY);
-
 fail:
 	/* (void) */ dpm->finish(dpm);
 	return retval;
@@ -542,18 +430,7 @@ static int armv8_dpm_full_context(struct target *target)
 		goto done;
 
 	do {
-		enum arm_mode mode = ARM_MODE_ANY;
-
 		did_read = false;
-
-		/* We "know" armv8_dpm_read_current_registers() was called so
-		 * the unmapped registers (R0..R7, PC, AND CPSR) and some
-		 * view of R8..R14 are current.  We also "know" oddities of
-		 * register mapping: special cases for R8..R12 and SPSR.
-		 *
-		 * Pick some mode with unread registers and read them all.
-		 * Repeat until done.
-		 */
 		for (unsigned i = 0; i < cache->num_regs; i++) {
 			struct arm_reg *r;
 
@@ -564,34 +441,17 @@ static int armv8_dpm_full_context(struct target *target)
 			/* may need to pick a mode and set CPSR */
 			if (!did_read) {
 				did_read = true;
-				mode = r->mode;
-
-				/* For regular (ARM_MODE_ANY) R8..R12
-				 * in case we've entered debug state
-				 * in FIQ mode we need to patch mode.
-				 */
-				if (mode != ARM_MODE_ANY)
-					retval = armv8_dpm_modeswitch(armv8_dpm, mode);
-				else
-					retval = armv8_dpm_modeswitch(armv8_dpm, ARM_MODE_USR);
-
-				if (retval != ERROR_OK)
-					goto done;
 			}
-			if (r->mode != mode)
-				continue;
 
-			/* CPSR was read, so "R16" must mean SPSR */
 			retval = aarch64_dpm_read_reg(armv8_dpm,
 					&cache->reg_list[i],
-					(r->num == 16) ? 17 : r->num);
+					r->num);
 			if (retval != ERROR_OK)
 				goto done;
 		}
 
 	} while (did_read);
 
-	retval = armv8_dpm_modeswitch(armv8_dpm, ARM_MODE_ANY);
 	/* (void) */ dpm->finish(dpm);
 done:
 	return retval;
diff --git a/src/target/armv8_dpm.h b/src/target/armv8_dpm.h
index ad87d22..160c524 100755
--- a/src/target/armv8_dpm.h
+++ b/src/target/armv8_dpm.h
@@ -111,7 +111,6 @@ struct armv8_dpm {
 int armv8_get_gdb_reg_list(struct target *target,
 		struct reg **reg_list[], int *reg_list_size,
 		enum target_register_class reg_class);
-int armv8_dpm_modeswitch(struct armv8_dpm *armv8_dpm, enum arm_mode mode);
 int armv8_dpm_read_current_registers(struct armv8_dpm *armv8_dpm);
 int armv8_dpm_write_dirty_registers(struct armv8_dpm *armv8_dpm, bool bpwp);
 void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr);
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 3643a8e..cbe5708 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -145,10 +145,8 @@ static int cortex_a53_restore_cp15_control_reg(struct target *target)
  *  remove apb predictible data abort */
 static int cortex_a53_check_address(struct target *target, uint32_t address)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a53);
-	struct armv8_dpm *armv8_dpm = &armv8_common->armv8.armv8_dpm;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
 
 	uint32_t os_border = armv7a->armv7a_mmu.os_border;
 	if ((address < os_border) &&
@@ -157,17 +155,17 @@ static int cortex_a53_check_address(struct target *target, uint32_t address)
 		return ERROR_FAIL;
 	}
 	if ((address >= os_border) &&
-		(cortex_a53->curr_mode != ARM_MODE_SVC)) {
-		armv8_dpm_modeswitch(armv8_dpm, ARM_MODE_SVC);
-		cortex_a53->curr_mode = ARM_MODE_SVC;
+		(cortex_a->curr_mode != ARM_MODE_SVC)) {
+		dpm_modeswitch(&armv7a->dpm, ARM_MODE_SVC);
+		cortex_a->curr_mode = ARM_MODE_SVC;
 		LOG_INFO("%" PRIx32 " access in kernel space and target not in supervisor",
 			address);
 		return ERROR_OK;
 	}
 	if ((address < os_border) &&
-		(cortex_a53->curr_mode == ARM_MODE_SVC)) {
-		armv8_dpm_modeswitch(armv8_dpm, ARM_MODE_ANY);
-		cortex_a53->curr_mode = ARM_MODE_ANY;
+		(cortex_a->curr_mode == ARM_MODE_SVC)) {
+		dpm_modeswitch(&armv7a->dpm, ARM_MODE_ANY);
+		cortex_a->curr_mode = ARM_MODE_ANY;
 	}
 	return ERROR_OK;
 }
@@ -1256,6 +1254,8 @@ static int cortex_a53_internal_restore(struct target *target, int current,
 		buf_set_u32(arm->pc->value, 0, 32, resume_pc);
 		arm->pc->dirty = 1;
 		arm->pc->valid = 1;
+		/* restore dpm_mode at system halt */
+		dpm_modeswitch(arm->dpm, ARM_MODE_ANY);
 	}
 	else
 	{
@@ -1277,8 +1277,6 @@ static int cortex_a53_internal_restore(struct target *target, int current,
 		armv8->pc->valid = 1;
 	}
 
-	/* restore dpm_mode at system halt */
-	armv8_dpm_modeswitch(&armv8_common->armv8.armv8_dpm, ARM_MODE_ANY);
 	/* called it now before restoring context because it uses cpu
 	 * register r0 for restoring cp15 control register */
 	retval = cortex_a53_restore_cp15_control_reg(target);
-- 
1.9.1


From 7c4187cb50840c71c93536bda16364b31221fec4 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 16/94] update breakpoint support for AArch64. Now h/w
 breakpoint is working. For s/w breakpoint, need to verify

---
 src/target/armv8.c       |  3 +++
 src/target/armv8_dpm.c   |  4 ++--
 src/target/cortex_a53.c  | 30 +++++++++---------------------
 src/target/target_type.h |  4 ++--
 4 files changed, 16 insertions(+), 25 deletions(-)

diff --git a/src/target/armv8.c b/src/target/armv8.c
index cca8b74..9be28f3 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -15,6 +15,7 @@
 #include "armv8.h"
 
 #define keep_old_code 0
+#define WITH_FPU 1
 
 static const struct {
 	const char *name;
@@ -189,6 +190,7 @@ static const struct {
 	{ .name = "sp", .cookie = 31, .mode = AARCH64_MODE_ANY, .gdb_index = 31, },
 	{ .name = "pc", .cookie = 32, .mode = AARCH64_MODE_ANY, .gdb_index = 32, },
 	{ .name = "cpsr", .cookie = 33, .mode = AARCH64_MODE_ANY, .gdb_index = 33, },
+#if WITH_FPU
 	{ .name = "v0", .cookie = 34, .mode = AARCH64_MODE_ANY, .gdb_index = 34, },
 	{ .name = "v1", .cookie = 35, .mode = AARCH64_MODE_ANY, .gdb_index = 35, },
 	{ .name = "v2", .cookie = 36, .mode = AARCH64_MODE_ANY, .gdb_index = 36, },
@@ -223,6 +225,7 @@ static const struct {
 	{ .name = "v31", .cookie = 65, .mode = AARCH64_MODE_ANY, .gdb_index = 65, },
 	{ .name = "fpsr", .cookie = 66, .mode = AARCH64_MODE_ANY, .gdb_index = 66, },
 	{ .name = "fpcr", .cookie = 67, .mode = AARCH64_MODE_ANY, .gdb_index = 67, },
+#endif
 };
 
 #if use_old_code
diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index 4553734..fd72fad 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -739,13 +739,13 @@ int armv8_dpm_setup(struct armv8_dpm * armv8_dpm)
 
 
 	/* breakpoint setup -- optional until it works everywhere */
-	if (!target->type->add_breakpoint) {
+	/*if (!target->type->add_breakpoint) {
 		target->type->add_breakpoint = dpm_add_breakpoint;
 		target->type->remove_breakpoint = dpm_remove_breakpoint;
 	}
 
 	/* watchpoint setup */
-	target->type->add_watchpoint = dpm_add_watchpoint;
+	/*target->type->add_watchpoint = dpm_add_watchpoint;
 	target->type->remove_watchpoint = dpm_remove_watchpoint;
 
 	/* FIXME add vector catch support */
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index cbe5708..ff8087b 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -361,8 +361,7 @@ static int cortex_a53_exec_opcode(struct target *target,
 		//LOG_USER("SQU: ARMv8: read pc");
         if(isAArch64(dscr)) opcode=ARMV8_A64_MRS(3, 3, 4, 5, 1, 0); //MRS R0, DLR_EL0
         else opcode=ARMV8_T32_MRC(15, 3, 0, 4, 5, 1); //change to read DLR
-        //SQU: TODO: might need some hack here to make OpenOCD happy, because of hack in arm_dpm.c::dpm_read_reg
-	}
+ 	}
     else if((opcode&0xFF000000)==0xEE000000) //MRC/MCR
     {
         //LOG_USER("SQU: MCR/MRC L=%d cp=%d op1=%d CRn=%d CRm=%d op2=%d Rt=%d", (opcode&0x100000)>>20, (opcode&0xF00)>>8, (opcode&0xE00000)>>21, (opcode&0xF0000)>>16, opcode&0xF,(opcode&0xE0)>>5,(opcode&0xF000)>>12);
@@ -862,7 +861,7 @@ static int cortex_a53_instr_read_data64_r0(struct arm_dpm *dpm,
     if(opcode==0xE1A0000F)
 	{//in case of MOV r0, pc
 		LOG_DEBUG("SQU: ARMv8: read pc= 0x%" PRIx64, tmp);
-		if(dpm->arm->core_state==ARM_STATE_ARM) //SQU: adjust PC to make OOCD happy
+		if(dpm->arm->core_state==ARM_STATE_ARM) //SQU: adjust PC to make OOCD happy, because of hack in arm_dpm.c::dpm_read_reg
 		{
 			tmp += 8;
 		}
@@ -1157,7 +1156,7 @@ static int cortex_a53_halt(struct target *target)
 		target->is_64b=false;
 		target->type->arch_state=armv7a_arch_state;
 	}
-	/*remote below hack. Changing state should be a request from gdb client, but not forced here
+	/*remove below hack. Changing state should be a request from gdb client, but not forced here
 	if(target->is_64b)
 	{
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 1, 1, 0, 0), &dummy); //read SCR_EL3 to X0
@@ -1311,9 +1310,9 @@ static int cortex_a53_internal_restart(struct target *target)
 	 * disable IRQs by default, with optional override...
 	 */
     /* SQU: for ARMv8, need to do acknowledge halt event then trigger restart */
-	/*retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTITRIGOUTSTATUS, &dummy);
-	LOG_USER("Before CTI ACK: DSCR= 0x%x  CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);*/
+	LOG_USER("SQU Before CTI ACK: DSCR= 0x%x  CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);
 	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINTACK, 1);
 
 	long long then = timeval_ms();
@@ -1328,31 +1327,19 @@ static int cortex_a53_internal_restart(struct target *target)
 			return ERROR_FAIL;
 		}
 	}
-	//cortex_a53_exec_opcode(target, 0x8F00F3DE, &dscr); //DRPS/ERET
 	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
 			armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		return retval;
-	//LOG_USER("After CTI ACK: DSCR= 0x%x; CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);
+	LOG_USER("SQU After CTI ACK: DSCR= 0x%x; CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);
 
 	if ((dscr & DSCR_INSTR_COMP) == 0)
 		LOG_ERROR("DSCR InstrCompl must be set before leaving debug!");
 
-	/*retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDPRSR, &dummy);
-	LOG_USER("Before restart: EDPRSR= 0x%" PRIx32, dummy);*/
-
-	//set EDECCR after restart but before restart, then always trigger halt after restart?
-	/*dummy = 8;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECCR, dummy);*/
-
 	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIAPPPULSE, 1<<CTIDBGCHAN_RESTART);
 	if (retval != ERROR_OK)
 		return retval;
 
-	//set EDECCR after restart but before check, might still too late
-	/*dummy = 8;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECCR, dummy);*/
-
 	then = timeval_ms();
 	for (;; ) {
 		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
@@ -1366,9 +1353,9 @@ static int cortex_a53_internal_restart(struct target *target)
 			return ERROR_FAIL;
 		}
 	}
-	/*retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDPRSR, &dummy);
-	LOG_USER("After restart: DSCR= 0x%x EDPRSR= 0x%" PRIx32, dscr, dummy);*/
+	LOG_USER("Successfully restart with DSCR= 0x%x EDPRSR= 0x%" PRIx32, dscr, dummy);
 	//for AArch32: dump DFSR, HSR, DFAR, HDAR, HPFAR
 	//HSR: MRC p15,4,<Rt>,c5,c2,0
 	/*retval = armv7a->arm.mrc(target, 15, 4, 0, 5, 2, &dummy);
@@ -1724,6 +1711,7 @@ static int cortex_a53_set_breakpoint(struct target *target,
 		control = ((matchmode & 0x7) << 20)
 			| (byte_addr_select << 5)
 			| (3 << 1) | 1;
+		if(target->is_64b) control |= 1<<13;
 		brp_list[brp_i].used = 1;
 		brp_list[brp_i].value = (breakpoint->address & 0xFFFFFFFC);
 		brp_list[brp_i].control = control;
diff --git a/src/target/target_type.h b/src/target/target_type.h
index 3df999c..a32b0e6 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -119,8 +119,8 @@ struct target_type {
 	 */
 	int (*read_memory)(struct target *target, uint32_t address,
 			uint32_t size, uint32_t count, uint8_t *buffer);
-	int (*read_memory_64)(struct target *target, uint32_t address,
-			uint32_t size, uint32_t count, uint8_t *buffer);
+	int (*read_memory_64)(struct target *target, uint64_t address,
+			uint64_t size, uint64_t count, uint8_t *buffer);
 	/**
 	 * Target memory write callback.  Do @b not call this function
 	 * directly, use target_write_memory() instead.
-- 
1.9.1


From f1fa16872ba36ec3df287eb19dbc85905f178259 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 17/94] remove some logging to avoid flooding to gdb

---
 src/target/cortex_a53.c | 186 ++----------------------------------------------
 1 file changed, 4 insertions(+), 182 deletions(-)

diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index ff8087b..70b36e6 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -431,184 +431,6 @@ static int cortex_a53_exec_opcode(struct target *target,
 	return retval;
 }
 
-#if 0
-/**************************************************************************
-Read core register with very few exec_opcode, fast but needs work_area.
-This can cause problems with MMU active.
-**************************************************************************/
-static int cortex_a53_read_regs_through_mem(struct target *target, uint32_t address,
-	uint32_t *regfile)
-{
-	int retval = ERROR_OK;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-
-    LOG_ERROR("SQU: current code might have issue to handle STMIA");
-
-	retval = cortex_a53_dap_read_coreregister_u32(target, regfile, 0);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = cortex_a53_dap_write_coreregister_u32(target, address, 0);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = cortex_a53_exec_opcode(target, ARMV4_5_STMIA(0, 0xFFFE, 0, 0), NULL);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = mem_ap_sel_read_buf(swjdp, armv7a->memory_ap,
-			(uint8_t *)(&regfile[1]), 4, 15, address);
-
-	return retval;
-}
-
-static int cortex_a53_dap_read_coreregister_u32(struct target *target,
-	uint32_t *value, int regnum)
-{
-	int retval = ERROR_OK;
-	uint8_t reg = regnum&0xFF;
-	uint32_t dscr = 0;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-
-    if(!target->is_64b)
-    {
-	    if (reg > 17)
-		    return retval;
-
-	    if (reg < 15) {
-		    /* Rn to DCCTX, "MCR p14, 0, Rn, c0, c5, 0"  0xEE00nE15 */
-		    retval = cortex_a53_exec_opcode(target,
-				    ARMV4_5_MCR(14, 0, reg, 0, 5, 0),
-				    &dscr);
-		    if (retval != ERROR_OK)
-			    return retval;
-	    } else if (reg == 15) {
-		    /* "MOV r0, r15"; then move r0 to DCCTX */
-		    retval = cortex_a53_exec_opcode(target, 0xE1A0000F, &dscr);
-		    if (retval != ERROR_OK)
-			    return retval;
-		    retval = cortex_a53_exec_opcode(target,
-				    ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
-				    &dscr);
-		    if (retval != ERROR_OK)
-			    return retval;
-	    } else {
-		    /* "MRS r0, CPSR" or "MRS r0, SPSR"
-		     * then move r0 to DCCTX
-		     */
-		    retval = cortex_a53_exec_opcode(target, ARMV4_5_MRS(0, reg & 1), &dscr);
-		    if (retval != ERROR_OK)
-			    return retval;
-		    retval = cortex_a53_exec_opcode(target,
-				    ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
-				    &dscr);
-		    if (retval != ERROR_OK)
-			    return retval;
-	    }
-    }
-    else //AArch64
-    {
-        add code
-    }
-	/* Wait for DTRRXfull then read DTRRTX */
-	long long then = timeval_ms();
-	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		if (timeval_ms() > then + 1000) {
-			LOG_ERROR("Timeout waiting for cortex_a53_exec_opcode");
-			return ERROR_FAIL;
-		}
-	}
-
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DTRTX, value);
-	LOG_DEBUG("read DCC 0x%08" PRIx32, *value);
-
-	return retval;
-}
-
-static int cortex_a53_dap_write_coreregister_u32(struct target *target,
-	uint32_t value, int regnum)
-{
-	int retval = ERROR_OK;
-	uint8_t Rd = regnum&0xFF;
-	uint32_t dscr;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-
-	LOG_DEBUG("register %i, value 0x%08" PRIx32, regnum, value);
-
-	/* Check that DCCRX is not full */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
-	if (retval != ERROR_OK)
-		return retval;
-	if (dscr & DSCR_DTR_RX_FULL) {
-		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
-		/* Clear DCCRX with MRC(p14, 0, Rd, c0, c5, 0), opcode  0xEE100E15 */
-		retval = cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	if (Rd > 17)
-		return retval;
-
-	/* Write DTRRX ... sets DSCR.DTRRXfull but exec_opcode() won't care */
-	LOG_DEBUG("write DCC 0x%08" PRIx32, value);
-	retval = mem_ap_sel_write_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DTRRX, value);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (Rd < 15) {
-		/* DCCRX to Rn, "MRC p14, 0, Rn, c0, c5, 0", 0xEE10nE15 */
-		retval = cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, Rd, 0, 5, 0),
-				&dscr);
-
-		if (retval != ERROR_OK)
-			return retval;
-	} else if (Rd == 15) {
-		/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15
-		 * then "mov r15, r0"
-		 */
-		retval = cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a53_exec_opcode(target, 0xE1A0F000, &dscr);
-		if (retval != ERROR_OK)
-			return retval;
-	} else {
-		/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15
-		 * then "MSR CPSR_cxsf, r0" or "MSR SPSR_cxsf, r0" (all fields)
-		 */
-		retval = cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a53_exec_opcode(target, ARMV4_5_MSR_GP(0, 0xF, Rd & 1),
-				&dscr);
-		if (retval != ERROR_OK)
-			return retval;
-
-		/* "Prefetch flush" after modifying execution status in CPSR */
-		if (Rd == 16) {
-			retval = cortex_a53_exec_opcode(target,
-					ARMV4_5_MCR(15, 0, 0, 7, 5, 4),
-					&dscr);
-			if (retval != ERROR_OK)
-				return retval;
-		}
-	}
-
-	return retval;
-}
-#endif
 
 /* Write to memory mapped registers directly with no cache or mmu handling */
 static int cortex_a53_dap_write_memap_register_u32(struct target *target,
@@ -1310,9 +1132,9 @@ static int cortex_a53_internal_restart(struct target *target)
 	 * disable IRQs by default, with optional override...
 	 */
     /* SQU: for ARMv8, need to do acknowledge halt event then trigger restart */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	/*retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTITRIGOUTSTATUS, &dummy);
-	LOG_USER("SQU Before CTI ACK: DSCR= 0x%x  CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);
+	LOG_USER("SQU Before CTI ACK: DSCR= 0x%x  CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);*/
 	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINTACK, 1);
 
 	long long then = timeval_ms();
@@ -1331,7 +1153,7 @@ static int cortex_a53_internal_restart(struct target *target)
 			armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		return retval;
-	LOG_USER("SQU After CTI ACK: DSCR= 0x%x; CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);
+	//LOG_USER("SQU After CTI ACK: DSCR= 0x%x; CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);
 
 	if ((dscr & DSCR_INSTR_COMP) == 0)
 		LOG_ERROR("DSCR InstrCompl must be set before leaving debug!");
@@ -1355,7 +1177,7 @@ static int cortex_a53_internal_restart(struct target *target)
 	}
 	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
 	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDPRSR, &dummy);
-	LOG_USER("Successfully restart with DSCR= 0x%x EDPRSR= 0x%" PRIx32, dscr, dummy);
+	//LOG_USER("Successfully restart with DSCR= 0x%x EDPRSR= 0x%" PRIx32, dscr, dummy);
 	//for AArch32: dump DFSR, HSR, DFAR, HDAR, HPFAR
 	//HSR: MRC p15,4,<Rt>,c5,c2,0
 	/*retval = armv7a->arm.mrc(target, 15, 4, 0, 5, 2, &dummy);
-- 
1.9.1


From c4b5a46d5d08208a42b70574bd57443b63c45a2c Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 18/94] fix buffer read/write size and count parameter type as
 OpenOCD expecting the size for byte/word/dword but not any other value. So it
 has to be 1/2/4.

---
 src/target/armv8_dpm.c   | 10 +++++-----
 src/target/cortex_a53.c  | 14 +++++++-------
 src/target/target_type.h |  8 ++++----
 3 files changed, 16 insertions(+), 16 deletions(-)

diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index fd72fad..8912eef 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -682,27 +682,27 @@ void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
 	switch(dscr & 0x3F)
 	{
 	case 0x37:
-		LOG_USER("SQU: Exception trigger halt");
+		LOG_INFO("SQU: Exception trigger halt");
 		target->debug_reason = DBG_REASON_UNDEFINED;
 		break;
 	case 0x7:
-		LOG_USER("SQU: Bpt trigger halt");
+		LOG_INFO("SQU: Bpt trigger halt");
 		target->debug_reason = DBG_REASON_BREAKPOINT;
 		break;
 	case 0x13:
-		LOG_USER("SQU: Ext debug req trigger halt");
+		LOG_INFO("SQU: Ext debug req trigger halt");
 		target->debug_reason = DBG_REASON_DBGRQ;
 		break;
 	case 0x1B:
 	case 0x1F:
 	case 0x3B:
-		LOG_USER("SQU: SingleStep trigger halt");
+		LOG_INFO("SQU: SingleStep trigger halt");
 		target->debug_reason = DBG_REASON_SINGLESTEP;
 		break;
 	default:
 		break;
 	}
-	LOG_USER("SQU: EL=%d, AArch64=%d", (dscr&0x300)>>8, (dscr>>(((dscr&0x300)>>8)+10))&1);
+	LOG_INFO("SQU: EL=%d, AArch64=%d", (dscr&0x300)>>8, (dscr>>(((dscr&0x300)>>8)+10))&1);
 }
 
 /*----------------------------------------------------------------------*/
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 70b36e6..a4a4d4e 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -2278,7 +2278,7 @@ error_free_buff_r:
  */
 
 static int cortex_a53_read_phys_memory_64(struct target *target,
-	uint64_t address, uint64_t size,
+	uint64_t address, uint32_t size,
 	uint64_t count, uint8_t *buffer)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
@@ -2321,7 +2321,7 @@ static int cortex_a53_read_phys_memory(struct target *target,
 }
 
 static int cortex_a53_read_memory_64(struct target *target, uint64_t address,
-	uint64_t size, uint64_t count, uint8_t *buffer)
+	uint32_t size, uint64_t count, uint8_t *buffer)
 {
 	int mmu_enabled = 0;
 	uint64_t virt, phys;
@@ -2381,11 +2381,11 @@ static int cortex_a53_read_memory(struct target *target, uint32_t address,
 
 static int cortex_a53_read_buffer_64(struct target *target, uint64_t address, uint64_t size, uint8_t *buffer)
 {
-	return cortex_a53_read_memory_64(target, address, size, 1, buffer);
+	return cortex_a53_read_memory_64(target, address, 1, size, buffer);
 }
 
 static int cortex_a53_write_phys_memory_64(struct target *target,
-	uint64_t address, uint64_t size,
+	uint64_t address, uint32_t size,
 	uint64_t count, const uint8_t *buffer)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
@@ -2480,7 +2480,7 @@ static int cortex_a53_write_phys_memory(struct target *target,
 }
 
 static int cortex_a53_write_memory_64(struct target *target, uint64_t address,
-	uint64_t size, uint64_t count, const uint8_t *buffer)
+	uint32_t size, uint64_t count, const uint8_t *buffer)
 {
 	int mmu_enabled = 0;
 	uint64_t virt, phys;
@@ -2512,7 +2512,7 @@ static int cortex_a53_write_memory_64(struct target *target, uint64_t address,
 				  phys);
 			address = phys;
 		}
-		retval = cortex_a53_write_phys_memory(target, address, size,
+		retval = cortex_a53_write_phys_memory_64(target, address, size,
 				count, buffer);
 	} else {
 		if (mmu_enabled) {
@@ -2537,7 +2537,7 @@ static int cortex_a53_write_memory(struct target *target, uint32_t address,
 
 static int cortex_a53_write_buffer_64(struct target *target, uint64_t address, uint64_t size, const uint8_t *buffer)
 {
-	return cortex_a53_write_memory(target, address, size, 1, buffer);
+	return cortex_a53_write_memory_64(target, address, 1, size, buffer);
 }
 
 static int cortex_a53_handle_target_request(void *priv)
diff --git a/src/target/target_type.h b/src/target/target_type.h
index a32b0e6..e249875 100644
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -120,7 +120,7 @@ struct target_type {
 	int (*read_memory)(struct target *target, uint32_t address,
 			uint32_t size, uint32_t count, uint8_t *buffer);
 	int (*read_memory_64)(struct target *target, uint64_t address,
-			uint64_t size, uint64_t count, uint8_t *buffer);
+			uint32_t size, uint64_t count, uint8_t *buffer);
 	/**
 	 * Target memory write callback.  Do @b not call this function
 	 * directly, use target_write_memory() instead.
@@ -128,7 +128,7 @@ struct target_type {
 	int (*write_memory)(struct target *target, uint32_t address,
 			uint32_t size, uint32_t count, const uint8_t *buffer);
 	int (*write_memory_64)(struct target *target, uint64_t address,
-			uint64_t size, uint64_t count, const uint8_t *buffer);
+			uint32_t size, uint64_t count, const uint8_t *buffer);
 
 	/* Default implementation will do some fancy alignment to improve performance, target can override */
 	int (*read_buffer)(struct target *target, uint32_t address,
@@ -254,7 +254,7 @@ struct target_type {
 	int (*read_phys_memory)(struct target *target, uint32_t phys_address,
 			uint32_t size, uint32_t count, uint8_t *buffer);
 	int (*read_phys_memory_64)(struct target *target, uint64_t phys_address,
-			uint64_t size, uint64_t count, uint8_t *buffer);
+			uint32_t size, uint64_t count, uint8_t *buffer);
 
 	/*
 	 * same as read_phys_memory, except that it writes...
@@ -262,7 +262,7 @@ struct target_type {
 	int (*write_phys_memory)(struct target *target, uint32_t phys_address,
 			uint32_t size, uint32_t count, const uint8_t *buffer);
 	int (*write_phys_memory_64)(struct target *target, uint64_t phys_address,
-			uint64_t size, uint64_t count, const uint8_t *buffer);
+			uint32_t size, uint64_t count, const uint8_t *buffer);
 
 	int (*mmu)(struct target *target, int *enabled);
 
-- 
1.9.1


From 506cc44c1d3ea14a66a662ac53768638cdb2cd73 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 19/94] Update arm mode code for AArch64 to print out state
 properly. Update log message to avoid flooding debug message.

---
 src/target/armv8.c      |  8 +++++---
 src/target/armv8_dpm.c  | 10 +++++-----
 src/target/cortex_a53.c | 22 ++++++++++++----------
 3 files changed, 22 insertions(+), 18 deletions(-)

diff --git a/src/target/armv8.c b/src/target/armv8.c
index 9be28f3..3823db8 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -457,17 +457,19 @@ int armv8_arch_state(struct target *target)
     struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a53);
     struct armv8 *armv8 = &armv8_common->armv8;
 	struct arm *arm = armv8->arm;
+	uint32_t cpsr;
+
 	if(!target->is_64b) return arm_arch_state(target);
 	if (arm->common_magic != ARM_COMMON_MAGIC) {
 		LOG_ERROR("BUG: called for a non-ARM target");
 		return ERROR_FAIL;
 	}
-
+	cpsr=buf_get_u32(armv8->cpsr->value, 0, 32);
 	LOG_USER("target halted in AArch64 state due to %s, current mode: %s\n"
 		"cpsr: 0x%8.8" PRIx32 " pc: 0x%" PRIx64 "%s",
 		debug_reason_name(target),
-		aarch64_mode_name(arm->core_mode),
-		buf_get_u32(armv8->cpsr->value, 0, 32),
+		aarch64_mode_name(cpsr & 0xF),
+		cpsr,
 		buf_get_u64(armv8->pc->value, 0, 64),
 		arm->is_semihosting ? ", semihosting" : "");
 
diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index 8912eef..9f9b889 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -682,27 +682,27 @@ void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
 	switch(dscr & 0x3F)
 	{
 	case 0x37:
-		LOG_INFO("SQU: Exception trigger halt");
+		LOG_DEBUG("SQU: Exception trigger halt");
 		target->debug_reason = DBG_REASON_UNDEFINED;
 		break;
 	case 0x7:
-		LOG_INFO("SQU: Bpt trigger halt");
+		LOG_DEBUG("SQU: Bpt trigger halt");
 		target->debug_reason = DBG_REASON_BREAKPOINT;
 		break;
 	case 0x13:
-		LOG_INFO("SQU: Ext debug req trigger halt");
+		LOG_DEBUG("SQU: Ext debug req trigger halt");
 		target->debug_reason = DBG_REASON_DBGRQ;
 		break;
 	case 0x1B:
 	case 0x1F:
 	case 0x3B:
-		LOG_INFO("SQU: SingleStep trigger halt");
+		LOG_DEBUG("SQU: SingleStep trigger halt");
 		target->debug_reason = DBG_REASON_SINGLESTEP;
 		break;
 	default:
 		break;
 	}
-	LOG_INFO("SQU: EL=%d, AArch64=%d", (dscr&0x300)>>8, (dscr>>(((dscr&0x300)>>8)+10))&1);
+	LOG_DEBUG("SQU: EL=%d, AArch64=%d", (dscr&0x300)>>8, (dscr>>(((dscr&0x300)>>8)+10))&1);
 }
 
 /*----------------------------------------------------------------------*/
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index a4a4d4e..2a84ccd 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -320,7 +320,7 @@ static int cortex_a53_exec_opcode(struct target *target,
 
 	//SQU: why not just read it? dscr = dscr_p ? *dscr_p : 0;
 	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
-	LOG_DEBUG("exec opcode 0x%08" PRIx32, opcode);
+	LOG_DEBUG("exec opcode=0x%08X as AArch64=%d (dscr=0x%08X)", opcode, isAArch64(dscr), dscr);
 
 	/* Wait for InstrCompl bit to be set */
 	long long then = timeval_ms();
@@ -386,11 +386,14 @@ static int cortex_a53_exec_opcode(struct target *target,
         		//coding: MSR/MRS|			L			|		cp			 |			op1			|			CRn		  |		CRm			|	op2		  |  Xt
         		opcode=0xD5100000|((opcode&0x100000)<<1)|((opcode&0x100)<<11)|((opcode&0xE00000)>>5)|((opcode&0xF0000)>>4)|((opcode&0xF)<<8)|(opcode&0xE0)|((opcode&0xF000)>>12);
             	break;
+        	case 0x70F35: //ICIMVAU
+        		opcode=0xD50B7520;
+        		break;
         	case 0x70F95: //CP15ISB
         		opcode=0xD5033FDF; //ISB CRm=b'1111
         		break;
         	default:
-        		LOG_USER("SQU: Need to handle MCR/MRC opcode=0x%x", opcode);
+        		LOG_ERROR("SQU: Need to handle MCR/MRC opcode=0x%x", opcode);
         		break;
         	}
         }
@@ -1977,7 +1980,7 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 	uint32_t dscr;
 	uint8_t *tmp_buff = NULL;
 
-	LOG_DEBUG("Writing APB-AP memory address 0x%" PRIx32 " size %"  PRIu32 " count%"  PRIu32,
+	LOG_DEBUG("Writing APB-AP memory address 0x%" PRIx32 " size %d"  PRIu32 " count%"  PRIu32,
 			  address, size, count);
 	if (target->state != TARGET_HALTED) {
 		LOG_WARNING("target not halted");
@@ -2134,7 +2137,7 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 	uint8_t buf[8];
 	uint8_t *u8buf_ptr;
 
-	LOG_DEBUG("Reading APB-AP memory address 0x%" PRIx32 " size %"  PRIu32 " count%"  PRIu32,
+	LOG_DEBUG("Reading APB-AP memory address 0x%" PRIx32 " size %d"  PRIu32 " count%"  PRIu32,
 			  address, size, count);
 	if (target->state != TARGET_HALTED) {
 		LOG_WARNING("target not halted");
@@ -2285,7 +2288,7 @@ static int cortex_a53_read_phys_memory_64(struct target *target,
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
 	uint8_t apsel = swjdp->apsel;
-	LOG_DEBUG("Reading memory at real address 0x%" PRIx64 "; size %" PRId64 "; count %" PRId64,
+	LOG_DEBUG("Reading memory at real address 0x%" PRIx64 "; size %d; count %" PRId64,
 		address, size, count);
 
 	if (count && buffer) {
@@ -2331,8 +2334,7 @@ static int cortex_a53_read_memory_64(struct target *target, uint64_t address,
 	uint8_t apsel = swjdp->apsel;
 
 	/* cortex_a53 handles unaligned memory access */
-	LOG_DEBUG("Reading memory at address 0x%" PRIx64 "; size %" PRId64 "; count %" PRId64, address,
-		size, count);
+	LOG_DEBUG("Reading memory at address 0x%" PRIx64 "; size %d; count %" PRId64, address, size, count);
 
 	/* determine if MMU was enabled on target stop */
 	retval = cortex_a53_mmu(target, &mmu_enabled);
@@ -2393,7 +2395,7 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
 	uint8_t apsel = swjdp->apsel;
 
-	LOG_DEBUG("Writing memory to real address 0x%" PRIx64 "; size %" PRId64 "; count %" PRId64, address,
+	LOG_DEBUG("Writing memory to real address 0x%" PRIx64 "; size %d; count %" PRId64, address,
 		size, count);
 
 	if (count && buffer) {
@@ -2490,7 +2492,7 @@ static int cortex_a53_write_memory_64(struct target *target, uint64_t address,
 	uint8_t apsel = swjdp->apsel;
 
 	/* cortex_a53 handles unaligned memory access */
-	LOG_DEBUG("Writing memory at address 0x%" PRIx64 "; size %" PRId64 "; count %" PRId64, address,
+	LOG_DEBUG("Writing memory at address 0x%" PRIx64 "; size %d; count %" PRId64, address,
 		size, count);
 
 	/* determine if MMU was enabled on target stop */
@@ -2499,7 +2501,7 @@ static int cortex_a53_write_memory_64(struct target *target, uint64_t address,
 		return retval;
 
 	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
-		LOG_DEBUG("Writing memory to address 0x%" PRIx64 "; size %" PRId64 "; count %" PRId64, address, size,
+		LOG_DEBUG("Writing memory to address 0x%" PRIx64 "; size %d; count %" PRId64, address, size,
 			count);
 		if (mmu_enabled) {
 			virt = address;
-- 
1.9.1


From ee3f78427c318571c01c1b85ee68d27d66e5b435 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 20/94] fixed hlt encoding for AArch64 for s/w bp

---
 src/target/cortex_a53.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 2a84ccd..b4b43d3 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -1562,7 +1562,10 @@ static int cortex_a53_set_breakpoint(struct target *target,
 		if (breakpoint->length == 2)
 			buf_set_u32(code, 0, 32, ARMV8_T_HLT(0x11)); //ARMV5_T_BKPT(0x11)
 		else
-			buf_set_u32(code, 0, 32, ARMV8_A32_HLT(0x11)); //ARMV5_BKPT(0x11)
+		{
+			if(target->is_64b) buf_set_u32(code, 0, 32, ARMV8_A64_HLT(0x11));
+			else buf_set_u32(code, 0, 32, ARMV8_A32_HLT(0x11)); //ARMV5_BKPT(0x11)
+		}
 		retval = target_read_memory(target,
 				breakpoint->address & 0xFFFFFFFE,
 				breakpoint->length, 1,
-- 
1.9.1


From 0d69ba3f8ba47fb3dad244a044c7966633e10525 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 21/94] update for get/set SP and SCTRL. The encoding for
 access SP and SCTRL at different EL is different.

---
 src/target/armv8_dpm.c  | 4 ++--
 src/target/cortex_a53.c | 4 +++-
 2 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index 9f9b889..b73beb6 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -53,7 +53,7 @@ static int aarch64_dpm_read_reg(struct armv8_dpm *armv8_dpm, struct reg *r, unsi
 			/*SQU: problem for read SPSel with below code, will get error in EDSCR:
 			retval = dpm->instr_read_data_r0(dpm, ARMV8_A64_MRS(3, 0, 4, 2, 0, 0), &v32);//SPSel is 32bit
 			LOG_USER("SQU: SPSel=0x%x", v32); //*/
-			retval = armv8_dpm->instr_read_data64_r0(dpm, ARMV8_A64_MRS(3, 0, 4, 1, 0, 0), &v64);//SP_EL0
+			retval = armv8_dpm->instr_read_data64_r0(dpm, 0x910003E0, &v64); //MOV X0, SP
 			break;
 		case 32:/* PC
 			 * "MSR X0, DLR_EL0"; then return via DCC */
@@ -109,7 +109,7 @@ static int aarch64_dpm_write_reg(struct armv8_dpm *armv8_dpm, struct reg *r, uns
 			break;
 		case 31:
 			//SP
-			retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 0, 4, 1, 0, 0), value);//SP_EL0
+			retval = armv8_dpm->instr_write_data64_r0(dpm, 0x9100001F, value);//MOV SP, X0
 			break;
 		case 32: //PC, "MSR X0, DLR_EL0"
 			retval = armv8_dpm->instr_write_data64_r0(dpm, ARMV8_A64_MSR(3, 3, 4, 5, 1, 0), value);
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index b4b43d3..391f7dc 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -374,7 +374,9 @@ static int cortex_a53_exec_opcode(struct target *target,
                 opcode=0xD5130500|((opcode&0x100000)<<1)|((opcode&0xF000)>>12);
                 break;
         	case 0x10F10: //SCTLR
-            	opcode=0xD51E1000|((opcode&0x100000)<<1)|((opcode&0xF000)>>12);
+            	opcode=0xD5181000|((opcode&0x100000)<<1)|((opcode&0xF000)>>12); //SCTLR_EL1
+            	if((dscr&0x300)==0x300) opcode|=6<<16; //SCTLR_EL3
+            	else if((dscr&0x300)==0x200) opcode|=4<<16; //SCTLR_EL2
             	break;
         	case 0x20F50: //TTBCR
             	opcode=0xD51E2040|((opcode&0x100000)<<1)|((opcode&0xF000)>>12);
-- 
1.9.1


From 5248c7e743580ea172fc1ea080d12c3115798b0f Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 22/94] adding more support for setting up ARMv8 MMU in both
 AArch32 and AArch64

---
 src/target/cortex_a53.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 391f7dc..057bd6e 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -378,9 +378,16 @@ static int cortex_a53_exec_opcode(struct target *target,
             	if((dscr&0x300)==0x300) opcode|=6<<16; //SCTLR_EL3
             	else if((dscr&0x300)==0x200) opcode|=4<<16; //SCTLR_EL2
             	break;
+        	case 0x20F10: //TTBR0
+        	case 0x20F30: //TTBR1|		L				|		Rt			  |   opc2=>opc1
+        		opcode=0xD5182000|((opcode&0x100000)<<1)|((opcode&0xF000)>>12)|((opcode&0xE0)<<11);
+        		break;
         	case 0x20F50: //TTBCR
             	opcode=0xD51E2040|((opcode&0x100000)<<1)|((opcode&0xF000)>>12);
             	break;
+        	case 0x70F36: //DCIMVAC
+        		opcode=0xD5087620|((opcode&0x100000)<<1)|((opcode&0xF000)>>12);
+        		break;
         	case 0xFB0:	//MPIDR
         	case 0x200F30: //CLIDR
         	case 0x400F10: //CSSELR
-- 
1.9.1


From 2f0d7e9366a80c8035a7a6b876c15cc70f167a90 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 23/94] add coversion from Arch64 to Arc32 handling for V8

---
 src/target/armv8.c      | 319 ++++++++++++++++++++++++++++++++++++++++++++++++
 src/target/armv8.h      |  18 +++
 src/target/armv8_dpm.h  |   7 ++
 src/target/cortex_a53.c |  99 ++++++++++++++-
 src/target/target.c     |   2 +-
 5 files changed, 441 insertions(+), 4 deletions(-)

diff --git a/src/target/armv8.c b/src/target/armv8.c
index 3823db8..830552e 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -14,6 +14,9 @@
 #include "register.h"
 #include "armv8.h"
 
+#include "arm_opcodes.h"
+
+
 #define keep_old_code 0
 #define WITH_FPU 1
 
@@ -911,6 +914,225 @@ const struct command_registration arm_command_handlers[] = {
 };
 #endif
 
+static int jim_drps(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
+{
+	struct command_context *context;
+	struct target *target;
+	struct arm *arm;
+	int retval;
+
+	context = current_command_context(interp);
+	assert(context != NULL);
+
+	target = get_current_target(context);
+	if (target == NULL) {
+		LOG_ERROR("%s: no current target", __func__);
+		return JIM_ERR;
+	}
+	if (!target_was_examined(target)) {
+		LOG_ERROR("%s: not yet examined", target_name(target));
+		return JIM_ERR;
+	}
+	arm = target_to_arm(target);
+	if (!is_arm(arm)) {
+		LOG_ERROR("%s: not an ARM", target_name(target));
+		return JIM_ERR;
+	}
+
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a53);
+	struct armv8 *armv8 = &armv8_common->armv8;
+
+	retval = armv8->drps(target);
+
+	if (retval != ERROR_OK)
+		return JIM_ERR;
+
+	return JIM_OK;
+}
+
+static int jim_msrmrs(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
+{
+	struct command_context *context;
+	struct target *target;
+	struct arm *arm;
+	int retval;
+
+	context = current_command_context(interp);
+	assert(context != NULL);
+
+	target = get_current_target(context);
+	if (target == NULL) {
+		LOG_ERROR("%s: no current target", __func__);
+		return JIM_ERR;
+	}
+	if (!target_was_examined(target)) {
+		LOG_ERROR("%s: not yet examined", target_name(target));
+		return JIM_ERR;
+	}
+	arm = target_to_arm(target);
+	if (!is_arm(arm)) {
+		LOG_ERROR("%s: not an ARM", target_name(target));
+		return JIM_ERR;
+	}
+
+//	if ((argc < 6) || (argc > 7)) {
+//		/* FIXME use the command name to verify # params... */
+//		LOG_ERROR("%s: wrong number of arguments", __func__);
+//		return JIM_ERR;
+//	}
+
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a53);
+	struct armv8 *armv8 = &armv8_common->armv8;
+
+
+	uint32_t op0;
+	uint32_t op1;
+	uint32_t op2;
+	uint32_t CRn;
+	uint32_t CRm;
+	uint32_t Rt;
+	uint32_t value;
+	long l;
+
+	/* NOTE:  parameter sequence matches ARM instruction set usage:
+	 *	MCR	pNUM, op1, rX, CRn, CRm, op2	; write CP from rX
+	 *	MRC	pNUM, op1, rX, CRn, CRm, op2	; read CP into rX
+	 * The "rX" is necessarily omitted; it uses Tcl mechanisms.
+	 */
+	retval = Jim_GetLong(interp, argv[1], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0xf) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+			"coprocessor", (int) l);
+		return JIM_ERR;
+	}
+	op0 = l;
+
+	retval = Jim_GetLong(interp, argv[2], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0x7) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+			"op1", (int) l);
+		return JIM_ERR;
+	}
+	op1 = l;
+
+	retval = Jim_GetLong(interp, argv[3], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0xf) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+			"CRn", (int) l);
+		return JIM_ERR;
+	}
+	CRn = l;
+
+	retval = Jim_GetLong(interp, argv[4], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0xf) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+			"CRm", (int) l);
+		return JIM_ERR;
+	}
+	CRm = l;
+
+	retval = Jim_GetLong(interp, argv[5], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0x7) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+			"op2", (int) l);
+		return JIM_ERR;
+	}
+	op2 = l;
+
+	retval = Jim_GetLong(interp, argv[6], &l);
+	if (retval != JIM_OK)
+		return retval;
+	if (l & ~0x7) {
+		LOG_ERROR("%s: %s %d out of range", __func__,
+			"op2", (int) l);
+		return JIM_ERR;
+	}
+	Rt = l;
+
+	value = 0;
+
+	/* FIXME don't assume "mrc" vs "mcr" from the number of params;
+	 * that could easily be a typo!  Check both...
+	 *
+	 * FIXME change the call syntax here ... simplest to just pass
+	 * the MRC() or MCR() instruction to be executed.  That will also
+	 * let us support the "mrc2" and "mcr2" opcodes (toggling one bit)
+	 * if that's ever needed.
+	 */
+	if (argc == 8) {
+		retval = Jim_GetLong(interp, argv[7], &l);
+		if (retval != JIM_OK)
+			return retval;
+		value = l;
+
+		/* NOTE: parameters reordered! */
+		/* ARMV4_5_MCR(cpnum, op1, 0, CRn, CRm, op2) */
+		//retval = arm->mcr(target, cpnum, op1, op2, CRn, CRm, value);
+		retval = armv8->msr(target, op0, op1, CRn, CRm, op2, Rt, value);
+		if (retval != ERROR_OK)
+			return JIM_ERR;
+	} else {
+		/* NOTE: parameters reordered! */
+		/* ARMV4_5_MRC(cpnum, op1, 0, CRn, CRm, op2) */
+		retval = armv8->mrs(target, op0, op1, CRn, CRm, op2, Rt, &value);
+
+		if (retval != ERROR_OK)
+				return JIM_ERR;
+
+		Jim_SetResult(interp, Jim_NewIntObj(interp, value));
+	}
+
+	return JIM_OK;
+}
+
+static const struct command_registration arm_exec_command_handlers[] = {
+
+	{
+		.name = "msr",
+		.mode = COMMAND_EXEC,
+		.jim_handler = &jim_msrmrs,
+		.help = "move to system register",
+		.usage = "cpnum op1 CRn CRm op2 value",
+	},
+	{
+		.name = "mrs",
+		.jim_handler = &jim_msrmrs,
+		.help = "move from sysem register",
+		.usage = "cpnum op1 CRn CRm op2",
+	},
+	{
+		.name = "drps",
+		.jim_handler = &jim_drps,
+		.help = "Debug restore processor state",
+		.usage = "cpnum op1 CRn CRm op2",
+	},
+
+	COMMAND_REGISTRATION_DONE
+};
+
+const struct command_registration arm_v8_command_handlers[] = {
+	{
+		.name = "arm",
+		.mode = COMMAND_ANY,
+		.help = "ARM command group",
+		.usage = "",
+		.chain = arm_exec_command_handlers,
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
 int armv8_get_gdb_reg_list(struct target *target,
 		struct reg **reg_list[], int *reg_list_size,
 		enum target_register_class reg_class)
@@ -1417,6 +1639,103 @@ int arm_init_arch_info(struct target *target, struct arm *arm)
 	if (!arm->mcr)
 		arm->mcr = arm_default_mcr;
 
+	if (!arm->mrs)
+		arm->mrs = arm_default_mrc;
+	if (!arm->msr)
+		arm->msr = arm_default_mcr;
+
+
 	return ERROR_OK;
 }
 #endif
+
+/*
+ * Coprocessor support
+ */
+
+/* Read coprocessor */
+static int armv8_mrs(struct target *target,
+	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
+	uint32_t *value)
+{
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
+	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
+	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
+	int retval;
+	uint32_t v32;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* read coprocessor register into R0; return via DCC */
+	retval = armv8_dpm->instr_read_data64_r0_msr(dpm, ARMV8_A64_MRS(op0, op1, CRn, CRm, op2, Rt), &v32);
+
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+static int armv8_msr(struct target *target,
+	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
+	uint32_t value)
+{
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
+	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
+	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
+	int retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* read DCC into r0; then write coprocessor register from R0 */
+	retval = armv8_dpm->instr_write_data64_r0_mrs(dpm, ARMV8_A64_MSR(op0, op1, CRn, CRm, op2, Rt), value);
+
+	retval =
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+static int armv8_drps(struct target *target,
+	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
+	uint32_t value)
+{
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
+	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
+	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
+	int retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = armv8_dpm->instr_execution(dpm, 0xD6BF03E0, value);//SP_EL0
+
+	// todo: change the target is_64b flag, should based on current dscr.
+	target->is_64b = false;
+	target->state = TARGET_RUNNING;
+
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+
+
+int armv8_init_arch_info(struct target *target)
+{
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a53);
+	struct armv8 *armv8 = &armv8_common->armv8;
+
+	if (!armv8->mrs)
+		armv8->mrs = armv8_mrs;
+	if (!armv8->msr)
+		armv8->msr = armv8_msr;
+	if (!armv8->drps)
+		armv8->drps = armv8_drps;
+
+	return ERROR_OK;
+}
diff --git a/src/target/armv8.h b/src/target/armv8.h
index 4605b27..5704455 100755
--- a/src/target/armv8.h
+++ b/src/target/armv8.h
@@ -73,6 +73,19 @@ struct armv8	//struct for armv8 core
 	struct reg_cache *core_cache;
 	struct reg *pc;
 	struct reg *cpsr;
+
+	/** Read coprocessor register.  */
+	int (*mrs)(struct target *target,
+	        uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
+	        uint32_t *value);
+
+	/** Write coprocessor register.  */
+	int (*msr)(struct target *target,
+	        uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
+	        uint32_t value);
+
+	/** Write coprocessor register.  */
+	int (*drps)(struct target *target);
 };
 
 struct armv8_common {
@@ -87,4 +100,9 @@ static inline struct armv8_common* cortex_a_to_armv8(struct cortex_a_common *cor
 
 int armv8_arch_state(struct target *target);
 
+extern const struct command_registration arm_v8_command_handlers[];
+
+int armv8_init_arch_info(struct target *target);
+
+
 #endif /* ARMV8_H */
diff --git a/src/target/armv8_dpm.h b/src/target/armv8_dpm.h
index 160c524..2109d3e 100755
--- a/src/target/armv8_dpm.h
+++ b/src/target/armv8_dpm.h
@@ -50,6 +50,13 @@ struct armv8_dpm {
 	/** Invoke after a series of instruction operations */
 	//int (*finish)(struct armv8_dpm *);
 
+	/** Runs one instruction */
+	int (*instr_execution)(struct arm_dpm *, uint32_t opcode, uint64_t *data);
+	int (*instr_write_data64_r0_mrs)(struct arm_dpm *,
+			uint32_t opcode, uint64_t data);
+	int (*instr_read_data64_r0_msr)(struct arm_dpm *,
+			uint32_t opcode, uint64_t *data);
+
 	/* WRITE TO CPU */
 
 	/** Runs one instruction, writing data to DCC before execution. */
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index b4b43d3..ee8f077 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -365,8 +365,8 @@ static int cortex_a53_exec_opcode(struct target *target,
     else if((opcode&0xFF000000)==0xEE000000) //MRC/MCR
     {
         //LOG_USER("SQU: MCR/MRC L=%d cp=%d op1=%d CRn=%d CRm=%d op2=%d Rt=%d", (opcode&0x100000)>>20, (opcode&0xF00)>>8, (opcode&0xE00000)>>21, (opcode&0xF0000)>>16, opcode&0xF,(opcode&0xE0)>>5,(opcode&0xF000)>>12);
-        //if(isAArch64(dscr)) //convert MCR/MRC to MSR/MRS
-    	if(target->is_64b)
+        if(isAArch64(dscr)) //convert MCR/MRC to MSR/MRS
+//    	if(target->is_64b)
         {
             switch (opcode & 0xEF0FFF)
         	{
@@ -563,6 +563,22 @@ static int cortex_a53_dpm_finish(struct arm_dpm *dpm)
 	return ERROR_OK;
 }
 
+static int cortex_a53_instr_execution(struct arm_dpm *dpm,
+	uint32_t opcode, uint64_t *data)
+{
+	struct cortex_a_common *a = dpm_to_a(dpm);
+	int retval;
+	uint32_t dscr = DSCR_INSTR_COMP;
+
+	/* the opcode, writing data to DCC */
+	retval = cortex_a53_exec_opcode(
+			a->armv7a_common.arm.target,
+			opcode,
+			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
+}
+
 static int cortex_a53_instr_write_data64_dcc(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t data)
 {
@@ -586,6 +602,36 @@ static int cortex_a53_instr_write_data_dcc(struct arm_dpm *dpm,
 	return cortex_a53_instr_write_data64_dcc(dpm, opcode, (uint64_t)data);
 }
 
+static int cortex_a53_instr_write_data64_r0_mrs(struct arm_dpm *dpm,
+	uint32_t opcode, uint64_t data)
+{
+	struct cortex_a_common *a = dpm_to_a(dpm);
+	uint32_t dscr = DSCR_INSTR_COMP;
+	int retval;
+
+	retval = cortex_a53_write_dcc(a, data);
+	if (retval != ERROR_OK)
+		return retval;
+
+		
+		/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15 */
+	retval = cortex_a53_exec_opcode(
+			a->armv7a_common.arm.target,
+			ARMV8_A64_MRS(2, 3, 0, 5, 0, 0),
+			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* then the opcode, taking data from R0 */
+	retval = cortex_a53_exec_opcode(
+			a->armv7a_common.arm.target,
+			opcode,
+			&dscr);
+
+	return retval;
+}
+
+
 static int cortex_a53_instr_write_data64_r0(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t data)
 {
@@ -658,6 +704,36 @@ static int cortex_a53_instr_read_data_dcc(struct arm_dpm *dpm,
 	return result;
 }
 
+static int cortex_a53_instr_read_data64_r0_msr(struct arm_dpm *dpm,
+	uint32_t opcode, uint64_t *data)
+{
+	struct cortex_a_common *a = dpm_to_a(dpm);
+	uint32_t dscr = DSCR_INSTR_COMP;
+	int retval;
+    uint64_t tmp;
+
+		/* the opcode, writing data to R0 */
+	retval = cortex_a53_exec_opcode(
+			a->armv7a_common.arm.target,
+			opcode,
+			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* write R0 to DCC */
+	retval = cortex_a53_exec_opcode(
+			a->armv7a_common.arm.target,
+			ARMV8_A64_MSR(2, 3, 0, 5, 0, 0),
+			&dscr);
+	if (retval != ERROR_OK)
+		return retval;
+
+    retval = cortex_a53_read_dcc(a, &tmp, &dscr);
+
+    *data=tmp;
+	return retval;
+}
+
 static int cortex_a53_instr_read_data64_r0(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t *data)
 {
@@ -799,6 +875,11 @@ static int cortex_a53_dpm_setup(struct armv8_common *armv8,uint32_t dfr0)
 	armv8_dpm->instr_read_data64_dcc = cortex_a53_instr_read_data64_dcc;
 	armv8_dpm->instr_read_data64_r0 = cortex_a53_instr_read_data64_r0;
 
+	armv8_dpm->instr_execution = cortex_a53_instr_execution;
+	armv8_dpm->instr_write_data64_r0_mrs = cortex_a53_instr_write_data64_r0_mrs;
+	armv8_dpm->instr_read_data64_r0_msr = cortex_a53_instr_read_data64_r0_msr;
+
+
 	retval = armv8_dpm_setup(armv8_dpm);
 	if (retval == ERROR_OK)
 		retval = armv8_dpm_initialize(armv8_dpm);
@@ -860,6 +941,7 @@ static int cortex_a53_poll(struct target *target)
 	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	enum target_state prev_target_state = target->state;
+
     dap_ap_select(swjdp, 1);  //swjdp->apsel=1;
 	/*  toggle to another core is done by gdb as follow */
 	/*  maint packet J core_id */
@@ -880,6 +962,7 @@ static int cortex_a53_poll(struct target *target)
 	cortex_a53->cpudbg_dscr = dscr;
 
 	if (DSCR_RUN_MODE(dscr) == (DSCR_CORE_HALTED | DSCR_CORE_RESTARTED)) {
+
 		if (prev_target_state != TARGET_HALTED) {
 			/* We have a halting debug event */
 			LOG_DEBUG("Target halted");
@@ -887,6 +970,7 @@ static int cortex_a53_poll(struct target *target)
 			if ((prev_target_state == TARGET_RUNNING)
 				|| (prev_target_state == TARGET_UNKNOWN)
 				|| (prev_target_state == TARGET_RESET)) {
+
 				retval = cortex_a53_debug_entry(target);
 				if (retval != ERROR_OK)
 					return retval;
@@ -897,6 +981,7 @@ static int cortex_a53_poll(struct target *target)
 				}
 				target_call_event_callbacks(target,
 					TARGET_EVENT_HALTED);
+
 			}
 			if (prev_target_state == TARGET_DEBUG_RUNNING) {
 				LOG_DEBUG(" ");
@@ -914,8 +999,9 @@ static int cortex_a53_poll(struct target *target)
 					TARGET_EVENT_DEBUG_HALTED);
 			}
 		}
-	} else if (DSCR_RUN_MODE(dscr) == DSCR_CORE_RESTARTED)
+	} else if (DSCR_RUN_MODE(dscr) == DSCR_CORE_RESTARTED) {
 		target->state = TARGET_RUNNING;
+	}
 	else {
 		LOG_DEBUG("Unknown target state dscr = 0x%08" PRIx32, dscr);
 		target->state = TARGET_UNKNOWN;
@@ -1028,6 +1114,7 @@ static int cortex_a53_halt(struct target *target)
 		}
 		retval = cortex_a53_halt(target); //recursively request halt
 	}*/
+	 
 	target->debug_reason = DBG_REASON_DBGRQ;
 
 	return retval;
@@ -2740,6 +2827,9 @@ static int cortex_a53_init_arch_info(struct target *target,
 
 	/* REVISIT v7a setup should be in a v7a-specific routine */
 	armv7a_init_arch_info(target, armv7a);
+
+	armv8_init_arch_info(target);
+
 	target_register_timer_callback(cortex_a53_handle_target_request, 1, 1, target);
 
 	return ERROR_OK;
@@ -2936,6 +3026,9 @@ static const struct command_registration cortex_a53_command_handlers[] = {
 		.chain = arm_command_handlers,
 	},
 	{
+		.chain = arm_v8_command_handlers,
+	},
+	{
 		.chain = armv7a_command_handlers,
 	},
 	{
diff --git a/src/target/target.c b/src/target/target.c
index c0c9c0c..0aa77cc 100644
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -2866,7 +2866,7 @@ COMMAND_HANDLER(handle_md_command)
 }
 
 typedef int (*target_write_fn)(struct target *target,
-		uint32_t address, uint32_t size, uint32_t count, const uint8_t *buffer);
+		uint64_t address, uint64_t size, uint64_t count, const uint8_t *buffer);
 
 static int target_fill_mem(struct target *target,
 		uint32_t address,
-- 
1.9.1


From f046e913b183a353306dfc331b474bf43c572517 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 24/94] add skip semihost command and get back modeswitch

---
 src/target/arm_dpm.c         |  12 ++++-
 src/target/arm_opcodes.h     |   4 ++
 src/target/arm_semihosting.c |  57 ++++++++++++++++++++
 src/target/arm_semihosting.h |   1 +
 src/target/armv8.c           | 120 +++++++++++++++++++++++++++++++++++++++++
 src/target/armv8.h           |   3 ++
 src/target/cortex_a53.c      | 126 +++++++++++++++++++++++++++++++++++++++----
 src/target/target.h          |   5 ++
 8 files changed, 316 insertions(+), 12 deletions(-)

diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index b8f392c..1c0025b 100644
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -240,7 +240,7 @@ static int dpm_write_reg(struct arm_dpm *dpm, struct reg *r, unsigned regnum)
 int arm_dpm_read_current_registers(struct arm_dpm *dpm)
 {
 	struct arm *arm = dpm->arm;
-	uint32_t cpsr;
+	uint32_t cpsr, spsr;
 	int retval;
 	struct reg *r;
 
@@ -276,6 +276,16 @@ int arm_dpm_read_current_registers(struct arm_dpm *dpm)
 	}
 
 	/* NOTE: SPSR ignored (if it's even relevant). */
+//	retval = dpm->instr_read_data_r0(dpm, 0x8030F3F2, &spsr);
+	retval = dpm->instr_read_data_r0(dpm, ARMV8_T32_MRS(1,2,0,1), &spsr);
+	if (retval != ERROR_OK)
+		goto fail;
+
+	if (arm->spsr) {
+		buf_set_u32(arm->spsr->value, 0, 32, spsr);
+		arm->spsr->valid = 1;
+		arm->spsr->dirty = 0;
+	}
 
 	/* REVISIT the debugger can trigger various exceptions.  See the
 	 * ARMv7A architecture spec, section C5.7, for more info about
diff --git a/src/target/arm_opcodes.h b/src/target/arm_opcodes.h
index 5490319..ba1ee94 100644
--- a/src/target/arm_opcodes.h
+++ b/src/target/arm_opcodes.h
@@ -176,6 +176,10 @@
 	(0xee100010 | (CRm) | ((op2) << 5) | ((CP) << 8) \
 	| ((Rd) << 12) | ((CRn) << 16) | ((op1) << 21))
 
+#define ARMV8_T32_MRS(R, M1, Rd, M) \
+	(0xF3E08020 | ((R)<<20) | ((M1) << 16) | ((Rd) << 8) \
+	| ((M) <<4))
+
 #define ARMV8_T32_MRC(CP, op1, Rd, CRn, CRm, op2) \
 	(0x0010ee10 | ((CRm)<<16) | ((op2) << 21) | ((CP) << 24) \
 	| ((Rd) << 28) | (CRn) | ((op1) << 5))
diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index 21b7809..2237693 100644
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -40,6 +40,7 @@
 #include "arm.h"
 #include "armv4_5.h"
 #include "arm7_9_common.h"
+#include "armv8.h"
 #include "armv7m.h"
 #include "cortex_m.h"
 #include "register.h"
@@ -467,6 +468,62 @@ static int do_semihosting(struct target *target)
  * @param retval Pointer to a location where the return code will be stored
  * @return non-zero value if a request was processed or an error encountered
  */
+int arm_semihosting_v8(struct target *target, int *retval)
+{
+	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
+	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a);
+	struct armv8 *armv8 = &armv8_common->armv8;
+	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
+	struct arm *arm = &armv7a->arm;
+	uint32_t pc, lr, spsr, cpsr;
+	struct reg *r;
+	int result;
+
+	if (!target->is_semihostskip)
+		return 0;
+
+	uint32_t r0 = buf_get_u32(arm->core_cache->reg_list[0].value, 0, 32);
+	uint32_t r1 = buf_get_u32(arm->core_cache->reg_list[1].value, 0, 32);
+
+	/* Check for PC == 0x00000008 or 0xffff0008: Supervisor Call vector. */
+	r = arm->pc;
+	r->dirty = 1;
+	pc = buf_get_u32(r->value, 0, 32);
+	LOG_USER("semihost pc = 0x%08" PRIx32, pc);
+	if (pc != 0x00000008 && pc != 0xffff0008 && pc != (target->codebase+8)) 
+	{
+		return 0;
+	}
+
+	r = arm_reg_current(arm, 14);
+	lr = buf_get_u32(r->value, 0, 32);
+
+	LOG_USER("semihost lr = 0x%08" PRIx32, lr);
+	/* Core-specific code should make sure SPSR is retrieved
+	 * when the above checks pass...
+	 */
+	spsr = buf_get_u32(arm->spsr->value, 0, 32);
+	cpsr = buf_get_u32(arm->cpsr->value, 0, 32);
+
+	buf_set_u32(arm->cpsr->value, 0, 32, spsr);
+	arm->cpsr->dirty = 1;
+	arm->core_mode = spsr & 0x1f;
+	if (spsr & 0x20)
+		arm->core_state = ARM_STATE_THUMB;
+
+	/* return value in R0 */
+	buf_set_u32(arm->core_cache->reg_list[0].value, 0, 32, result);
+	arm->core_cache->reg_list[0].dirty = 1;
+
+	/* LR --> PC */
+	buf_set_u32(arm->core_cache->reg_list[15].value, 0, 32,
+		buf_get_u32(arm_reg_current(arm, 14)->value, 0, 32));
+	arm->core_cache->reg_list[15].dirty = 1;
+
+	*retval = target_resume(target, 1, 0, 0, 0);
+	return 1;
+}
+
 int arm_semihosting(struct target *target, int *retval)
 {
 	struct arm *arm = target_to_arm(target);
diff --git a/src/target/arm_semihosting.h b/src/target/arm_semihosting.h
index 58b3432..13c1d79 100644
--- a/src/target/arm_semihosting.h
+++ b/src/target/arm_semihosting.h
@@ -22,5 +22,6 @@
 #define ARM_SEMIHOSTING_H
 
 int arm_semihosting(struct target *target, int *retval);
+int arm_semihosting_v8(struct target *target, int *retval);
 
 #endif
diff --git a/src/target/armv8.c b/src/target/armv8.c
index 830552e..f65f997 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -914,6 +914,54 @@ const struct command_registration arm_command_handlers[] = {
 };
 #endif
 
+static int jim_modeswitch(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
+{
+	struct command_context *context;
+	struct target *target;
+	struct arm *arm;
+	int retval;
+
+	context = current_command_context(interp);
+	assert(context != NULL);
+
+	target = get_current_target(context);
+	if (target == NULL) {
+		LOG_ERROR("%s: no current target", __func__);
+		return JIM_ERR;
+	}
+	if (!target_was_examined(target)) {
+		LOG_ERROR("%s: not yet examined", target_name(target));
+		return JIM_ERR;
+	}
+	arm = target_to_arm(target);
+	if (!is_arm(arm)) {
+		LOG_ERROR("%s: not an ARM", target_name(target));
+		return JIM_ERR;
+	}
+
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a53);
+	struct armv8 *armv8 = &armv8_common->armv8;
+
+	uint32_t value;
+	long l;
+
+	retval = Jim_GetLong(interp, argv[1], &l);
+	if (retval != JIM_OK)
+		return retval;
+	LOG_ERROR("%s: %s %d", __func__,
+			"value is", (int) l);
+	value = l;
+
+	retval = armv8->modeswitch(target, value);
+
+	if (retval != ERROR_OK)
+		return JIM_ERR;
+
+	return JIM_OK;
+}
+
+
 static int jim_drps(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 {
 	struct command_context *context;
@@ -1097,6 +1145,47 @@ static int jim_msrmrs(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 	return JIM_OK;
 }
 
+static int armv8_setup_semihosting(struct target *target, uint32_t value)
+{
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
+	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
+	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
+	int retval = ERROR_OK;
+
+	// set semihosting skip enable
+	target->is_semihostskip = true;
+	target->codebase = value;
+
+	return retval;
+}
+
+COMMAND_HANDLER(handle_arm_semihosting_command)
+{
+	struct target *target = get_current_target(CMD_CTX);
+
+	if (target == NULL) {
+		LOG_ERROR("No target selected");
+		return ERROR_FAIL;
+	}
+
+	struct arm *arm = target_to_arm(target);
+
+	if (!is_arm(arm)) {
+		command_print(CMD_CTX, "current target isn't an ARM");
+		return ERROR_FAIL;
+	}
+
+	uint32_t address;
+	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+
+    armv8_setup_semihosting(target, address);
+
+	command_print(CMD_CTX, "semihosting code baseaddress is 0x%x", address);
+
+	return ERROR_OK;
+}
+
 static const struct command_registration arm_exec_command_handlers[] = {
 
 	{
@@ -1119,6 +1208,21 @@ static const struct command_registration arm_exec_command_handlers[] = {
 		.usage = "cpnum op1 CRn CRm op2",
 	},
 
+	{
+		.name = "modeswitch",
+		.jim_handler = &jim_modeswitch,
+		.help = "Debug restore processor state",
+		.usage = "cpnum op1 CRn CRm op2",
+	},
+
+	{
+		"semihostskip",
+		.handler = handle_arm_semihosting_command,
+		.mode = COMMAND_EXEC,
+		.usage = "[baseaddress]",
+		.help = "activate support for semihosting operations",
+	},
+
 	COMMAND_REGISTRATION_DONE
 };
 
@@ -1722,6 +1826,20 @@ static int armv8_drps(struct target *target,
 	return retval;
 }
 
+static int armv8_modeswitch(struct target *target, uint32_t value)
+{
+	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
+	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
+	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
+	int retval = ERROR_OK;
+
+	// set modeswitch and asic rom base
+	target->mode_switch = true;
+	target->romcbase = value;
+
+	return retval;
+}
 
 
 int armv8_init_arch_info(struct target *target)
@@ -1736,6 +1854,8 @@ int armv8_init_arch_info(struct target *target)
 		armv8->msr = armv8_msr;
 	if (!armv8->drps)
 		armv8->drps = armv8_drps;
+	if (!armv8->modeswitch)
+		armv8->modeswitch = armv8_modeswitch;
 
 	return ERROR_OK;
 }
diff --git a/src/target/armv8.h b/src/target/armv8.h
index 5704455..19f6899 100755
--- a/src/target/armv8.h
+++ b/src/target/armv8.h
@@ -86,6 +86,9 @@ struct armv8	//struct for armv8 core
 
 	/** Write coprocessor register.  */
 	int (*drps)(struct target *target);
+
+	/** Write coprocessor register.  */
+	int (*modeswitch)(struct target *target, uint32_t value);
 };
 
 struct armv8_common {
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 498ee17..b35fb61 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -356,6 +356,11 @@ static int cortex_a53_exec_opcode(struct target *target,
 		if(isAArch64(dscr)) opcode=ARMV8_A64_MRS(3, 3, 4, 5, 0, 0); //MRS R0, DSPSR_EL0
         else opcode=ARMV8_T32_MRC(15, 3, 0, 4, 5, 0); //change to read DSPSR
 	}
+	else if(opcode==0xF3F28030)
+	{//in case of MRS r0, spsr
+		LOG_USER("ARMv8: read spsr");
+        opcode = (opcode>>16) | (opcode<<16);
+ 	}
 	else if(opcode==0xE1A0000F)
 	{//in case of MOV r0, pc
 		//LOG_USER("SQU: ARMv8: read pc");
@@ -988,9 +993,13 @@ static int cortex_a53_poll(struct target *target)
 					if (retval != ERROR_OK)
 						return retval;
 				}
+				if (arm_semihosting_v8(target, &retval) != 0)
+					return retval;
+
 				target_call_event_callbacks(target,
 					TARGET_EVENT_HALTED);
 
+
 			}
 			if (prev_target_state == TARGET_DEBUG_RUNNING) {
 				LOG_DEBUG(" ");
@@ -1076,26 +1085,114 @@ static int cortex_a53_halt(struct target *target)
 		target->is_64b=false;
 		target->type->arch_state=armv7a_arch_state;
 	}
-	/*remove below hack. Changing state should be a request from gdb client, but not forced here
-	if(target->is_64b)
+	//remove below hack. Changing state should be a request from gdb client, but not forced here
+	if(target->is_64b && target->mode_switch)
 	{
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 1, 1, 0, 0), &dummy); //read SCR_EL3 to X0
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
 		LOG_USER("Running in AArch64. SCR_EL3=0x%x",dummy);
+//		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x400);//SCR:RW=0,NS=1
 		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 6, 1, 1, 0, 0), &dummy); //SCR_EL3=X0
+
+		      cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 4, 1, 1, 0, 0), &dummy); //read HCR_EL2 to X0
+              cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+              retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+              LOG_USER("Running in AArch64. HCR_EL2=0x%x",dummy);
+/*              mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
+              cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
+              cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 4, 1, 1, 0, 0), &dummy); //HCR_EL2=X0
+*/
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 12, 0, 2, 0), &dummy);    // MRS RMR_EL3, R0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+		LOG_USER("Read RMR_EL# before DRPS = 0x%x", dummy);
+
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 3, 4, 5, 0, 0), &dummy);    // MRS DSPSR_EL0, R0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+		LOG_USER("Read DSPSR_EL0 before DRPS = 0x%x", dummy);
+
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 3, 4, 5, 1, 0), &dummy);     // MRS DLR_EL0, R0, mov pc?
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+
+		LOG_USER("Read DLR_EL0 before DRPS = 0x%x", dummy);
+
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 0, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL1, R0, mov pc?
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+
+		LOG_USER("Read SPSR_EL1 before DRPS = 0x%x", dummy);
+
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 4, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL2, R0, mov pc?
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+
+		LOG_USER("Read SPSR_EL2 before DRPS = 0x%x", dummy);
+
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL3, R0, mov pc?
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+
+		LOG_USER("Read SPSR_EL3 before DRPS = 0x%x", dummy);
+
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL3, R0, mov pc?
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+
+		LOG_USER("Read SPSR_EL3 before DRPS = 0x%x", dummy);
+
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 0, 0, 2, 2, 0), &dummy);     // MRS MDSCR_EL1, R0, mov pc?
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+
+		LOG_USER("Read MDSCR_EL1 before DRPS = 0x%x", dummy);
+		// write forever loop into the memory 0xFE800000
+		//dummy = 0xEAFFFFFE;
+        //retval = cortex_a53_write_phys_memory(target, 0xFE800000, 4, 1, &dummy);
+
+		// write spsr_el3 
+		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, 0);
+//		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x1c5);//0,
+		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x1d1);//0, for EL1 ARCH32 bits.
+
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 6, 4, 0, 0, 0), &dummy); //SPSR_EL3 ,=X0
+
 		LOG_USER("DRPS");
 		cortex_a53_exec_opcode(target, 0xD6BF03E0, &dummy); //0x8F00F3DE=>ERET 0xD6BF03E0=>DRPS
+
+		// dummy has Arch32, 64 target type information.
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDSCR, &dummy);
+	    LOG_USER("after DRPS, EDSCR = 0x%08" PRIx32, dummy);
+		
+		// set to DSPSR_EL0 to 0x1d0
 		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, 0);
-		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x1D0);
-		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);
-		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 3, 4, 5, 0, 0), &dummy);
+		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x1D1);
+//		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x1D6); // set to Monitor mode
+//		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);    //X0=DTRRX
+//		cortex_a53_exec_opcode(target, ARMV8_T32_MRC(14, 0, 0, 5, 0, 0), &dummy);    //X0=DTRRX
+//		cortex_a53_exec_opcode(target, ARMV8_T32_MCR(15, 3, 0, 4, 5, 0), &dummy);    // MSR DSPSR_EL0, R0
+		cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dummy);    //X0=DTRRX
+		cortex_a53_exec_opcode(target, ARMV4_5_MCR(15, 3, 0, 4, 5, 0), &dummy);    // MSR DSPSR_EL0, R0
+
+	    LOG_USER("Asic ROM base is = 0x%08" PRIx32, target->romcbase);
+		// set to 0xFE800000 as PC
 		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, 0);
-		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0xFC010000); //0x100084 is for 8916
-		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);
-		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 3, 4, 5, 1, 0), &dummy);
+//		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x100000); //for 8916
+		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, target->romcbase); //0x100084 is for 8916
+//		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0xFE800000);
+//		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);     //X0=DTRRX
+//		cortex_a53_exec_opcode(target, ARMV8_T32_MRC(14, 0, 0, 5, 0, 0), &dummy);    //X0=DTRRX / DBGDTRRXint
+//		cortex_a53_exec_opcode(target, ARMV8_T32_MCR(15, 3, 0, 4, 5, 1), &dummy);     // MSR DLR_EL0, R0, mov pc?
+		cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dummy);    //X0=DTRRX / DBGDTRRXint
+		cortex_a53_exec_opcode(target, ARMV4_5_MCR(15, 3, 0, 4, 5, 1), &dummy);     // MSR DLR_EL0, R0, mov pc?
+	    retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDSCR, &dummy);
+	    LOG_USER("after DRPS, EDSCR = 0x%08" PRIx32, dummy);
+
 		//send CTI ACK
 		retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINTACK, 1);
 		then = timeval_ms();
@@ -1103,7 +1200,7 @@ static int cortex_a53_halt(struct target *target)
 			retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTITRIGOUTSTATUS, &dummy);
 			if (retval != ERROR_OK) return retval;
 			if ((dummy & 1) == 0) break;
-			if (timeval_ms() > then + 1000) {
+			if (timeval_ms() > then + 100000) {
 				LOG_ERROR("Timeout waiting for CTI ack");
 				return ERROR_FAIL;
 			}
@@ -1121,8 +1218,15 @@ static int cortex_a53_halt(struct target *target)
 				return ERROR_FAIL;
 			}
 		}
-		retval = cortex_a53_halt(target); //recursively request halt
-	}*/
+
+		retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIAPPPULSE, 1<<CTIDBGCHAN_HALT); //trigger dbg req evt
+		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDSCR, &dummy);
+		LOG_USER("After My CTI1 triggered: %d EDSCR 0x%08" PRIx32, retval, dummy);
+
+		target->is_64b=false;
+		target->type->arch_state=armv7a_arch_state;
+
+	}
 	 
 	target->debug_reason = DBG_REASON_DBGRQ;
 
diff --git a/src/target/target.h b/src/target/target.h
index 8c5b3b7..f09e93f 100644
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -183,6 +183,11 @@ struct target {
 										 * currently. */
 	uint32_t ctibase;					/* added to support ARMv8 by SQU*/
 	bool is_64b;						/* added to support 64bit architecture by SQU */
+	uint32_t romcbase;					/* ROM base code for different Asic*/
+	bool mode_switch;					/* 64bit to 32 bit mode switch support */
+	uint32_t codebase;					/* Code start address for loading axf*/
+	bool is_semihostskip;				/* semihost skip enable/disable */
+
 	struct rtos *rtos;					/* Instance of Real Time Operating System support */
 	bool rtos_auto_detect;				/* A flag that indicates that the RTOS has been specified as "auto"
 										 * and must be detected when symbols are offered */
-- 
1.9.1


From c777ea7e70ec6b07adc3e166cb01002ed6a7fe51 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 25/94] 64bit cleanup

---
 src/target/target32.c    | 351 +++++++++++++++++++++++++++++++++++++++++++++++
 src/target/target_addr.h |  37 +++++
 2 files changed, 388 insertions(+)
 create mode 100644 src/target/target32.c
 create mode 100644 src/target/target_addr.h

diff --git a/src/target/target32.c b/src/target/target32.c
new file mode 100644
index 0000000..7283872
--- /dev/null
+++ b/src/target/target32.c
@@ -0,0 +1,351 @@
+/***************************************************************************
+ *                                                                         *
+ *   Copyright (C) 2016 Eric Katzfey                                       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+
+#include <helper/time_support.h>
+#include <jtag/jtag.h>
+#include <flash/nor/core.h>
+
+#include "target.h"
+#include "target_type.h"
+#include "target_request.h"
+#include "breakpoints.h"
+#include "register.h"
+#include "trace.h"
+#include "image.h"
+
+
+
+static int err_read_phys_memory32(struct target *target, uint32_t address,
+		uint32_t size, uint32_t count, uint8_t *buffer)
+{
+	LOG_ERROR("Not implemented: %s", __func__);
+	return ERROR_FAIL;
+}
+
+static int err_write_phys_memory32(struct target *target, uint32_t address,
+		uint32_t size, uint32_t count, const uint8_t *buffer)
+{
+	LOG_ERROR("Not implemented: %s", __func__);
+	return ERROR_FAIL;
+}
+
+static int identity_virt2phys(struct target *target,
+		uint32_t virtual, uint32_t *physical)
+{
+	*physical = virtual;
+	return ERROR_OK;
+}
+
+static int target32_read_buffer_default( struct target *target, uint32_t address, uint32_t count, uint8_t *buffer)
+{
+	struct target_addr tmp;
+	TARGET_ADDR_INIT( &tmp, address );
+	return target64_read_buffer_default( target, &tmp, count, buffer );
+}
+
+static int target32_write_buffer_default(struct target *target, uint32_t address, uint32_t count, const uint8_t *buffer)
+{
+	struct target_addr tmp;
+	TARGET_ADDR_INIT( &tmp, address );
+	return target64_write_buffer_default( target, &tmp, count, buffer );
+}
+
+int target32_resume( struct target *target, int current, uint64_t address, int handle_breakpoints, int debug_execution)
+{
+	struct target_addr _address;
+	TARGET_ADDR_INIT( &_address, address );
+	return target64_resume( target, current, &_address, handle_breakpoints, debug_execution);
+}
+
+int target32_run_algorithm(struct target *target,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_param,
+		uint64_t entry_point, uint64_t exit_point,
+		int timeout_ms, void *arch_info)
+{
+	struct target_addr _entry_point;
+	struct target_addr _exit_point;
+	TARGET_ADDR_INIT( &_entry_point, entry_point );
+	TARGET_ADDR_INIT( &_exit_point,  exit_point );
+	
+	return target64_run_algorithm( target,
+		num_mem_params, mem_params,
+		num_reg_params, reg_param,
+		&_entry_point, &_exit_point,
+		timeout_ms, arch_info);
+}
+
+int target32_start_algorithm(struct target *target,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_params,
+		uint64_t entry_point, uint64_t exit_point,
+		void *arch_info)
+{
+	struct target_addr _entry_point;
+	struct target_addr _exit_point;
+	TARGET_ADDR_INIT( &_entry_point, entry_point );
+	TARGET_ADDR_INIT( &_exit_point , exit_point  );
+	
+	return target64_start_algorithm(target,
+		num_mem_params, mem_params,
+		num_reg_params, reg_params,
+		&_entry_point, &_exit_point,
+		arch_info);
+}
+
+int target32_wait_algorithm(struct target *target,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_params,
+		uint64_t exit_point, int timeout_ms,
+		void *arch_info)
+{
+	struct target_addr _exit_point;
+	TARGET_ADDR_INIT( &_exit_point, exit_point );
+
+	return target64_wait_algorithm(target,
+		num_mem_params, mem_params,
+		num_reg_params, reg_params,
+		&_exit_point, timeout_ms,
+		arch_info);
+
+}
+
+int target32_run_flash_async_algorithm(struct target *target,
+		const uint8_t *buffer, uint32_t count, int block_size,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_params,
+		uint64_t buffer_start, uint64_t buffer_size,
+		uint64_t entry_point, uint64_t exit_point, void *arch_info)
+{
+	struct target_addr _buffer_start, _entry_point, _exit_point;
+	TARGET_ADDR_INIT( &_buffer_start, buffer_start );
+	TARGET_ADDR_INIT( &_entry_point, entry_point );
+	TARGET_ADDR_INIT( &_exit_point, exit_point );
+
+	return target64_run_flash_async_algorithm(target,
+		buffer, count, block_size,
+		num_mem_params, mem_params,
+		num_reg_params, reg_params,
+		&_buffer_start, buffer_size,
+		&_entry_point, &_exit_point, arch_info);
+}
+
+int target32_read_memory(struct target *target,
+		uint64_t address, uint64_t size, uint64_t count, uint8_t *buffer)
+{
+	struct target_addr _address;
+	TARGET_ADDR_INIT( &_address, address );
+	return target64_read_memory( target, &_address, size, count, buffer );
+}
+
+int target32_read_phys_memory(struct target *target,
+			    uint64_t address, uint64_t size, uint64_t count, uint8_t *buffer)
+{
+	struct target_addr _address;
+	TARGET_ADDR_PHYS( &_address, address );
+	return target64_read_phys_memory( target, &_address, size, count, buffer );
+}
+
+int target32_write_memory(struct target *target,
+		uint64_t address, uint64_t size, uint64_t count, const uint8_t *buffer)
+{
+	struct target_addr _address;
+	TARGET_ADDR_INIT( &_address, address );
+	
+	return target64_write_memory( target, &_address, size, count, buffer );
+}
+
+int target32_write_phys_memory(struct target *target,
+		uint64_t address, uint64_t size, uint64_t count, const uint8_t *buffer)
+{
+	struct target_addr tmp_addr;
+	TARGET_ADDR_PHYS( &tmp_addr, address );
+	
+	return target64_write_phys_memory( target, &tmp_addr, size, count, buffer );
+}
+
+int target32_step(struct target *target,
+		int current, uint64_t address, int handle_breakpoints)
+{
+	struct target_addr _address;
+	TARGET_ADDR_INIT( &_address, address );
+	return target64_step( target, current, &_address, handle_breakpoints);
+}
+
+static int no_mmu(struct target *target, int *enabled)
+{
+	*enabled = 0;
+	return ERROR_OK;
+}
+
+
+void target32_init( struct target *target )
+{
+	struct target_type *type;
+	type = target->type;
+	
+	if( type->pIo32_legacy_api == NULL ){
+		/* This is not a 32bit platform */
+		return;
+	}
+	
+
+	if (type->mmu) {
+		if (type->pIo32_legacy_api->write_phys_memory == NULL) {
+			LOG_ERROR("type '%s' is missing write_phys_memory",
+				  type->name);
+			type->pIo32_legacy_api->write_phys_memory = err_write_phys_memory32;
+		}
+		if (type->pIo32_legacy_api->read_phys_memory == NULL) {
+			LOG_ERROR("type '%s' is missing read_phys_memory",
+				  type->name);
+			type->pIo32_legacy_api->read_phys_memory = err_read_phys_memory32;
+		}
+		if (type->pIo32_legacy_api->virt2phys == NULL) {
+			LOG_ERROR("type '%s' is missing virt2phys", type->name);
+			type->pIo32_legacy_api->virt2phys = identity_virt2phys;
+		}
+	} else {
+		/* Make sure no-MMU targets all behave the same:  make no
+		 * distinction between physical and virtual addresses, and
+		 * ensure that virt2phys() is always an identity mapping.
+		 */
+		if (type->pIo32_legacy_api->write_phys_memory || type->pIo32_legacy_api->read_phys_memory || type->pIo32_legacy_api->virt2phys)
+			LOG_WARNING("type '%s' has bad MMU hooks", type->name);
+		
+		type->mmu = no_mmu;
+		type->pIo32_legacy_api->write_phys_memory = type->pIo32_legacy_api->write_memory;
+		type->pIo32_legacy_api->read_phys_memory = type->pIo32_legacy_api->read_memory;
+		type->pIo32_legacy_api->virt2phys = identity_virt2phys;
+	}
+
+
+	if (type->pIo32_legacy_api->read_buffer == NULL)
+		type->pIo32_legacy_api->read_buffer = target32_read_buffer_default;
+
+	if (type->pIo32_legacy_api->write_buffer == NULL)
+		type->pIo32_legacy_api->write_buffer = target32_write_buffer_default;
+}
+
+int target32_write_buffer(struct target *target, uint64_t address, uint64_t size, const uint8_t *buffer)
+{
+	struct target_addr addr;
+	TARGET_ADDR_INIT( &addr, address );
+	return target64_write_buffer( target, &addr, size, buffer );
+}
+
+
+int target32_read_buffer(struct target *target,
+		uint64_t address, uint64_t size, uint8_t *buffer)
+{
+	struct target_addr tmp_addr;
+	TARGET_ADDR_INIT( &tmp_addr, address );
+	return target64_read_buffer( target,&tmp_addr, size, buffer );
+}
+
+
+int target32_checksum_memory(struct target *target, uint64_t address, uint64_t size, uint32_t* crc)
+{
+	struct target_addr addr;
+	TARGET_ADDR_INIT( &addr, address );
+	return target64_checksum_memory( target, &addr, size, crc );
+}
+
+int target32_blank_check_memory(struct target *target, uint64_t address, uint64_t size, uint32_t* blank)
+{
+	struct target_addr addr;
+	TARGET_ADDR_INIT( &addr, address );
+	return target64_blank_check_memory( target, &addr, size, blank );
+}
+
+
+int target32_read_u32( struct target *target, uint64_t address, uint32_t *value)
+{
+	struct target_addr addr;
+	TARGET_ADDR_INIT( &addr, address );
+	return target64_read_u32( target, &addr, value );
+}
+
+
+int target32_read_u16( struct target *target, uint64_t address, uint16_t *value)
+{
+	struct target_addr addr;
+	TARGET_ADDR_INIT( &addr, address );
+	return target64_read_u16( target, &addr, value );
+}
+
+
+int target32_read_u8(struct target *target, uint64_t address, uint8_t *value)
+{
+	struct target_addr addr;
+	TARGET_ADDR_INIT( &addr, address );
+	return target64_read_u8( target, &addr, value );
+}
+
+int target32_write_u64(struct target *target, uint64_t address, uint64_t value )
+{
+	struct target_addr addr;
+	TARGET_ADDR_INIT( &addr, address );
+	return target64_write_u64( target, &addr, value );
+}
+
+int target32_write_u32(struct target *target, uint64_t address, uint32_t value )
+{
+	struct target_addr addr;
+	TARGET_ADDR_INIT( &addr, address );
+	return target64_write_u32( target, &addr, value );
+}
+
+
+
+
+int target32_write_u16(struct target *target, uint64_t address, uint16_t value )
+{
+	struct target_addr addr;
+	TARGET_ADDR_INIT( &addr, address );
+	return target64_write_u16( target, &addr, value );
+}
+
+int target32_write_u8(struct target *target, uint64_t address, uint8_t value )
+{
+	struct target_addr addr;
+	TARGET_ADDR_INIT( &addr, address );
+	return target64_write_u8( target, &addr, value );
+}
+
+int target32_virt2phys( struct target *target, uint64_t v, uint32_t *p )
+{
+	struct target_addr va,pa;
+	int r;
+	
+	if( target->type->pIo32_legacy_api ){
+		r = target->type->pIo32_legacy_api->virt2phys( target, v, p );
+	} else {
+		TARGET_ADDR_INIT( &va, v );
+		r = target->type->pIo64_api->virt2phys( target, &va, &pa );
+		*p = pa.addr;
+	}
+	return r;
+}
diff --git a/src/target/target_addr.h b/src/target/target_addr.h
new file mode 100644
index 0000000..a085913
--- /dev/null
+++ b/src/target/target_addr.h
@@ -0,0 +1,37 @@
+#if !defined(TARGET_ADDR_H)
+#define TARGET_ADDR_H
+
+enum ta_route {
+	TA_ROUTE_DEFAULT,
+	TA_ROUTE_PHYSICAL,
+	TA_ROUTE_VIRTUAL,
+	TA_ROUTE_TRUSTZONE,
+	TA_ROUTE_HYPERVISOR,
+	
+	TA_ROUTE_arm_dap_port0 = 0x100,
+	TA_ROUTE_arm_dap_port1 = 0x101,
+	TA_ROUTE_arm_dap_port2 = 0x102,
+	TA_ROUTE_arm_dap_port3 = 0x103,
+	TA_ROUTE_arm_dap_port4 = 0x104,
+	TA_ROUTE_arm_dap_port5 = 0x105,
+	TA_ROUTE_arm_dap_port6 = 0x106,
+	TA_ROUTE_arm_dap_port7 = 0x107,
+	/* ... */
+	TA_ROUTE_dap_port255 = 0x1ff,
+
+	TA_force_32bit = 0x12345678
+};
+
+
+struct target_addr {
+	uint64_t addr;
+	enum     ta_route route;
+	uint32_t route_attributes;
+};
+
+extern struct target_addr *__target_addr_init( struct target_addr *pAddr, uint64_t addr );
+extern struct target_addr *__target_addr_phys( struct target_addr *pAddr, uint64_t addr );
+#define TARGET_ADDR_INIT( P, A )  __target_addr_init( P, A )
+#define TARGET_ADDR_PHYS( P, A )  __target_addr_phys( P, A )
+
+#endif
-- 
1.9.1


From 0244aec4b305237e7f41fa84b6b887b9a8bff763 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 26/94] armV8 64bits support

---
 .gitignore                                         |    0
 .gitmodules                                        |    0
 AUTHORS                                            |    0
 AUTHORS.ChangeLog                                  |    0
 BUGS                                               |    0
 COPYING                                            |    0
 ChangeLog                                          |    0
 Doxyfile.in                                        |    0
 HACKING                                            |    0
 Makefile.am                                        |    0
 NEWS                                               |    0
 NEWS-0.2.0                                         |    0
 NEWS-0.3.0                                         |    0
 NEWS-0.4.0                                         |    0
 NEWS-0.5.0                                         |    0
 NEWS-0.6.0                                         |    0
 NEWS-0.7.0                                         |    0
 NEWS-0.8.0                                         |    0
 NEWTAPS                                            |    0
 README                                             |    0
 README.OSX                                         |    0
 README.Windows                                     |    0
 TODO                                               |    0
 common.mk                                          |    0
 config_subdir.m4                                   |    0
 configure.ac                                       |    0
 contrib/99-openocd.rules                           |    0
 contrib/coresight-trace.txt                        |    0
 contrib/itmdump.c                                  |    0
 contrib/libdcc/README                              |    0
 contrib/libdcc/dcc_stdio.c                         |    0
 contrib/libdcc/dcc_stdio.h                         |    0
 contrib/libdcc/example.c                           |    0
 contrib/loaders/README                             |    0
 contrib/loaders/checksum/armv4_5_crc.s             |    0
 contrib/loaders/checksum/armv7m_crc.s              |    0
 contrib/loaders/checksum/mips32.s                  |    0
 contrib/loaders/erase_check/armv4_5_erase_check.s  |    0
 contrib/loaders/erase_check/armv7m_erase_check.s   |    0
 contrib/loaders/flash/armv4_5_cfi_intel_16.s       |    0
 contrib/loaders/flash/armv4_5_cfi_intel_32.s       |    0
 contrib/loaders/flash/armv4_5_cfi_intel_8.s        |    0
 contrib/loaders/flash/armv4_5_cfi_span_16.s        |    0
 contrib/loaders/flash/armv4_5_cfi_span_16_dq7.s    |    0
 contrib/loaders/flash/armv4_5_cfi_span_32.s        |    0
 contrib/loaders/flash/armv4_5_cfi_span_8.s         |    0
 contrib/loaders/flash/armv7m_cfi_span_16.s         |    0
 contrib/loaders/flash/armv7m_cfi_span_16_dq7.s     |    0
 contrib/loaders/flash/armv7m_io.s                  |    0
 .../flash/at91sam7x/at91sam7x_ocl_flash.script     |    0
 contrib/loaders/flash/at91sam7x/at91sam7x_ram.ld   |    0
 contrib/loaders/flash/at91sam7x/crt.s              |    0
 contrib/loaders/flash/at91sam7x/dcc.c              |    0
 contrib/loaders/flash/at91sam7x/dcc.h              |    0
 contrib/loaders/flash/at91sam7x/main.c             |    0
 contrib/loaders/flash/at91sam7x/makefile           |    0
 contrib/loaders/flash/at91sam7x/ocl.h              |    0
 contrib/loaders/flash/at91sam7x/platform.h         |    0
 contrib/loaders/flash/at91sam7x/samflash.c         |    0
 contrib/loaders/flash/at91sam7x/samflash.h         |    0
 contrib/loaders/flash/at91sam7x/samregs.h          |    0
 contrib/loaders/flash/efm32.S                      |    0
 contrib/loaders/flash/lpcspifi_erase.S             |    0
 contrib/loaders/flash/lpcspifi_init.S              |    0
 contrib/loaders/flash/lpcspifi_write.S             |    0
 contrib/loaders/flash/mdr32fx.S                    |    0
 contrib/loaders/flash/mrvlqspi_write.S             |    0
 contrib/loaders/flash/pic32mx.s                    |    0
 contrib/loaders/flash/stellaris.s                  |    0
 contrib/loaders/flash/stm32f1x.S                   |    0
 contrib/loaders/flash/stm32f2x.S                   |    0
 contrib/loaders/flash/stm32lx.S                    |    0
 contrib/loaders/flash/str7x.s                      |    0
 contrib/loaders/flash/str9x.s                      |    0
 contrib/remote_bitbang/remote_bitbang_sysfsgpio.c  |    0
 contrib/rpc_examples/ocdrpc.hs                     |    0
 contrib/xsvf_tools/svf2xsvf.py                     |    0
 contrib/xsvf_tools/xsvfdump.py                     |    0
 doc/INSTALL.txt                                    |    0
 doc/Makefile.am                                    |    0
 doc/fdl.texi                                       |    0
 doc/manual/app.txt                                 |    0
 doc/manual/flash.txt                               |    0
 doc/manual/helper.txt                              |    0
 doc/manual/images/jtag-state-machine-large.png     |  Bin
 doc/manual/jtag.txt                                |    0
 doc/manual/jtag/drivers/remote_bitbang.txt         |    0
 doc/manual/main.txt                                |    0
 doc/manual/primer/autotools.txt                    |    0
 doc/manual/primer/commands.txt                     |    0
 doc/manual/primer/docs.txt                         |    0
 doc/manual/primer/jtag.txt                         |    0
 doc/manual/primer/tcl.txt                          |    0
 doc/manual/release.txt                             |    0
 doc/manual/scripting.txt                           |    0
 doc/manual/server.txt                              |    0
 doc/manual/style.txt                               |    0
 doc/manual/target.txt                              |    0
 doc/manual/target/mips.txt                         |    0
 doc/manual/target/notarm.txt                       |    0
 doc/openocd.1                                      |    0
 doc/openocd.texi                                   |    0
 src/Makefile.am                                    |    0
 src/flash/Makefile.am                              |    0
 src/flash/common.c                                 |    0
 src/flash/common.h                                 |    0
 src/flash/mflash.c                                 |    0
 src/flash/mflash.h                                 |    0
 src/flash/nand/Makefile.am                         |    0
 src/flash/nand/arm_io.c                            |    0
 src/flash/nand/arm_io.h                            |    0
 src/flash/nand/at91sam9.c                          |    0
 src/flash/nand/core.c                              |    0
 src/flash/nand/core.h                              |    0
 src/flash/nand/davinci.c                           |    0
 src/flash/nand/driver.c                            |    0
 src/flash/nand/driver.h                            |    0
 src/flash/nand/ecc.c                               |    0
 src/flash/nand/ecc_kw.c                            |    0
 src/flash/nand/fileio.c                            |    0
 src/flash/nand/fileio.h                            |    0
 src/flash/nand/imp.h                               |    0
 src/flash/nand/lpc3180.c                           |    0
 src/flash/nand/lpc3180.h                           |    0
 src/flash/nand/lpc32xx.c                           |    0
 src/flash/nand/lpc32xx.h                           |    0
 src/flash/nand/mx3.c                               |    0
 src/flash/nand/mx3.h                               |    0
 src/flash/nand/mxc.c                               |    0
 src/flash/nand/mxc.h                               |    0
 src/flash/nand/nonce.c                             |    0
 src/flash/nand/nuc910.c                            |    0
 src/flash/nand/nuc910.h                            |    0
 src/flash/nand/orion.c                             |    0
 src/flash/nand/s3c2410.c                           |    0
 src/flash/nand/s3c2412.c                           |    0
 src/flash/nand/s3c2440.c                           |    0
 src/flash/nand/s3c2443.c                           |    0
 src/flash/nand/s3c24xx.c                           |    0
 src/flash/nand/s3c24xx.h                           |    0
 src/flash/nand/s3c24xx_regs.h                      |    0
 src/flash/nand/s3c6400.c                           |    0
 src/flash/nand/tcl.c                               |    0
 src/flash/nor/Makefile.am                          |    0
 src/flash/nor/aduc702x.c                           |    0
 src/flash/nor/at91sam3.c                           |    0
 src/flash/nor/at91sam4.c                           |    0
 src/flash/nor/at91sam4l.c                          |    0
 src/flash/nor/at91sam7.c                           |    0
 src/flash/nor/at91samd.c                           |    0
 src/flash/nor/avrf.c                               |    0
 src/flash/nor/cfi.c                                |    2 +-
 src/flash/nor/cfi.h                                |    0
 src/flash/nor/core.c                               |    0
 src/flash/nor/core.h                               |    0
 src/flash/nor/driver.h                             |    0
 src/flash/nor/drivers.c                            |    0
 src/flash/nor/dsp5680xx_flash.c                    |    0
 src/flash/nor/efm32.c                              |    0
 src/flash/nor/em357.c                              |    0
 src/flash/nor/faux.c                               |    0
 src/flash/nor/fm3.c                                |    0
 src/flash/nor/imp.h                                |    0
 src/flash/nor/kinetis.c                            |    0
 src/flash/nor/lpc2000.c                            |    2 +-
 src/flash/nor/lpc288x.c                            |    0
 src/flash/nor/lpc2900.c                            |    2 +-
 src/flash/nor/lpcspifi.c                           |    2 +-
 src/flash/nor/mdr.c                                |    0
 src/flash/nor/mini51.c                             |    0
 src/flash/nor/mrvlqspi.c                           |    0
 src/flash/nor/non_cfi.c                            |    0
 src/flash/nor/non_cfi.h                            |    0
 src/flash/nor/nrf51.c                              |    0
 src/flash/nor/nuc1x.c                              |    0
 src/flash/nor/ocl.c                                |    0
 src/flash/nor/ocl.h                                |    0
 src/flash/nor/pic32mx.c                            |    0
 src/flash/nor/spi.c                                |    0
 src/flash/nor/spi.h                                |    0
 src/flash/nor/stellaris.c                          |    0
 src/flash/nor/stm32f1x.c                           |    0
 src/flash/nor/stm32f2x.c                           |    0
 src/flash/nor/stm32lx.c                            |    0
 src/flash/nor/stmsmi.c                             |    0
 src/flash/nor/str7x.c                              |    0
 src/flash/nor/str9x.c                              |    0
 src/flash/nor/str9xpec.c                           |    0
 src/flash/nor/tcl.c                                |    2 +-
 src/flash/nor/tms470.c                             |    0
 src/flash/nor/virtual.c                            |    0
 src/flash/startup.tcl                              |    0
 src/hello.c                                        |    0
 src/hello.h                                        |    0
 src/helper/Makefile.am                             |    0
 src/helper/binarybuffer.c                          |    0
 src/helper/binarybuffer.h                          |    0
 src/helper/command.c                               |    0
 src/helper/command.h                               |    0
 src/helper/configuration.c                         |    0
 src/helper/configuration.h                         |    0
 src/helper/fileio.c                                |    0
 src/helper/fileio.h                                |    0
 src/helper/ioutil.c                                |    0
 src/helper/ioutil.h                                |    0
 src/helper/ioutil_stubs.c                          |    0
 src/helper/jim-nvp.c                               |    0
 src/helper/jim-nvp.h                               |    0
 src/helper/list.h                                  |    0
 src/helper/log.c                                   |    0
 src/helper/log.h                                   |    0
 src/helper/options.c                               |    0
 src/helper/replacements.c                          |    0
 src/helper/replacements.h                          |    0
 src/helper/startup.tcl                             |    0
 src/helper/system.h                                |    0
 src/helper/time_support.c                          |    0
 src/helper/time_support.h                          |    0
 src/helper/time_support_common.c                   |    0
 src/helper/types.h                                 |    0
 src/helper/util.c                                  |    0
 src/helper/util.h                                  |    0
 src/jtag/Makefile.am                               |    0
 src/jtag/adapter.c                                 |    0
 src/jtag/aice/Makefile.am                          |    0
 src/jtag/aice/aice_interface.c                     |    0
 src/jtag/aice/aice_interface.h                     |    0
 src/jtag/aice/aice_pipe.c                          |    0
 src/jtag/aice/aice_pipe.h                          |    0
 src/jtag/aice/aice_port.c                          |    0
 src/jtag/aice/aice_port.h                          |    0
 src/jtag/aice/aice_transport.c                     |    0
 src/jtag/aice/aice_transport.h                     |    0
 src/jtag/aice/aice_usb.c                           |    0
 src/jtag/aice/aice_usb.h                           |    0
 src/jtag/commands.c                                |    0
 src/jtag/commands.h                                |    0
 src/jtag/core.c                                    |    0
 src/jtag/driver.h                                  |    0
 src/jtag/drivers/Makefile.am                       |    0
 src/jtag/drivers/Makefile.rlink                    |    0
 src/jtag/drivers/OpenULINK/Makefile                |    0
 src/jtag/drivers/OpenULINK/README                  |    0
 src/jtag/drivers/OpenULINK/include/common.h        |    0
 src/jtag/drivers/OpenULINK/include/delay.h         |    0
 src/jtag/drivers/OpenULINK/include/io.h            |    0
 src/jtag/drivers/OpenULINK/include/jtag.h          |    0
 src/jtag/drivers/OpenULINK/include/main.h          |    0
 src/jtag/drivers/OpenULINK/include/msgtypes.h      |    0
 src/jtag/drivers/OpenULINK/include/protocol.h      |    0
 src/jtag/drivers/OpenULINK/include/reg_ezusb.h     |    0
 src/jtag/drivers/OpenULINK/include/usb.h           |    0
 src/jtag/drivers/OpenULINK/src/USBJmpTb.a51        |    0
 src/jtag/drivers/OpenULINK/src/delay.c             |    0
 src/jtag/drivers/OpenULINK/src/jtag.c              |    0
 src/jtag/drivers/OpenULINK/src/main.c              |    0
 src/jtag/drivers/OpenULINK/src/protocol.c          |    0
 src/jtag/drivers/OpenULINK/src/usb.c               |    0
 src/jtag/drivers/OpenULINK/ulink_firmware.hex      |    0
 src/jtag/drivers/amt_jtagaccel.c                   |    0
 src/jtag/drivers/arm-jtag-ew.c                     |    0
 src/jtag/drivers/at91rm9200.c                      |    0
 src/jtag/drivers/bcm2835gpio.c                     |    0
 src/jtag/drivers/bitbang.c                         |    0
 src/jtag/drivers/bitbang.h                         |    0
 src/jtag/drivers/bitq.c                            |    0
 src/jtag/drivers/bitq.h                            |    0
 src/jtag/drivers/buspirate.c                       |    0
 src/jtag/drivers/cmsis_dap_usb.c                   |    0
 src/jtag/drivers/driver.c                          |    0
 src/jtag/drivers/dummy.c                           |    0
 src/jtag/drivers/ep93xx.c                          |    0
 src/jtag/drivers/ft2232.c                          |    0
 src/jtag/drivers/ftd2xx_common.h                   |    0
 src/jtag/drivers/ftdi.c                            |    0
 src/jtag/drivers/gw16012.c                         |    0
 src/jtag/drivers/jlink.c                           |    0
 src/jtag/drivers/jtag_vpi.c                        |    0
 src/jtag/drivers/libusb0_common.c                  |    0
 src/jtag/drivers/libusb0_common.h                  |    0
 src/jtag/drivers/libusb1_common.c                  |    0
 src/jtag/drivers/libusb1_common.h                  |    0
 src/jtag/drivers/libusb_common.h                   |    0
 src/jtag/drivers/minidriver_imp.h                  |    0
 src/jtag/drivers/mpsse.c                           |    2 +-
 src/jtag/drivers/mpsse.h                           |    0
 src/jtag/drivers/opendous.c                        |    0
 src/jtag/drivers/openjtag.c                        |    0
 src/jtag/drivers/osbdm.c                           |    0
 src/jtag/drivers/parport.c                         |    0
 src/jtag/drivers/presto.c                          |    0
 src/jtag/drivers/remote_bitbang.c                  |    0
 src/jtag/drivers/rlink.c                           |    0
 src/jtag/drivers/rlink.h                           |    0
 src/jtag/drivers/rlink_call.m4                     |    0
 src/jtag/drivers/rlink_dtc_cmd.h                   |    0
 src/jtag/drivers/rlink_ep1_cmd.h                   |    0
 src/jtag/drivers/rlink_init.m4                     |    0
 src/jtag/drivers/rlink_speed_table.c               |    0
 src/jtag/drivers/rlink_st7.h                       |    0
 src/jtag/drivers/stlink_usb.c                      |    0
 src/jtag/drivers/sysfsgpio.c                       |    0
 src/jtag/drivers/ti_icdi_usb.c                     |    0
 src/jtag/drivers/ulink.c                           |    0
 src/jtag/drivers/usb_blaster/Makefile.am           |    0
 src/jtag/drivers/usb_blaster/README.CheapClone     |    0
 .../drivers/usb_blaster/ublast2_access_libusb.c    |    0
 src/jtag/drivers/usb_blaster/ublast_access.h       |    0
 .../drivers/usb_blaster/ublast_access_ftd2xx.c     |    0
 src/jtag/drivers/usb_blaster/ublast_access_ftdi.c  |    0
 src/jtag/drivers/usb_blaster/usb_blaster.c         |    0
 src/jtag/drivers/usb_common.c                      |    0
 src/jtag/drivers/usb_common.h                      |    0
 src/jtag/drivers/usbprog.c                         |    0
 src/jtag/drivers/versaloon/usbtoxxx/usbtogpio.c    |    0
 src/jtag/drivers/versaloon/usbtoxxx/usbtojtagraw.c |    0
 src/jtag/drivers/versaloon/usbtoxxx/usbtopwr.c     |    0
 src/jtag/drivers/versaloon/usbtoxxx/usbtoswd.c     |    0
 src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.c     |    0
 src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h     |    0
 .../drivers/versaloon/usbtoxxx/usbtoxxx_internal.h |    0
 src/jtag/drivers/versaloon/versaloon.c             |    0
 src/jtag/drivers/versaloon/versaloon.h             |    0
 src/jtag/drivers/versaloon/versaloon_include.h     |    0
 src/jtag/drivers/versaloon/versaloon_internal.h    |    0
 src/jtag/drivers/vsllink.c                         |    0
 src/jtag/hla/Makefile.am                           |    0
 src/jtag/hla/hla_interface.c                       |    0
 src/jtag/hla/hla_interface.h                       |    0
 src/jtag/hla/hla_layout.c                          |    0
 src/jtag/hla/hla_layout.h                          |    0
 src/jtag/hla/hla_tcl.c                             |    0
 src/jtag/hla/hla_tcl.h                             |    0
 src/jtag/hla/hla_transport.c                       |    0
 src/jtag/hla/hla_transport.h                       |    0
 src/jtag/interface.c                               |    0
 src/jtag/interface.h                               |    0
 src/jtag/interfaces.c                              |    0
 src/jtag/interfaces.h                              |    0
 src/jtag/jtag.h                                    |    0
 src/jtag/minidriver.h                              |    0
 src/jtag/minidriver/minidriver_imp.h               |    0
 src/jtag/minidummy/jtag_minidriver.h               |    0
 src/jtag/minidummy/minidummy.c                     |    0
 src/jtag/startup.tcl                               |    0
 src/jtag/swd.h                                     |    0
 src/jtag/tcl.c                                     |    0
 src/jtag/tcl.h                                     |    0
 src/jtag/zy1000/jtag_minidriver.h                  |    0
 src/jtag/zy1000/zy1000.c                           |    0
 src/main.c                                         |    0
 src/openocd.c                                      |    0
 src/openocd.h                                      |    0
 src/pld/Makefile.am                                |    0
 src/pld/pld.c                                      |    0
 src/pld/pld.h                                      |    0
 src/pld/virtex2.c                                  |    0
 src/pld/virtex2.h                                  |    0
 src/pld/xilinx_bit.c                               |    0
 src/pld/xilinx_bit.h                               |    0
 src/rtos/ChibiOS.c                                 |    0
 src/rtos/FreeRTOS.c                                |    0
 src/rtos/Makefile.am                               |    0
 src/rtos/ThreadX.c                                 |    0
 src/rtos/eCos.c                                    |    0
 src/rtos/embKernel.c                               |    0
 src/rtos/linux.c                                   |    2 +-
 src/rtos/linux_header.h                            |    0
 src/rtos/rtos.c                                    |    0
 src/rtos/rtos.h                                    |    0
 src/rtos/rtos_chibios_stackings.c                  |    0
 src/rtos/rtos_chibios_stackings.h                  |    0
 src/rtos/rtos_ecos_stackings.c                     |    0
 src/rtos/rtos_ecos_stackings.h                     |    0
 src/rtos/rtos_embkernel_stackings.c                |    0
 src/rtos/rtos_embkernel_stackings.h                |    0
 src/rtos/rtos_standard_stackings.c                 |    0
 src/rtos/rtos_standard_stackings.h                 |    0
 src/server/Makefile.am                             |    0
 src/server/gdb_server.c                            |   12 +-
 src/server/gdb_server.h                            |    0
 src/server/server.c                                |    0
 src/server/server.h                                |    0
 src/server/server_stubs.c                          |    0
 src/server/startup.tcl                             |    0
 src/server/tcl_server.c                            |    0
 src/server/tcl_server.h                            |    0
 src/server/telnet_server.c                         |    0
 src/server/telnet_server.h                         |    0
 src/svf/Makefile.am                                |    0
 src/svf/svf.c                                      |    0
 src/svf/svf.h                                      |    0
 src/target/Makefile.am                             |    1 +
 src/target/adi_v5_jtag.c                           |    0
 src/target/adi_v5_swd.c                            |    2 +-
 src/target/algorithm.c                             |    2 +-
 src/target/algorithm.h                             |    6 +-
 src/target/arm.h                                   |    0
 src/target/arm11.c                                 |   27 +-
 src/target/arm11.h                                 |    0
 src/target/arm11_dbgtap.c                          |    0
 src/target/arm11_dbgtap.h                          |    0
 src/target/arm720t.c                               |   30 +-
 src/target/arm720t.h                               |    0
 src/target/arm7_9_common.c                         |   14 +-
 src/target/arm7_9_common.h                         |    0
 src/target/arm7tdmi.c                              |   24 +-
 src/target/arm7tdmi.h                              |    0
 src/target/arm920t.c                               |   31 +-
 src/target/arm920t.h                               |    0
 src/target/arm926ejs.c                             |   32 +-
 src/target/arm926ejs.h                             |    0
 src/target/arm946e.c                               |   29 +-
 src/target/arm946e.h                               |    0
 src/target/arm966e.c                               |   25 +-
 src/target/arm966e.h                               |    0
 src/target/arm9tdmi.c                              |   23 +-
 src/target/arm9tdmi.h                              |    0
 src/target/arm_adi_v5.c                            |    0
 src/target/arm_adi_v5.h                            |    0
 src/target/arm_disassembler.c                      |    0
 src/target/arm_disassembler.h                      |    0
 src/target/arm_dpm.c                               |    0
 src/target/arm_dpm.h                               |    0
 src/target/arm_jtag.c                              |    0
 src/target/arm_jtag.h                              |    0
 src/target/arm_opcodes.h                           |    0
 src/target/arm_semihosting.c                       |    0
 src/target/arm_semihosting.h                       |    0
 src/target/arm_simulator.c                         |    0
 src/target/arm_simulator.h                         |    0
 src/target/armv4_5.c                               |    0
 src/target/armv4_5.h                               |    0
 src/target/armv4_5_cache.c                         |    0
 src/target/armv4_5_cache.h                         |    0
 src/target/armv4_5_mmu.c                           |    0
 src/target/armv4_5_mmu.h                           |    0
 src/target/armv7a.c                                |    2 +-
 src/target/armv7a.h                                |    0
 src/target/armv7m.c                                |    0
 src/target/armv7m.h                                |    0
 src/target/armv8.c                                 |  139 +--
 src/target/armv8_dpm.c                             |    8 +-
 src/target/armv8_dpm.h                             |    2 +-
 src/target/avr32_ap7k.c                            |   24 +-
 src/target/avr32_ap7k.h                            |    0
 src/target/avr32_jtag.c                            |    0
 src/target/avr32_jtag.h                            |    0
 src/target/avr32_mem.c                             |    0
 src/target/avr32_mem.h                             |    0
 src/target/avr32_regs.c                            |    0
 src/target/avr32_regs.h                            |    0
 src/target/avrt.c                                  |   30 +-
 src/target/avrt.h                                  |    0
 src/target/breakpoints.c                           |  207 ++--
 src/target/breakpoints.h                           |   60 +-
 src/target/cortex_a.c                              |   56 +-
 src/target/cortex_a.h                              |    0
 src/target/cortex_a53.c                            |  361 +++---
 src/target/cortex_m.c                              |   31 +-
 src/target/cortex_m.h                              |    0
 src/target/dsp563xx.c                              |   23 +-
 src/target/dsp563xx.h                              |    0
 src/target/dsp563xx_once.c                         |    0
 src/target/dsp563xx_once.h                         |    0
 src/target/dsp5680xx.c                             |   23 +-
 src/target/dsp5680xx.h                             |    0
 src/target/embeddedice.c                           |    0
 src/target/embeddedice.h                           |    0
 src/target/etb.c                                   |    0
 src/target/etb.h                                   |    0
 src/target/etm.c                                   |    2 +-
 src/target/etm.h                                   |    0
 src/target/etm_dummy.c                             |    0
 src/target/etm_dummy.h                             |    0
 src/target/fa526.c                                 |   24 +-
 src/target/feroceon.c                              |   48 +-
 src/target/hla_target.c                            |   27 +-
 src/target/image.c                                 |   31 +-
 src/target/image.h                                 |   19 +-
 src/target/lakemont.c                              |    0
 src/target/lakemont.h                              |    0
 src/target/mips32.c                                |    0
 src/target/mips32.h                                |    0
 src/target/mips32_dmaacc.c                         |    0
 src/target/mips32_dmaacc.h                         |    0
 src/target/mips32_pracc.c                          |    2 +-
 src/target/mips32_pracc.h                          |    0
 src/target/mips_ejtag.c                            |    0
 src/target/mips_ejtag.h                            |    0
 src/target/mips_m4k.c                              |   29 +-
 src/target/mips_m4k.h                              |    0
 src/target/nds32.c                                 |   24 +-
 src/target/nds32.h                                 |    0
 src/target/nds32_aice.c                            |    0
 src/target/nds32_aice.h                            |    0
 src/target/nds32_cmd.c                             |    0
 src/target/nds32_cmd.h                             |    0
 src/target/nds32_disassembler.c                    |    0
 src/target/nds32_disassembler.h                    |    0
 src/target/nds32_edm.h                             |    0
 src/target/nds32_insn.h                            |    0
 src/target/nds32_reg.c                             |    0
 src/target/nds32_reg.h                             |    0
 src/target/nds32_tlb.c                             |    0
 src/target/nds32_tlb.h                             |    0
 src/target/nds32_v2.c                              |   42 +-
 src/target/nds32_v2.h                              |    0
 src/target/nds32_v3.c                              |   41 +-
 src/target/nds32_v3.h                              |    0
 src/target/nds32_v3_common.c                       |    8 +-
 src/target/nds32_v3_common.h                       |    0
 src/target/nds32_v3m.c                             |   45 +-
 src/target/nds32_v3m.h                             |    0
 src/target/oocd_trace.c                            |    0
 src/target/oocd_trace.h                            |    0
 src/target/openrisc/Makefile.am                    |    0
 src/target/openrisc/jsp_server.c                   |    0
 src/target/openrisc/jsp_server.h                   |    0
 src/target/openrisc/or1k.c                         |   36 +-
 src/target/openrisc/or1k.h                         |    0
 src/target/openrisc/or1k_du.h                      |    0
 src/target/openrisc/or1k_du_adv.c                  |    0
 src/target/openrisc/or1k_tap.h                     |    0
 src/target/openrisc/or1k_tap_mohor.c               |    0
 src/target/openrisc/or1k_tap_vjtag.c               |    0
 src/target/openrisc/or1k_tap_xilinx_bscan.c        |    0
 src/target/quark_x10xx.c                           |   20 +-
 src/target/register.c                              |    0
 src/target/register.h                              |    0
 src/target/smp.c                                   |    0
 src/target/smp.h                                   |    0
 src/target/startup.tcl                             |    0
 src/target/target.c                                | 1283 +++++++++++++-------
 src/target/target.h                                |  258 +++-
 src/target/target32.c                              |    0
 src/target/target_addr.h                           |    0
 src/target/target_request.c                        |    0
 src/target/target_request.h                        |    0
 src/target/target_type.h                           |  238 ++--
 src/target/testee.c                                |    0
 src/target/trace.c                                 |    0
 src/target/trace.h                                 |    0
 src/target/x86_32_common.c                         |   34 +-
 src/target/x86_32_common.h                         |    0
 src/target/xscale.c                                |   35 +-
 src/target/xscale.h                                |    0
 src/target/xscale/debug_handler.S                  |    0
 src/target/xscale/debug_handler.cmd                |    0
 src/target/xscale/protocol.h                       |    0
 src/transport/Makefile.am                          |    0
 src/transport/transport.c                          |    0
 src/transport/transport.h                          |    0
 src/xsvf/Makefile.am                               |    0
 src/xsvf/xsvf.c                                    |    0
 src/xsvf/xsvf.h                                    |    0
 tcl/bitsbytes.tcl                                  |    0
 tcl/board/actux3.cfg                               |    0
 tcl/board/altera_sockit.cfg                        |    0
 tcl/board/am3517evm.cfg                            |    0
 tcl/board/arm_evaluator7t.cfg                      |    0
 tcl/board/asus-rt-n16.cfg                          |    0
 tcl/board/asus-rt-n66u.cfg                         |    0
 tcl/board/at91cap7a-stk-sdram.cfg                  |    0
 tcl/board/at91eb40a.cfg                            |    0
 tcl/board/at91rm9200-dk.cfg                        |    0
 tcl/board/at91rm9200-ek.cfg                        |    0
 tcl/board/at91sam9261-ek.cfg                       |    0
 tcl/board/at91sam9263-ek.cfg                       |    0
 tcl/board/at91sam9g20-ek.cfg                       |    0
 tcl/board/atmel_at91sam7s-ek.cfg                   |    0
 tcl/board/atmel_at91sam9260-ek.cfg                 |    0
 tcl/board/atmel_at91sam9rl-ek.cfg                  |    0
 tcl/board/atmel_sam3n_ek.cfg                       |    0
 tcl/board/atmel_sam3s_ek.cfg                       |    0
 tcl/board/atmel_sam3u_ek.cfg                       |    0
 tcl/board/atmel_sam3x_ek.cfg                       |    0
 tcl/board/atmel_sam4e_ek.cfg                       |    0
 tcl/board/atmel_sam4l8_xplained_pro.cfg            |    0
 tcl/board/atmel_sam4s_ek.cfg                       |    0
 tcl/board/atmel_sam4s_xplained_pro.cfg             |    0
 tcl/board/atmel_samd20_xplained_pro.cfg            |    0
 tcl/board/atmel_samd21_xplained_pro.cfg            |    0
 tcl/board/atmel_samg53_xplained_pro.cfg            |    0
 tcl/board/atmel_samr21_xplained_pro.cfg            |    0
 tcl/board/balloon3-cpu.cfg                         |    0
 tcl/board/bcm28155_ap.cfg                          |    0
 tcl/board/bt-homehubv1.cfg                         |    0
 tcl/board/colibri.cfg                              |    0
 tcl/board/crossbow_tech_imote2.cfg                 |    0
 tcl/board/csb337.cfg                               |    0
 tcl/board/csb732.cfg                               |    0
 tcl/board/da850evm.cfg                             |    0
 tcl/board/digi_connectcore_wi-9c.cfg               |    0
 tcl/board/digilent_zedboard.cfg                    |    0
 tcl/board/diolan_lpc4350-db1.cfg                   |    0
 tcl/board/dm355evm.cfg                             |    0
 tcl/board/dm365evm.cfg                             |    0
 tcl/board/dm6446evm.cfg                            |    0
 tcl/board/dp_busblaster_v3.cfg                     |    0
 tcl/board/efikamx.cfg                              |    0
 tcl/board/eir.cfg                                  |    0
 tcl/board/ek-lm3s1968.cfg                          |    0
 tcl/board/ek-lm3s3748.cfg                          |    0
 tcl/board/ek-lm3s6965.cfg                          |    0
 tcl/board/ek-lm3s811-revb.cfg                      |    0
 tcl/board/ek-lm3s811.cfg                           |    0
 tcl/board/ek-lm3s8962.cfg                          |    0
 tcl/board/ek-lm3s9b9x.cfg                          |    0
 tcl/board/ek-lm3s9d92.cfg                          |    0
 tcl/board/ek-lm4f120xl.cfg                         |    0
 tcl/board/ek-lm4f232.cfg                           |    0
 tcl/board/ek-tm4c123gxl.cfg                        |    0
 tcl/board/ek-tm4c1294xl.cfg                        |    0
 tcl/board/embedded-artists_lpc2478-32.cfg          |    0
 tcl/board/ethernut3.cfg                            |    0
 tcl/board/frdm-kl25z.cfg                           |    0
 tcl/board/frdm-kl46z.cfg                           |    0
 tcl/board/glyn_tonga2.cfg                          |    0
 tcl/board/gumstix-aerocore.cfg                     |    0
 tcl/board/hammer.cfg                               |    0
 tcl/board/hilscher_nxdb500sys.cfg                  |    0
 tcl/board/hilscher_nxeb500hmi.cfg                  |    0
 tcl/board/hilscher_nxhx10.cfg                      |    0
 tcl/board/hilscher_nxhx50.cfg                      |    0
 tcl/board/hilscher_nxhx500.cfg                     |    0
 tcl/board/hilscher_nxsb100.cfg                     |    0
 tcl/board/hitex_lpc1768stick.cfg                   |    0
 tcl/board/hitex_lpc2929.cfg                        |    0
 tcl/board/hitex_stm32-performancestick.cfg         |    0
 tcl/board/hitex_str9-comstick.cfg                  |    0
 tcl/board/iar_lpc1768.cfg                          |    0
 tcl/board/iar_str912_sk.cfg                        |    0
 tcl/board/icnova_imx53_sodimm.cfg                  |    0
 tcl/board/icnova_sam9g45_sodimm.cfg                |    0
 tcl/board/imx27ads.cfg                             |    0
 tcl/board/imx27lnst.cfg                            |    0
 tcl/board/imx28evk.cfg                             |    0
 tcl/board/imx31pdk.cfg                             |    0
 tcl/board/imx35pdk.cfg                             |    0
 tcl/board/imx53-m53evk.cfg                         |    0
 tcl/board/imx53loco.cfg                            |    0
 tcl/board/keil_mcb1700.cfg                         |    0
 tcl/board/keil_mcb2140.cfg                         |    0
 tcl/board/kwikstik.cfg                             |    0
 tcl/board/linksys-wrt54gl.cfg                      |    0
 tcl/board/linksys_nslu2.cfg                        |    0
 tcl/board/lisa-l.cfg                               |    0
 tcl/board/logicpd_imx27.cfg                        |    0
 tcl/board/lpc1850_spifi_generic.cfg                |    0
 tcl/board/lpc4350_spifi_generic.cfg                |    0
 tcl/board/lubbock.cfg                              |    0
 tcl/board/mbed-lpc11u24.cfg                        |    0
 tcl/board/mbed-lpc1768.cfg                         |    0
 tcl/board/mcb1700.cfg                              |    0
 tcl/board/microchip_explorer16.cfg                 |    0
 tcl/board/mini2440.cfg                             |    0
 tcl/board/mini6410.cfg                             |    0
 tcl/board/nds32_xc5.cfg                            |    0
 tcl/board/netgear-dg834v3.cfg                      |    0
 tcl/board/nordic_nrf51822_mkit.cfg                 |    0
 tcl/board/olimex_LPC2378STK.cfg                    |    0
 tcl/board/olimex_lpc_h2148.cfg                     |    0
 tcl/board/olimex_sam7_ex256.cfg                    |    2 +-
 tcl/board/olimex_sam9_l9260.cfg                    |    0
 tcl/board/olimex_stm32_h103.cfg                    |    0
 tcl/board/olimex_stm32_h107.cfg                    |    0
 tcl/board/olimex_stm32_p107.cfg                    |    0
 tcl/board/omap2420_h4.cfg                          |    0
 tcl/board/open-bldc.cfg                            |    0
 tcl/board/openrd.cfg                               |    0
 tcl/board/or1k_generic.cfg                         |    0
 tcl/board/osk5912.cfg                              |    0
 tcl/board/phone_se_j100i.cfg                       |    0
 tcl/board/phytec_lpc3250.cfg                       |    0
 tcl/board/pic-p32mx.cfg                            |    0
 tcl/board/propox_mmnet1001.cfg                     |    0
 tcl/board/pxa255_sst.cfg                           |    0
 tcl/board/quark_x10xx_board.cfg                    |    0
 tcl/board/redbee.cfg                               |    0
 tcl/board/rsc-w910.cfg                             |    0
 tcl/board/sheevaplug.cfg                           |    0
 tcl/board/smdk6410.cfg                             |    0
 tcl/board/spear300evb.cfg                          |    0
 tcl/board/spear300evb_mod.cfg                      |    0
 tcl/board/spear310evb20.cfg                        |    0
 tcl/board/spear310evb20_mod.cfg                    |    0
 tcl/board/spear320cpu.cfg                          |    0
 tcl/board/spear320cpu_mod.cfg                      |    0
 tcl/board/st_nucleo_f030r8.cfg                     |    0
 tcl/board/st_nucleo_f103rb.cfg                     |    0
 tcl/board/st_nucleo_f334r8.cfg                     |    0
 tcl/board/st_nucleo_f401re.cfg                     |    0
 tcl/board/st_nucleo_f411re.cfg                     |    0
 tcl/board/steval_pcc010.cfg                        |    0
 tcl/board/stm320518_eval.cfg                       |    0
 tcl/board/stm320518_eval_stlink.cfg                |    0
 tcl/board/stm32100b_eval.cfg                       |    0
 tcl/board/stm3210b_eval.cfg                        |    0
 tcl/board/stm3210c_eval.cfg                        |    0
 tcl/board/stm3210e_eval.cfg                        |    0
 tcl/board/stm3220g_eval.cfg                        |    0
 tcl/board/stm3220g_eval_stlink.cfg                 |    0
 tcl/board/stm3241g_eval.cfg                        |    0
 tcl/board/stm3241g_eval_stlink.cfg                 |    0
 tcl/board/stm32429i_eval.cfg                       |    0
 tcl/board/stm32429i_eval_stlink.cfg                |    0
 tcl/board/stm32439i_eval.cfg                       |    0
 tcl/board/stm32439i_eval_stlink.cfg                |    0
 tcl/board/stm32f0discovery.cfg                     |    0
 tcl/board/stm32f3discovery.cfg                     |    0
 tcl/board/stm32f429discovery.cfg                   |    0
 tcl/board/stm32f4discovery.cfg                     |    0
 tcl/board/stm32l0discovery.cfg                     |    0
 tcl/board/stm32ldiscovery.cfg                      |    0
 tcl/board/stm32vldiscovery.cfg                     |    0
 tcl/board/str910-eval.cfg                          |    0
 tcl/board/telo.cfg                                 |    0
 tcl/board/ti_am335xevm.cfg                         |    0
 tcl/board/ti_am43xx_evm.cfg                        |    0
 tcl/board/ti_beagleboard.cfg                       |    0
 tcl/board/ti_beagleboard_xm.cfg                    |    0
 tcl/board/ti_beaglebone.cfg                        |    0
 tcl/board/ti_blaze.cfg                             |    0
 tcl/board/ti_pandaboard.cfg                        |    0
 tcl/board/ti_pandaboard_es.cfg                     |    0
 tcl/board/ti_tmdx570ls31usb.cfg                    |    0
 tcl/board/topas910.cfg                             |    0
 tcl/board/topasa900.cfg                            |    0
 tcl/board/twr-k60f120m.cfg                         |    0
 tcl/board/twr-k60n512.cfg                          |    0
 tcl/board/tx25_stk5.cfg                            |    0
 tcl/board/tx27_stk5.cfg                            |    0
 tcl/board/unknown_at91sam9260.cfg                  |    0
 tcl/board/uptech_2410.cfg                          |    0
 tcl/board/verdex.cfg                               |    0
 tcl/board/voipac.cfg                               |    0
 tcl/board/voltcraft_dso-3062c.cfg                  |    0
 tcl/board/x300t.cfg                                |    0
 tcl/board/zy1000.cfg                               |    0
 tcl/chip/atmel/at91/aic.tcl                        |    0
 tcl/chip/atmel/at91/at91_pio.cfg                   |    0
 tcl/chip/atmel/at91/at91_pmc.cfg                   |    0
 tcl/chip/atmel/at91/at91_rstc.cfg                  |    0
 tcl/chip/atmel/at91/at91_wdt.cfg                   |    0
 tcl/chip/atmel/at91/at91sam7x128.tcl               |    0
 tcl/chip/atmel/at91/at91sam7x256.tcl               |    0
 tcl/chip/atmel/at91/at91sam9261.cfg                |    0
 tcl/chip/atmel/at91/at91sam9261_matrix.cfg         |    0
 tcl/chip/atmel/at91/at91sam9263.cfg                |    0
 tcl/chip/atmel/at91/at91sam9263_matrix.cfg         |    0
 tcl/chip/atmel/at91/at91sam9_init.cfg              |    0
 tcl/chip/atmel/at91/at91sam9_sdramc.cfg            |    0
 tcl/chip/atmel/at91/at91sam9_smc.cfg               |    0
 tcl/chip/atmel/at91/hardware.cfg                   |    0
 tcl/chip/atmel/at91/pmc.tcl                        |    0
 tcl/chip/atmel/at91/rtt.tcl                        |    0
 tcl/chip/atmel/at91/sam9_smc.cfg                   |    0
 tcl/chip/atmel/at91/usarts.tcl                     |    0
 tcl/chip/st/spear/quirk_no_srst.tcl                |    0
 tcl/chip/st/spear/spear3xx.tcl                     |    0
 tcl/chip/st/spear/spear3xx_ddr.tcl                 |    0
 tcl/chip/st/stm32/stm32.tcl                        |    0
 tcl/chip/st/stm32/stm32_rcc.tcl                    |    0
 tcl/chip/st/stm32/stm32_regs.tcl                   |    0
 tcl/chip/ti/lm3s/lm3s.tcl                          |    0
 tcl/chip/ti/lm3s/lm3s_regs.tcl                     |    0
 tcl/cpld/lattice-lc4032ze.cfg                      |    0
 tcl/cpld/xilinx-xcr3256.cfg                        |    0
 tcl/cpu/arm/arm7tdmi.tcl                           |    0
 tcl/cpu/arm/arm920.tcl                             |    0
 tcl/cpu/arm/arm946.tcl                             |    0
 tcl/cpu/arm/arm966.tcl                             |    0
 tcl/cpu/arm/cortex_m3.tcl                          |    0
 tcl/interface/altera-usb-blaster.cfg               |    0
 tcl/interface/altera-usb-blaster2.cfg              |    0
 tcl/interface/arm-jtag-ew.cfg                      |    0
 tcl/interface/at91rm9200.cfg                       |    0
 tcl/interface/axm0432.cfg                          |    0
 tcl/interface/busblaster.cfg                       |    0
 tcl/interface/buspirate.cfg                        |    0
 tcl/interface/calao-usb-a9260-c01.cfg              |    0
 tcl/interface/calao-usb-a9260-c02.cfg              |    0
 tcl/interface/calao-usb-a9260.cfg                  |    0
 tcl/interface/chameleon.cfg                        |    0
 tcl/interface/cmsis-dap.cfg                        |    0
 tcl/interface/cortino.cfg                          |    0
 tcl/interface/digilent-hs1.cfg                     |    0
 tcl/interface/dlp-usb1232h.cfg                     |    0
 tcl/interface/dummy.cfg                            |    0
 tcl/interface/estick.cfg                           |    0
 tcl/interface/flashlink.cfg                        |    0
 tcl/interface/flossjtag-noeeprom.cfg               |    0
 tcl/interface/flossjtag.cfg                        |    0
 tcl/interface/flyswatter.cfg                       |    0
 tcl/interface/flyswatter2.cfg                      |    0
 tcl/interface/ftdi/axm0432.cfg                     |    0
 tcl/interface/ftdi/calao-usb-a9260-c01.cfg         |    0
 tcl/interface/ftdi/calao-usb-a9260-c02.cfg         |    0
 tcl/interface/ftdi/cortino.cfg                     |    0
 tcl/interface/ftdi/digilent_jtag_smt2.cfg          |    0
 tcl/interface/ftdi/dlp-usb1232h.cfg                |    0
 tcl/interface/ftdi/dp_busblaster.cfg               |    0
 tcl/interface/ftdi/dp_busblaster_kt-link.cfg       |    0
 tcl/interface/ftdi/flossjtag-noeeprom.cfg          |    0
 tcl/interface/ftdi/flossjtag.cfg                   |    0
 tcl/interface/ftdi/flyswatter.cfg                  |    0
 tcl/interface/ftdi/flyswatter2.cfg                 |    0
 tcl/interface/ftdi/gw16042.cfg                     |    0
 tcl/interface/ftdi/hilscher_nxhx10_etm.cfg         |    0
 tcl/interface/ftdi/hilscher_nxhx500_etm.cfg        |    0
 tcl/interface/ftdi/hilscher_nxhx500_re.cfg         |    0
 tcl/interface/ftdi/hilscher_nxhx50_etm.cfg         |    0
 tcl/interface/ftdi/hilscher_nxhx50_re.cfg          |    0
 tcl/interface/ftdi/hitex_lpc1768stick.cfg          |    0
 tcl/interface/ftdi/hitex_str9-comstick.cfg         |    0
 tcl/interface/ftdi/icebear.cfg                     |    0
 tcl/interface/ftdi/jtag-lock-pick_tiny_2.cfg       |    0
 tcl/interface/ftdi/jtagkey.cfg                     |    0
 tcl/interface/ftdi/jtagkey2.cfg                    |    0
 tcl/interface/ftdi/jtagkey2p.cfg                   |    0
 tcl/interface/ftdi/kt-link.cfg                     |    0
 tcl/interface/ftdi/lisa-l.cfg                      |    0
 tcl/interface/ftdi/luminary-icdi.cfg               |    0
 tcl/interface/ftdi/luminary-lm3s811.cfg            |    0
 tcl/interface/ftdi/luminary.cfg                    |    0
 tcl/interface/ftdi/m53evk.cfg                      |    0
 tcl/interface/ftdi/minimodule.cfg                  |    0
 tcl/interface/ftdi/neodb.cfg                       |    0
 tcl/interface/ftdi/ngxtech.cfg                     |    0
 tcl/interface/ftdi/olimex-arm-jtag-swd.cfg         |    0
 tcl/interface/ftdi/olimex-arm-usb-ocd-h.cfg        |    0
 tcl/interface/ftdi/olimex-arm-usb-ocd.cfg          |    0
 tcl/interface/ftdi/olimex-arm-usb-tiny-h.cfg       |    0
 tcl/interface/ftdi/olimex-jtag-tiny.cfg            |    0
 tcl/interface/ftdi/oocdlink.cfg                    |    0
 tcl/interface/ftdi/opendous_ftdi.cfg               |    0
 tcl/interface/ftdi/openocd-usb-hs.cfg              |    0
 tcl/interface/ftdi/openocd-usb.cfg                 |    0
 tcl/interface/ftdi/openrd.cfg                      |    0
 tcl/interface/ftdi/redbee-econotag.cfg             |    0
 tcl/interface/ftdi/redbee-usb.cfg                  |    0
 tcl/interface/ftdi/rowley-cc-arm-swd.cfg           |    0
 tcl/interface/ftdi/sheevaplug.cfg                  |    0
 tcl/interface/ftdi/signalyzer-lite.cfg             |    0
 tcl/interface/ftdi/signalyzer.cfg                  |    0
 tcl/interface/ftdi/stm32-stick.cfg                 |    0
 tcl/interface/ftdi/swd-resistor-hack.cfg           |    0
 tcl/interface/ftdi/tumpa-lite.cfg                  |    0
 tcl/interface/ftdi/tumpa.cfg                       |    0
 tcl/interface/ftdi/turtelizer2-revB.cfg            |    0
 tcl/interface/ftdi/turtelizer2-revC.cfg            |    0
 tcl/interface/ftdi/vpaclink.cfg                    |    0
 tcl/interface/ftdi/xds100v2.cfg                    |    0
 tcl/interface/hilscher_nxhx10_etm.cfg              |    0
 tcl/interface/hilscher_nxhx500_etm.cfg             |    0
 tcl/interface/hilscher_nxhx500_re.cfg              |    0
 tcl/interface/hilscher_nxhx50_etm.cfg              |    0
 tcl/interface/hilscher_nxhx50_re.cfg               |    0
 tcl/interface/hitex_str9-comstick.cfg              |    0
 tcl/interface/icebear.cfg                          |    0
 tcl/interface/jlink.cfg                            |    0
 tcl/interface/jtag-lock-pick_tiny_2.cfg            |    0
 tcl/interface/jtag_vpi.cfg                         |    0
 tcl/interface/jtagkey-tiny.cfg                     |    0
 tcl/interface/jtagkey.cfg                          |    0
 tcl/interface/jtagkey2.cfg                         |    0
 tcl/interface/jtagkey2p.cfg                        |    0
 tcl/interface/kt-link.cfg                          |    0
 tcl/interface/lisa-l.cfg                           |    0
 tcl/interface/luminary-icdi.cfg                    |    0
 tcl/interface/luminary-lm3s811.cfg                 |    0
 tcl/interface/luminary.cfg                         |    0
 tcl/interface/minimodule.cfg                       |    0
 tcl/interface/nds32-aice.cfg                       |    0
 tcl/interface/neodb.cfg                            |    0
 tcl/interface/ngxtech.cfg                          |    0
 tcl/interface/olimex-arm-usb-ocd-h.cfg             |    0
 tcl/interface/olimex-arm-usb-ocd.cfg               |    0
 tcl/interface/olimex-arm-usb-tiny-h.cfg            |    0
 tcl/interface/olimex-jtag-tiny.cfg                 |    0
 tcl/interface/oocdlink.cfg                         |    0
 tcl/interface/opendous.cfg                         |    0
 tcl/interface/opendous_ftdi.cfg                    |    0
 tcl/interface/openjtag.cfg                         |    0
 tcl/interface/openocd-usb-hs.cfg                   |    0
 tcl/interface/openocd-usb.cfg                      |    0
 tcl/interface/openrd.cfg                           |    0
 tcl/interface/osbdm.cfg                            |    0
 tcl/interface/parport.cfg                          |    0
 tcl/interface/parport_dlc5.cfg                     |    0
 tcl/interface/raspberrypi-native.cfg               |    0
 tcl/interface/redbee-econotag.cfg                  |    0
 tcl/interface/redbee-usb.cfg                       |    0
 tcl/interface/rlink.cfg                            |    0
 tcl/interface/sheevaplug.cfg                       |    0
 tcl/interface/signalyzer-h2.cfg                    |    0
 tcl/interface/signalyzer-h4.cfg                    |    0
 tcl/interface/signalyzer-lite.cfg                  |    0
 tcl/interface/signalyzer.cfg                       |    0
 tcl/interface/stlink-v1.cfg                        |    0
 tcl/interface/stlink-v2-1.cfg                      |    0
 tcl/interface/stlink-v2.cfg                        |    0
 tcl/interface/stm32-stick.cfg                      |    0
 tcl/interface/sysfsgpio-raspberrypi.cfg            |    0
 tcl/interface/ti-icdi.cfg                          |    0
 tcl/interface/turtelizer2.cfg                      |    0
 tcl/interface/ulink.cfg                            |    0
 tcl/interface/usb-jtag.cfg                         |    0
 tcl/interface/usbprog.cfg                          |    0
 tcl/interface/vpaclink.cfg                         |    0
 tcl/interface/vsllink.cfg                          |    0
 tcl/interface/xds100v2.cfg                         |    0
 tcl/mem_helper.tcl                                 |    0
 tcl/memory.tcl                                     |    0
 tcl/mmr_helpers.tcl                                |    0
 "tcl/target/1986\320\262\320\2651\321\202.cfg"     |    0
 tcl/target/aduc702x.cfg                            |    0
 tcl/target/altera_fpgasoc.cfg                      |    0
 tcl/target/am335x.cfg                              |    0
 tcl/target/am437x.cfg                              |    0
 tcl/target/amdm37x.cfg                             |    0
 tcl/target/ar71xx.cfg                              |    0
 tcl/target/armada370.cfg                           |    0
 tcl/target/at32ap7000.cfg                          |    0
 tcl/target/at91r40008.cfg                          |    0
 tcl/target/at91rm9200.cfg                          |    0
 tcl/target/at91sam3XXX.cfg                         |    0
 tcl/target/at91sam3ax_4x.cfg                       |    0
 tcl/target/at91sam3ax_8x.cfg                       |    0
 tcl/target/at91sam3ax_xx.cfg                       |    0
 tcl/target/at91sam3nXX.cfg                         |    0
 tcl/target/at91sam3sXX.cfg                         |    0
 tcl/target/at91sam3u1c.cfg                         |    0
 tcl/target/at91sam3u1e.cfg                         |    0
 tcl/target/at91sam3u2c.cfg                         |    0
 tcl/target/at91sam3u2e.cfg                         |    0
 tcl/target/at91sam3u4c.cfg                         |    0
 tcl/target/at91sam3u4e.cfg                         |    0
 tcl/target/at91sam3uxx.cfg                         |    0
 tcl/target/at91sam4XXX.cfg                         |    0
 tcl/target/at91sam4lXX.cfg                         |    0
 tcl/target/at91sam4sXX.cfg                         |    0
 tcl/target/at91sam4sd32x.cfg                       |    0
 tcl/target/at91sam7se512.cfg                       |    0
 tcl/target/at91sam7sx.cfg                          |    0
 tcl/target/at91sam7x256.cfg                        |    0
 tcl/target/at91sam7x512.cfg                        |    0
 tcl/target/at91sam9.cfg                            |    0
 tcl/target/at91sam9260.cfg                         |    0
 tcl/target/at91sam9260_ext_RAM_ext_flash.cfg       |    0
 tcl/target/at91sam9261.cfg                         |    0
 tcl/target/at91sam9263.cfg                         |    0
 tcl/target/at91sam9g10.cfg                         |    0
 tcl/target/at91sam9g20.cfg                         |    0
 tcl/target/at91sam9g45.cfg                         |    0
 tcl/target/at91sam9rl.cfg                          |    0
 tcl/target/at91samdXX.cfg                          |    0
 tcl/target/at91samg5x.cfg                          |    0
 tcl/target/atmega128.cfg                           |    0
 tcl/target/avr32.cfg                               |    0
 tcl/target/bcm281xx.cfg                            |    0
 tcl/target/bcm4706.cfg                             |    0
 tcl/target/bcm4718.cfg                             |    0
 tcl/target/bcm47xx.cfg                             |    0
 tcl/target/bcm5352e.cfg                            |    0
 tcl/target/bcm6348.cfg                             |    0
 tcl/target/c100.cfg                                |    0
 tcl/target/c100config.tcl                          |    0
 tcl/target/c100helper.tcl                          |    0
 tcl/target/c100regs.tcl                            |    0
 tcl/target/cs351x.cfg                              |    0
 tcl/target/davinci.cfg                             |    0
 tcl/target/dragonite.cfg                           |    0
 tcl/target/dsp56321.cfg                            |    0
 tcl/target/dsp568013.cfg                           |    0
 tcl/target/dsp568037.cfg                           |    0
 tcl/target/efm32.cfg                               |    0
 tcl/target/efm32_stlink.cfg                        |    0
 tcl/target/epc9301.cfg                             |    0
 tcl/target/faux.cfg                                |    0
 tcl/target/feroceon.cfg                            |    0
 tcl/target/fm3.cfg                                 |    0
 tcl/target/gp326xxxa.cfg                           |    0
 tcl/target/hilscher_netx10.cfg                     |    0
 tcl/target/hilscher_netx50.cfg                     |    0
 tcl/target/hilscher_netx500.cfg                    |    0
 tcl/target/icepick.cfg                             |    0
 tcl/target/imx.cfg                                 |    0
 tcl/target/imx21.cfg                               |    0
 tcl/target/imx25.cfg                               |    0
 tcl/target/imx27.cfg                               |    0
 tcl/target/imx28.cfg                               |    0
 tcl/target/imx31.cfg                               |    0
 tcl/target/imx35.cfg                               |    0
 tcl/target/imx51.cfg                               |    0
 tcl/target/imx53.cfg                               |    0
 tcl/target/imx6.cfg                                |    0
 tcl/target/is5114.cfg                              |    0
 tcl/target/ixp42x.cfg                              |    0
 tcl/target/k40.cfg                                 |    0
 tcl/target/k60.cfg                                 |    0
 tcl/target/kl25.cfg                                |    0
 tcl/target/kl25z_hla.cfg                           |    0
 tcl/target/kl46.cfg                                |    0
 tcl/target/ks869x.cfg                              |    0
 tcl/target/lpc11xx.cfg                             |    0
 tcl/target/lpc12xx.cfg                             |    0
 tcl/target/lpc13xx.cfg                             |    0
 tcl/target/lpc17xx.cfg                             |    0
 tcl/target/lpc1850.cfg                             |    0
 tcl/target/lpc1xxx.cfg                             |    0
 tcl/target/lpc2103.cfg                             |    0
 tcl/target/lpc2124.cfg                             |    0
 tcl/target/lpc2129.cfg                             |    0
 tcl/target/lpc2148.cfg                             |    0
 tcl/target/lpc2294.cfg                             |    0
 tcl/target/lpc2378.cfg                             |    0
 tcl/target/lpc2460.cfg                             |    0
 tcl/target/lpc2478.cfg                             |    0
 tcl/target/lpc2900.cfg                             |    0
 tcl/target/lpc2xxx.cfg                             |    0
 tcl/target/lpc3131.cfg                             |    0
 tcl/target/lpc3250.cfg                             |    0
 tcl/target/lpc4350.cfg                             |    0
 tcl/target/mc13224v.cfg                            |    0
 tcl/target/mdr32f9q2i.cfg                          |    0
 tcl/target/nds32v2.cfg                             |    0
 tcl/target/nds32v3.cfg                             |    0
 tcl/target/nds32v3m.cfg                            |    0
 tcl/target/nrf51.cfg                               |    0
 tcl/target/nrf51_stlink.tcl                        |    0
 tcl/target/nuc910.cfg                              |    0
 tcl/target/omap2420.cfg                            |    0
 tcl/target/omap3530.cfg                            |    0
 tcl/target/omap4430.cfg                            |    0
 tcl/target/omap4460.cfg                            |    0
 tcl/target/omap5912.cfg                            |    0
 tcl/target/omapl138.cfg                            |    0
 tcl/target/or1k.cfg                                |    0
 tcl/target/pic32mx.cfg                             |    0
 tcl/target/pxa255.cfg                              |    0
 tcl/target/pxa270.cfg                              |    0
 tcl/target/pxa3xx.cfg                              |    0
 tcl/target/quark_x10xx.cfg                         |    0
 tcl/target/readme.txt                              |    0
 tcl/target/samsung_s3c2410.cfg                     |    0
 tcl/target/samsung_s3c2440.cfg                     |    0
 tcl/target/samsung_s3c2450.cfg                     |    0
 tcl/target/samsung_s3c4510.cfg                     |    0
 tcl/target/samsung_s3c6410.cfg                     |    0
 tcl/target/sharp_lh79532.cfg                       |    0
 tcl/target/smp8634.cfg                             |    0
 tcl/target/spear3xx.cfg                            |    0
 tcl/target/stellaris.cfg                           |    0
 tcl/target/stellaris_icdi.cfg                      |    0
 tcl/target/stm32_stlink.cfg                        |    0
 tcl/target/stm32f0x.cfg                            |    0
 tcl/target/stm32f0x_stlink.cfg                     |    0
 tcl/target/stm32f1x.cfg                            |    0
 tcl/target/stm32f1x_stlink.cfg                     |    0
 tcl/target/stm32f2x.cfg                            |    0
 tcl/target/stm32f2x_stlink.cfg                     |    0
 tcl/target/stm32f3x.cfg                            |    0
 tcl/target/stm32f3x_stlink.cfg                     |    0
 tcl/target/stm32f4x.cfg                            |    0
 tcl/target/stm32f4x_stlink.cfg                     |    0
 tcl/target/stm32l.cfg                              |    0
 tcl/target/stm32lx_dual_bank.cfg                   |    0
 tcl/target/stm32lx_stlink.cfg                      |    0
 tcl/target/stm32w108_stlink.cfg                    |    0
 tcl/target/stm32w108xx.cfg                         |    0
 tcl/target/stm32xl.cfg                             |    0
 tcl/target/str710.cfg                              |    0
 tcl/target/str730.cfg                              |    0
 tcl/target/str750.cfg                              |    0
 tcl/target/str912.cfg                              |    0
 tcl/target/swj-dp.tcl                              |    0
 tcl/target/test_reset_syntax_error.cfg             |    0
 tcl/target/test_syntax_error.cfg                   |    0
 tcl/target/ti-ar7.cfg                              |    0
 tcl/target/ti_calypso.cfg                          |    0
 tcl/target/ti_dm355.cfg                            |    0
 tcl/target/ti_dm365.cfg                            |    0
 tcl/target/ti_dm6446.cfg                           |    0
 tcl/target/ti_tms570.cfg                           |    0
 tcl/target/tmpa900.cfg                             |    0
 tcl/target/tmpa910.cfg                             |    0
 tcl/target/u8500.cfg                               |    0
 tcl/target/zynq_7000.cfg                           |    0
 "tcl/target/\320\2721879x\320\2611\321\217.cfg"    |    0
 tcl/test/syntax1.cfg                               |    0
 tcl/tools/firmware-recovery.tcl                    |    0
 tcl/tools/memtest.tcl                              |    0
 testing/build.test1/Makefile                       |    0
 testing/build.test1/Makefile.confuse               |    0
 testing/build.test1/Makefile.ftd2xx                |    0
 testing/build.test1/Makefile.libftdi               |    0
 testing/build.test1/Makefile.libusb                |    0
 testing/build.test1/Makefile.openocd               |    0
 testing/build.test1/README.TXT                     |    0
 testing/build.test1/local.uses                     |    0
 testing/build.test1/mingw32_help/include/elf.h     |    0
 .../build.test1/mingw32_help/include/sys/cdefs.h   |    0
 .../build.test1/mingw32_help/include/sys/elf32.h   |    0
 .../build.test1/mingw32_help/include/sys/elf64.h   |    0
 .../mingw32_help/include/sys/elf_common.h          |    0
 .../mingw32_help/include/sys/elf_generic.h         |    0
 testing/build.test2/Makefile                       |    0
 testing/build.test2/README.txt                     |    0
 testing/build.test2/local.uses                     |    0
 testing/examples/AT91R40008Test/inc/typedefs.h     |    0
 testing/examples/AT91R40008Test/makefile           |    0
 .../AT91R40008Test/prj/at91r40008_reset.script     |    0
 .../AT91R40008Test/prj/at91r40008_turtle.cfg       |    0
 .../examples/AT91R40008Test/prj/eclipse_ram.gdb    |    0
 .../examples/AT91R40008Test/prj/ethernut3_ram.ld   |    0
 testing/examples/AT91R40008Test/src/crt.s          |    0
 testing/examples/AT91R40008Test/src/main.c         |    0
 testing/examples/AT91R40008Test/test_ram.elf       |  Bin
 testing/examples/AT91R40008Test/test_ram.hex       |    0
 testing/examples/AT91R40008Test/test_ram.map       |    0
 testing/examples/LPC2148Test/inc/typedefs.h        |    0
 testing/examples/LPC2148Test/makefile              |    0
 testing/examples/LPC2148Test/prj/eclipse_ram.gdb   |    0
 testing/examples/LPC2148Test/prj/eclipse_rom.gdb   |    0
 .../examples/LPC2148Test/prj/lpc2148_jtagkey.cfg   |    0
 testing/examples/LPC2148Test/prj/lpc2148_ram.ld    |    0
 testing/examples/LPC2148Test/prj/lpc2148_rom.ld    |    0
 testing/examples/LPC2148Test/src/crt.s             |    0
 testing/examples/LPC2148Test/src/main.c            |    0
 testing/examples/LPC2148Test/test_ram.elf          |  Bin
 testing/examples/LPC2148Test/test_ram.hex          |    0
 testing/examples/LPC2148Test/test_ram.map          |    0
 testing/examples/LPC2148Test/test_rom.elf          |  Bin
 testing/examples/LPC2148Test/test_rom.hex          |    0
 testing/examples/LPC2148Test/test_rom.map          |    0
 testing/examples/LPC2294Test/inc/typedefs.h        |    0
 testing/examples/LPC2294Test/makefile              |    0
 testing/examples/LPC2294Test/prj/eclipse_ram.gdb   |    0
 testing/examples/LPC2294Test/prj/eclipse_rom.gdb   |    0
 .../examples/LPC2294Test/prj/lpc2294_jtagkey.cfg   |    0
 testing/examples/LPC2294Test/prj/lpc2294_ram.ld    |    0
 testing/examples/LPC2294Test/prj/lpc2294_rom.ld    |    0
 testing/examples/LPC2294Test/src/crt.s             |    0
 testing/examples/LPC2294Test/src/main.c            |    0
 testing/examples/LPC2294Test/test_ram.elf          |  Bin
 testing/examples/LPC2294Test/test_ram.hex          |    0
 testing/examples/LPC2294Test/test_ram.map          |    0
 testing/examples/LPC2294Test/test_rom.elf          |  Bin
 testing/examples/LPC2294Test/test_rom.hex          |    0
 testing/examples/LPC2294Test/test_rom.map          |    0
 testing/examples/PIC32/BlinkingLeds.c              |    0
 testing/examples/PIC32/BlinkingLeds.elf            |  Bin
 testing/examples/PIC32/readme.txt                  |    0
 testing/examples/SAM7S256Test/inc/typedefs.h       |    0
 testing/examples/SAM7S256Test/makefile             |    0
 testing/examples/SAM7S256Test/prj/eclipse_ram.gdb  |    0
 testing/examples/SAM7S256Test/prj/eclipse_rom.gdb  |    0
 .../examples/SAM7S256Test/prj/sam7s256_jtagkey.cfg |    0
 testing/examples/SAM7S256Test/prj/sam7s256_ram.ld  |    0
 .../SAM7S256Test/prj/sam7s256_reset.script         |    0
 testing/examples/SAM7S256Test/prj/sam7s256_rom.ld  |    0
 testing/examples/SAM7S256Test/results/607.html     |    0
 testing/examples/SAM7S256Test/src/crt.s            |    0
 testing/examples/SAM7S256Test/src/main.c           |    0
 testing/examples/SAM7S256Test/test_ram.elf         |  Bin
 testing/examples/SAM7S256Test/test_ram.hex         |    0
 testing/examples/SAM7S256Test/test_ram.map         |    0
 testing/examples/SAM7S256Test/test_rom.elf         |  Bin
 testing/examples/SAM7S256Test/test_rom.hex         |    0
 testing/examples/SAM7S256Test/test_rom.map         |    0
 testing/examples/SAM7X256Test/inc/typedefs.h       |    0
 testing/examples/SAM7X256Test/makefile             |    0
 testing/examples/SAM7X256Test/prj/eclipse_ram.gdb  |    0
 testing/examples/SAM7X256Test/prj/eclipse_rom.gdb  |    0
 .../examples/SAM7X256Test/prj/sam7x256_jtagkey.cfg |    0
 testing/examples/SAM7X256Test/prj/sam7x256_ram.ld  |    0
 .../SAM7X256Test/prj/sam7x256_reset.script         |    0
 testing/examples/SAM7X256Test/prj/sam7x256_rom.ld  |    0
 testing/examples/SAM7X256Test/src/crt.s            |    0
 testing/examples/SAM7X256Test/src/main.c           |    0
 testing/examples/SAM7X256Test/test_ram.elf         |  Bin
 testing/examples/SAM7X256Test/test_ram.hex         |    0
 testing/examples/SAM7X256Test/test_ram.map         |    0
 testing/examples/SAM7X256Test/test_rom.elf         |  Bin
 testing/examples/SAM7X256Test/test_rom.hex         |    0
 testing/examples/SAM7X256Test/test_rom.map         |    0
 testing/examples/STM32-103/main.elf                |  Bin
 testing/examples/STM32-103/readme.txt              |    0
 testing/examples/STR710JtagSpeed/inc/typedefs.h    |    0
 testing/examples/STR710JtagSpeed/makefile          |    0
 .../STR710JtagSpeed/prj/eclipse_ft2232_ram.gdb     |    0
 .../STR710JtagSpeed/prj/str710_jtagkey.cfg         |    0
 testing/examples/STR710JtagSpeed/prj/str7_ram.ld   |    0
 testing/examples/STR710JtagSpeed/src/crt.s         |    0
 testing/examples/STR710JtagSpeed/src/main.c        |    0
 testing/examples/STR710JtagSpeed/test.elf          |  Bin
 testing/examples/STR710JtagSpeed/test.hex          |    0
 testing/examples/STR710JtagSpeed/test.map          |    0
 testing/examples/STR710Test/.gitignore             |    0
 testing/examples/STR710Test/inc/typedefs.h         |    0
 testing/examples/STR710Test/makefile               |    0
 testing/examples/STR710Test/prj/eclipse_ram.gdb    |    0
 testing/examples/STR710Test/prj/eclipse_rom.gdb    |    0
 testing/examples/STR710Test/prj/hitex_str7_ram.ld  |    0
 testing/examples/STR710Test/prj/hitex_str7_rom.ld  |    0
 testing/examples/STR710Test/prj/str710_jtagkey.cfg |    0
 .../examples/STR710Test/prj/str710_program.script  |    0
 testing/examples/STR710Test/src/crt.s              |    0
 testing/examples/STR710Test/src/main.c             |    0
 testing/examples/STR710Test/test_ram.elf           |  Bin
 testing/examples/STR710Test/test_ram.hex           |    0
 testing/examples/STR710Test/test_ram.map           |    0
 testing/examples/STR710Test/test_rom.elf           |  Bin
 testing/examples/STR710Test/test_rom.hex           |    0
 testing/examples/STR710Test/test_rom.map           |    0
 testing/examples/STR912Test/inc/typedefs.h         |    0
 testing/examples/STR912Test/makefile               |    0
 testing/examples/STR912Test/prj/eclipse_ram.gdb    |    0
 testing/examples/STR912Test/prj/eclipse_rom.gdb    |    0
 testing/examples/STR912Test/prj/str912_jtagkey.cfg |    0
 .../examples/STR912Test/prj/str912_program.script  |    0
 testing/examples/STR912Test/prj/str912_ram.ld      |    0
 testing/examples/STR912Test/prj/str912_rom.ld      |    0
 testing/examples/STR912Test/src/main.c             |    0
 testing/examples/STR912Test/src/startup.s          |    0
 testing/examples/STR912Test/test_ram.elf           |  Bin
 testing/examples/STR912Test/test_ram.hex           |    0
 testing/examples/STR912Test/test_ram.map           |    0
 testing/examples/STR912Test/test_rom.elf           |  Bin
 testing/examples/STR912Test/test_rom.hex           |    0
 testing/examples/STR912Test/test_rom.map           |    0
 testing/examples/cortex/cm3-ftest.cfg              |    0
 testing/examples/cortex/fault.c                    |    0
 testing/examples/cortex/lm3s3748.elf               |  Bin
 testing/examples/cortex/test.c                     |    0
 testing/examples/cortex/test.ld                    |    0
 testing/examples/ledtest-imx27ads/Makefile         |    0
 testing/examples/ledtest-imx27ads/crt0.S           |    0
 testing/examples/ledtest-imx27ads/gdbinit-imx27ads |    0
 testing/examples/ledtest-imx27ads/ldscript         |    0
 testing/examples/ledtest-imx27ads/test.c           |    0
 testing/examples/ledtest-imx27ads/test.elf         |  Bin
 testing/examples/ledtest-imx31pdk/Makefile         |    0
 testing/examples/ledtest-imx31pdk/crt0.S           |    0
 testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk |    0
 testing/examples/ledtest-imx31pdk/ldscript         |    0
 testing/examples/ledtest-imx31pdk/test.c           |    0
 testing/examples/ledtest-imx31pdk/test.elf         |  Bin
 testing/index.html                                 |    0
 testing/profile_stm32.txt                          |    0
 testing/results/template.html                      |    0
 testing/smoketests.html                            |    0
 testing/tcl_server.tcl                             |    0
 testing/tcl_test.tcl                               |    0
 testing/testcases.html                             |    0
 tools/logger.pl                                    |    0
 tools/release/helpers.sh                           |    0
 uncrustify.cfg                                     |    0
 1260 files changed, 2156 insertions(+), 1330 deletions(-)
 mode change 100644 => 100755 .gitignore
 mode change 100644 => 100755 .gitmodules
 mode change 100644 => 100755 AUTHORS
 mode change 100644 => 100755 AUTHORS.ChangeLog
 mode change 100644 => 100755 BUGS
 mode change 100644 => 100755 COPYING
 mode change 100644 => 100755 ChangeLog
 mode change 100644 => 100755 Doxyfile.in
 mode change 100644 => 100755 HACKING
 mode change 100644 => 100755 Makefile.am
 mode change 100644 => 100755 NEWS
 mode change 100644 => 100755 NEWS-0.2.0
 mode change 100644 => 100755 NEWS-0.3.0
 mode change 100644 => 100755 NEWS-0.4.0
 mode change 100644 => 100755 NEWS-0.5.0
 mode change 100644 => 100755 NEWS-0.6.0
 mode change 100644 => 100755 NEWS-0.7.0
 mode change 100644 => 100755 NEWS-0.8.0
 mode change 100644 => 100755 NEWTAPS
 mode change 100644 => 100755 README
 mode change 100644 => 100755 README.OSX
 mode change 100644 => 100755 README.Windows
 mode change 100644 => 100755 TODO
 mode change 100644 => 100755 common.mk
 mode change 100644 => 100755 config_subdir.m4
 mode change 100644 => 100755 configure.ac
 mode change 100644 => 100755 contrib/99-openocd.rules
 mode change 100644 => 100755 contrib/coresight-trace.txt
 mode change 100644 => 100755 contrib/itmdump.c
 mode change 100644 => 100755 contrib/libdcc/README
 mode change 100644 => 100755 contrib/libdcc/dcc_stdio.c
 mode change 100644 => 100755 contrib/libdcc/dcc_stdio.h
 mode change 100644 => 100755 contrib/libdcc/example.c
 mode change 100644 => 100755 contrib/loaders/README
 mode change 100644 => 100755 contrib/loaders/checksum/armv4_5_crc.s
 mode change 100644 => 100755 contrib/loaders/checksum/armv7m_crc.s
 mode change 100644 => 100755 contrib/loaders/checksum/mips32.s
 mode change 100644 => 100755 contrib/loaders/erase_check/armv4_5_erase_check.s
 mode change 100644 => 100755 contrib/loaders/erase_check/armv7m_erase_check.s
 mode change 100644 => 100755 contrib/loaders/flash/armv4_5_cfi_intel_16.s
 mode change 100644 => 100755 contrib/loaders/flash/armv4_5_cfi_intel_32.s
 mode change 100644 => 100755 contrib/loaders/flash/armv4_5_cfi_intel_8.s
 mode change 100644 => 100755 contrib/loaders/flash/armv4_5_cfi_span_16.s
 mode change 100644 => 100755 contrib/loaders/flash/armv4_5_cfi_span_16_dq7.s
 mode change 100644 => 100755 contrib/loaders/flash/armv4_5_cfi_span_32.s
 mode change 100644 => 100755 contrib/loaders/flash/armv4_5_cfi_span_8.s
 mode change 100644 => 100755 contrib/loaders/flash/armv7m_cfi_span_16.s
 mode change 100644 => 100755 contrib/loaders/flash/armv7m_cfi_span_16_dq7.s
 mode change 100644 => 100755 contrib/loaders/flash/armv7m_io.s
 mode change 100644 => 100755 contrib/loaders/flash/at91sam7x/at91sam7x_ocl_flash.script
 mode change 100644 => 100755 contrib/loaders/flash/at91sam7x/at91sam7x_ram.ld
 mode change 100644 => 100755 contrib/loaders/flash/at91sam7x/crt.s
 mode change 100644 => 100755 contrib/loaders/flash/at91sam7x/dcc.c
 mode change 100644 => 100755 contrib/loaders/flash/at91sam7x/dcc.h
 mode change 100644 => 100755 contrib/loaders/flash/at91sam7x/main.c
 mode change 100644 => 100755 contrib/loaders/flash/at91sam7x/makefile
 mode change 100644 => 100755 contrib/loaders/flash/at91sam7x/ocl.h
 mode change 100644 => 100755 contrib/loaders/flash/at91sam7x/platform.h
 mode change 100644 => 100755 contrib/loaders/flash/at91sam7x/samflash.c
 mode change 100644 => 100755 contrib/loaders/flash/at91sam7x/samflash.h
 mode change 100644 => 100755 contrib/loaders/flash/at91sam7x/samregs.h
 mode change 100644 => 100755 contrib/loaders/flash/efm32.S
 mode change 100644 => 100755 contrib/loaders/flash/lpcspifi_erase.S
 mode change 100644 => 100755 contrib/loaders/flash/lpcspifi_init.S
 mode change 100644 => 100755 contrib/loaders/flash/lpcspifi_write.S
 mode change 100644 => 100755 contrib/loaders/flash/mdr32fx.S
 mode change 100644 => 100755 contrib/loaders/flash/mrvlqspi_write.S
 mode change 100644 => 100755 contrib/loaders/flash/pic32mx.s
 mode change 100644 => 100755 contrib/loaders/flash/stellaris.s
 mode change 100644 => 100755 contrib/loaders/flash/stm32f1x.S
 mode change 100644 => 100755 contrib/loaders/flash/stm32f2x.S
 mode change 100644 => 100755 contrib/loaders/flash/stm32lx.S
 mode change 100644 => 100755 contrib/loaders/flash/str7x.s
 mode change 100644 => 100755 contrib/loaders/flash/str9x.s
 mode change 100644 => 100755 contrib/remote_bitbang/remote_bitbang_sysfsgpio.c
 mode change 100644 => 100755 contrib/rpc_examples/ocdrpc.hs
 mode change 100644 => 100755 contrib/xsvf_tools/svf2xsvf.py
 mode change 100644 => 100755 contrib/xsvf_tools/xsvfdump.py
 mode change 100644 => 100755 doc/INSTALL.txt
 mode change 100644 => 100755 doc/Makefile.am
 mode change 100644 => 100755 doc/fdl.texi
 mode change 100644 => 100755 doc/manual/app.txt
 mode change 100644 => 100755 doc/manual/flash.txt
 mode change 100644 => 100755 doc/manual/helper.txt
 mode change 100644 => 100755 doc/manual/images/jtag-state-machine-large.png
 mode change 100644 => 100755 doc/manual/jtag.txt
 mode change 100644 => 100755 doc/manual/jtag/drivers/remote_bitbang.txt
 mode change 100644 => 100755 doc/manual/main.txt
 mode change 100644 => 100755 doc/manual/primer/autotools.txt
 mode change 100644 => 100755 doc/manual/primer/commands.txt
 mode change 100644 => 100755 doc/manual/primer/docs.txt
 mode change 100644 => 100755 doc/manual/primer/jtag.txt
 mode change 100644 => 100755 doc/manual/primer/tcl.txt
 mode change 100644 => 100755 doc/manual/release.txt
 mode change 100644 => 100755 doc/manual/scripting.txt
 mode change 100644 => 100755 doc/manual/server.txt
 mode change 100644 => 100755 doc/manual/style.txt
 mode change 100644 => 100755 doc/manual/target.txt
 mode change 100644 => 100755 doc/manual/target/mips.txt
 mode change 100644 => 100755 doc/manual/target/notarm.txt
 mode change 100644 => 100755 doc/openocd.1
 mode change 100644 => 100755 doc/openocd.texi
 mode change 100644 => 100755 src/Makefile.am
 mode change 100644 => 100755 src/flash/Makefile.am
 mode change 100644 => 100755 src/flash/common.c
 mode change 100644 => 100755 src/flash/common.h
 mode change 100644 => 100755 src/flash/mflash.c
 mode change 100644 => 100755 src/flash/mflash.h
 mode change 100644 => 100755 src/flash/nand/Makefile.am
 mode change 100644 => 100755 src/flash/nand/arm_io.c
 mode change 100644 => 100755 src/flash/nand/arm_io.h
 mode change 100644 => 100755 src/flash/nand/at91sam9.c
 mode change 100644 => 100755 src/flash/nand/core.c
 mode change 100644 => 100755 src/flash/nand/core.h
 mode change 100644 => 100755 src/flash/nand/davinci.c
 mode change 100644 => 100755 src/flash/nand/driver.c
 mode change 100644 => 100755 src/flash/nand/driver.h
 mode change 100644 => 100755 src/flash/nand/ecc.c
 mode change 100644 => 100755 src/flash/nand/ecc_kw.c
 mode change 100644 => 100755 src/flash/nand/fileio.c
 mode change 100644 => 100755 src/flash/nand/fileio.h
 mode change 100644 => 100755 src/flash/nand/imp.h
 mode change 100644 => 100755 src/flash/nand/lpc3180.c
 mode change 100644 => 100755 src/flash/nand/lpc3180.h
 mode change 100644 => 100755 src/flash/nand/lpc32xx.c
 mode change 100644 => 100755 src/flash/nand/lpc32xx.h
 mode change 100644 => 100755 src/flash/nand/mx3.c
 mode change 100644 => 100755 src/flash/nand/mx3.h
 mode change 100644 => 100755 src/flash/nand/mxc.c
 mode change 100644 => 100755 src/flash/nand/mxc.h
 mode change 100644 => 100755 src/flash/nand/nonce.c
 mode change 100644 => 100755 src/flash/nand/nuc910.c
 mode change 100644 => 100755 src/flash/nand/nuc910.h
 mode change 100644 => 100755 src/flash/nand/orion.c
 mode change 100644 => 100755 src/flash/nand/s3c2410.c
 mode change 100644 => 100755 src/flash/nand/s3c2412.c
 mode change 100644 => 100755 src/flash/nand/s3c2440.c
 mode change 100644 => 100755 src/flash/nand/s3c2443.c
 mode change 100644 => 100755 src/flash/nand/s3c24xx.c
 mode change 100644 => 100755 src/flash/nand/s3c24xx.h
 mode change 100644 => 100755 src/flash/nand/s3c24xx_regs.h
 mode change 100644 => 100755 src/flash/nand/s3c6400.c
 mode change 100644 => 100755 src/flash/nand/tcl.c
 mode change 100644 => 100755 src/flash/nor/Makefile.am
 mode change 100644 => 100755 src/flash/nor/aduc702x.c
 mode change 100644 => 100755 src/flash/nor/at91sam3.c
 mode change 100644 => 100755 src/flash/nor/at91sam4.c
 mode change 100644 => 100755 src/flash/nor/at91sam4l.c
 mode change 100644 => 100755 src/flash/nor/at91sam7.c
 mode change 100644 => 100755 src/flash/nor/at91samd.c
 mode change 100644 => 100755 src/flash/nor/avrf.c
 mode change 100644 => 100755 src/flash/nor/cfi.c
 mode change 100644 => 100755 src/flash/nor/cfi.h
 mode change 100644 => 100755 src/flash/nor/core.c
 mode change 100644 => 100755 src/flash/nor/core.h
 mode change 100644 => 100755 src/flash/nor/driver.h
 mode change 100644 => 100755 src/flash/nor/drivers.c
 mode change 100644 => 100755 src/flash/nor/dsp5680xx_flash.c
 mode change 100644 => 100755 src/flash/nor/efm32.c
 mode change 100644 => 100755 src/flash/nor/em357.c
 mode change 100644 => 100755 src/flash/nor/faux.c
 mode change 100644 => 100755 src/flash/nor/fm3.c
 mode change 100644 => 100755 src/flash/nor/imp.h
 mode change 100644 => 100755 src/flash/nor/kinetis.c
 mode change 100644 => 100755 src/flash/nor/lpc2000.c
 mode change 100644 => 100755 src/flash/nor/lpc288x.c
 mode change 100644 => 100755 src/flash/nor/lpc2900.c
 mode change 100644 => 100755 src/flash/nor/lpcspifi.c
 mode change 100644 => 100755 src/flash/nor/mdr.c
 mode change 100644 => 100755 src/flash/nor/mini51.c
 mode change 100644 => 100755 src/flash/nor/mrvlqspi.c
 mode change 100644 => 100755 src/flash/nor/non_cfi.c
 mode change 100644 => 100755 src/flash/nor/non_cfi.h
 mode change 100644 => 100755 src/flash/nor/nrf51.c
 mode change 100644 => 100755 src/flash/nor/nuc1x.c
 mode change 100644 => 100755 src/flash/nor/ocl.c
 mode change 100644 => 100755 src/flash/nor/ocl.h
 mode change 100644 => 100755 src/flash/nor/pic32mx.c
 mode change 100644 => 100755 src/flash/nor/spi.c
 mode change 100644 => 100755 src/flash/nor/spi.h
 mode change 100644 => 100755 src/flash/nor/stellaris.c
 mode change 100644 => 100755 src/flash/nor/stm32f1x.c
 mode change 100644 => 100755 src/flash/nor/stm32f2x.c
 mode change 100644 => 100755 src/flash/nor/stm32lx.c
 mode change 100644 => 100755 src/flash/nor/stmsmi.c
 mode change 100644 => 100755 src/flash/nor/str7x.c
 mode change 100644 => 100755 src/flash/nor/str9x.c
 mode change 100644 => 100755 src/flash/nor/str9xpec.c
 mode change 100644 => 100755 src/flash/nor/tcl.c
 mode change 100644 => 100755 src/flash/nor/tms470.c
 mode change 100644 => 100755 src/flash/nor/virtual.c
 mode change 100644 => 100755 src/flash/startup.tcl
 mode change 100644 => 100755 src/hello.c
 mode change 100644 => 100755 src/hello.h
 mode change 100644 => 100755 src/helper/Makefile.am
 mode change 100644 => 100755 src/helper/binarybuffer.c
 mode change 100644 => 100755 src/helper/binarybuffer.h
 mode change 100644 => 100755 src/helper/command.c
 mode change 100644 => 100755 src/helper/command.h
 mode change 100644 => 100755 src/helper/configuration.c
 mode change 100644 => 100755 src/helper/configuration.h
 mode change 100644 => 100755 src/helper/fileio.c
 mode change 100644 => 100755 src/helper/fileio.h
 mode change 100644 => 100755 src/helper/ioutil.c
 mode change 100644 => 100755 src/helper/ioutil.h
 mode change 100644 => 100755 src/helper/ioutil_stubs.c
 mode change 100644 => 100755 src/helper/jim-nvp.c
 mode change 100644 => 100755 src/helper/jim-nvp.h
 mode change 100644 => 100755 src/helper/list.h
 mode change 100644 => 100755 src/helper/log.c
 mode change 100644 => 100755 src/helper/log.h
 mode change 100644 => 100755 src/helper/options.c
 mode change 100644 => 100755 src/helper/replacements.c
 mode change 100644 => 100755 src/helper/replacements.h
 mode change 100644 => 100755 src/helper/startup.tcl
 mode change 100644 => 100755 src/helper/system.h
 mode change 100644 => 100755 src/helper/time_support.c
 mode change 100644 => 100755 src/helper/time_support.h
 mode change 100644 => 100755 src/helper/time_support_common.c
 mode change 100644 => 100755 src/helper/types.h
 mode change 100644 => 100755 src/helper/util.c
 mode change 100644 => 100755 src/helper/util.h
 mode change 100644 => 100755 src/jtag/Makefile.am
 mode change 100644 => 100755 src/jtag/adapter.c
 mode change 100644 => 100755 src/jtag/aice/Makefile.am
 mode change 100644 => 100755 src/jtag/aice/aice_interface.c
 mode change 100644 => 100755 src/jtag/aice/aice_interface.h
 mode change 100644 => 100755 src/jtag/aice/aice_pipe.c
 mode change 100644 => 100755 src/jtag/aice/aice_pipe.h
 mode change 100644 => 100755 src/jtag/aice/aice_port.c
 mode change 100644 => 100755 src/jtag/aice/aice_port.h
 mode change 100644 => 100755 src/jtag/aice/aice_transport.c
 mode change 100644 => 100755 src/jtag/aice/aice_transport.h
 mode change 100644 => 100755 src/jtag/aice/aice_usb.c
 mode change 100644 => 100755 src/jtag/aice/aice_usb.h
 mode change 100644 => 100755 src/jtag/commands.c
 mode change 100644 => 100755 src/jtag/commands.h
 mode change 100644 => 100755 src/jtag/core.c
 mode change 100644 => 100755 src/jtag/driver.h
 mode change 100644 => 100755 src/jtag/drivers/Makefile.am
 mode change 100644 => 100755 src/jtag/drivers/Makefile.rlink
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/Makefile
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/README
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/include/common.h
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/include/delay.h
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/include/io.h
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/include/jtag.h
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/include/main.h
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/include/msgtypes.h
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/include/protocol.h
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/include/reg_ezusb.h
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/include/usb.h
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/src/USBJmpTb.a51
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/src/delay.c
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/src/jtag.c
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/src/main.c
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/src/protocol.c
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/src/usb.c
 mode change 100644 => 100755 src/jtag/drivers/OpenULINK/ulink_firmware.hex
 mode change 100644 => 100755 src/jtag/drivers/amt_jtagaccel.c
 mode change 100644 => 100755 src/jtag/drivers/arm-jtag-ew.c
 mode change 100644 => 100755 src/jtag/drivers/at91rm9200.c
 mode change 100644 => 100755 src/jtag/drivers/bcm2835gpio.c
 mode change 100644 => 100755 src/jtag/drivers/bitbang.c
 mode change 100644 => 100755 src/jtag/drivers/bitbang.h
 mode change 100644 => 100755 src/jtag/drivers/bitq.c
 mode change 100644 => 100755 src/jtag/drivers/bitq.h
 mode change 100644 => 100755 src/jtag/drivers/buspirate.c
 mode change 100644 => 100755 src/jtag/drivers/cmsis_dap_usb.c
 mode change 100644 => 100755 src/jtag/drivers/driver.c
 mode change 100644 => 100755 src/jtag/drivers/dummy.c
 mode change 100644 => 100755 src/jtag/drivers/ep93xx.c
 mode change 100644 => 100755 src/jtag/drivers/ft2232.c
 mode change 100644 => 100755 src/jtag/drivers/ftd2xx_common.h
 mode change 100644 => 100755 src/jtag/drivers/ftdi.c
 mode change 100644 => 100755 src/jtag/drivers/gw16012.c
 mode change 100644 => 100755 src/jtag/drivers/jlink.c
 mode change 100644 => 100755 src/jtag/drivers/jtag_vpi.c
 mode change 100644 => 100755 src/jtag/drivers/libusb0_common.c
 mode change 100644 => 100755 src/jtag/drivers/libusb0_common.h
 mode change 100644 => 100755 src/jtag/drivers/libusb1_common.c
 mode change 100644 => 100755 src/jtag/drivers/libusb1_common.h
 mode change 100644 => 100755 src/jtag/drivers/libusb_common.h
 mode change 100644 => 100755 src/jtag/drivers/minidriver_imp.h
 mode change 100644 => 100755 src/jtag/drivers/mpsse.c
 mode change 100644 => 100755 src/jtag/drivers/mpsse.h
 mode change 100644 => 100755 src/jtag/drivers/opendous.c
 mode change 100644 => 100755 src/jtag/drivers/openjtag.c
 mode change 100644 => 100755 src/jtag/drivers/osbdm.c
 mode change 100644 => 100755 src/jtag/drivers/parport.c
 mode change 100644 => 100755 src/jtag/drivers/presto.c
 mode change 100644 => 100755 src/jtag/drivers/remote_bitbang.c
 mode change 100644 => 100755 src/jtag/drivers/rlink.c
 mode change 100644 => 100755 src/jtag/drivers/rlink.h
 mode change 100644 => 100755 src/jtag/drivers/rlink_call.m4
 mode change 100644 => 100755 src/jtag/drivers/rlink_dtc_cmd.h
 mode change 100644 => 100755 src/jtag/drivers/rlink_ep1_cmd.h
 mode change 100644 => 100755 src/jtag/drivers/rlink_init.m4
 mode change 100644 => 100755 src/jtag/drivers/rlink_speed_table.c
 mode change 100644 => 100755 src/jtag/drivers/rlink_st7.h
 mode change 100644 => 100755 src/jtag/drivers/stlink_usb.c
 mode change 100644 => 100755 src/jtag/drivers/sysfsgpio.c
 mode change 100644 => 100755 src/jtag/drivers/ti_icdi_usb.c
 mode change 100644 => 100755 src/jtag/drivers/ulink.c
 mode change 100644 => 100755 src/jtag/drivers/usb_blaster/Makefile.am
 mode change 100644 => 100755 src/jtag/drivers/usb_blaster/README.CheapClone
 mode change 100644 => 100755 src/jtag/drivers/usb_blaster/ublast2_access_libusb.c
 mode change 100644 => 100755 src/jtag/drivers/usb_blaster/ublast_access.h
 mode change 100644 => 100755 src/jtag/drivers/usb_blaster/ublast_access_ftd2xx.c
 mode change 100644 => 100755 src/jtag/drivers/usb_blaster/ublast_access_ftdi.c
 mode change 100644 => 100755 src/jtag/drivers/usb_blaster/usb_blaster.c
 mode change 100644 => 100755 src/jtag/drivers/usb_common.c
 mode change 100644 => 100755 src/jtag/drivers/usb_common.h
 mode change 100644 => 100755 src/jtag/drivers/usbprog.c
 mode change 100644 => 100755 src/jtag/drivers/versaloon/usbtoxxx/usbtogpio.c
 mode change 100644 => 100755 src/jtag/drivers/versaloon/usbtoxxx/usbtojtagraw.c
 mode change 100644 => 100755 src/jtag/drivers/versaloon/usbtoxxx/usbtopwr.c
 mode change 100644 => 100755 src/jtag/drivers/versaloon/usbtoxxx/usbtoswd.c
 mode change 100644 => 100755 src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.c
 mode change 100644 => 100755 src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h
 mode change 100644 => 100755 src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx_internal.h
 mode change 100644 => 100755 src/jtag/drivers/versaloon/versaloon.c
 mode change 100644 => 100755 src/jtag/drivers/versaloon/versaloon.h
 mode change 100644 => 100755 src/jtag/drivers/versaloon/versaloon_include.h
 mode change 100644 => 100755 src/jtag/drivers/versaloon/versaloon_internal.h
 mode change 100644 => 100755 src/jtag/drivers/vsllink.c
 mode change 100644 => 100755 src/jtag/hla/Makefile.am
 mode change 100644 => 100755 src/jtag/hla/hla_interface.c
 mode change 100644 => 100755 src/jtag/hla/hla_interface.h
 mode change 100644 => 100755 src/jtag/hla/hla_layout.c
 mode change 100644 => 100755 src/jtag/hla/hla_layout.h
 mode change 100644 => 100755 src/jtag/hla/hla_tcl.c
 mode change 100644 => 100755 src/jtag/hla/hla_tcl.h
 mode change 100644 => 100755 src/jtag/hla/hla_transport.c
 mode change 100644 => 100755 src/jtag/hla/hla_transport.h
 mode change 100644 => 100755 src/jtag/interface.c
 mode change 100644 => 100755 src/jtag/interface.h
 mode change 100644 => 100755 src/jtag/interfaces.c
 mode change 100644 => 100755 src/jtag/interfaces.h
 mode change 100644 => 100755 src/jtag/jtag.h
 mode change 100644 => 100755 src/jtag/minidriver.h
 mode change 100644 => 100755 src/jtag/minidriver/minidriver_imp.h
 mode change 100644 => 100755 src/jtag/minidummy/jtag_minidriver.h
 mode change 100644 => 100755 src/jtag/minidummy/minidummy.c
 mode change 100644 => 100755 src/jtag/startup.tcl
 mode change 100644 => 100755 src/jtag/swd.h
 mode change 100644 => 100755 src/jtag/tcl.c
 mode change 100644 => 100755 src/jtag/tcl.h
 mode change 100644 => 100755 src/jtag/zy1000/jtag_minidriver.h
 mode change 100644 => 100755 src/jtag/zy1000/zy1000.c
 mode change 100644 => 100755 src/main.c
 mode change 100644 => 100755 src/openocd.c
 mode change 100644 => 100755 src/openocd.h
 mode change 100644 => 100755 src/pld/Makefile.am
 mode change 100644 => 100755 src/pld/pld.c
 mode change 100644 => 100755 src/pld/pld.h
 mode change 100644 => 100755 src/pld/virtex2.c
 mode change 100644 => 100755 src/pld/virtex2.h
 mode change 100644 => 100755 src/pld/xilinx_bit.c
 mode change 100644 => 100755 src/pld/xilinx_bit.h
 mode change 100644 => 100755 src/rtos/ChibiOS.c
 mode change 100644 => 100755 src/rtos/FreeRTOS.c
 mode change 100644 => 100755 src/rtos/Makefile.am
 mode change 100644 => 100755 src/rtos/ThreadX.c
 mode change 100644 => 100755 src/rtos/eCos.c
 mode change 100644 => 100755 src/rtos/embKernel.c
 mode change 100644 => 100755 src/rtos/linux.c
 mode change 100644 => 100755 src/rtos/linux_header.h
 mode change 100644 => 100755 src/rtos/rtos.c
 mode change 100644 => 100755 src/rtos/rtos.h
 mode change 100644 => 100755 src/rtos/rtos_chibios_stackings.c
 mode change 100644 => 100755 src/rtos/rtos_chibios_stackings.h
 mode change 100644 => 100755 src/rtos/rtos_ecos_stackings.c
 mode change 100644 => 100755 src/rtos/rtos_ecos_stackings.h
 mode change 100644 => 100755 src/rtos/rtos_embkernel_stackings.c
 mode change 100644 => 100755 src/rtos/rtos_embkernel_stackings.h
 mode change 100644 => 100755 src/rtos/rtos_standard_stackings.c
 mode change 100644 => 100755 src/rtos/rtos_standard_stackings.h
 mode change 100644 => 100755 src/server/Makefile.am
 mode change 100644 => 100755 src/server/gdb_server.c
 mode change 100644 => 100755 src/server/gdb_server.h
 mode change 100644 => 100755 src/server/server.c
 mode change 100644 => 100755 src/server/server.h
 mode change 100644 => 100755 src/server/server_stubs.c
 mode change 100644 => 100755 src/server/startup.tcl
 mode change 100644 => 100755 src/server/tcl_server.c
 mode change 100644 => 100755 src/server/tcl_server.h
 mode change 100644 => 100755 src/server/telnet_server.c
 mode change 100644 => 100755 src/server/telnet_server.h
 mode change 100644 => 100755 src/svf/Makefile.am
 mode change 100644 => 100755 src/svf/svf.c
 mode change 100644 => 100755 src/svf/svf.h
 mode change 100644 => 100755 src/target/Makefile.am
 mode change 100644 => 100755 src/target/adi_v5_jtag.c
 mode change 100644 => 100755 src/target/adi_v5_swd.c
 mode change 100644 => 100755 src/target/algorithm.c
 mode change 100644 => 100755 src/target/algorithm.h
 mode change 100644 => 100755 src/target/arm.h
 mode change 100644 => 100755 src/target/arm11.c
 mode change 100644 => 100755 src/target/arm11.h
 mode change 100644 => 100755 src/target/arm11_dbgtap.c
 mode change 100644 => 100755 src/target/arm11_dbgtap.h
 mode change 100644 => 100755 src/target/arm720t.c
 mode change 100644 => 100755 src/target/arm720t.h
 mode change 100644 => 100755 src/target/arm7_9_common.c
 mode change 100644 => 100755 src/target/arm7_9_common.h
 mode change 100644 => 100755 src/target/arm7tdmi.c
 mode change 100644 => 100755 src/target/arm7tdmi.h
 mode change 100644 => 100755 src/target/arm920t.c
 mode change 100644 => 100755 src/target/arm920t.h
 mode change 100644 => 100755 src/target/arm926ejs.c
 mode change 100644 => 100755 src/target/arm926ejs.h
 mode change 100644 => 100755 src/target/arm946e.c
 mode change 100644 => 100755 src/target/arm946e.h
 mode change 100644 => 100755 src/target/arm966e.c
 mode change 100644 => 100755 src/target/arm966e.h
 mode change 100644 => 100755 src/target/arm9tdmi.c
 mode change 100644 => 100755 src/target/arm9tdmi.h
 mode change 100644 => 100755 src/target/arm_adi_v5.c
 mode change 100644 => 100755 src/target/arm_adi_v5.h
 mode change 100644 => 100755 src/target/arm_disassembler.c
 mode change 100644 => 100755 src/target/arm_disassembler.h
 mode change 100644 => 100755 src/target/arm_dpm.c
 mode change 100644 => 100755 src/target/arm_dpm.h
 mode change 100644 => 100755 src/target/arm_jtag.c
 mode change 100644 => 100755 src/target/arm_jtag.h
 mode change 100644 => 100755 src/target/arm_opcodes.h
 mode change 100644 => 100755 src/target/arm_semihosting.c
 mode change 100644 => 100755 src/target/arm_semihosting.h
 mode change 100644 => 100755 src/target/arm_simulator.c
 mode change 100644 => 100755 src/target/arm_simulator.h
 mode change 100644 => 100755 src/target/armv4_5.c
 mode change 100644 => 100755 src/target/armv4_5.h
 mode change 100644 => 100755 src/target/armv4_5_cache.c
 mode change 100644 => 100755 src/target/armv4_5_cache.h
 mode change 100644 => 100755 src/target/armv4_5_mmu.c
 mode change 100644 => 100755 src/target/armv4_5_mmu.h
 mode change 100644 => 100755 src/target/armv7a.c
 mode change 100644 => 100755 src/target/armv7a.h
 mode change 100644 => 100755 src/target/armv7m.c
 mode change 100644 => 100755 src/target/armv7m.h
 mode change 100644 => 100755 src/target/avr32_ap7k.c
 mode change 100644 => 100755 src/target/avr32_ap7k.h
 mode change 100644 => 100755 src/target/avr32_jtag.c
 mode change 100644 => 100755 src/target/avr32_jtag.h
 mode change 100644 => 100755 src/target/avr32_mem.c
 mode change 100644 => 100755 src/target/avr32_mem.h
 mode change 100644 => 100755 src/target/avr32_regs.c
 mode change 100644 => 100755 src/target/avr32_regs.h
 mode change 100644 => 100755 src/target/avrt.c
 mode change 100644 => 100755 src/target/avrt.h
 mode change 100644 => 100755 src/target/breakpoints.c
 mode change 100644 => 100755 src/target/breakpoints.h
 mode change 100644 => 100755 src/target/cortex_a.h
 mode change 100644 => 100755 src/target/cortex_m.h
 mode change 100644 => 100755 src/target/dsp563xx.c
 mode change 100644 => 100755 src/target/dsp563xx.h
 mode change 100644 => 100755 src/target/dsp563xx_once.c
 mode change 100644 => 100755 src/target/dsp563xx_once.h
 mode change 100644 => 100755 src/target/dsp5680xx.c
 mode change 100644 => 100755 src/target/dsp5680xx.h
 mode change 100644 => 100755 src/target/embeddedice.c
 mode change 100644 => 100755 src/target/embeddedice.h
 mode change 100644 => 100755 src/target/etb.c
 mode change 100644 => 100755 src/target/etb.h
 mode change 100644 => 100755 src/target/etm.c
 mode change 100644 => 100755 src/target/etm.h
 mode change 100644 => 100755 src/target/etm_dummy.c
 mode change 100644 => 100755 src/target/etm_dummy.h
 mode change 100644 => 100755 src/target/fa526.c
 mode change 100644 => 100755 src/target/feroceon.c
 mode change 100644 => 100755 src/target/hla_target.c
 mode change 100644 => 100755 src/target/image.c
 mode change 100644 => 100755 src/target/image.h
 mode change 100644 => 100755 src/target/lakemont.c
 mode change 100644 => 100755 src/target/lakemont.h
 mode change 100644 => 100755 src/target/mips32.c
 mode change 100644 => 100755 src/target/mips32.h
 mode change 100644 => 100755 src/target/mips32_dmaacc.c
 mode change 100644 => 100755 src/target/mips32_dmaacc.h
 mode change 100644 => 100755 src/target/mips32_pracc.c
 mode change 100644 => 100755 src/target/mips32_pracc.h
 mode change 100644 => 100755 src/target/mips_ejtag.c
 mode change 100644 => 100755 src/target/mips_ejtag.h
 mode change 100644 => 100755 src/target/mips_m4k.c
 mode change 100644 => 100755 src/target/mips_m4k.h
 mode change 100644 => 100755 src/target/nds32.c
 mode change 100644 => 100755 src/target/nds32.h
 mode change 100644 => 100755 src/target/nds32_aice.c
 mode change 100644 => 100755 src/target/nds32_aice.h
 mode change 100644 => 100755 src/target/nds32_cmd.c
 mode change 100644 => 100755 src/target/nds32_cmd.h
 mode change 100644 => 100755 src/target/nds32_disassembler.c
 mode change 100644 => 100755 src/target/nds32_disassembler.h
 mode change 100644 => 100755 src/target/nds32_edm.h
 mode change 100644 => 100755 src/target/nds32_insn.h
 mode change 100644 => 100755 src/target/nds32_reg.c
 mode change 100644 => 100755 src/target/nds32_reg.h
 mode change 100644 => 100755 src/target/nds32_tlb.c
 mode change 100644 => 100755 src/target/nds32_tlb.h
 mode change 100644 => 100755 src/target/nds32_v2.c
 mode change 100644 => 100755 src/target/nds32_v2.h
 mode change 100644 => 100755 src/target/nds32_v3.c
 mode change 100644 => 100755 src/target/nds32_v3.h
 mode change 100644 => 100755 src/target/nds32_v3_common.c
 mode change 100644 => 100755 src/target/nds32_v3_common.h
 mode change 100644 => 100755 src/target/nds32_v3m.c
 mode change 100644 => 100755 src/target/nds32_v3m.h
 mode change 100644 => 100755 src/target/oocd_trace.c
 mode change 100644 => 100755 src/target/oocd_trace.h
 mode change 100644 => 100755 src/target/openrisc/Makefile.am
 mode change 100644 => 100755 src/target/openrisc/jsp_server.c
 mode change 100644 => 100755 src/target/openrisc/jsp_server.h
 mode change 100644 => 100755 src/target/openrisc/or1k.c
 mode change 100644 => 100755 src/target/openrisc/or1k.h
 mode change 100644 => 100755 src/target/openrisc/or1k_du.h
 mode change 100644 => 100755 src/target/openrisc/or1k_du_adv.c
 mode change 100644 => 100755 src/target/openrisc/or1k_tap.h
 mode change 100644 => 100755 src/target/openrisc/or1k_tap_mohor.c
 mode change 100644 => 100755 src/target/openrisc/or1k_tap_vjtag.c
 mode change 100644 => 100755 src/target/openrisc/or1k_tap_xilinx_bscan.c
 mode change 100644 => 100755 src/target/quark_x10xx.c
 mode change 100644 => 100755 src/target/register.c
 mode change 100644 => 100755 src/target/register.h
 mode change 100644 => 100755 src/target/smp.c
 mode change 100644 => 100755 src/target/smp.h
 mode change 100644 => 100755 src/target/startup.tcl
 mode change 100644 => 100755 src/target/target.c
 mode change 100644 => 100755 src/target/target.h
 mode change 100644 => 100755 src/target/target32.c
 mode change 100644 => 100755 src/target/target_addr.h
 mode change 100644 => 100755 src/target/target_request.c
 mode change 100644 => 100755 src/target/target_request.h
 mode change 100644 => 100755 src/target/target_type.h
 mode change 100644 => 100755 src/target/testee.c
 mode change 100644 => 100755 src/target/trace.c
 mode change 100644 => 100755 src/target/trace.h
 mode change 100644 => 100755 src/target/x86_32_common.c
 mode change 100644 => 100755 src/target/x86_32_common.h
 mode change 100644 => 100755 src/target/xscale.c
 mode change 100644 => 100755 src/target/xscale.h
 mode change 100644 => 100755 src/target/xscale/debug_handler.S
 mode change 100644 => 100755 src/target/xscale/debug_handler.cmd
 mode change 100644 => 100755 src/target/xscale/protocol.h
 mode change 100644 => 100755 src/transport/Makefile.am
 mode change 100644 => 100755 src/transport/transport.c
 mode change 100644 => 100755 src/transport/transport.h
 mode change 100644 => 100755 src/xsvf/Makefile.am
 mode change 100644 => 100755 src/xsvf/xsvf.c
 mode change 100644 => 100755 src/xsvf/xsvf.h
 mode change 100644 => 100755 tcl/bitsbytes.tcl
 mode change 100644 => 100755 tcl/board/actux3.cfg
 mode change 100644 => 100755 tcl/board/altera_sockit.cfg
 mode change 100644 => 100755 tcl/board/am3517evm.cfg
 mode change 100644 => 100755 tcl/board/arm_evaluator7t.cfg
 mode change 100644 => 100755 tcl/board/asus-rt-n16.cfg
 mode change 100644 => 100755 tcl/board/asus-rt-n66u.cfg
 mode change 100644 => 100755 tcl/board/at91cap7a-stk-sdram.cfg
 mode change 100644 => 100755 tcl/board/at91eb40a.cfg
 mode change 100644 => 100755 tcl/board/at91rm9200-dk.cfg
 mode change 100644 => 100755 tcl/board/at91rm9200-ek.cfg
 mode change 100644 => 100755 tcl/board/at91sam9261-ek.cfg
 mode change 100644 => 100755 tcl/board/at91sam9263-ek.cfg
 mode change 100644 => 100755 tcl/board/at91sam9g20-ek.cfg
 mode change 100644 => 100755 tcl/board/atmel_at91sam7s-ek.cfg
 mode change 100644 => 100755 tcl/board/atmel_at91sam9260-ek.cfg
 mode change 100644 => 100755 tcl/board/atmel_at91sam9rl-ek.cfg
 mode change 100644 => 100755 tcl/board/atmel_sam3n_ek.cfg
 mode change 100644 => 100755 tcl/board/atmel_sam3s_ek.cfg
 mode change 100644 => 100755 tcl/board/atmel_sam3u_ek.cfg
 mode change 100644 => 100755 tcl/board/atmel_sam3x_ek.cfg
 mode change 100644 => 100755 tcl/board/atmel_sam4e_ek.cfg
 mode change 100644 => 100755 tcl/board/atmel_sam4l8_xplained_pro.cfg
 mode change 100644 => 100755 tcl/board/atmel_sam4s_ek.cfg
 mode change 100644 => 100755 tcl/board/atmel_sam4s_xplained_pro.cfg
 mode change 100644 => 100755 tcl/board/atmel_samd20_xplained_pro.cfg
 mode change 100644 => 100755 tcl/board/atmel_samd21_xplained_pro.cfg
 mode change 100644 => 100755 tcl/board/atmel_samg53_xplained_pro.cfg
 mode change 100644 => 100755 tcl/board/atmel_samr21_xplained_pro.cfg
 mode change 100644 => 100755 tcl/board/balloon3-cpu.cfg
 mode change 100644 => 100755 tcl/board/bcm28155_ap.cfg
 mode change 100644 => 100755 tcl/board/bt-homehubv1.cfg
 mode change 100644 => 100755 tcl/board/colibri.cfg
 mode change 100644 => 100755 tcl/board/crossbow_tech_imote2.cfg
 mode change 100644 => 100755 tcl/board/csb337.cfg
 mode change 100644 => 100755 tcl/board/csb732.cfg
 mode change 100644 => 100755 tcl/board/da850evm.cfg
 mode change 100644 => 100755 tcl/board/digi_connectcore_wi-9c.cfg
 mode change 100644 => 100755 tcl/board/digilent_zedboard.cfg
 mode change 100644 => 100755 tcl/board/diolan_lpc4350-db1.cfg
 mode change 100644 => 100755 tcl/board/dm355evm.cfg
 mode change 100644 => 100755 tcl/board/dm365evm.cfg
 mode change 100644 => 100755 tcl/board/dm6446evm.cfg
 mode change 100644 => 100755 tcl/board/dp_busblaster_v3.cfg
 mode change 100644 => 100755 tcl/board/efikamx.cfg
 mode change 100644 => 100755 tcl/board/eir.cfg
 mode change 100644 => 100755 tcl/board/ek-lm3s1968.cfg
 mode change 100644 => 100755 tcl/board/ek-lm3s3748.cfg
 mode change 100644 => 100755 tcl/board/ek-lm3s6965.cfg
 mode change 100644 => 100755 tcl/board/ek-lm3s811-revb.cfg
 mode change 100644 => 100755 tcl/board/ek-lm3s811.cfg
 mode change 100644 => 100755 tcl/board/ek-lm3s8962.cfg
 mode change 100644 => 100755 tcl/board/ek-lm3s9b9x.cfg
 mode change 100644 => 100755 tcl/board/ek-lm3s9d92.cfg
 mode change 100644 => 100755 tcl/board/ek-lm4f120xl.cfg
 mode change 100644 => 100755 tcl/board/ek-lm4f232.cfg
 mode change 100644 => 100755 tcl/board/ek-tm4c123gxl.cfg
 mode change 100644 => 100755 tcl/board/ek-tm4c1294xl.cfg
 mode change 100644 => 100755 tcl/board/embedded-artists_lpc2478-32.cfg
 mode change 100644 => 100755 tcl/board/ethernut3.cfg
 mode change 100644 => 100755 tcl/board/frdm-kl25z.cfg
 mode change 100644 => 100755 tcl/board/frdm-kl46z.cfg
 mode change 100644 => 100755 tcl/board/glyn_tonga2.cfg
 mode change 100644 => 100755 tcl/board/gumstix-aerocore.cfg
 mode change 100644 => 100755 tcl/board/hammer.cfg
 mode change 100644 => 100755 tcl/board/hilscher_nxdb500sys.cfg
 mode change 100644 => 100755 tcl/board/hilscher_nxeb500hmi.cfg
 mode change 100644 => 100755 tcl/board/hilscher_nxhx10.cfg
 mode change 100644 => 100755 tcl/board/hilscher_nxhx50.cfg
 mode change 100644 => 100755 tcl/board/hilscher_nxhx500.cfg
 mode change 100644 => 100755 tcl/board/hilscher_nxsb100.cfg
 mode change 100644 => 100755 tcl/board/hitex_lpc1768stick.cfg
 mode change 100644 => 100755 tcl/board/hitex_lpc2929.cfg
 mode change 100644 => 100755 tcl/board/hitex_stm32-performancestick.cfg
 mode change 100644 => 100755 tcl/board/hitex_str9-comstick.cfg
 mode change 100644 => 100755 tcl/board/iar_lpc1768.cfg
 mode change 100644 => 100755 tcl/board/iar_str912_sk.cfg
 mode change 100644 => 100755 tcl/board/icnova_imx53_sodimm.cfg
 mode change 100644 => 100755 tcl/board/icnova_sam9g45_sodimm.cfg
 mode change 100644 => 100755 tcl/board/imx27ads.cfg
 mode change 100644 => 100755 tcl/board/imx27lnst.cfg
 mode change 100644 => 100755 tcl/board/imx28evk.cfg
 mode change 100644 => 100755 tcl/board/imx31pdk.cfg
 mode change 100644 => 100755 tcl/board/imx35pdk.cfg
 mode change 100644 => 100755 tcl/board/imx53-m53evk.cfg
 mode change 100644 => 100755 tcl/board/imx53loco.cfg
 mode change 100644 => 100755 tcl/board/keil_mcb1700.cfg
 mode change 100644 => 100755 tcl/board/keil_mcb2140.cfg
 mode change 100644 => 100755 tcl/board/kwikstik.cfg
 mode change 100644 => 100755 tcl/board/linksys-wrt54gl.cfg
 mode change 100644 => 100755 tcl/board/linksys_nslu2.cfg
 mode change 100644 => 100755 tcl/board/lisa-l.cfg
 mode change 100644 => 100755 tcl/board/logicpd_imx27.cfg
 mode change 100644 => 100755 tcl/board/lpc1850_spifi_generic.cfg
 mode change 100644 => 100755 tcl/board/lpc4350_spifi_generic.cfg
 mode change 100644 => 100755 tcl/board/lubbock.cfg
 mode change 100644 => 100755 tcl/board/mbed-lpc11u24.cfg
 mode change 100644 => 100755 tcl/board/mbed-lpc1768.cfg
 mode change 100644 => 100755 tcl/board/mcb1700.cfg
 mode change 100644 => 100755 tcl/board/microchip_explorer16.cfg
 mode change 100644 => 100755 tcl/board/mini2440.cfg
 mode change 100644 => 100755 tcl/board/mini6410.cfg
 mode change 100644 => 100755 tcl/board/nds32_xc5.cfg
 mode change 100644 => 100755 tcl/board/netgear-dg834v3.cfg
 mode change 100644 => 100755 tcl/board/nordic_nrf51822_mkit.cfg
 mode change 100644 => 100755 tcl/board/olimex_LPC2378STK.cfg
 mode change 100644 => 100755 tcl/board/olimex_lpc_h2148.cfg
 mode change 100644 => 100755 tcl/board/olimex_sam7_ex256.cfg
 mode change 100644 => 100755 tcl/board/olimex_sam9_l9260.cfg
 mode change 100644 => 100755 tcl/board/olimex_stm32_h103.cfg
 mode change 100644 => 100755 tcl/board/olimex_stm32_h107.cfg
 mode change 100644 => 100755 tcl/board/olimex_stm32_p107.cfg
 mode change 100644 => 100755 tcl/board/omap2420_h4.cfg
 mode change 100644 => 100755 tcl/board/open-bldc.cfg
 mode change 100644 => 100755 tcl/board/openrd.cfg
 mode change 100644 => 100755 tcl/board/or1k_generic.cfg
 mode change 100644 => 100755 tcl/board/osk5912.cfg
 mode change 100644 => 100755 tcl/board/phone_se_j100i.cfg
 mode change 100644 => 100755 tcl/board/phytec_lpc3250.cfg
 mode change 100644 => 100755 tcl/board/pic-p32mx.cfg
 mode change 100644 => 100755 tcl/board/propox_mmnet1001.cfg
 mode change 100644 => 100755 tcl/board/pxa255_sst.cfg
 mode change 100644 => 100755 tcl/board/quark_x10xx_board.cfg
 mode change 100644 => 100755 tcl/board/redbee.cfg
 mode change 100644 => 100755 tcl/board/rsc-w910.cfg
 mode change 100644 => 100755 tcl/board/sheevaplug.cfg
 mode change 100644 => 100755 tcl/board/smdk6410.cfg
 mode change 100644 => 100755 tcl/board/spear300evb.cfg
 mode change 100644 => 100755 tcl/board/spear300evb_mod.cfg
 mode change 100644 => 100755 tcl/board/spear310evb20.cfg
 mode change 100644 => 100755 tcl/board/spear310evb20_mod.cfg
 mode change 100644 => 100755 tcl/board/spear320cpu.cfg
 mode change 100644 => 100755 tcl/board/spear320cpu_mod.cfg
 mode change 100644 => 100755 tcl/board/st_nucleo_f030r8.cfg
 mode change 100644 => 100755 tcl/board/st_nucleo_f103rb.cfg
 mode change 100644 => 100755 tcl/board/st_nucleo_f334r8.cfg
 mode change 100644 => 100755 tcl/board/st_nucleo_f401re.cfg
 mode change 100644 => 100755 tcl/board/st_nucleo_f411re.cfg
 mode change 100644 => 100755 tcl/board/steval_pcc010.cfg
 mode change 100644 => 100755 tcl/board/stm320518_eval.cfg
 mode change 100644 => 100755 tcl/board/stm320518_eval_stlink.cfg
 mode change 100644 => 100755 tcl/board/stm32100b_eval.cfg
 mode change 100644 => 100755 tcl/board/stm3210b_eval.cfg
 mode change 100644 => 100755 tcl/board/stm3210c_eval.cfg
 mode change 100644 => 100755 tcl/board/stm3210e_eval.cfg
 mode change 100644 => 100755 tcl/board/stm3220g_eval.cfg
 mode change 100644 => 100755 tcl/board/stm3220g_eval_stlink.cfg
 mode change 100644 => 100755 tcl/board/stm3241g_eval.cfg
 mode change 100644 => 100755 tcl/board/stm3241g_eval_stlink.cfg
 mode change 100644 => 100755 tcl/board/stm32429i_eval.cfg
 mode change 100644 => 100755 tcl/board/stm32429i_eval_stlink.cfg
 mode change 100644 => 100755 tcl/board/stm32439i_eval.cfg
 mode change 100644 => 100755 tcl/board/stm32439i_eval_stlink.cfg
 mode change 100644 => 100755 tcl/board/stm32f0discovery.cfg
 mode change 100644 => 100755 tcl/board/stm32f3discovery.cfg
 mode change 100644 => 100755 tcl/board/stm32f429discovery.cfg
 mode change 100644 => 100755 tcl/board/stm32f4discovery.cfg
 mode change 100644 => 100755 tcl/board/stm32l0discovery.cfg
 mode change 100644 => 100755 tcl/board/stm32ldiscovery.cfg
 mode change 100644 => 100755 tcl/board/stm32vldiscovery.cfg
 mode change 100644 => 100755 tcl/board/str910-eval.cfg
 mode change 100644 => 100755 tcl/board/telo.cfg
 mode change 100644 => 100755 tcl/board/ti_am335xevm.cfg
 mode change 100644 => 100755 tcl/board/ti_am43xx_evm.cfg
 mode change 100644 => 100755 tcl/board/ti_beagleboard.cfg
 mode change 100644 => 100755 tcl/board/ti_beagleboard_xm.cfg
 mode change 100644 => 100755 tcl/board/ti_beaglebone.cfg
 mode change 100644 => 100755 tcl/board/ti_blaze.cfg
 mode change 100644 => 100755 tcl/board/ti_pandaboard.cfg
 mode change 100644 => 100755 tcl/board/ti_pandaboard_es.cfg
 mode change 100644 => 100755 tcl/board/ti_tmdx570ls31usb.cfg
 mode change 100644 => 100755 tcl/board/topas910.cfg
 mode change 100644 => 100755 tcl/board/topasa900.cfg
 mode change 100644 => 100755 tcl/board/twr-k60f120m.cfg
 mode change 100644 => 100755 tcl/board/twr-k60n512.cfg
 mode change 100644 => 100755 tcl/board/tx25_stk5.cfg
 mode change 100644 => 100755 tcl/board/tx27_stk5.cfg
 mode change 100644 => 100755 tcl/board/unknown_at91sam9260.cfg
 mode change 100644 => 100755 tcl/board/uptech_2410.cfg
 mode change 100644 => 100755 tcl/board/verdex.cfg
 mode change 100644 => 100755 tcl/board/voipac.cfg
 mode change 100644 => 100755 tcl/board/voltcraft_dso-3062c.cfg
 mode change 100644 => 100755 tcl/board/x300t.cfg
 mode change 100644 => 100755 tcl/board/zy1000.cfg
 mode change 100644 => 100755 tcl/chip/atmel/at91/aic.tcl
 mode change 100644 => 100755 tcl/chip/atmel/at91/at91_pio.cfg
 mode change 100644 => 100755 tcl/chip/atmel/at91/at91_pmc.cfg
 mode change 100644 => 100755 tcl/chip/atmel/at91/at91_rstc.cfg
 mode change 100644 => 100755 tcl/chip/atmel/at91/at91_wdt.cfg
 mode change 100644 => 100755 tcl/chip/atmel/at91/at91sam7x128.tcl
 mode change 100644 => 100755 tcl/chip/atmel/at91/at91sam7x256.tcl
 mode change 100644 => 100755 tcl/chip/atmel/at91/at91sam9261.cfg
 mode change 100644 => 100755 tcl/chip/atmel/at91/at91sam9261_matrix.cfg
 mode change 100644 => 100755 tcl/chip/atmel/at91/at91sam9263.cfg
 mode change 100644 => 100755 tcl/chip/atmel/at91/at91sam9263_matrix.cfg
 mode change 100644 => 100755 tcl/chip/atmel/at91/at91sam9_init.cfg
 mode change 100644 => 100755 tcl/chip/atmel/at91/at91sam9_sdramc.cfg
 mode change 100644 => 100755 tcl/chip/atmel/at91/at91sam9_smc.cfg
 mode change 100644 => 100755 tcl/chip/atmel/at91/hardware.cfg
 mode change 100644 => 100755 tcl/chip/atmel/at91/pmc.tcl
 mode change 100644 => 100755 tcl/chip/atmel/at91/rtt.tcl
 mode change 100644 => 100755 tcl/chip/atmel/at91/sam9_smc.cfg
 mode change 100644 => 100755 tcl/chip/atmel/at91/usarts.tcl
 mode change 100644 => 100755 tcl/chip/st/spear/quirk_no_srst.tcl
 mode change 100644 => 100755 tcl/chip/st/spear/spear3xx.tcl
 mode change 100644 => 100755 tcl/chip/st/spear/spear3xx_ddr.tcl
 mode change 100644 => 100755 tcl/chip/st/stm32/stm32.tcl
 mode change 100644 => 100755 tcl/chip/st/stm32/stm32_rcc.tcl
 mode change 100644 => 100755 tcl/chip/st/stm32/stm32_regs.tcl
 mode change 100644 => 100755 tcl/chip/ti/lm3s/lm3s.tcl
 mode change 100644 => 100755 tcl/chip/ti/lm3s/lm3s_regs.tcl
 mode change 100644 => 100755 tcl/cpld/lattice-lc4032ze.cfg
 mode change 100644 => 100755 tcl/cpld/xilinx-xcr3256.cfg
 mode change 100644 => 100755 tcl/cpu/arm/arm7tdmi.tcl
 mode change 100644 => 100755 tcl/cpu/arm/arm920.tcl
 mode change 100644 => 100755 tcl/cpu/arm/arm946.tcl
 mode change 100644 => 100755 tcl/cpu/arm/arm966.tcl
 mode change 100644 => 100755 tcl/cpu/arm/cortex_m3.tcl
 mode change 100644 => 100755 tcl/interface/altera-usb-blaster.cfg
 mode change 100644 => 100755 tcl/interface/altera-usb-blaster2.cfg
 mode change 100644 => 100755 tcl/interface/arm-jtag-ew.cfg
 mode change 100644 => 100755 tcl/interface/at91rm9200.cfg
 mode change 100644 => 100755 tcl/interface/axm0432.cfg
 mode change 100644 => 100755 tcl/interface/busblaster.cfg
 mode change 100644 => 100755 tcl/interface/buspirate.cfg
 mode change 100644 => 100755 tcl/interface/calao-usb-a9260-c01.cfg
 mode change 100644 => 100755 tcl/interface/calao-usb-a9260-c02.cfg
 mode change 100644 => 100755 tcl/interface/calao-usb-a9260.cfg
 mode change 100644 => 100755 tcl/interface/chameleon.cfg
 mode change 100644 => 100755 tcl/interface/cmsis-dap.cfg
 mode change 100644 => 100755 tcl/interface/cortino.cfg
 mode change 100644 => 100755 tcl/interface/digilent-hs1.cfg
 mode change 100644 => 100755 tcl/interface/dlp-usb1232h.cfg
 mode change 100644 => 100755 tcl/interface/dummy.cfg
 mode change 100644 => 100755 tcl/interface/estick.cfg
 mode change 100644 => 100755 tcl/interface/flashlink.cfg
 mode change 100644 => 100755 tcl/interface/flossjtag-noeeprom.cfg
 mode change 100644 => 100755 tcl/interface/flossjtag.cfg
 mode change 100644 => 100755 tcl/interface/flyswatter.cfg
 mode change 100644 => 100755 tcl/interface/flyswatter2.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/axm0432.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/calao-usb-a9260-c01.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/calao-usb-a9260-c02.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/cortino.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/digilent_jtag_smt2.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/dlp-usb1232h.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/dp_busblaster.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/dp_busblaster_kt-link.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/flossjtag-noeeprom.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/flossjtag.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/flyswatter.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/flyswatter2.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/gw16042.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/hilscher_nxhx10_etm.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/hilscher_nxhx500_etm.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/hilscher_nxhx500_re.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/hilscher_nxhx50_etm.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/hilscher_nxhx50_re.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/hitex_lpc1768stick.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/hitex_str9-comstick.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/icebear.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/jtag-lock-pick_tiny_2.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/jtagkey.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/jtagkey2.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/jtagkey2p.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/kt-link.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/lisa-l.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/luminary-icdi.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/luminary-lm3s811.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/luminary.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/m53evk.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/minimodule.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/neodb.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/ngxtech.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/olimex-arm-jtag-swd.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/olimex-arm-usb-ocd-h.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/olimex-arm-usb-ocd.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/olimex-arm-usb-tiny-h.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/olimex-jtag-tiny.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/oocdlink.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/opendous_ftdi.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/openocd-usb-hs.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/openocd-usb.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/openrd.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/redbee-econotag.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/redbee-usb.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/rowley-cc-arm-swd.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/sheevaplug.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/signalyzer-lite.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/signalyzer.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/stm32-stick.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/swd-resistor-hack.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/tumpa-lite.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/tumpa.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/turtelizer2-revB.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/turtelizer2-revC.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/vpaclink.cfg
 mode change 100644 => 100755 tcl/interface/ftdi/xds100v2.cfg
 mode change 100644 => 100755 tcl/interface/hilscher_nxhx10_etm.cfg
 mode change 100644 => 100755 tcl/interface/hilscher_nxhx500_etm.cfg
 mode change 100644 => 100755 tcl/interface/hilscher_nxhx500_re.cfg
 mode change 100644 => 100755 tcl/interface/hilscher_nxhx50_etm.cfg
 mode change 100644 => 100755 tcl/interface/hilscher_nxhx50_re.cfg
 mode change 100644 => 100755 tcl/interface/hitex_str9-comstick.cfg
 mode change 100644 => 100755 tcl/interface/icebear.cfg
 mode change 100644 => 100755 tcl/interface/jlink.cfg
 mode change 100644 => 100755 tcl/interface/jtag-lock-pick_tiny_2.cfg
 mode change 100644 => 100755 tcl/interface/jtag_vpi.cfg
 mode change 100644 => 100755 tcl/interface/jtagkey-tiny.cfg
 mode change 100644 => 100755 tcl/interface/jtagkey.cfg
 mode change 100644 => 100755 tcl/interface/jtagkey2.cfg
 mode change 100644 => 100755 tcl/interface/jtagkey2p.cfg
 mode change 100644 => 100755 tcl/interface/kt-link.cfg
 mode change 100644 => 100755 tcl/interface/lisa-l.cfg
 mode change 100644 => 100755 tcl/interface/luminary-icdi.cfg
 mode change 100644 => 100755 tcl/interface/luminary-lm3s811.cfg
 mode change 100644 => 100755 tcl/interface/luminary.cfg
 mode change 100644 => 100755 tcl/interface/minimodule.cfg
 mode change 100644 => 100755 tcl/interface/nds32-aice.cfg
 mode change 100644 => 100755 tcl/interface/neodb.cfg
 mode change 100644 => 100755 tcl/interface/ngxtech.cfg
 mode change 100644 => 100755 tcl/interface/olimex-arm-usb-ocd-h.cfg
 mode change 100644 => 100755 tcl/interface/olimex-arm-usb-ocd.cfg
 mode change 100644 => 100755 tcl/interface/olimex-arm-usb-tiny-h.cfg
 mode change 100644 => 100755 tcl/interface/olimex-jtag-tiny.cfg
 mode change 100644 => 100755 tcl/interface/oocdlink.cfg
 mode change 100644 => 100755 tcl/interface/opendous.cfg
 mode change 100644 => 100755 tcl/interface/opendous_ftdi.cfg
 mode change 100644 => 100755 tcl/interface/openjtag.cfg
 mode change 100644 => 100755 tcl/interface/openocd-usb-hs.cfg
 mode change 100644 => 100755 tcl/interface/openocd-usb.cfg
 mode change 100644 => 100755 tcl/interface/openrd.cfg
 mode change 100644 => 100755 tcl/interface/osbdm.cfg
 mode change 100644 => 100755 tcl/interface/parport.cfg
 mode change 100644 => 100755 tcl/interface/parport_dlc5.cfg
 mode change 100644 => 100755 tcl/interface/raspberrypi-native.cfg
 mode change 100644 => 100755 tcl/interface/redbee-econotag.cfg
 mode change 100644 => 100755 tcl/interface/redbee-usb.cfg
 mode change 100644 => 100755 tcl/interface/rlink.cfg
 mode change 100644 => 100755 tcl/interface/sheevaplug.cfg
 mode change 100644 => 100755 tcl/interface/signalyzer-h2.cfg
 mode change 100644 => 100755 tcl/interface/signalyzer-h4.cfg
 mode change 100644 => 100755 tcl/interface/signalyzer-lite.cfg
 mode change 100644 => 100755 tcl/interface/signalyzer.cfg
 mode change 100644 => 100755 tcl/interface/stlink-v1.cfg
 mode change 100644 => 100755 tcl/interface/stlink-v2-1.cfg
 mode change 100644 => 100755 tcl/interface/stlink-v2.cfg
 mode change 100644 => 100755 tcl/interface/stm32-stick.cfg
 mode change 100644 => 100755 tcl/interface/sysfsgpio-raspberrypi.cfg
 mode change 100644 => 100755 tcl/interface/ti-icdi.cfg
 mode change 100644 => 100755 tcl/interface/turtelizer2.cfg
 mode change 100644 => 100755 tcl/interface/ulink.cfg
 mode change 100644 => 100755 tcl/interface/usb-jtag.cfg
 mode change 100644 => 100755 tcl/interface/usbprog.cfg
 mode change 100644 => 100755 tcl/interface/vpaclink.cfg
 mode change 100644 => 100755 tcl/interface/vsllink.cfg
 mode change 100644 => 100755 tcl/interface/xds100v2.cfg
 mode change 100644 => 100755 tcl/mem_helper.tcl
 mode change 100644 => 100755 tcl/memory.tcl
 mode change 100644 => 100755 tcl/mmr_helpers.tcl
 mode change 100644 => 100755 "tcl/target/1986\320\262\320\2651\321\202.cfg"
 mode change 100644 => 100755 tcl/target/aduc702x.cfg
 mode change 100644 => 100755 tcl/target/altera_fpgasoc.cfg
 mode change 100644 => 100755 tcl/target/am335x.cfg
 mode change 100644 => 100755 tcl/target/am437x.cfg
 mode change 100644 => 100755 tcl/target/amdm37x.cfg
 mode change 100644 => 100755 tcl/target/ar71xx.cfg
 mode change 100644 => 100755 tcl/target/armada370.cfg
 mode change 100644 => 100755 tcl/target/at32ap7000.cfg
 mode change 100644 => 100755 tcl/target/at91r40008.cfg
 mode change 100644 => 100755 tcl/target/at91rm9200.cfg
 mode change 100644 => 100755 tcl/target/at91sam3XXX.cfg
 mode change 100644 => 100755 tcl/target/at91sam3ax_4x.cfg
 mode change 100644 => 100755 tcl/target/at91sam3ax_8x.cfg
 mode change 100644 => 100755 tcl/target/at91sam3ax_xx.cfg
 mode change 100644 => 100755 tcl/target/at91sam3nXX.cfg
 mode change 100644 => 100755 tcl/target/at91sam3sXX.cfg
 mode change 100644 => 100755 tcl/target/at91sam3u1c.cfg
 mode change 100644 => 100755 tcl/target/at91sam3u1e.cfg
 mode change 100644 => 100755 tcl/target/at91sam3u2c.cfg
 mode change 100644 => 100755 tcl/target/at91sam3u2e.cfg
 mode change 100644 => 100755 tcl/target/at91sam3u4c.cfg
 mode change 100644 => 100755 tcl/target/at91sam3u4e.cfg
 mode change 100644 => 100755 tcl/target/at91sam3uxx.cfg
 mode change 100644 => 100755 tcl/target/at91sam4XXX.cfg
 mode change 100644 => 100755 tcl/target/at91sam4lXX.cfg
 mode change 100644 => 100755 tcl/target/at91sam4sXX.cfg
 mode change 100644 => 100755 tcl/target/at91sam4sd32x.cfg
 mode change 100644 => 100755 tcl/target/at91sam7se512.cfg
 mode change 100644 => 100755 tcl/target/at91sam7sx.cfg
 mode change 100644 => 100755 tcl/target/at91sam7x256.cfg
 mode change 100644 => 100755 tcl/target/at91sam7x512.cfg
 mode change 100644 => 100755 tcl/target/at91sam9.cfg
 mode change 100644 => 100755 tcl/target/at91sam9260.cfg
 mode change 100644 => 100755 tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
 mode change 100644 => 100755 tcl/target/at91sam9261.cfg
 mode change 100644 => 100755 tcl/target/at91sam9263.cfg
 mode change 100644 => 100755 tcl/target/at91sam9g10.cfg
 mode change 100644 => 100755 tcl/target/at91sam9g20.cfg
 mode change 100644 => 100755 tcl/target/at91sam9g45.cfg
 mode change 100644 => 100755 tcl/target/at91sam9rl.cfg
 mode change 100644 => 100755 tcl/target/at91samdXX.cfg
 mode change 100644 => 100755 tcl/target/at91samg5x.cfg
 mode change 100644 => 100755 tcl/target/atmega128.cfg
 mode change 100644 => 100755 tcl/target/avr32.cfg
 mode change 100644 => 100755 tcl/target/bcm281xx.cfg
 mode change 100644 => 100755 tcl/target/bcm4706.cfg
 mode change 100644 => 100755 tcl/target/bcm4718.cfg
 mode change 100644 => 100755 tcl/target/bcm47xx.cfg
 mode change 100644 => 100755 tcl/target/bcm5352e.cfg
 mode change 100644 => 100755 tcl/target/bcm6348.cfg
 mode change 100644 => 100755 tcl/target/c100.cfg
 mode change 100644 => 100755 tcl/target/c100config.tcl
 mode change 100644 => 100755 tcl/target/c100helper.tcl
 mode change 100644 => 100755 tcl/target/c100regs.tcl
 mode change 100644 => 100755 tcl/target/cs351x.cfg
 mode change 100644 => 100755 tcl/target/davinci.cfg
 mode change 100644 => 100755 tcl/target/dragonite.cfg
 mode change 100644 => 100755 tcl/target/dsp56321.cfg
 mode change 100644 => 100755 tcl/target/dsp568013.cfg
 mode change 100644 => 100755 tcl/target/dsp568037.cfg
 mode change 100644 => 100755 tcl/target/efm32.cfg
 mode change 100644 => 100755 tcl/target/efm32_stlink.cfg
 mode change 100644 => 100755 tcl/target/epc9301.cfg
 mode change 100644 => 100755 tcl/target/faux.cfg
 mode change 100644 => 100755 tcl/target/feroceon.cfg
 mode change 100644 => 100755 tcl/target/fm3.cfg
 mode change 100644 => 100755 tcl/target/gp326xxxa.cfg
 mode change 100644 => 100755 tcl/target/hilscher_netx10.cfg
 mode change 100644 => 100755 tcl/target/hilscher_netx50.cfg
 mode change 100644 => 100755 tcl/target/hilscher_netx500.cfg
 mode change 100644 => 100755 tcl/target/icepick.cfg
 mode change 100644 => 100755 tcl/target/imx.cfg
 mode change 100644 => 100755 tcl/target/imx21.cfg
 mode change 100644 => 100755 tcl/target/imx25.cfg
 mode change 100644 => 100755 tcl/target/imx27.cfg
 mode change 100644 => 100755 tcl/target/imx28.cfg
 mode change 100644 => 100755 tcl/target/imx31.cfg
 mode change 100644 => 100755 tcl/target/imx35.cfg
 mode change 100644 => 100755 tcl/target/imx51.cfg
 mode change 100644 => 100755 tcl/target/imx53.cfg
 mode change 100644 => 100755 tcl/target/imx6.cfg
 mode change 100644 => 100755 tcl/target/is5114.cfg
 mode change 100644 => 100755 tcl/target/ixp42x.cfg
 mode change 100644 => 100755 tcl/target/k40.cfg
 mode change 100644 => 100755 tcl/target/k60.cfg
 mode change 100644 => 100755 tcl/target/kl25.cfg
 mode change 100644 => 100755 tcl/target/kl25z_hla.cfg
 mode change 100644 => 100755 tcl/target/kl46.cfg
 mode change 100644 => 100755 tcl/target/ks869x.cfg
 mode change 100644 => 100755 tcl/target/lpc11xx.cfg
 mode change 100644 => 100755 tcl/target/lpc12xx.cfg
 mode change 100644 => 100755 tcl/target/lpc13xx.cfg
 mode change 100644 => 100755 tcl/target/lpc17xx.cfg
 mode change 100644 => 100755 tcl/target/lpc1850.cfg
 mode change 100644 => 100755 tcl/target/lpc1xxx.cfg
 mode change 100644 => 100755 tcl/target/lpc2103.cfg
 mode change 100644 => 100755 tcl/target/lpc2124.cfg
 mode change 100644 => 100755 tcl/target/lpc2129.cfg
 mode change 100644 => 100755 tcl/target/lpc2148.cfg
 mode change 100644 => 100755 tcl/target/lpc2294.cfg
 mode change 100644 => 100755 tcl/target/lpc2378.cfg
 mode change 100644 => 100755 tcl/target/lpc2460.cfg
 mode change 100644 => 100755 tcl/target/lpc2478.cfg
 mode change 100644 => 100755 tcl/target/lpc2900.cfg
 mode change 100644 => 100755 tcl/target/lpc2xxx.cfg
 mode change 100644 => 100755 tcl/target/lpc3131.cfg
 mode change 100644 => 100755 tcl/target/lpc3250.cfg
 mode change 100644 => 100755 tcl/target/lpc4350.cfg
 mode change 100644 => 100755 tcl/target/mc13224v.cfg
 mode change 100644 => 100755 tcl/target/mdr32f9q2i.cfg
 mode change 100644 => 100755 tcl/target/nds32v2.cfg
 mode change 100644 => 100755 tcl/target/nds32v3.cfg
 mode change 100644 => 100755 tcl/target/nds32v3m.cfg
 mode change 100644 => 100755 tcl/target/nrf51.cfg
 mode change 100644 => 100755 tcl/target/nrf51_stlink.tcl
 mode change 100644 => 100755 tcl/target/nuc910.cfg
 mode change 100644 => 100755 tcl/target/omap2420.cfg
 mode change 100644 => 100755 tcl/target/omap3530.cfg
 mode change 100644 => 100755 tcl/target/omap4430.cfg
 mode change 100644 => 100755 tcl/target/omap4460.cfg
 mode change 100644 => 100755 tcl/target/omap5912.cfg
 mode change 100644 => 100755 tcl/target/omapl138.cfg
 mode change 100644 => 100755 tcl/target/or1k.cfg
 mode change 100644 => 100755 tcl/target/pic32mx.cfg
 mode change 100644 => 100755 tcl/target/pxa255.cfg
 mode change 100644 => 100755 tcl/target/pxa270.cfg
 mode change 100644 => 100755 tcl/target/pxa3xx.cfg
 mode change 100644 => 100755 tcl/target/quark_x10xx.cfg
 mode change 100644 => 100755 tcl/target/readme.txt
 mode change 100644 => 100755 tcl/target/samsung_s3c2410.cfg
 mode change 100644 => 100755 tcl/target/samsung_s3c2440.cfg
 mode change 100644 => 100755 tcl/target/samsung_s3c2450.cfg
 mode change 100644 => 100755 tcl/target/samsung_s3c4510.cfg
 mode change 100644 => 100755 tcl/target/samsung_s3c6410.cfg
 mode change 100644 => 100755 tcl/target/sharp_lh79532.cfg
 mode change 100644 => 100755 tcl/target/smp8634.cfg
 mode change 100644 => 100755 tcl/target/spear3xx.cfg
 mode change 100644 => 100755 tcl/target/stellaris.cfg
 mode change 100644 => 100755 tcl/target/stellaris_icdi.cfg
 mode change 100644 => 100755 tcl/target/stm32_stlink.cfg
 mode change 100644 => 100755 tcl/target/stm32f0x.cfg
 mode change 100644 => 100755 tcl/target/stm32f0x_stlink.cfg
 mode change 100644 => 100755 tcl/target/stm32f1x.cfg
 mode change 100644 => 100755 tcl/target/stm32f1x_stlink.cfg
 mode change 100644 => 100755 tcl/target/stm32f2x.cfg
 mode change 100644 => 100755 tcl/target/stm32f2x_stlink.cfg
 mode change 100644 => 100755 tcl/target/stm32f3x.cfg
 mode change 100644 => 100755 tcl/target/stm32f3x_stlink.cfg
 mode change 100644 => 100755 tcl/target/stm32f4x.cfg
 mode change 100644 => 100755 tcl/target/stm32f4x_stlink.cfg
 mode change 100644 => 100755 tcl/target/stm32l.cfg
 mode change 100644 => 100755 tcl/target/stm32lx_dual_bank.cfg
 mode change 100644 => 100755 tcl/target/stm32lx_stlink.cfg
 mode change 100644 => 100755 tcl/target/stm32w108_stlink.cfg
 mode change 100644 => 100755 tcl/target/stm32w108xx.cfg
 mode change 100644 => 100755 tcl/target/stm32xl.cfg
 mode change 100644 => 100755 tcl/target/str710.cfg
 mode change 100644 => 100755 tcl/target/str730.cfg
 mode change 100644 => 100755 tcl/target/str750.cfg
 mode change 100644 => 100755 tcl/target/str912.cfg
 mode change 100644 => 100755 tcl/target/swj-dp.tcl
 mode change 100644 => 100755 tcl/target/test_reset_syntax_error.cfg
 mode change 100644 => 100755 tcl/target/test_syntax_error.cfg
 mode change 100644 => 100755 tcl/target/ti-ar7.cfg
 mode change 100644 => 100755 tcl/target/ti_calypso.cfg
 mode change 100644 => 100755 tcl/target/ti_dm355.cfg
 mode change 100644 => 100755 tcl/target/ti_dm365.cfg
 mode change 100644 => 100755 tcl/target/ti_dm6446.cfg
 mode change 100644 => 100755 tcl/target/ti_tms570.cfg
 mode change 100644 => 100755 tcl/target/tmpa900.cfg
 mode change 100644 => 100755 tcl/target/tmpa910.cfg
 mode change 100644 => 100755 tcl/target/u8500.cfg
 mode change 100644 => 100755 tcl/target/zynq_7000.cfg
 mode change 100644 => 100755 "tcl/target/\320\2721879x\320\2611\321\217.cfg"
 mode change 100644 => 100755 tcl/test/syntax1.cfg
 mode change 100644 => 100755 tcl/tools/firmware-recovery.tcl
 mode change 100644 => 100755 tcl/tools/memtest.tcl
 mode change 100644 => 100755 testing/build.test1/Makefile
 mode change 100644 => 100755 testing/build.test1/Makefile.confuse
 mode change 100644 => 100755 testing/build.test1/Makefile.ftd2xx
 mode change 100644 => 100755 testing/build.test1/Makefile.libftdi
 mode change 100644 => 100755 testing/build.test1/Makefile.libusb
 mode change 100644 => 100755 testing/build.test1/Makefile.openocd
 mode change 100644 => 100755 testing/build.test1/README.TXT
 mode change 100644 => 100755 testing/build.test1/local.uses
 mode change 100644 => 100755 testing/build.test1/mingw32_help/include/elf.h
 mode change 100644 => 100755 testing/build.test1/mingw32_help/include/sys/cdefs.h
 mode change 100644 => 100755 testing/build.test1/mingw32_help/include/sys/elf32.h
 mode change 100644 => 100755 testing/build.test1/mingw32_help/include/sys/elf64.h
 mode change 100644 => 100755 testing/build.test1/mingw32_help/include/sys/elf_common.h
 mode change 100644 => 100755 testing/build.test1/mingw32_help/include/sys/elf_generic.h
 mode change 100644 => 100755 testing/build.test2/Makefile
 mode change 100644 => 100755 testing/build.test2/README.txt
 mode change 100644 => 100755 testing/build.test2/local.uses
 mode change 100644 => 100755 testing/examples/AT91R40008Test/inc/typedefs.h
 mode change 100644 => 100755 testing/examples/AT91R40008Test/makefile
 mode change 100644 => 100755 testing/examples/AT91R40008Test/prj/at91r40008_reset.script
 mode change 100644 => 100755 testing/examples/AT91R40008Test/prj/at91r40008_turtle.cfg
 mode change 100644 => 100755 testing/examples/AT91R40008Test/prj/eclipse_ram.gdb
 mode change 100644 => 100755 testing/examples/AT91R40008Test/prj/ethernut3_ram.ld
 mode change 100644 => 100755 testing/examples/AT91R40008Test/src/crt.s
 mode change 100644 => 100755 testing/examples/AT91R40008Test/src/main.c
 mode change 100644 => 100755 testing/examples/AT91R40008Test/test_ram.elf
 mode change 100644 => 100755 testing/examples/AT91R40008Test/test_ram.hex
 mode change 100644 => 100755 testing/examples/AT91R40008Test/test_ram.map
 mode change 100644 => 100755 testing/examples/LPC2148Test/inc/typedefs.h
 mode change 100644 => 100755 testing/examples/LPC2148Test/makefile
 mode change 100644 => 100755 testing/examples/LPC2148Test/prj/eclipse_ram.gdb
 mode change 100644 => 100755 testing/examples/LPC2148Test/prj/eclipse_rom.gdb
 mode change 100644 => 100755 testing/examples/LPC2148Test/prj/lpc2148_jtagkey.cfg
 mode change 100644 => 100755 testing/examples/LPC2148Test/prj/lpc2148_ram.ld
 mode change 100644 => 100755 testing/examples/LPC2148Test/prj/lpc2148_rom.ld
 mode change 100644 => 100755 testing/examples/LPC2148Test/src/crt.s
 mode change 100644 => 100755 testing/examples/LPC2148Test/src/main.c
 mode change 100644 => 100755 testing/examples/LPC2148Test/test_ram.elf
 mode change 100644 => 100755 testing/examples/LPC2148Test/test_ram.hex
 mode change 100644 => 100755 testing/examples/LPC2148Test/test_ram.map
 mode change 100644 => 100755 testing/examples/LPC2148Test/test_rom.elf
 mode change 100644 => 100755 testing/examples/LPC2148Test/test_rom.hex
 mode change 100644 => 100755 testing/examples/LPC2148Test/test_rom.map
 mode change 100644 => 100755 testing/examples/LPC2294Test/inc/typedefs.h
 mode change 100644 => 100755 testing/examples/LPC2294Test/makefile
 mode change 100644 => 100755 testing/examples/LPC2294Test/prj/eclipse_ram.gdb
 mode change 100644 => 100755 testing/examples/LPC2294Test/prj/eclipse_rom.gdb
 mode change 100644 => 100755 testing/examples/LPC2294Test/prj/lpc2294_jtagkey.cfg
 mode change 100644 => 100755 testing/examples/LPC2294Test/prj/lpc2294_ram.ld
 mode change 100644 => 100755 testing/examples/LPC2294Test/prj/lpc2294_rom.ld
 mode change 100644 => 100755 testing/examples/LPC2294Test/src/crt.s
 mode change 100644 => 100755 testing/examples/LPC2294Test/src/main.c
 mode change 100644 => 100755 testing/examples/LPC2294Test/test_ram.elf
 mode change 100644 => 100755 testing/examples/LPC2294Test/test_ram.hex
 mode change 100644 => 100755 testing/examples/LPC2294Test/test_ram.map
 mode change 100644 => 100755 testing/examples/LPC2294Test/test_rom.elf
 mode change 100644 => 100755 testing/examples/LPC2294Test/test_rom.hex
 mode change 100644 => 100755 testing/examples/LPC2294Test/test_rom.map
 mode change 100644 => 100755 testing/examples/PIC32/BlinkingLeds.c
 mode change 100644 => 100755 testing/examples/PIC32/BlinkingLeds.elf
 mode change 100644 => 100755 testing/examples/PIC32/readme.txt
 mode change 100644 => 100755 testing/examples/SAM7S256Test/inc/typedefs.h
 mode change 100644 => 100755 testing/examples/SAM7S256Test/makefile
 mode change 100644 => 100755 testing/examples/SAM7S256Test/prj/eclipse_ram.gdb
 mode change 100644 => 100755 testing/examples/SAM7S256Test/prj/eclipse_rom.gdb
 mode change 100644 => 100755 testing/examples/SAM7S256Test/prj/sam7s256_jtagkey.cfg
 mode change 100644 => 100755 testing/examples/SAM7S256Test/prj/sam7s256_ram.ld
 mode change 100644 => 100755 testing/examples/SAM7S256Test/prj/sam7s256_reset.script
 mode change 100644 => 100755 testing/examples/SAM7S256Test/prj/sam7s256_rom.ld
 mode change 100644 => 100755 testing/examples/SAM7S256Test/results/607.html
 mode change 100644 => 100755 testing/examples/SAM7S256Test/src/crt.s
 mode change 100644 => 100755 testing/examples/SAM7S256Test/src/main.c
 mode change 100644 => 100755 testing/examples/SAM7S256Test/test_ram.elf
 mode change 100644 => 100755 testing/examples/SAM7S256Test/test_ram.hex
 mode change 100644 => 100755 testing/examples/SAM7S256Test/test_ram.map
 mode change 100644 => 100755 testing/examples/SAM7S256Test/test_rom.elf
 mode change 100644 => 100755 testing/examples/SAM7S256Test/test_rom.hex
 mode change 100644 => 100755 testing/examples/SAM7S256Test/test_rom.map
 mode change 100644 => 100755 testing/examples/SAM7X256Test/inc/typedefs.h
 mode change 100644 => 100755 testing/examples/SAM7X256Test/makefile
 mode change 100644 => 100755 testing/examples/SAM7X256Test/prj/eclipse_ram.gdb
 mode change 100644 => 100755 testing/examples/SAM7X256Test/prj/eclipse_rom.gdb
 mode change 100644 => 100755 testing/examples/SAM7X256Test/prj/sam7x256_jtagkey.cfg
 mode change 100644 => 100755 testing/examples/SAM7X256Test/prj/sam7x256_ram.ld
 mode change 100644 => 100755 testing/examples/SAM7X256Test/prj/sam7x256_reset.script
 mode change 100644 => 100755 testing/examples/SAM7X256Test/prj/sam7x256_rom.ld
 mode change 100644 => 100755 testing/examples/SAM7X256Test/src/crt.s
 mode change 100644 => 100755 testing/examples/SAM7X256Test/src/main.c
 mode change 100644 => 100755 testing/examples/SAM7X256Test/test_ram.elf
 mode change 100644 => 100755 testing/examples/SAM7X256Test/test_ram.hex
 mode change 100644 => 100755 testing/examples/SAM7X256Test/test_ram.map
 mode change 100644 => 100755 testing/examples/SAM7X256Test/test_rom.elf
 mode change 100644 => 100755 testing/examples/SAM7X256Test/test_rom.hex
 mode change 100644 => 100755 testing/examples/SAM7X256Test/test_rom.map
 mode change 100644 => 100755 testing/examples/STM32-103/main.elf
 mode change 100644 => 100755 testing/examples/STM32-103/readme.txt
 mode change 100644 => 100755 testing/examples/STR710JtagSpeed/inc/typedefs.h
 mode change 100644 => 100755 testing/examples/STR710JtagSpeed/makefile
 mode change 100644 => 100755 testing/examples/STR710JtagSpeed/prj/eclipse_ft2232_ram.gdb
 mode change 100644 => 100755 testing/examples/STR710JtagSpeed/prj/str710_jtagkey.cfg
 mode change 100644 => 100755 testing/examples/STR710JtagSpeed/prj/str7_ram.ld
 mode change 100644 => 100755 testing/examples/STR710JtagSpeed/src/crt.s
 mode change 100644 => 100755 testing/examples/STR710JtagSpeed/src/main.c
 mode change 100644 => 100755 testing/examples/STR710JtagSpeed/test.elf
 mode change 100644 => 100755 testing/examples/STR710JtagSpeed/test.hex
 mode change 100644 => 100755 testing/examples/STR710JtagSpeed/test.map
 mode change 100644 => 100755 testing/examples/STR710Test/.gitignore
 mode change 100644 => 100755 testing/examples/STR710Test/inc/typedefs.h
 mode change 100644 => 100755 testing/examples/STR710Test/makefile
 mode change 100644 => 100755 testing/examples/STR710Test/prj/eclipse_ram.gdb
 mode change 100644 => 100755 testing/examples/STR710Test/prj/eclipse_rom.gdb
 mode change 100644 => 100755 testing/examples/STR710Test/prj/hitex_str7_ram.ld
 mode change 100644 => 100755 testing/examples/STR710Test/prj/hitex_str7_rom.ld
 mode change 100644 => 100755 testing/examples/STR710Test/prj/str710_jtagkey.cfg
 mode change 100644 => 100755 testing/examples/STR710Test/prj/str710_program.script
 mode change 100644 => 100755 testing/examples/STR710Test/src/crt.s
 mode change 100644 => 100755 testing/examples/STR710Test/src/main.c
 mode change 100644 => 100755 testing/examples/STR710Test/test_ram.elf
 mode change 100644 => 100755 testing/examples/STR710Test/test_ram.hex
 mode change 100644 => 100755 testing/examples/STR710Test/test_ram.map
 mode change 100644 => 100755 testing/examples/STR710Test/test_rom.elf
 mode change 100644 => 100755 testing/examples/STR710Test/test_rom.hex
 mode change 100644 => 100755 testing/examples/STR710Test/test_rom.map
 mode change 100644 => 100755 testing/examples/STR912Test/inc/typedefs.h
 mode change 100644 => 100755 testing/examples/STR912Test/makefile
 mode change 100644 => 100755 testing/examples/STR912Test/prj/eclipse_ram.gdb
 mode change 100644 => 100755 testing/examples/STR912Test/prj/eclipse_rom.gdb
 mode change 100644 => 100755 testing/examples/STR912Test/prj/str912_jtagkey.cfg
 mode change 100644 => 100755 testing/examples/STR912Test/prj/str912_program.script
 mode change 100644 => 100755 testing/examples/STR912Test/prj/str912_ram.ld
 mode change 100644 => 100755 testing/examples/STR912Test/prj/str912_rom.ld
 mode change 100644 => 100755 testing/examples/STR912Test/src/main.c
 mode change 100644 => 100755 testing/examples/STR912Test/src/startup.s
 mode change 100644 => 100755 testing/examples/STR912Test/test_ram.elf
 mode change 100644 => 100755 testing/examples/STR912Test/test_ram.hex
 mode change 100644 => 100755 testing/examples/STR912Test/test_ram.map
 mode change 100644 => 100755 testing/examples/STR912Test/test_rom.elf
 mode change 100644 => 100755 testing/examples/STR912Test/test_rom.hex
 mode change 100644 => 100755 testing/examples/STR912Test/test_rom.map
 mode change 100644 => 100755 testing/examples/cortex/cm3-ftest.cfg
 mode change 100644 => 100755 testing/examples/cortex/fault.c
 mode change 100644 => 100755 testing/examples/cortex/lm3s3748.elf
 mode change 100644 => 100755 testing/examples/cortex/test.c
 mode change 100644 => 100755 testing/examples/cortex/test.ld
 mode change 100644 => 100755 testing/examples/ledtest-imx27ads/Makefile
 mode change 100644 => 100755 testing/examples/ledtest-imx27ads/crt0.S
 mode change 100644 => 100755 testing/examples/ledtest-imx27ads/gdbinit-imx27ads
 mode change 100644 => 100755 testing/examples/ledtest-imx27ads/ldscript
 mode change 100644 => 100755 testing/examples/ledtest-imx27ads/test.c
 mode change 100644 => 100755 testing/examples/ledtest-imx27ads/test.elf
 mode change 100644 => 100755 testing/examples/ledtest-imx31pdk/Makefile
 mode change 100644 => 100755 testing/examples/ledtest-imx31pdk/crt0.S
 mode change 100644 => 100755 testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk
 mode change 100644 => 100755 testing/examples/ledtest-imx31pdk/ldscript
 mode change 100644 => 100755 testing/examples/ledtest-imx31pdk/test.c
 mode change 100644 => 100755 testing/examples/ledtest-imx31pdk/test.elf
 mode change 100644 => 100755 testing/index.html
 mode change 100644 => 100755 testing/profile_stm32.txt
 mode change 100644 => 100755 testing/results/template.html
 mode change 100644 => 100755 testing/smoketests.html
 mode change 100644 => 100755 testing/tcl_server.tcl
 mode change 100644 => 100755 testing/tcl_test.tcl
 mode change 100644 => 100755 testing/testcases.html
 mode change 100644 => 100755 tools/logger.pl
 mode change 100644 => 100755 tools/release/helpers.sh
 mode change 100644 => 100755 uncrustify.cfg

diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
diff --git a/.gitmodules b/.gitmodules
old mode 100644
new mode 100755
diff --git a/AUTHORS b/AUTHORS
old mode 100644
new mode 100755
diff --git a/AUTHORS.ChangeLog b/AUTHORS.ChangeLog
old mode 100644
new mode 100755
diff --git a/BUGS b/BUGS
old mode 100644
new mode 100755
diff --git a/COPYING b/COPYING
old mode 100644
new mode 100755
diff --git a/ChangeLog b/ChangeLog
old mode 100644
new mode 100755
diff --git a/Doxyfile.in b/Doxyfile.in
old mode 100644
new mode 100755
diff --git a/HACKING b/HACKING
old mode 100644
new mode 100755
diff --git a/Makefile.am b/Makefile.am
old mode 100644
new mode 100755
diff --git a/NEWS b/NEWS
old mode 100644
new mode 100755
diff --git a/NEWS-0.2.0 b/NEWS-0.2.0
old mode 100644
new mode 100755
diff --git a/NEWS-0.3.0 b/NEWS-0.3.0
old mode 100644
new mode 100755
diff --git a/NEWS-0.4.0 b/NEWS-0.4.0
old mode 100644
new mode 100755
diff --git a/NEWS-0.5.0 b/NEWS-0.5.0
old mode 100644
new mode 100755
diff --git a/NEWS-0.6.0 b/NEWS-0.6.0
old mode 100644
new mode 100755
diff --git a/NEWS-0.7.0 b/NEWS-0.7.0
old mode 100644
new mode 100755
diff --git a/NEWS-0.8.0 b/NEWS-0.8.0
old mode 100644
new mode 100755
diff --git a/NEWTAPS b/NEWTAPS
old mode 100644
new mode 100755
diff --git a/README b/README
old mode 100644
new mode 100755
diff --git a/README.OSX b/README.OSX
old mode 100644
new mode 100755
diff --git a/README.Windows b/README.Windows
old mode 100644
new mode 100755
diff --git a/TODO b/TODO
old mode 100644
new mode 100755
diff --git a/common.mk b/common.mk
old mode 100644
new mode 100755
diff --git a/config_subdir.m4 b/config_subdir.m4
old mode 100644
new mode 100755
diff --git a/configure.ac b/configure.ac
old mode 100644
new mode 100755
diff --git a/contrib/99-openocd.rules b/contrib/99-openocd.rules
old mode 100644
new mode 100755
diff --git a/contrib/coresight-trace.txt b/contrib/coresight-trace.txt
old mode 100644
new mode 100755
diff --git a/contrib/itmdump.c b/contrib/itmdump.c
old mode 100644
new mode 100755
diff --git a/contrib/libdcc/README b/contrib/libdcc/README
old mode 100644
new mode 100755
diff --git a/contrib/libdcc/dcc_stdio.c b/contrib/libdcc/dcc_stdio.c
old mode 100644
new mode 100755
diff --git a/contrib/libdcc/dcc_stdio.h b/contrib/libdcc/dcc_stdio.h
old mode 100644
new mode 100755
diff --git a/contrib/libdcc/example.c b/contrib/libdcc/example.c
old mode 100644
new mode 100755
diff --git a/contrib/loaders/README b/contrib/loaders/README
old mode 100644
new mode 100755
diff --git a/contrib/loaders/checksum/armv4_5_crc.s b/contrib/loaders/checksum/armv4_5_crc.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/checksum/armv7m_crc.s b/contrib/loaders/checksum/armv7m_crc.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/checksum/mips32.s b/contrib/loaders/checksum/mips32.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/erase_check/armv4_5_erase_check.s b/contrib/loaders/erase_check/armv4_5_erase_check.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/erase_check/armv7m_erase_check.s b/contrib/loaders/erase_check/armv7m_erase_check.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/armv4_5_cfi_intel_16.s b/contrib/loaders/flash/armv4_5_cfi_intel_16.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/armv4_5_cfi_intel_32.s b/contrib/loaders/flash/armv4_5_cfi_intel_32.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/armv4_5_cfi_intel_8.s b/contrib/loaders/flash/armv4_5_cfi_intel_8.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/armv4_5_cfi_span_16.s b/contrib/loaders/flash/armv4_5_cfi_span_16.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/armv4_5_cfi_span_16_dq7.s b/contrib/loaders/flash/armv4_5_cfi_span_16_dq7.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/armv4_5_cfi_span_32.s b/contrib/loaders/flash/armv4_5_cfi_span_32.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/armv4_5_cfi_span_8.s b/contrib/loaders/flash/armv4_5_cfi_span_8.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/armv7m_cfi_span_16.s b/contrib/loaders/flash/armv7m_cfi_span_16.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/armv7m_cfi_span_16_dq7.s b/contrib/loaders/flash/armv7m_cfi_span_16_dq7.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/armv7m_io.s b/contrib/loaders/flash/armv7m_io.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/at91sam7x/at91sam7x_ocl_flash.script b/contrib/loaders/flash/at91sam7x/at91sam7x_ocl_flash.script
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/at91sam7x/at91sam7x_ram.ld b/contrib/loaders/flash/at91sam7x/at91sam7x_ram.ld
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/at91sam7x/crt.s b/contrib/loaders/flash/at91sam7x/crt.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/at91sam7x/dcc.c b/contrib/loaders/flash/at91sam7x/dcc.c
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/at91sam7x/dcc.h b/contrib/loaders/flash/at91sam7x/dcc.h
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/at91sam7x/main.c b/contrib/loaders/flash/at91sam7x/main.c
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/at91sam7x/makefile b/contrib/loaders/flash/at91sam7x/makefile
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/at91sam7x/ocl.h b/contrib/loaders/flash/at91sam7x/ocl.h
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/at91sam7x/platform.h b/contrib/loaders/flash/at91sam7x/platform.h
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/at91sam7x/samflash.c b/contrib/loaders/flash/at91sam7x/samflash.c
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/at91sam7x/samflash.h b/contrib/loaders/flash/at91sam7x/samflash.h
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/at91sam7x/samregs.h b/contrib/loaders/flash/at91sam7x/samregs.h
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/efm32.S b/contrib/loaders/flash/efm32.S
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/lpcspifi_erase.S b/contrib/loaders/flash/lpcspifi_erase.S
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/lpcspifi_init.S b/contrib/loaders/flash/lpcspifi_init.S
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/lpcspifi_write.S b/contrib/loaders/flash/lpcspifi_write.S
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/mdr32fx.S b/contrib/loaders/flash/mdr32fx.S
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/mrvlqspi_write.S b/contrib/loaders/flash/mrvlqspi_write.S
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/pic32mx.s b/contrib/loaders/flash/pic32mx.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/stellaris.s b/contrib/loaders/flash/stellaris.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/stm32f1x.S b/contrib/loaders/flash/stm32f1x.S
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/stm32f2x.S b/contrib/loaders/flash/stm32f2x.S
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/stm32lx.S b/contrib/loaders/flash/stm32lx.S
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/str7x.s b/contrib/loaders/flash/str7x.s
old mode 100644
new mode 100755
diff --git a/contrib/loaders/flash/str9x.s b/contrib/loaders/flash/str9x.s
old mode 100644
new mode 100755
diff --git a/contrib/remote_bitbang/remote_bitbang_sysfsgpio.c b/contrib/remote_bitbang/remote_bitbang_sysfsgpio.c
old mode 100644
new mode 100755
diff --git a/contrib/rpc_examples/ocdrpc.hs b/contrib/rpc_examples/ocdrpc.hs
old mode 100644
new mode 100755
diff --git a/contrib/xsvf_tools/svf2xsvf.py b/contrib/xsvf_tools/svf2xsvf.py
old mode 100644
new mode 100755
diff --git a/contrib/xsvf_tools/xsvfdump.py b/contrib/xsvf_tools/xsvfdump.py
old mode 100644
new mode 100755
diff --git a/doc/INSTALL.txt b/doc/INSTALL.txt
old mode 100644
new mode 100755
diff --git a/doc/Makefile.am b/doc/Makefile.am
old mode 100644
new mode 100755
diff --git a/doc/fdl.texi b/doc/fdl.texi
old mode 100644
new mode 100755
diff --git a/doc/manual/app.txt b/doc/manual/app.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/flash.txt b/doc/manual/flash.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/helper.txt b/doc/manual/helper.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/images/jtag-state-machine-large.png b/doc/manual/images/jtag-state-machine-large.png
old mode 100644
new mode 100755
diff --git a/doc/manual/jtag.txt b/doc/manual/jtag.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/jtag/drivers/remote_bitbang.txt b/doc/manual/jtag/drivers/remote_bitbang.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/main.txt b/doc/manual/main.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/primer/autotools.txt b/doc/manual/primer/autotools.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/primer/commands.txt b/doc/manual/primer/commands.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/primer/docs.txt b/doc/manual/primer/docs.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/primer/jtag.txt b/doc/manual/primer/jtag.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/primer/tcl.txt b/doc/manual/primer/tcl.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/release.txt b/doc/manual/release.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/scripting.txt b/doc/manual/scripting.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/server.txt b/doc/manual/server.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/style.txt b/doc/manual/style.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/target.txt b/doc/manual/target.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/target/mips.txt b/doc/manual/target/mips.txt
old mode 100644
new mode 100755
diff --git a/doc/manual/target/notarm.txt b/doc/manual/target/notarm.txt
old mode 100644
new mode 100755
diff --git a/doc/openocd.1 b/doc/openocd.1
old mode 100644
new mode 100755
diff --git a/doc/openocd.texi b/doc/openocd.texi
old mode 100644
new mode 100755
diff --git a/src/Makefile.am b/src/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/flash/Makefile.am b/src/flash/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/flash/common.c b/src/flash/common.c
old mode 100644
new mode 100755
diff --git a/src/flash/common.h b/src/flash/common.h
old mode 100644
new mode 100755
diff --git a/src/flash/mflash.c b/src/flash/mflash.c
old mode 100644
new mode 100755
diff --git a/src/flash/mflash.h b/src/flash/mflash.h
old mode 100644
new mode 100755
diff --git a/src/flash/nand/Makefile.am b/src/flash/nand/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/flash/nand/arm_io.c b/src/flash/nand/arm_io.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/arm_io.h b/src/flash/nand/arm_io.h
old mode 100644
new mode 100755
diff --git a/src/flash/nand/at91sam9.c b/src/flash/nand/at91sam9.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/core.c b/src/flash/nand/core.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/core.h b/src/flash/nand/core.h
old mode 100644
new mode 100755
diff --git a/src/flash/nand/davinci.c b/src/flash/nand/davinci.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/driver.c b/src/flash/nand/driver.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/driver.h b/src/flash/nand/driver.h
old mode 100644
new mode 100755
diff --git a/src/flash/nand/ecc.c b/src/flash/nand/ecc.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/ecc_kw.c b/src/flash/nand/ecc_kw.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/fileio.c b/src/flash/nand/fileio.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/fileio.h b/src/flash/nand/fileio.h
old mode 100644
new mode 100755
diff --git a/src/flash/nand/imp.h b/src/flash/nand/imp.h
old mode 100644
new mode 100755
diff --git a/src/flash/nand/lpc3180.c b/src/flash/nand/lpc3180.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/lpc3180.h b/src/flash/nand/lpc3180.h
old mode 100644
new mode 100755
diff --git a/src/flash/nand/lpc32xx.c b/src/flash/nand/lpc32xx.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/lpc32xx.h b/src/flash/nand/lpc32xx.h
old mode 100644
new mode 100755
diff --git a/src/flash/nand/mx3.c b/src/flash/nand/mx3.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/mx3.h b/src/flash/nand/mx3.h
old mode 100644
new mode 100755
diff --git a/src/flash/nand/mxc.c b/src/flash/nand/mxc.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/mxc.h b/src/flash/nand/mxc.h
old mode 100644
new mode 100755
diff --git a/src/flash/nand/nonce.c b/src/flash/nand/nonce.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/nuc910.c b/src/flash/nand/nuc910.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/nuc910.h b/src/flash/nand/nuc910.h
old mode 100644
new mode 100755
diff --git a/src/flash/nand/orion.c b/src/flash/nand/orion.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/s3c2410.c b/src/flash/nand/s3c2410.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/s3c2412.c b/src/flash/nand/s3c2412.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/s3c2440.c b/src/flash/nand/s3c2440.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/s3c2443.c b/src/flash/nand/s3c2443.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/s3c24xx.c b/src/flash/nand/s3c24xx.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/s3c24xx.h b/src/flash/nand/s3c24xx.h
old mode 100644
new mode 100755
diff --git a/src/flash/nand/s3c24xx_regs.h b/src/flash/nand/s3c24xx_regs.h
old mode 100644
new mode 100755
diff --git a/src/flash/nand/s3c6400.c b/src/flash/nand/s3c6400.c
old mode 100644
new mode 100755
diff --git a/src/flash/nand/tcl.c b/src/flash/nand/tcl.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/Makefile.am b/src/flash/nor/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/flash/nor/aduc702x.c b/src/flash/nor/aduc702x.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/at91sam3.c b/src/flash/nor/at91sam3.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/at91sam4.c b/src/flash/nor/at91sam4.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/at91sam4l.c b/src/flash/nor/at91sam4l.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/at91sam7.c b/src/flash/nor/at91sam7.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/at91samd.c b/src/flash/nor/at91samd.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/avrf.c b/src/flash/nor/avrf.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
old mode 100644
new mode 100755
index 97d3f19..cd935d7
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1300,7 +1300,7 @@ static int cfi_intel_write_block(struct flash_bank *bank, const uint8_t *buffer,
 	busy_pattern_val  = cfi_command_val(bank, 0x80);
 	error_pattern_val = cfi_command_val(bank, 0x7e);
 
-	LOG_DEBUG("Using target buffer at 0x%08" PRIx32 " and of size 0x%04" PRIx32,
+	LOG_DEBUG("Using target buffer at 0x%08" PRIx64 " and of size 0x%04" PRIx32,
 		source->address, buffer_size);
 
 	/* Programming main loop */
diff --git a/src/flash/nor/cfi.h b/src/flash/nor/cfi.h
old mode 100644
new mode 100755
diff --git a/src/flash/nor/core.c b/src/flash/nor/core.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/core.h b/src/flash/nor/core.h
old mode 100644
new mode 100755
diff --git a/src/flash/nor/driver.h b/src/flash/nor/driver.h
old mode 100644
new mode 100755
diff --git a/src/flash/nor/drivers.c b/src/flash/nor/drivers.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/dsp5680xx_flash.c b/src/flash/nor/dsp5680xx_flash.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/efm32.c b/src/flash/nor/efm32.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/em357.c b/src/flash/nor/em357.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/faux.c b/src/flash/nor/faux.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/fm3.c b/src/flash/nor/fm3.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/imp.h b/src/flash/nor/imp.h
old mode 100644
new mode 100755
diff --git a/src/flash/nor/kinetis.c b/src/flash/nor/kinetis.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
old mode 100644
new mode 100755
index 0af00f9..433973f
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -580,7 +580,7 @@ static int lpc2000_iap_working_area_init(struct flash_bank *bank, struct working
 
 	int retval = target_write_memory(target, (*iap_working_area)->address, 4, 2, jump_gate);
 	if (retval != ERROR_OK)
-		LOG_ERROR("Write memory at address 0x%8.8" PRIx32 " failed (check work_area definition)",
+		LOG_ERROR("Write memory at address 0x%8.8" PRIx64 " failed (check work_area definition)",
 				(*iap_working_area)->address);
 
 	return retval;
diff --git a/src/flash/nor/lpc288x.c b/src/flash/nor/lpc288x.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
old mode 100644
new mode 100755
index 7c3e675..fe5d791
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -657,7 +657,7 @@ COMMAND_HANDLER(lpc2900_handle_write_custom_command)
 	if ((image.sections[0].base_address != 0) ||
 			(image.sections[0].size != ISS_CUSTOMER_SIZE)) {
 		LOG_ERROR("Incorrect image file size. Expected %d, "
-			"got %" PRIu32,
+			"got %" PRIu64,
 			ISS_CUSTOMER_SIZE, image.sections[0].size);
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
diff --git a/src/flash/nor/lpcspifi.c b/src/flash/nor/lpcspifi.c
old mode 100644
new mode 100755
index 7355c30..502ae26
--- a/src/flash/nor/lpcspifi.c
+++ b/src/flash/nor/lpcspifi.c
@@ -203,7 +203,7 @@ static int lpcspifi_set_hw_mode(struct flash_bank *bank)
 		return retval;
 	}
 
-	LOG_DEBUG("Writing algorithm to working area at 0x%08" PRIx32,
+	LOG_DEBUG("Writing algorithm to working area at 0x%08" PRIx64,
 		spifi_init_algorithm->address);
 	/* Write algorithm to working area */
 	retval = target_write_buffer(target,
diff --git a/src/flash/nor/mdr.c b/src/flash/nor/mdr.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/mini51.c b/src/flash/nor/mini51.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/mrvlqspi.c b/src/flash/nor/mrvlqspi.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/non_cfi.c b/src/flash/nor/non_cfi.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/non_cfi.h b/src/flash/nor/non_cfi.h
old mode 100644
new mode 100755
diff --git a/src/flash/nor/nrf51.c b/src/flash/nor/nrf51.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/nuc1x.c b/src/flash/nor/nuc1x.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/ocl.c b/src/flash/nor/ocl.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/ocl.h b/src/flash/nor/ocl.h
old mode 100644
new mode 100755
diff --git a/src/flash/nor/pic32mx.c b/src/flash/nor/pic32mx.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/spi.c b/src/flash/nor/spi.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/spi.h b/src/flash/nor/spi.h
old mode 100644
new mode 100755
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/stm32f1x.c b/src/flash/nor/stm32f1x.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/stm32f2x.c b/src/flash/nor/stm32f2x.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/stm32lx.c b/src/flash/nor/stm32lx.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/stmsmi.c b/src/flash/nor/stmsmi.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/str7x.c b/src/flash/nor/str7x.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/str9x.c b/src/flash/nor/str9x.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/str9xpec.c b/src/flash/nor/str9xpec.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
old mode 100644
new mode 100755
index 8f97ebd..6971cf2
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -401,7 +401,7 @@ COMMAND_HANDLER(handle_flash_write_image_command)
 
 	if (CMD_ARGC >= 2) {
 		image.base_address_set = 1;
-		COMMAND_PARSE_NUMBER(llong, CMD_ARGV[1], image.base_address);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], image.base_address);
 	} else {
 		image.base_address_set = 0;
 		image.base_address = 0x0;
diff --git a/src/flash/nor/tms470.c b/src/flash/nor/tms470.c
old mode 100644
new mode 100755
diff --git a/src/flash/nor/virtual.c b/src/flash/nor/virtual.c
old mode 100644
new mode 100755
diff --git a/src/flash/startup.tcl b/src/flash/startup.tcl
old mode 100644
new mode 100755
diff --git a/src/hello.c b/src/hello.c
old mode 100644
new mode 100755
diff --git a/src/hello.h b/src/hello.h
old mode 100644
new mode 100755
diff --git a/src/helper/Makefile.am b/src/helper/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/helper/binarybuffer.c b/src/helper/binarybuffer.c
old mode 100644
new mode 100755
diff --git a/src/helper/binarybuffer.h b/src/helper/binarybuffer.h
old mode 100644
new mode 100755
diff --git a/src/helper/command.c b/src/helper/command.c
old mode 100644
new mode 100755
diff --git a/src/helper/command.h b/src/helper/command.h
old mode 100644
new mode 100755
diff --git a/src/helper/configuration.c b/src/helper/configuration.c
old mode 100644
new mode 100755
diff --git a/src/helper/configuration.h b/src/helper/configuration.h
old mode 100644
new mode 100755
diff --git a/src/helper/fileio.c b/src/helper/fileio.c
old mode 100644
new mode 100755
diff --git a/src/helper/fileio.h b/src/helper/fileio.h
old mode 100644
new mode 100755
diff --git a/src/helper/ioutil.c b/src/helper/ioutil.c
old mode 100644
new mode 100755
diff --git a/src/helper/ioutil.h b/src/helper/ioutil.h
old mode 100644
new mode 100755
diff --git a/src/helper/ioutil_stubs.c b/src/helper/ioutil_stubs.c
old mode 100644
new mode 100755
diff --git a/src/helper/jim-nvp.c b/src/helper/jim-nvp.c
old mode 100644
new mode 100755
diff --git a/src/helper/jim-nvp.h b/src/helper/jim-nvp.h
old mode 100644
new mode 100755
diff --git a/src/helper/list.h b/src/helper/list.h
old mode 100644
new mode 100755
diff --git a/src/helper/log.c b/src/helper/log.c
old mode 100644
new mode 100755
diff --git a/src/helper/log.h b/src/helper/log.h
old mode 100644
new mode 100755
diff --git a/src/helper/options.c b/src/helper/options.c
old mode 100644
new mode 100755
diff --git a/src/helper/replacements.c b/src/helper/replacements.c
old mode 100644
new mode 100755
diff --git a/src/helper/replacements.h b/src/helper/replacements.h
old mode 100644
new mode 100755
diff --git a/src/helper/startup.tcl b/src/helper/startup.tcl
old mode 100644
new mode 100755
diff --git a/src/helper/system.h b/src/helper/system.h
old mode 100644
new mode 100755
diff --git a/src/helper/time_support.c b/src/helper/time_support.c
old mode 100644
new mode 100755
diff --git a/src/helper/time_support.h b/src/helper/time_support.h
old mode 100644
new mode 100755
diff --git a/src/helper/time_support_common.c b/src/helper/time_support_common.c
old mode 100644
new mode 100755
diff --git a/src/helper/types.h b/src/helper/types.h
old mode 100644
new mode 100755
diff --git a/src/helper/util.c b/src/helper/util.c
old mode 100644
new mode 100755
diff --git a/src/helper/util.h b/src/helper/util.h
old mode 100644
new mode 100755
diff --git a/src/jtag/Makefile.am b/src/jtag/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/jtag/adapter.c b/src/jtag/adapter.c
old mode 100644
new mode 100755
diff --git a/src/jtag/aice/Makefile.am b/src/jtag/aice/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/jtag/aice/aice_interface.c b/src/jtag/aice/aice_interface.c
old mode 100644
new mode 100755
diff --git a/src/jtag/aice/aice_interface.h b/src/jtag/aice/aice_interface.h
old mode 100644
new mode 100755
diff --git a/src/jtag/aice/aice_pipe.c b/src/jtag/aice/aice_pipe.c
old mode 100644
new mode 100755
diff --git a/src/jtag/aice/aice_pipe.h b/src/jtag/aice/aice_pipe.h
old mode 100644
new mode 100755
diff --git a/src/jtag/aice/aice_port.c b/src/jtag/aice/aice_port.c
old mode 100644
new mode 100755
diff --git a/src/jtag/aice/aice_port.h b/src/jtag/aice/aice_port.h
old mode 100644
new mode 100755
diff --git a/src/jtag/aice/aice_transport.c b/src/jtag/aice/aice_transport.c
old mode 100644
new mode 100755
diff --git a/src/jtag/aice/aice_transport.h b/src/jtag/aice/aice_transport.h
old mode 100644
new mode 100755
diff --git a/src/jtag/aice/aice_usb.c b/src/jtag/aice/aice_usb.c
old mode 100644
new mode 100755
diff --git a/src/jtag/aice/aice_usb.h b/src/jtag/aice/aice_usb.h
old mode 100644
new mode 100755
diff --git a/src/jtag/commands.c b/src/jtag/commands.c
old mode 100644
new mode 100755
diff --git a/src/jtag/commands.h b/src/jtag/commands.h
old mode 100644
new mode 100755
diff --git a/src/jtag/core.c b/src/jtag/core.c
old mode 100644
new mode 100755
diff --git a/src/jtag/driver.h b/src/jtag/driver.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/Makefile.am b/src/jtag/drivers/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/Makefile.rlink b/src/jtag/drivers/Makefile.rlink
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/Makefile b/src/jtag/drivers/OpenULINK/Makefile
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/README b/src/jtag/drivers/OpenULINK/README
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/include/common.h b/src/jtag/drivers/OpenULINK/include/common.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/include/delay.h b/src/jtag/drivers/OpenULINK/include/delay.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/include/io.h b/src/jtag/drivers/OpenULINK/include/io.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/include/jtag.h b/src/jtag/drivers/OpenULINK/include/jtag.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/include/main.h b/src/jtag/drivers/OpenULINK/include/main.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/include/msgtypes.h b/src/jtag/drivers/OpenULINK/include/msgtypes.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/include/protocol.h b/src/jtag/drivers/OpenULINK/include/protocol.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/include/reg_ezusb.h b/src/jtag/drivers/OpenULINK/include/reg_ezusb.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/include/usb.h b/src/jtag/drivers/OpenULINK/include/usb.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/src/USBJmpTb.a51 b/src/jtag/drivers/OpenULINK/src/USBJmpTb.a51
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/src/delay.c b/src/jtag/drivers/OpenULINK/src/delay.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/src/jtag.c b/src/jtag/drivers/OpenULINK/src/jtag.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/src/main.c b/src/jtag/drivers/OpenULINK/src/main.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/src/protocol.c b/src/jtag/drivers/OpenULINK/src/protocol.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/src/usb.c b/src/jtag/drivers/OpenULINK/src/usb.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/OpenULINK/ulink_firmware.hex b/src/jtag/drivers/OpenULINK/ulink_firmware.hex
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/amt_jtagaccel.c b/src/jtag/drivers/amt_jtagaccel.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/arm-jtag-ew.c b/src/jtag/drivers/arm-jtag-ew.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/at91rm9200.c b/src/jtag/drivers/at91rm9200.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/bcm2835gpio.c b/src/jtag/drivers/bcm2835gpio.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/bitbang.c b/src/jtag/drivers/bitbang.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/bitbang.h b/src/jtag/drivers/bitbang.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/bitq.c b/src/jtag/drivers/bitq.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/bitq.h b/src/jtag/drivers/bitq.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/buspirate.c b/src/jtag/drivers/buspirate.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/cmsis_dap_usb.c b/src/jtag/drivers/cmsis_dap_usb.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/dummy.c b/src/jtag/drivers/dummy.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/ep93xx.c b/src/jtag/drivers/ep93xx.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/ft2232.c b/src/jtag/drivers/ft2232.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/ftd2xx_common.h b/src/jtag/drivers/ftd2xx_common.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/ftdi.c b/src/jtag/drivers/ftdi.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/gw16012.c b/src/jtag/drivers/gw16012.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/jtag_vpi.c b/src/jtag/drivers/jtag_vpi.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/libusb0_common.c b/src/jtag/drivers/libusb0_common.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/libusb0_common.h b/src/jtag/drivers/libusb0_common.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/libusb1_common.c b/src/jtag/drivers/libusb1_common.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/libusb1_common.h b/src/jtag/drivers/libusb1_common.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/libusb_common.h b/src/jtag/drivers/libusb_common.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/minidriver_imp.h b/src/jtag/drivers/minidriver_imp.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/mpsse.c b/src/jtag/drivers/mpsse.c
old mode 100644
new mode 100755
index d9f73a2..3b0ac5e
--- a/src/jtag/drivers/mpsse.c
+++ b/src/jtag/drivers/mpsse.c
@@ -128,7 +128,7 @@ static bool open_matching_device(struct mpsse_ctx *ctx, const uint16_t *vid, con
 			LOG_ERROR("libusb_get_device_descriptor() failed with %s", libusb_error_name(err));
 			continue;
 		}
-
+		printf("Found: vid: 0x%04x pid: 0x%04x\n", desc.idVendor, desc.idProduct );
 		if (vid && *vid != desc.idVendor)
 			continue;
 		if (pid && *pid != desc.idProduct)
diff --git a/src/jtag/drivers/mpsse.h b/src/jtag/drivers/mpsse.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/opendous.c b/src/jtag/drivers/opendous.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/openjtag.c b/src/jtag/drivers/openjtag.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/osbdm.c b/src/jtag/drivers/osbdm.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/parport.c b/src/jtag/drivers/parport.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/presto.c b/src/jtag/drivers/presto.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/remote_bitbang.c b/src/jtag/drivers/remote_bitbang.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/rlink.c b/src/jtag/drivers/rlink.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/rlink.h b/src/jtag/drivers/rlink.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/rlink_call.m4 b/src/jtag/drivers/rlink_call.m4
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/rlink_dtc_cmd.h b/src/jtag/drivers/rlink_dtc_cmd.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/rlink_ep1_cmd.h b/src/jtag/drivers/rlink_ep1_cmd.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/rlink_init.m4 b/src/jtag/drivers/rlink_init.m4
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/rlink_speed_table.c b/src/jtag/drivers/rlink_speed_table.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/rlink_st7.h b/src/jtag/drivers/rlink_st7.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/stlink_usb.c b/src/jtag/drivers/stlink_usb.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/sysfsgpio.c b/src/jtag/drivers/sysfsgpio.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/ti_icdi_usb.c b/src/jtag/drivers/ti_icdi_usb.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/usb_blaster/Makefile.am b/src/jtag/drivers/usb_blaster/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/usb_blaster/README.CheapClone b/src/jtag/drivers/usb_blaster/README.CheapClone
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/usb_blaster/ublast2_access_libusb.c b/src/jtag/drivers/usb_blaster/ublast2_access_libusb.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/usb_blaster/ublast_access.h b/src/jtag/drivers/usb_blaster/ublast_access.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/usb_blaster/ublast_access_ftd2xx.c b/src/jtag/drivers/usb_blaster/ublast_access_ftd2xx.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/usb_blaster/ublast_access_ftdi.c b/src/jtag/drivers/usb_blaster/ublast_access_ftdi.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/usb_blaster/usb_blaster.c b/src/jtag/drivers/usb_blaster/usb_blaster.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/usb_common.c b/src/jtag/drivers/usb_common.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/usb_common.h b/src/jtag/drivers/usb_common.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/usbprog.c b/src/jtag/drivers/usbprog.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtogpio.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtogpio.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtojtagraw.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtojtagraw.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtopwr.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtopwr.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtoswd.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtoswd.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.c b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx_internal.h b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx_internal.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/versaloon/versaloon.c b/src/jtag/drivers/versaloon/versaloon.c
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/versaloon/versaloon.h b/src/jtag/drivers/versaloon/versaloon.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/versaloon/versaloon_include.h b/src/jtag/drivers/versaloon/versaloon_include.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/versaloon/versaloon_internal.h b/src/jtag/drivers/versaloon/versaloon_internal.h
old mode 100644
new mode 100755
diff --git a/src/jtag/drivers/vsllink.c b/src/jtag/drivers/vsllink.c
old mode 100644
new mode 100755
diff --git a/src/jtag/hla/Makefile.am b/src/jtag/hla/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/jtag/hla/hla_interface.c b/src/jtag/hla/hla_interface.c
old mode 100644
new mode 100755
diff --git a/src/jtag/hla/hla_interface.h b/src/jtag/hla/hla_interface.h
old mode 100644
new mode 100755
diff --git a/src/jtag/hla/hla_layout.c b/src/jtag/hla/hla_layout.c
old mode 100644
new mode 100755
diff --git a/src/jtag/hla/hla_layout.h b/src/jtag/hla/hla_layout.h
old mode 100644
new mode 100755
diff --git a/src/jtag/hla/hla_tcl.c b/src/jtag/hla/hla_tcl.c
old mode 100644
new mode 100755
diff --git a/src/jtag/hla/hla_tcl.h b/src/jtag/hla/hla_tcl.h
old mode 100644
new mode 100755
diff --git a/src/jtag/hla/hla_transport.c b/src/jtag/hla/hla_transport.c
old mode 100644
new mode 100755
diff --git a/src/jtag/hla/hla_transport.h b/src/jtag/hla/hla_transport.h
old mode 100644
new mode 100755
diff --git a/src/jtag/interface.c b/src/jtag/interface.c
old mode 100644
new mode 100755
diff --git a/src/jtag/interface.h b/src/jtag/interface.h
old mode 100644
new mode 100755
diff --git a/src/jtag/interfaces.c b/src/jtag/interfaces.c
old mode 100644
new mode 100755
diff --git a/src/jtag/interfaces.h b/src/jtag/interfaces.h
old mode 100644
new mode 100755
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
old mode 100644
new mode 100755
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
old mode 100644
new mode 100755
diff --git a/src/jtag/minidriver/minidriver_imp.h b/src/jtag/minidriver/minidriver_imp.h
old mode 100644
new mode 100755
diff --git a/src/jtag/minidummy/jtag_minidriver.h b/src/jtag/minidummy/jtag_minidriver.h
old mode 100644
new mode 100755
diff --git a/src/jtag/minidummy/minidummy.c b/src/jtag/minidummy/minidummy.c
old mode 100644
new mode 100755
diff --git a/src/jtag/startup.tcl b/src/jtag/startup.tcl
old mode 100644
new mode 100755
diff --git a/src/jtag/swd.h b/src/jtag/swd.h
old mode 100644
new mode 100755
diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
old mode 100644
new mode 100755
diff --git a/src/jtag/tcl.h b/src/jtag/tcl.h
old mode 100644
new mode 100755
diff --git a/src/jtag/zy1000/jtag_minidriver.h b/src/jtag/zy1000/jtag_minidriver.h
old mode 100644
new mode 100755
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
old mode 100644
new mode 100755
diff --git a/src/main.c b/src/main.c
old mode 100644
new mode 100755
diff --git a/src/openocd.c b/src/openocd.c
old mode 100644
new mode 100755
diff --git a/src/openocd.h b/src/openocd.h
old mode 100644
new mode 100755
diff --git a/src/pld/Makefile.am b/src/pld/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/pld/pld.c b/src/pld/pld.c
old mode 100644
new mode 100755
diff --git a/src/pld/pld.h b/src/pld/pld.h
old mode 100644
new mode 100755
diff --git a/src/pld/virtex2.c b/src/pld/virtex2.c
old mode 100644
new mode 100755
diff --git a/src/pld/virtex2.h b/src/pld/virtex2.h
old mode 100644
new mode 100755
diff --git a/src/pld/xilinx_bit.c b/src/pld/xilinx_bit.c
old mode 100644
new mode 100755
diff --git a/src/pld/xilinx_bit.h b/src/pld/xilinx_bit.h
old mode 100644
new mode 100755
diff --git a/src/rtos/ChibiOS.c b/src/rtos/ChibiOS.c
old mode 100644
new mode 100755
diff --git a/src/rtos/FreeRTOS.c b/src/rtos/FreeRTOS.c
old mode 100644
new mode 100755
diff --git a/src/rtos/Makefile.am b/src/rtos/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/rtos/ThreadX.c b/src/rtos/ThreadX.c
old mode 100644
new mode 100755
diff --git a/src/rtos/eCos.c b/src/rtos/eCos.c
old mode 100644
new mode 100755
diff --git a/src/rtos/embKernel.c b/src/rtos/embKernel.c
old mode 100644
new mode 100755
diff --git a/src/rtos/linux.c b/src/rtos/linux.c
old mode 100644
new mode 100755
index 9021d8c..b4f887f
--- a/src/rtos/linux.c
+++ b/src/rtos/linux.c
@@ -112,7 +112,7 @@ static int linux_compute_virt2phys(struct target *target, uint32_t address)
 	struct linux_os *linux_os = (struct linux_os *)
 		target->rtos->rtos_specific_params;
 	uint32_t pa = 0;
-	int retval = target->type->virt2phys(target, address, &pa);
+	int retval = target_virt2phys(target, address, &pa);
 	if (retval != ERROR_OK) {
 		LOG_ERROR("Cannot compute linux virt2phys translation");
 		/*  fixes default address  */
diff --git a/src/rtos/linux_header.h b/src/rtos/linux_header.h
old mode 100644
new mode 100755
diff --git a/src/rtos/rtos.c b/src/rtos/rtos.c
old mode 100644
new mode 100755
diff --git a/src/rtos/rtos.h b/src/rtos/rtos.h
old mode 100644
new mode 100755
diff --git a/src/rtos/rtos_chibios_stackings.c b/src/rtos/rtos_chibios_stackings.c
old mode 100644
new mode 100755
diff --git a/src/rtos/rtos_chibios_stackings.h b/src/rtos/rtos_chibios_stackings.h
old mode 100644
new mode 100755
diff --git a/src/rtos/rtos_ecos_stackings.c b/src/rtos/rtos_ecos_stackings.c
old mode 100644
new mode 100755
diff --git a/src/rtos/rtos_ecos_stackings.h b/src/rtos/rtos_ecos_stackings.h
old mode 100644
new mode 100755
diff --git a/src/rtos/rtos_embkernel_stackings.c b/src/rtos/rtos_embkernel_stackings.c
old mode 100644
new mode 100755
diff --git a/src/rtos/rtos_embkernel_stackings.h b/src/rtos/rtos_embkernel_stackings.h
old mode 100644
new mode 100755
diff --git a/src/rtos/rtos_standard_stackings.c b/src/rtos/rtos_standard_stackings.c
old mode 100644
new mode 100755
diff --git a/src/rtos/rtos_standard_stackings.h b/src/rtos/rtos_standard_stackings.h
old mode 100644
new mode 100755
diff --git a/src/server/Makefile.am b/src/server/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
old mode 100644
new mode 100755
index b926be9..abe7039
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -734,22 +734,24 @@ static void gdb_signal_reply(struct target *target, struct connection *connectio
 		stop_reason[0] = '\0';
 		if (target->debug_reason == DBG_REASON_WATCHPOINT) {
 			enum watchpoint_rw hit_wp_type;
-			uint32_t hit_wp_address;
+			struct target_addr tmp_addr;
 
-			if (watchpoint_hit(target, &hit_wp_type, &hit_wp_address) == ERROR_OK) {
+			if (watchpoint64_hit(target, &hit_wp_type, &tmp_addr) == ERROR_OK) {
 
+				const char *cp;
+				cp = target_addr2str1(target, &tmp_addr);
 				switch (hit_wp_type) {
 					case WPT_WRITE:
 						snprintf(stop_reason, sizeof(stop_reason),
-								"watch:%08" PRIx32 ";", hit_wp_address);
+							 "watch:%s;", cp);
 						break;
 					case WPT_READ:
 						snprintf(stop_reason, sizeof(stop_reason),
-								"rwatch:%08" PRIx32 ";", hit_wp_address);
+							 "rwatch:%s;", cp );
 						break;
 					case WPT_ACCESS:
 						snprintf(stop_reason, sizeof(stop_reason),
-								"awatch:%08" PRIx32 ";", hit_wp_address);
+							 "awatch:%s;", cp );
 						break;
 					default:
 						break;
diff --git a/src/server/gdb_server.h b/src/server/gdb_server.h
old mode 100644
new mode 100755
diff --git a/src/server/server.c b/src/server/server.c
old mode 100644
new mode 100755
diff --git a/src/server/server.h b/src/server/server.h
old mode 100644
new mode 100755
diff --git a/src/server/server_stubs.c b/src/server/server_stubs.c
old mode 100644
new mode 100755
diff --git a/src/server/startup.tcl b/src/server/startup.tcl
old mode 100644
new mode 100755
diff --git a/src/server/tcl_server.c b/src/server/tcl_server.c
old mode 100644
new mode 100755
diff --git a/src/server/tcl_server.h b/src/server/tcl_server.h
old mode 100644
new mode 100755
diff --git a/src/server/telnet_server.c b/src/server/telnet_server.c
old mode 100644
new mode 100755
diff --git a/src/server/telnet_server.h b/src/server/telnet_server.h
old mode 100644
new mode 100755
diff --git a/src/svf/Makefile.am b/src/svf/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/svf/svf.c b/src/svf/svf.c
old mode 100644
new mode 100755
diff --git a/src/svf/svf.h b/src/svf/svf.h
old mode 100644
new mode 100755
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
old mode 100644
new mode 100755
index d232e58..97db1f4
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -49,6 +49,7 @@ TARGET_CORE_SRC = \
 	image.c \
 	breakpoints.c \
 	target.c \
+	target32.c \
 	target_request.c \
 	testee.c \
 	smp.c
diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
old mode 100644
new mode 100755
diff --git a/src/target/adi_v5_swd.c b/src/target/adi_v5_swd.c
old mode 100644
new mode 100755
index 11c3883..59f0906
--- a/src/target/adi_v5_swd.c
+++ b/src/target/adi_v5_swd.c
@@ -407,7 +407,7 @@ static int swd_select(struct command_context *ctx)
 
 	if (ctx->current_target) {
 		/* force DAP into SWD mode (not JTAG) */
-		struct target *target = get_current_target(ctx);
+		target = get_current_target(ctx);
 		retval = dap_to_swd(target);
 	}
 
diff --git a/src/target/algorithm.c b/src/target/algorithm.c
old mode 100644
new mode 100755
index aa8262a..f4f879e
--- a/src/target/algorithm.c
+++ b/src/target/algorithm.c
@@ -25,7 +25,7 @@
 #include "algorithm.h"
 #include <helper/binarybuffer.h>
 
-void init_mem_param(struct mem_param *param, uint32_t address, uint32_t size, enum param_direction direction)
+void init_mem_param(struct mem_param *param, uint64_t address, uint64_t size, enum param_direction direction)
 {
 	param->address = address;
 	param->size = size;
diff --git a/src/target/algorithm.h b/src/target/algorithm.h
old mode 100644
new mode 100755
index 2d510db..e087f3d
--- a/src/target/algorithm.h
+++ b/src/target/algorithm.h
@@ -28,8 +28,8 @@ enum param_direction {
 };
 
 struct mem_param {
-	uint32_t address;
-	uint32_t size;
+	uint64_t address;
+	uint64_t size;
 	uint8_t *value;
 	enum param_direction direction;
 };
@@ -42,7 +42,7 @@ struct reg_param {
 };
 
 void init_mem_param(struct mem_param *param,
-		uint32_t address, uint32_t size, enum param_direction dir);
+		uint64_t address, uint64_t size, enum param_direction dir);
 void destroy_mem_param(struct mem_param *param);
 
 void init_reg_param(struct reg_param *param,
diff --git a/src/target/arm.h b/src/target/arm.h
old mode 100644
new mode 100755
diff --git a/src/target/arm11.c b/src/target/arm11.c
old mode 100644
new mode 100755
index 61f1f64..aa5931e
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -461,7 +461,7 @@ static int arm11_resume(struct target *target, int current,
 
 		for (bp = target->breakpoints; bp; bp = bp->next) {
 			if (bp->address == address) {
-				LOG_DEBUG("must step over %08" PRIx32 "", bp->address);
+				LOG_DEBUG("must step over %08" PRIx64 "", bp->address);
 				arm11_step(target, 1, 0, 0);
 				break;
 			}
@@ -487,7 +487,7 @@ static int arm11_resume(struct target *target, int current,
 
 			CHECK_RETVAL(arm11_sc7_run(arm11, brp, ARRAY_SIZE(brp)));
 
-			LOG_DEBUG("Add BP %d at %08" PRIx32, brp_num,
+			LOG_DEBUG("Add BP %d at %08" PRIx64, brp_num,
 				bp->address);
 
 			brp_num++;
@@ -1317,33 +1317,38 @@ static const struct command_registration arm11_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io32 arm11_target32 = {
+	.read_memory = arm11_read_memory,
+	.write_memory = arm11_write_memory,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+	.step = arm11_step,
+	.resume = arm11_resume,
+};
+
 /** Holds methods for ARM11xx targets. */
 struct target_type arm11_target = {
 	.name = "arm11",
 
+	.pIo32_legacy_api = &arm11_target32,
+	
 	.poll = arm11_poll,
 	.arch_state = arm11_arch_state,
 
 	.halt = arm11_halt,
-	.resume = arm11_resume,
-	.step = arm11_step,
 
 	.assert_reset = arm11_assert_reset,
 	.deassert_reset = arm11_deassert_reset,
 
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
-	.read_memory = arm11_read_memory,
-	.write_memory = arm11_write_memory,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
 
 	.add_breakpoint = arm11_add_breakpoint,
 	.remove_breakpoint = arm11_remove_breakpoint,
 
-	.run_algorithm = armv4_5_run_algorithm,
-
 	.commands = arm11_command_handlers,
 	.target_create = arm11_target_create,
 	.init_target = arm11_init_target,
diff --git a/src/target/arm11.h b/src/target/arm11.h
old mode 100644
new mode 100755
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
old mode 100644
new mode 100755
diff --git a/src/target/arm11_dbgtap.h b/src/target/arm11_dbgtap.h
old mode 100644
new mode 100755
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
old mode 100644
new mode 100755
index 619c80a..facdae9
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -547,16 +547,32 @@ static const struct command_registration arm720t_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io32 arm720t_target32 = {
+	.read_memory = arm720t_read_memory,
+	.write_memory = arm7_9_write_memory_opt,
+	.read_phys_memory = arm720t_read_phys_memory,
+	.write_phys_memory = arm720t_write_phys_memory,
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+	.virt2phys = arm720_virt2phys,
+	.resume = arm7_9_resume,
+	.step = arm7_9_step,
+};
+
+
 /** Holds methods for ARM720 targets. */
 struct target_type arm720t_target = {
 	.name = "arm720t",
 
+
+	.pIo32_legacy_api = &arm720t_target32,
+	
 	.poll = arm7_9_poll,
 	.arch_state = arm720t_arch_state,
 
 	.halt = arm7_9_halt,
-	.resume = arm7_9_resume,
-	.step = arm7_9_step,
 
 	.assert_reset = arm7_9_assert_reset,
 	.deassert_reset = arm7_9_deassert_reset,
@@ -564,17 +580,7 @@ struct target_type arm720t_target = {
 
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
-	.read_memory = arm720t_read_memory,
-	.write_memory = arm7_9_write_memory_opt,
-	.read_phys_memory = arm720t_read_phys_memory,
-	.write_phys_memory = arm720t_write_phys_memory,
 	.mmu = arm720_mmu,
-	.virt2phys = arm720_virt2phys,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
 
 	.add_breakpoint = arm7_9_add_breakpoint,
 	.remove_breakpoint = arm7_9_remove_breakpoint,
diff --git a/src/target/arm720t.h b/src/target/arm720t.h
old mode 100644
new mode 100755
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
old mode 100644
new mode 100755
index 7f0e3ad..2cc683b
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -103,7 +103,7 @@ static void arm7_9_assign_wp(struct arm7_9_common *arm7_9, struct breakpoint *br
 		arm7_9->wp_available--;
 	} else
 		LOG_ERROR("BUG: no hardware comparator available");
-	LOG_DEBUG("BPID: %" PRId32 " (0x%08" PRIx32 ") using hw wp: %d",
+	LOG_DEBUG("BPID: %" PRId32 " (0x%08" PRIx64 ") using hw wp: %d",
 			breakpoint->unique_id,
 			breakpoint->address,
 			breakpoint->set);
@@ -189,7 +189,7 @@ static int arm7_9_set_breakpoint(struct target *target, struct breakpoint *break
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 	int retval = ERROR_OK;
 
-	LOG_DEBUG("BPID: %" PRId32 ", Address: 0x%08" PRIx32 ", Type: %d",
+	LOG_DEBUG("BPID: %" PRId32 ", Address: 0x%08" PRIx64 ", Type: %d",
 		breakpoint->unique_id,
 		breakpoint->address,
 		breakpoint->type);
@@ -246,7 +246,7 @@ static int arm7_9_set_breakpoint(struct target *target, struct breakpoint *break
 			if (retval != ERROR_OK)
 				return retval;
 			if (verify != arm7_9->arm_bkpt) {
-				LOG_ERROR("Unable to set 32 bit software breakpoint at address %08" PRIx32
+				LOG_ERROR("Unable to set 32 bit software breakpoint at address %08" PRIx64
 						" - check that memory is read/writable", breakpoint->address);
 				return ERROR_OK;
 			}
@@ -266,7 +266,7 @@ static int arm7_9_set_breakpoint(struct target *target, struct breakpoint *break
 			if (retval != ERROR_OK)
 				return retval;
 			if (verify != arm7_9->thumb_bkpt) {
-				LOG_ERROR("Unable to set thumb software breakpoint at address %08" PRIx32
+				LOG_ERROR("Unable to set thumb software breakpoint at address %08" PRIx64
 						" - check that memory is read/writable", breakpoint->address);
 				return ERROR_OK;
 			}
@@ -301,7 +301,7 @@ static int arm7_9_unset_breakpoint(struct target *target, struct breakpoint *bre
 	int retval = ERROR_OK;
 	struct arm7_9_common *arm7_9 = target_to_arm7_9(target);
 
-	LOG_DEBUG("BPID: %" PRId32 ", Address: 0x%08" PRIx32,
+	LOG_DEBUG("BPID: %" PRId32 ", Address: 0x%08" PRIx64,
 		breakpoint->unique_id,
 		breakpoint->address);
 
@@ -1719,7 +1719,7 @@ int arm7_9_resume(struct target *target,
 		breakpoint = breakpoint_find(target,
 				buf_get_u32(arm->pc->value, 0, 32));
 		if (breakpoint != NULL) {
-			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 " (id: %" PRId32,
+			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx64 " (id: %" PRId32,
 				breakpoint->address,
 				breakpoint->unique_id);
 			retval = arm7_9_unset_breakpoint(target, breakpoint);
@@ -1778,7 +1778,7 @@ int arm7_9_resume(struct target *target,
 			LOG_DEBUG("new PC after step: 0x%8.8" PRIx32,
 				buf_get_u32(arm->pc->value, 0, 32));
 
-			LOG_DEBUG("set breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
+			LOG_DEBUG("set breakpoint at 0x%8.8" PRIx64 "", breakpoint->address);
 			retval = arm7_9_set_breakpoint(target, breakpoint);
 			if (retval != ERROR_OK)
 				return retval;
diff --git a/src/target/arm7_9_common.h b/src/target/arm7_9_common.h
old mode 100644
new mode 100755
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
old mode 100644
new mode 100755
index 807efad..5c58805
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -683,18 +683,31 @@ static int arm7tdmi_target_create(struct target *target, Jim_Interp *interp)
 	return ERROR_OK;
 }
 
+static struct target_io32 arm7tdmi_target32 = {
+	.read_memory = arm7_9_read_memory,
+	.write_memory = arm7_9_write_memory_opt,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+	.resume = arm7_9_resume,
+	.step = arm7_9_step,
+};
+
+
 /** Holds methods for ARM7TDMI targets. */
 struct target_type arm7tdmi_target = {
 	.name = "arm7tdmi",
 
+	.pIo32_legacy_api = &arm7tdmi_target32,
+	
 	.poll = arm7_9_poll,
 	.arch_state = arm_arch_state,
 
 	.target_request_data = arm7_9_target_request_data,
 
 	.halt = arm7_9_halt,
-	.resume = arm7_9_resume,
-	.step = arm7_9_step,
 
 	.assert_reset = arm7_9_assert_reset,
 	.deassert_reset = arm7_9_deassert_reset,
@@ -702,13 +715,6 @@ struct target_type arm7tdmi_target = {
 
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
-	.read_memory = arm7_9_read_memory,
-	.write_memory = arm7_9_write_memory_opt,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
 
 	.add_breakpoint = arm7_9_add_breakpoint,
 	.remove_breakpoint = arm7_9_remove_breakpoint,
diff --git a/src/target/arm7tdmi.h b/src/target/arm7tdmi.h
old mode 100644
new mode 100755
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
old mode 100644
new mode 100755
index f6a0f5b..acdaa11
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -1678,36 +1678,43 @@ const struct command_registration arm920t_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io32 arm920t_target32 = {
+  
+	.read_memory = arm920t_read_memory,
+	.write_memory = arm7_9_write_memory_opt,
+	.read_phys_memory = arm920t_read_phys_memory,
+	.write_phys_memory = arm920t_write_phys_memory,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+	.resume = arm7_9_resume,
+	.step = arm7_9_step,
+	.virt2phys = arm920_virt2phys,
+};
+
+
 /** Holds methods for ARM920 targets. */
 struct target_type arm920t_target = {
 	.name = "arm920t",
 
+	.pIo32_legacy_api = &arm920t_target32,
+
 	.poll = arm7_9_poll,
 	.arch_state = arm920t_arch_state,
 
 	.target_request_data = arm7_9_target_request_data,
 
 	.halt = arm7_9_halt,
-	.resume = arm7_9_resume,
-	.step = arm7_9_step,
 
 	.assert_reset = arm7_9_assert_reset,
 	.deassert_reset = arm7_9_deassert_reset,
 	.soft_reset_halt = arm920t_soft_reset_halt,
 
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
-
-	.read_memory = arm920t_read_memory,
-	.write_memory = arm7_9_write_memory_opt,
-	.read_phys_memory = arm920t_read_phys_memory,
-	.write_phys_memory = arm920t_write_phys_memory,
 	.mmu = arm920_mmu,
-	.virt2phys = arm920_virt2phys,
 
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
 
 	.add_breakpoint = arm7_9_add_breakpoint,
 	.remove_breakpoint = arm7_9_remove_breakpoint,
diff --git a/src/target/arm920t.h b/src/target/arm920t.h
old mode 100644
new mode 100755
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
old mode 100644
new mode 100755
index 4e77ff2..daad5b7
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -626,7 +626,7 @@ int arm926ejs_write_memory(struct target *target, uint32_t address,
 		}
 
 		uint32_t pa;
-		retval = target->type->virt2phys(target, address, &pa);
+		retval = target_virt2phys(target, address, &pa);
 		if (retval != ERROR_OK)
 			return retval;
 
@@ -789,18 +789,33 @@ const struct command_registration arm926ejs_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io32 arm926ejs_target32 = {
+	.read_memory = arm7_9_read_memory,
+	.write_memory = arm7_9_write_memory_opt,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+	.resume = arm7_9_resume,
+	.run_algorithm = armv4_5_run_algorithm,
+	.read_phys_memory = arm926ejs_read_phys_memory,
+	.write_phys_memory = arm926ejs_write_phys_memory,
+	.step = arm7_9_step,
+	.virt2phys = arm926ejs_virt2phys,
+};
+
 /** Holds methods for ARM926 targets. */
 struct target_type arm926ejs_target = {
 	.name = "arm926ejs",
 
+	.pIo32_legacy_api = &arm926ejs_target32,
+
 	.poll = arm7_9_poll,
 	.arch_state = arm926ejs_arch_state,
 
 	.target_request_data = arm7_9_target_request_data,
 
 	.halt = arm7_9_halt,
-	.resume = arm7_9_resume,
-	.step = arm7_9_step,
+
 
 	.assert_reset = arm7_9_assert_reset,
 	.deassert_reset = arm7_9_deassert_reset,
@@ -808,14 +823,6 @@ struct target_type arm926ejs_target = {
 
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
-	.read_memory = arm7_9_read_memory,
-	.write_memory = arm7_9_write_memory_opt,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
-
 	.add_breakpoint = arm7_9_add_breakpoint,
 	.remove_breakpoint = arm7_9_remove_breakpoint,
 	.add_watchpoint = arm7_9_add_watchpoint,
@@ -826,9 +833,6 @@ struct target_type arm926ejs_target = {
 	.init_target = arm9tdmi_init_target,
 	.examine = arm7_9_examine,
 	.check_reset = arm7_9_check_reset,
-	.virt2phys = arm926ejs_virt2phys,
 	.mmu = arm926ejs_mmu,
 
-	.read_phys_memory = arm926ejs_read_phys_memory,
-	.write_phys_memory = arm926ejs_write_phys_memory,
 };
diff --git a/src/target/arm926ejs.h b/src/target/arm926ejs.h
old mode 100644
new mode 100755
diff --git a/src/target/arm946e.c b/src/target/arm946e.c
old mode 100644
new mode 100755
index fb50d69..e387732
--- a/src/target/arm946e.c
+++ b/src/target/arm946e.c
@@ -741,18 +741,34 @@ const struct command_registration arm946e_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io32 arm946t_target32 = {
+  
+	/* .read_memory = arm7_9_read_memory, */
+	/* .write_memory = arm7_9_write_memory, */
+	.read_memory = arm946e_read_memory,
+	.write_memory = arm946e_write_memory,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+	.resume = arm7_9_resume,
+	.step = arm7_9_step,
+
+};
+
 /** Holds methods for ARM946 targets. */
 struct target_type arm946e_target = {
 	.name = "arm946e",
 
+	.pIo32_legacy_api = &arm946t_target32,
+	
 	.poll = arm7_9_poll,
 	.arch_state = arm_arch_state,
 
 	.target_request_data = arm7_9_target_request_data,
 
 	.halt = arm7_9_halt,
-	.resume = arm7_9_resume,
-	.step = arm7_9_step,
 
 	.assert_reset = arm7_9_assert_reset,
 	.deassert_reset = arm7_9_deassert_reset,
@@ -760,15 +776,6 @@ struct target_type arm946e_target = {
 
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
-	/* .read_memory = arm7_9_read_memory, */
-	/* .write_memory = arm7_9_write_memory, */
-	.read_memory = arm946e_read_memory,
-	.write_memory = arm946e_write_memory,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
 
 	.add_breakpoint = arm7_9_add_breakpoint,
 	.remove_breakpoint = arm7_9_remove_breakpoint,
diff --git a/src/target/arm946e.h b/src/target/arm946e.h
old mode 100644
new mode 100755
diff --git a/src/target/arm966e.c b/src/target/arm966e.c
old mode 100644
new mode 100755
index 6a96ab1..cbee69b
--- a/src/target/arm966e.c
+++ b/src/target/arm966e.c
@@ -244,18 +244,31 @@ const struct command_registration arm966e_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io32 arm966t_target32 = {
+
+	.read_memory = arm7_9_read_memory,
+	.write_memory = arm7_9_write_memory_opt,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+	.resume = arm7_9_resume,
+	.step = arm7_9_step,
+};
+  
 /** Holds methods for ARM966 targets. */
 struct target_type arm966e_target = {
 	.name = "arm966e",
 
+	.pIo32_legacy_api = &arm966t_target32,
+	
 	.poll = arm7_9_poll,
 	.arch_state = arm_arch_state,
 
 	.target_request_data = arm7_9_target_request_data,
 
 	.halt = arm7_9_halt,
-	.resume = arm7_9_resume,
-	.step = arm7_9_step,
 
 	.assert_reset = arm7_9_assert_reset,
 	.deassert_reset = arm7_9_deassert_reset,
@@ -263,14 +276,6 @@ struct target_type arm966e_target = {
 
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
-	.read_memory = arm7_9_read_memory,
-	.write_memory = arm7_9_write_memory_opt,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
-
 	.add_breakpoint = arm7_9_add_breakpoint,
 	.remove_breakpoint = arm7_9_remove_breakpoint,
 	.add_watchpoint = arm7_9_add_watchpoint,
diff --git a/src/target/arm966e.h b/src/target/arm966e.h
old mode 100644
new mode 100755
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
old mode 100644
new mode 100755
index ac07534..0f8f1d0
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -885,18 +885,30 @@ const struct command_registration arm9tdmi_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io32 arm9tdmi_target32 = {
+	.read_memory = arm7_9_read_memory,
+	.write_memory = arm7_9_write_memory_opt,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+	.resume = arm7_9_resume,
+	.step = arm7_9_step,
+};
+
 /** Holds methods for ARM9TDMI targets. */
 struct target_type arm9tdmi_target = {
 	.name = "arm9tdmi",
 
+	.pIo32_legacy_api = &arm9tdmi_target32,
+	
 	.poll = arm7_9_poll,
 	.arch_state = arm_arch_state,
 
 	.target_request_data = arm7_9_target_request_data,
 
 	.halt = arm7_9_halt,
-	.resume = arm7_9_resume,
-	.step = arm7_9_step,
 
 	.assert_reset = arm7_9_assert_reset,
 	.deassert_reset = arm7_9_deassert_reset,
@@ -904,13 +916,6 @@ struct target_type arm9tdmi_target = {
 
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
-	.read_memory = arm7_9_read_memory,
-	.write_memory = arm7_9_write_memory_opt,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
 
 	.add_breakpoint = arm7_9_add_breakpoint,
 	.remove_breakpoint = arm7_9_remove_breakpoint,
diff --git a/src/target/arm9tdmi.h b/src/target/arm9tdmi.h
old mode 100644
new mode 100755
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
old mode 100644
new mode 100755
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
old mode 100644
new mode 100755
diff --git a/src/target/arm_disassembler.c b/src/target/arm_disassembler.c
old mode 100644
new mode 100755
diff --git a/src/target/arm_disassembler.h b/src/target/arm_disassembler.h
old mode 100644
new mode 100755
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
old mode 100644
new mode 100755
diff --git a/src/target/arm_dpm.h b/src/target/arm_dpm.h
old mode 100644
new mode 100755
diff --git a/src/target/arm_jtag.c b/src/target/arm_jtag.c
old mode 100644
new mode 100755
diff --git a/src/target/arm_jtag.h b/src/target/arm_jtag.h
old mode 100644
new mode 100755
diff --git a/src/target/arm_opcodes.h b/src/target/arm_opcodes.h
old mode 100644
new mode 100755
diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
old mode 100644
new mode 100755
diff --git a/src/target/arm_semihosting.h b/src/target/arm_semihosting.h
old mode 100644
new mode 100755
diff --git a/src/target/arm_simulator.c b/src/target/arm_simulator.c
old mode 100644
new mode 100755
diff --git a/src/target/arm_simulator.h b/src/target/arm_simulator.h
old mode 100644
new mode 100755
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
old mode 100644
new mode 100755
diff --git a/src/target/armv4_5.h b/src/target/armv4_5.h
old mode 100644
new mode 100755
diff --git a/src/target/armv4_5_cache.c b/src/target/armv4_5_cache.c
old mode 100644
new mode 100755
diff --git a/src/target/armv4_5_cache.h b/src/target/armv4_5_cache.h
old mode 100644
new mode 100755
diff --git a/src/target/armv4_5_mmu.c b/src/target/armv4_5_mmu.c
old mode 100644
new mode 100755
diff --git a/src/target/armv4_5_mmu.h b/src/target/armv4_5_mmu.h
old mode 100644
new mode 100755
diff --git a/src/target/armv7a.c b/src/target/armv7a.c
old mode 100644
new mode 100755
index bf474d3..e009f8d
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -413,7 +413,7 @@ static int armv7a_l2x_flush_all_data(struct target *target)
 	retval = armv7a_flush_all_data(target);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = target->type->write_phys_memory(target,
+	retval = target_write_phys_memory(target,
 			(uint32_t)(base+(uint32_t)L2X0_CLEAN_INV_WAY),
 			(uint32_t)4,
 			(uint32_t)1,
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
old mode 100644
new mode 100755
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
old mode 100644
new mode 100755
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
old mode 100644
new mode 100755
diff --git a/src/target/armv8.c b/src/target/armv8.c
index f65f997..cc74e2b 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -954,7 +954,7 @@ static int jim_modeswitch(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 	value = l;
 
 	retval = armv8->modeswitch(target, value);
-
+
 	if (retval != ERROR_OK)
 		return JIM_ERR;
 
@@ -992,7 +992,7 @@ static int jim_drps(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 	struct armv8 *armv8 = &armv8_common->armv8;
 
 	retval = armv8->drps(target);
-
+
 	if (retval != ERROR_OK)
 		return JIM_ERR;
 
@@ -1135,7 +1135,7 @@ static int jim_msrmrs(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 		/* NOTE: parameters reordered! */
 		/* ARMV4_5_MRC(cpnum, op1, 0, CRn, CRm, op2) */
 		retval = armv8->mrs(target, op0, op1, CRn, CRm, op2, Rt, &value);
-
+
 		if (retval != ERROR_OK)
 				return JIM_ERR;
 
@@ -1145,24 +1145,25 @@ static int jim_msrmrs(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 	return JIM_OK;
 }
 
-static int armv8_setup_semihosting(struct target *target, uint32_t value)
+static int armv8_setup_semihosting(struct target *target, const struct target_addr *pValue)
 {
 	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
 	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
 	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
 	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
-	int retval = ERROR_OK;
+	int retval = ERROR_OK;
 
 	// set semihosting skip enable
 	target->is_semihostskip = true;
-	target->codebase = value;
-
+	target->codebase = pValue->addr;
+
 	return retval;
 }
 
 COMMAND_HANDLER(handle_arm_semihosting_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
+	struct target_addr addr;
 
 	if (target == NULL) {
 		LOG_ERROR("No target selected");
@@ -1176,12 +1177,12 @@ COMMAND_HANDLER(handle_arm_semihosting_command)
 		return ERROR_FAIL;
 	}
 
-	uint32_t address;
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+	TARGET_ADDR_INIT( &addr,0 );
+	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], addr.addr );
 
-    armv8_setup_semihosting(target, address);
+	armv8_setup_semihosting(target, &addr);
 
-	command_print(CMD_CTX, "semihosting code baseaddress is 0x%x", address);
+	command_print(CMD_CTX, "semihosting code baseaddress is 0x%s", target_addr2str1(target,&addr));
 
 	return ERROR_OK;
 }
@@ -1244,7 +1245,7 @@ int armv8_get_gdb_reg_list(struct target *target,
 	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
 	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a);
 	struct armv8 *armv8 = &armv8_common->armv8;
-	unsigned int i;
+	int i;
 
 	if(!target->is_64b) return arm_get_gdb_reg_list(target, reg_list, reg_list_size, reg_class);
 	if (!is_aarch64_mode(armv8->arm->core_mode)) {
@@ -1753,93 +1754,93 @@ int arm_init_arch_info(struct target *target, struct arm *arm)
 }
 #endif
 
-/*
- * Coprocessor support
- */
-
-/* Read coprocessor */
-static int armv8_mrs(struct target *target,
-	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
-	uint32_t *value)
-{
+/*
+ * Coprocessor support
+ */
+
+/* Read coprocessor */
+static int armv8_mrs(struct target *target,
+	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
+	uint32_t *value)
+{
 	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
 	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
 	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
 	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
-	int retval;
-	uint32_t v32;
-
-	retval = dpm->prepare(dpm);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* read coprocessor register into R0; return via DCC */
+	int retval;
+	uint32_t v32;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* read coprocessor register into R0; return via DCC */
 	retval = armv8_dpm->instr_read_data64_r0_msr(dpm, ARMV8_A64_MRS(op0, op1, CRn, CRm, op2, Rt), &v32);
-
-	/* (void) */ dpm->finish(dpm);
-	return retval;
-}
-
-static int armv8_msr(struct target *target,
-	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
-	uint32_t value)
-{
+
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+static int armv8_msr(struct target *target,
+	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
+	uint32_t value)
+{
 	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
 	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
 	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
 	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
-	int retval;
-
-	retval = dpm->prepare(dpm);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* read DCC into r0; then write coprocessor register from R0 */
+	int retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
+	/* read DCC into r0; then write coprocessor register from R0 */
 	retval = armv8_dpm->instr_write_data64_r0_mrs(dpm, ARMV8_A64_MSR(op0, op1, CRn, CRm, op2, Rt), value);
 
-	retval =
-	/* (void) */ dpm->finish(dpm);
-	return retval;
-}
+	retval =
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
 
-static int armv8_drps(struct target *target,
-	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
-	uint32_t value)
-{
+static int armv8_drps(struct target *target,
+	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
+	uint32_t value)
+{
 	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
 	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
 	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
 	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
-	int retval;
-
-	retval = dpm->prepare(dpm);
-	if (retval != ERROR_OK)
-		return retval;
-
+	int retval;
+
+	retval = dpm->prepare(dpm);
+	if (retval != ERROR_OK)
+		return retval;
+
 	retval = armv8_dpm->instr_execution(dpm, 0xD6BF03E0, value);//SP_EL0
 
 	// todo: change the target is_64b flag, should based on current dscr.
 	target->is_64b = false;
 	target->state = TARGET_RUNNING;
-
-	/* (void) */ dpm->finish(dpm);
-	return retval;
-}
 
-static int armv8_modeswitch(struct target *target, uint32_t value)
-{
+	/* (void) */ dpm->finish(dpm);
+	return retval;
+}
+
+static int armv8_modeswitch(struct target *target, uint64_t value)
+{
 	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
 	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
 	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
 	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
-	int retval = ERROR_OK;
+	int retval = ERROR_OK;
 
 	// set modeswitch and asic rom base
 	target->mode_switch = true;
 	target->romcbase = value;
-
-	return retval;
-}
+
+	return retval;
+}
 
 
 int armv8_init_arch_info(struct target *target)
diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index b73beb6..3040aa0 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -471,7 +471,7 @@ done:
  */
 
 static int dpm_bpwp_setup(struct arm_dpm *dpm, struct dpm_bpwp *xp,
-	uint32_t addr, uint32_t length)
+	uint64_t addr, uint32_t length)
 {
 	uint32_t control;
 
@@ -520,8 +520,8 @@ static int dpm_bpwp_setup(struct arm_dpm *dpm, struct dpm_bpwp *xp,
 	xp->control = control;
 	xp->dirty = true;
 
-	LOG_DEBUG("BPWP: addr %8.8" PRIx32 ", control %" PRIx32 ", number %d",
-		xp->address, control, xp->number);
+	LOG_DEBUG("BPWP: addr %s, control %" PRIx32 ", number %d",
+		  target_addr64str1(dpm->arm->target,xp->address), control, xp->number);
 
 	/* hardware is updated in write_dirty_registers() */
 	return ERROR_OK;
@@ -649,7 +649,7 @@ static int dpm_remove_watchpoint(struct target *target, struct watchpoint *wp)
 	return retval;
 }
 
-void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr)
+void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint64_t addr)
 {
 	switch (dpm->arm->core_state) {
 		case ARM_STATE_ARM:
diff --git a/src/target/armv8_dpm.h b/src/target/armv8_dpm.h
index 2109d3e..ab1330d 100755
--- a/src/target/armv8_dpm.h
+++ b/src/target/armv8_dpm.h
@@ -120,7 +120,7 @@ int armv8_get_gdb_reg_list(struct target *target,
 		enum target_register_class reg_class);
 int armv8_dpm_read_current_registers(struct armv8_dpm *armv8_dpm);
 int armv8_dpm_write_dirty_registers(struct armv8_dpm *armv8_dpm, bool bpwp);
-void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr);
+void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint64_t addr);
 void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr);
 int armv8_dpm_setup(struct armv8_dpm * armv8_dpm);
 int armv8_dpm_initialize(struct armv8_dpm * armv8_dpm);
diff --git a/src/target/avr32_ap7k.c b/src/target/avr32_ap7k.c
old mode 100644
new mode 100755
index 55d1efb..7a2877f
--- a/src/target/avr32_ap7k.c
+++ b/src/target/avr32_ap7k.c
@@ -350,7 +350,7 @@ static int avr32_ap7k_resume(struct target *target, int current,
 		/* Single step past breakpoint at current address */
 		breakpoint = breakpoint_find(target, resume_pc);
 		if (breakpoint) {
-			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
+			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx64 "", breakpoint->address);
 #if 0
 			avr32_ap7k_unset_breakpoint(target, breakpoint);
 			avr32_ap7k_single_step_core(target);
@@ -593,28 +593,32 @@ int avr32_ap7k_get_gdb_reg_list(struct target *target, struct reg **reg_list[],
 	return ERROR_FAIL;
 }
 
+static struct target_io32 avr32_target32 = {
+	.read_memory = avr32_ap7k_read_memory,
+	.write_memory = avr32_ap7k_write_memory,
+	/* .checksum_memory = avr32_ap7k_checksum_memory, */
+	/* .blank_check_memory = avr32_ap7k_blank_check_memory, */
+
+	/* .run_algorithm = avr32_ap7k_run_algorithm, */
+	.resume = avr32_ap7k_resume,
+	.step = avr32_ap7k_step,
+};
+
 struct target_type avr32_ap7k_target = {
 	.name = "avr32_ap7k",
 
+	.pIo32_legacy_api = &avr32_target32,
+	
 	.poll = avr32_ap7k_poll,
 	.arch_state = avr32_ap7k_arch_state,
 
 	.halt = avr32_ap7k_halt,
-	.resume = avr32_ap7k_resume,
-	.step = avr32_ap7k_step,
 
 	.assert_reset = avr32_ap7k_assert_reset,
 	.deassert_reset = avr32_ap7k_deassert_reset,
 
 	.get_gdb_reg_list = avr32_ap7k_get_gdb_reg_list,
 
-	.read_memory = avr32_ap7k_read_memory,
-	.write_memory = avr32_ap7k_write_memory,
-	/* .checksum_memory = avr32_ap7k_checksum_memory, */
-	/* .blank_check_memory = avr32_ap7k_blank_check_memory, */
-
-	/* .run_algorithm = avr32_ap7k_run_algorithm, */
-
 	.add_breakpoint = avr32_ap7k_add_breakpoint,
 	.remove_breakpoint = avr32_ap7k_remove_breakpoint,
 	.add_watchpoint = avr32_ap7k_add_watchpoint,
diff --git a/src/target/avr32_ap7k.h b/src/target/avr32_ap7k.h
old mode 100644
new mode 100755
diff --git a/src/target/avr32_jtag.c b/src/target/avr32_jtag.c
old mode 100644
new mode 100755
diff --git a/src/target/avr32_jtag.h b/src/target/avr32_jtag.h
old mode 100644
new mode 100755
diff --git a/src/target/avr32_mem.c b/src/target/avr32_mem.c
old mode 100644
new mode 100755
diff --git a/src/target/avr32_mem.h b/src/target/avr32_mem.h
old mode 100644
new mode 100755
diff --git a/src/target/avr32_regs.c b/src/target/avr32_regs.c
old mode 100644
new mode 100755
diff --git a/src/target/avr32_regs.h b/src/target/avr32_regs.h
old mode 100644
new mode 100755
diff --git a/src/target/avrt.c b/src/target/avrt.c
old mode 100644
new mode 100755
index a4ce46b..a18efac
--- a/src/target/avrt.c
+++ b/src/target/avrt.c
@@ -49,29 +49,39 @@ static int mcu_write_dr(struct jtag_tap *tap, uint8_t *dr_in, uint8_t *dr_out, i
 static int mcu_write_ir_u8(struct jtag_tap *tap, uint8_t *ir_in, uint8_t ir_out, int ir_len, int rti);
 static int mcu_write_dr_u32(struct jtag_tap *tap, uint32_t *ir_in, uint32_t ir_out, int dr_len, int rti);
 
+
+static struct target_io32 avr_target32 = {
+
+  /*
+    // no idea why this was commented out in orginal..
+    // So I moved, and left as commented out here
+    //                          
+	.read_memory = avr_read_memory,
+	.write_memory = avr_write_memory,
+	.bulk_write_memory = avr_bulk_write_memory,
+	.checksum_memory = avr_checksum_memory,
+	.blank_check_memory = avr_blank_check_memory,
+	.run_algorithm = avr_run_algorithm,
+  */
+	.resume = avr_resume,
+	.step = avr_step,
+};
+  
 struct target_type avr_target = {
 	.name = "avr",
 
+	.pIo32_legacy_api = &avr_target32,
+	
 	.poll = avr_poll,
 	.arch_state = avr_arch_state,
 
 	.halt = avr_halt,
-	.resume = avr_resume,
-	.step = avr_step,
 
 	.assert_reset = avr_assert_reset,
 	.deassert_reset = avr_deassert_reset,
 /*
 	.get_gdb_reg_list = avr_get_gdb_reg_list,
 
-	.read_memory = avr_read_memory,
-	.write_memory = avr_write_memory,
-	.bulk_write_memory = avr_bulk_write_memory,
-	.checksum_memory = avr_checksum_memory,
-	.blank_check_memory = avr_blank_check_memory,
-
-	.run_algorithm = avr_run_algorithm,
-
 	.add_breakpoint = avr_add_breakpoint,
 	.remove_breakpoint = avr_remove_breakpoint,
 	.add_watchpoint = avr_add_watchpoint,
diff --git a/src/target/avrt.h b/src/target/avrt.h
old mode 100644
new mode 100755
diff --git a/src/target/breakpoints.c b/src/target/breakpoints.c
old mode 100644
new mode 100755
index b854f1f..02ea0b9
--- a/src/target/breakpoints.c
+++ b/src/target/breakpoints.c
@@ -43,9 +43,9 @@ static const char * const watchpoint_rw_strings[] = {
 /* monotonic counter/id-number for breakpoints and watch points */
 static int bpwp_unique_id;
 
-int breakpoint_add_internal(struct target *target,
-	uint32_t address,
-	uint32_t length,
+static int breakpoint64_add_internal(struct target *target,
+	const struct target_addr *pAddr,
+	uint64_t length,
 	enum breakpoint_type type)
 {
 	struct breakpoint *breakpoint = target->breakpoints;
@@ -57,13 +57,13 @@ int breakpoint_add_internal(struct target *target,
 	n = 0;
 	while (breakpoint) {
 		n++;
-		if (breakpoint->address == address) {
+		if (breakpoint->address == pAddr->addr) {
 			/* FIXME don't assume "same address" means "same
 			 * breakpoint" ... check all the parameters before
 			 * succeeding.
 			 */
-			LOG_DEBUG("Duplicate Breakpoint address: 0x%08" PRIx32 " (BP %" PRIu32 ")",
-				address, breakpoint->unique_id);
+			LOG_DEBUG("Duplicate Breakpoint address: 0x%s (BP %" PRIu32 ")",
+				  target_addr2str1( target, pAddr), breakpoint->unique_id);
 			return ERROR_OK;
 		}
 		breakpoint_p = &breakpoint->next;
@@ -71,7 +71,7 @@ int breakpoint_add_internal(struct target *target,
 	}
 
 	(*breakpoint_p) = malloc(sizeof(struct breakpoint));
-	(*breakpoint_p)->address = address;
+	(*breakpoint_p)->address = pAddr->addr;
 	(*breakpoint_p)->asid = 0;
 	(*breakpoint_p)->length = length;
 	(*breakpoint_p)->type = type;
@@ -100,17 +100,18 @@ fail:
 			return retval;
 	}
 
-	LOG_DEBUG("added %s breakpoint at 0x%8.8" PRIx32 " of length 0x%8.8x, (BPID: %" PRIu32 ")",
-		breakpoint_type_strings[(*breakpoint_p)->type],
-		(*breakpoint_p)->address, (*breakpoint_p)->length,
-		(*breakpoint_p)->unique_id);
+	LOG_DEBUG("added %s breakpoint at %s of length %d, (BPID: %" PRIu32 ")",
+		  breakpoint_type_strings[(*breakpoint_p)->type],
+		  target_addr64str1( target, (*breakpoint_p)->address),
+		  (*breakpoint_p)->length,
+		  (*breakpoint_p)->unique_id);
 
 	return ERROR_OK;
 }
 
-int context_breakpoint_add_internal(struct target *target,
+static int contextXX_breakpoint_add_internal(struct target *target,
 	uint32_t asid,
-	uint32_t length,
+	uint64_t length,
 	enum breakpoint_type type)
 {
 	struct breakpoint *breakpoint = target->breakpoints;
@@ -160,10 +161,10 @@ int context_breakpoint_add_internal(struct target *target,
 	return ERROR_OK;
 }
 
-int hybrid_breakpoint_add_internal(struct target *target,
-	uint32_t address,
+static int hybridXX_breakpoint_add_internal(struct target *target,
+	const struct target_addr *pAddr,
 	uint32_t asid,
-	uint32_t length,
+	uint64_t length,
 	enum breakpoint_type type)
 {
 	struct breakpoint *breakpoint = target->breakpoints;
@@ -173,7 +174,7 @@ int hybrid_breakpoint_add_internal(struct target *target,
 	n = 0;
 	while (breakpoint) {
 		n++;
-		if ((breakpoint->asid == asid) && (breakpoint->address == address)) {
+		if ((breakpoint->asid == asid) && (breakpoint->address == pAddr->addr)) {
 			/* FIXME don't assume "same address" means "same
 			 * breakpoint" ... check all the parameters before
 			 * succeeding.
@@ -181,9 +182,9 @@ int hybrid_breakpoint_add_internal(struct target *target,
 			LOG_DEBUG("Duplicate Hybrid Breakpoint asid: 0x%08" PRIx32 " (BP %" PRIu32 ")",
 				asid, breakpoint->unique_id);
 			return -1;
-		} else if ((breakpoint->address == address) && (breakpoint->asid == 0)) {
-			LOG_DEBUG("Duplicate Breakpoint IVA: 0x%08" PRIx32 " (BP %" PRIu32 ")",
-				address, breakpoint->unique_id);
+		} else if ((breakpoint->address == pAddr->addr) && (breakpoint->asid == 0)) {
+			LOG_DEBUG("Duplicate Breakpoint IVA: 0x%s (BP %" PRIu32 ")",
+				  target_addr2str1( target, pAddr), breakpoint->unique_id);
 			return -1;
 
 		}
@@ -191,7 +192,7 @@ int hybrid_breakpoint_add_internal(struct target *target,
 		breakpoint = breakpoint->next;
 	}
 	(*breakpoint_p) = malloc(sizeof(struct breakpoint));
-	(*breakpoint_p)->address = address;
+	(*breakpoint_p)->address = pAddr->addr;
 	(*breakpoint_p)->asid = asid;
 	(*breakpoint_p)->length = length;
 	(*breakpoint_p)->type = type;
@@ -210,18 +211,18 @@ int hybrid_breakpoint_add_internal(struct target *target,
 		return retval;
 	}
 	LOG_DEBUG(
-		"added %s Hybrid breakpoint at address 0x%8.8" PRIx32 " of length 0x%8.8x, (BPID: %" PRIu32 ")",
+		"added %s Hybrid breakpoint at address %s of length 0x%8.8x, (BPID: %" PRIu32 ")",
 		breakpoint_type_strings[(*breakpoint_p)->type],
-		(*breakpoint_p)->address,
+		target_addr64str1( target, (*breakpoint_p)->address ),
 		(*breakpoint_p)->length,
 		(*breakpoint_p)->unique_id);
 
 	return ERROR_OK;
 }
 
-int breakpoint_add(struct target *target,
-	uint32_t address,
-	uint32_t length,
+int breakpoint64_add(struct target *target,
+	const struct target_addr *pAddr,
+	uint64_t length,
 	enum breakpoint_type type)
 {
 	int retval = ERROR_OK;
@@ -230,22 +231,22 @@ int breakpoint_add(struct target *target,
 		struct target *curr;
 		head = target->head;
 		if (type == BKPT_SOFT)
-			return breakpoint_add_internal(head->target, address, length, type);
+			return breakpoint64_add_internal(head->target, pAddr, length, type);
 
 		while (head != (struct target_list *)NULL) {
 			curr = head->target;
-			retval = breakpoint_add_internal(curr, address, length, type);
+			retval = breakpoint64_add_internal(curr, pAddr, length, type);
 			if (retval != ERROR_OK)
 				return retval;
 			head = head->next;
 		}
 		return retval;
 	} else
-		return breakpoint_add_internal(target, address, length, type);
+		return breakpoint64_add_internal(target, pAddr, length, type);
 }
-int context_breakpoint_add(struct target *target,
+int context32_breakpoint_add(struct target *target,
 	uint32_t asid,
-	uint32_t length,
+	uint64_t length,
 	enum breakpoint_type type)
 {
 	int retval = ERROR_OK;
@@ -255,19 +256,21 @@ int context_breakpoint_add(struct target *target,
 		head = target->head;
 		while (head != (struct target_list *)NULL) {
 			curr = head->target;
-			retval = context_breakpoint_add_internal(curr, asid, length, type);
+			retval = contextXX_breakpoint_add_internal(curr, asid, length, type);
 			if (retval != ERROR_OK)
 				return retval;
 			head = head->next;
 		}
 		return retval;
 	} else
-		return context_breakpoint_add_internal(target, asid, length, type);
+		return contextXX_breakpoint_add_internal(target, asid, length, type);
 }
-int hybrid_breakpoint_add(struct target *target,
-	uint32_t address,
+
+
+int hybrid64_breakpoint_add(struct target *target,
+	const struct target_addr *pAddr,
 	uint32_t asid,
-	uint32_t length,
+	uint64_t length,
 	enum breakpoint_type type)
 {
 	int retval = ERROR_OK;
@@ -277,14 +280,14 @@ int hybrid_breakpoint_add(struct target *target,
 		head = target->head;
 		while (head != (struct target_list *)NULL) {
 			curr = head->target;
-			retval = hybrid_breakpoint_add_internal(curr, address, asid, length, type);
+			retval = hybridXX_breakpoint_add_internal(curr, pAddr, asid, length, type);
 			if (retval != ERROR_OK)
 				return retval;
 			head = head->next;
 		}
 		return retval;
 	} else
-		return hybrid_breakpoint_add_internal(target, address, asid, length, type);
+		return hybridXX_breakpoint_add_internal(target, pAddr, asid, length, type);
 }
 
 /* free up a breakpoint */
@@ -312,16 +315,16 @@ static void breakpoint_free(struct target *target, struct breakpoint *breakpoint
 	free(breakpoint);
 }
 
-int breakpoint_remove_internal(struct target *target, uint32_t address)
+int breakpoint_remove_internal(struct target *target, const struct target_addr *pAddr)
 {
 	struct breakpoint *breakpoint = target->breakpoints;
 
 	while (breakpoint) {
-		if ((breakpoint->address == address) && (breakpoint->asid == 0))
+		if ((breakpoint->address == pAddr->addr) && (breakpoint->asid == 0))
 			break;
-		else if ((breakpoint->address == 0) && (breakpoint->asid == address))
+		else if ((breakpoint->address == 0) && (breakpoint->asid == pAddr->addr))
 			break;
-		else if ((breakpoint->address == address) && (breakpoint->asid != 0))
+		else if ((breakpoint->address == pAddr->addr) && (breakpoint->asid != 0))
 			break;
 		breakpoint = breakpoint->next;
 	}
@@ -331,11 +334,11 @@ int breakpoint_remove_internal(struct target *target, uint32_t address)
 		return 1;
 	} else {
 		if (!target->smp)
-			LOG_ERROR("no breakpoint at address 0x%8.8" PRIx32 " found", address);
+			LOG_ERROR("no breakpoint at address 0x%s found", target_addr2str1( target, pAddr));
 		return 0;
 	}
 }
-void breakpoint_remove(struct target *target, uint32_t address)
+void breakpoint64_remove(struct target *target, const struct target_addr *pAddr )
 {
 	int found = 0;
 	if (target->smp) {
@@ -344,13 +347,13 @@ void breakpoint_remove(struct target *target, uint32_t address)
 		head = target->head;
 		while (head != (struct target_list *)NULL) {
 			curr = head->target;
-			found += breakpoint_remove_internal(curr, address);
+			found += breakpoint_remove_internal(curr, pAddr);
 			head = head->next;
 		}
 		if (found == 0)
-			LOG_ERROR("no breakpoint at address 0x%8.8" PRIx32 " found", address);
+			LOG_ERROR("no breakpoint at address 0x%s found", target_addr2str1( target,pAddr));
 	} else
-		breakpoint_remove_internal(target, address);
+		breakpoint_remove_internal(target, pAddr);
 }
 
 void breakpoint_clear_target_internal(struct target *target)
@@ -377,12 +380,12 @@ void breakpoint_clear_target(struct target *target)
 
 }
 
-struct breakpoint *breakpoint_find(struct target *target, uint32_t address)
+struct breakpoint *breakpoint64_find(struct target *target, const struct target_addr *pAddr )
 {
 	struct breakpoint *breakpoint = target->breakpoints;
 
 	while (breakpoint) {
-		if (breakpoint->address == address)
+		if (breakpoint->address == pAddr->addr)
 			return breakpoint;
 		breakpoint = breakpoint->next;
 	}
@@ -390,8 +393,8 @@ struct breakpoint *breakpoint_find(struct target *target, uint32_t address)
 	return NULL;
 }
 
-int watchpoint_add(struct target *target, uint32_t address, uint32_t length,
-	enum watchpoint_rw rw, uint32_t value, uint32_t mask)
+int watchpoint64_add(struct target *target, const struct target_addr *pAddr, uint64_t length,
+	enum watchpoint_rw rw, uint64_t value, uint64_t mask)
 {
 	struct watchpoint *watchpoint = target->watchpoints;
 	struct watchpoint **watchpoint_p = &target->watchpoints;
@@ -399,14 +402,14 @@ int watchpoint_add(struct target *target, uint32_t address, uint32_t length,
 	const char *reason;
 
 	while (watchpoint) {
-		if (watchpoint->address == address) {
+		if (watchpoint->address == pAddr->addr) {
 			if (watchpoint->length != length
 				|| watchpoint->value != value
 				|| watchpoint->mask != mask
 				|| watchpoint->rw != rw) {
-				LOG_ERROR("address 0x%8.8" PRIx32
+				LOG_ERROR("address 0x%s "
 					"already has watchpoint %d",
-					address, watchpoint->unique_id);
+					  target_addr2str1( target, pAddr), watchpoint->unique_id);
 				return ERROR_FAIL;
 			}
 
@@ -418,7 +421,7 @@ int watchpoint_add(struct target *target, uint32_t address, uint32_t length,
 	}
 
 	(*watchpoint_p) = calloc(1, sizeof(struct watchpoint));
-	(*watchpoint_p)->address = address;
+	(*watchpoint_p)->address = pAddr->addr;
 	(*watchpoint_p)->length = length;
 	(*watchpoint_p)->value = value;
 	(*watchpoint_p)->mask = mask;
@@ -438,19 +441,19 @@ int watchpoint_add(struct target *target, uint32_t address, uint32_t length,
 		default:
 			reason = "unrecognized error";
 bye:
-			LOG_ERROR("can't add %s watchpoint at 0x%8.8" PRIx32 ", %s",
+			LOG_ERROR("can't add %s watchpoint at 0x%s, %s",
 				watchpoint_rw_strings[(*watchpoint_p)->rw],
-				address, reason);
+				target_addr2str1( target, pAddr), reason);
 			free(*watchpoint_p);
 			*watchpoint_p = NULL;
 			return retval;
 	}
 
-	LOG_DEBUG("added %s watchpoint at 0x%8.8" PRIx32
-		" of length 0x%8.8" PRIx32 " (WPID: %d)",
+	LOG_DEBUG("added %s watchpoint at %s"
+		" of length %s (WPID: %d)",
 		watchpoint_rw_strings[(*watchpoint_p)->rw],
-		(*watchpoint_p)->address,
-		(*watchpoint_p)->length,
+		target_addr64str1( target, (*watchpoint_p)->address),
+		target_addr64str2( target, (*watchpoint_p)->length ),
 		(*watchpoint_p)->unique_id);
 
 	return ERROR_OK;
@@ -477,12 +480,12 @@ static void watchpoint_free(struct target *target, struct watchpoint *watchpoint
 	free(watchpoint);
 }
 
-void watchpoint_remove(struct target *target, uint32_t address)
+void watchpoint64_remove(struct target *target, const struct target_addr *pAddr )
 {
 	struct watchpoint *watchpoint = target->watchpoints;
 
 	while (watchpoint) {
-		if (watchpoint->address == address)
+		if (watchpoint->address == pAddr->addr)
 			break;
 		watchpoint = watchpoint->next;
 	}
@@ -490,7 +493,7 @@ void watchpoint_remove(struct target *target, uint32_t address)
 	if (watchpoint)
 		watchpoint_free(target, watchpoint);
 	else
-		LOG_ERROR("no watchpoint at address 0x%8.8" PRIx32 " found", address);
+		LOG_ERROR("no watchpoint at address 0x%s found", target_addr2str1(target,pAddr));
 }
 
 void watchpoint_clear_target(struct target *target)
@@ -501,7 +504,7 @@ void watchpoint_clear_target(struct target *target)
 		watchpoint_free(target, target->watchpoints);
 }
 
-int watchpoint_hit(struct target *target, enum watchpoint_rw *rw, uint32_t *address)
+int watchpoint64_hit(struct target *target, enum watchpoint_rw *rw, struct target_addr *pAddr )
 {
 	int retval;
 	struct watchpoint *hit_watchpoint;
@@ -511,11 +514,79 @@ int watchpoint_hit(struct target *target, enum watchpoint_rw *rw, uint32_t *addr
 		return ERROR_FAIL;
 
 	*rw = hit_watchpoint->rw;
-	*address = hit_watchpoint->address;
+	TARGET_ADDR_INIT( pAddr, hit_watchpoint->address );
 
-	LOG_DEBUG("Found hit watchpoint at 0x%8.8" PRIx32 " (WPID: %d)",
-		hit_watchpoint->address,
+	LOG_DEBUG("Found hit watchpoint at 0x%s (WPID: %d)",
+		target_addr2str1( target, pAddr ),
 		hit_watchpoint->unique_id);
 
 	return ERROR_OK;
 }
+
+
+int hybrid32_breakpoint_add(struct target *target,
+	uint64_t address,
+	uint32_t asid,
+	uint64_t length,
+	enum breakpoint_type type)
+{
+	struct target_addr tmp;
+	TARGET_ADDR_INIT( &tmp, address );
+	return hybrid64_breakpoint_add( target, &tmp, asid, length, type );
+}
+
+
+void breakpoint32_remove(struct target *target, uint64_t address)
+{
+	struct target_addr tmp;
+	TARGET_ADDR_INIT( &tmp, address );
+	breakpoint64_remove( target, &tmp );
+}
+
+
+
+struct breakpoint *breakpoint32_find(struct target *target, uint64_t address)
+{
+	struct target_addr tmp;
+	TARGET_ADDR_INIT( &tmp, address );
+	return breakpoint64_find( target, &tmp );
+}
+
+
+int watchpoint32_add(struct target *target, uint64_t address, uint64_t length,
+	enum watchpoint_rw rw, uint64_t value, uint64_t mask)
+{
+	struct target_addr tmp;
+	TARGET_ADDR_INIT( &tmp, address );
+	return watchpoint64_add( target, &tmp, length, rw, value, mask );
+}
+
+void watchpoint32_remove(struct target *target, uint64_t address)
+{
+	struct target_addr addr;
+	TARGET_ADDR_INIT( &addr, address );
+	watchpoint64_remove( target, &addr );
+}
+
+
+int watchpoint32_hit( struct target *target, enum watchpoint_rw *rw, uint32_t *address)
+{
+  struct target_addr addr;
+  int r;
+
+  r = watchpoint64_hit( target, rw, &addr );
+  *address = addr.addr;
+  return r;
+}
+  
+
+
+int breakpoint32_add(struct target *target,
+	uint64_t address,
+	uint64_t length,
+	enum breakpoint_type type)
+{
+	struct target_addr tmp_addr;
+	TARGET_ADDR_INIT( &tmp_addr, address );
+	return breakpoint64_add( target, &tmp_addr, length, type );
+}
diff --git a/src/target/breakpoints.h b/src/target/breakpoints.h
old mode 100644
new mode 100755
index 0246acd..1c932b4
--- a/src/target/breakpoints.h
+++ b/src/target/breakpoints.h
@@ -22,6 +22,7 @@
 #define BREAKPOINTS_H
 
 struct target;
+#include "target_addr.h"
 
 enum breakpoint_type {
 	BKPT_HARD,
@@ -33,7 +34,7 @@ enum watchpoint_rw {
 };
 
 struct breakpoint {
-	uint32_t address;
+	uint64_t address;
 	uint32_t asid;
 	int length;
 	enum breakpoint_type type;
@@ -45,8 +46,8 @@ struct breakpoint {
 };
 
 struct watchpoint {
-	uint32_t address;
-	uint32_t length;
+	uint64_t address;
+	uint64_t length;
 	uint32_t mask;
 	uint32_t value;
 	enum watchpoint_rw rw;
@@ -56,23 +57,50 @@ struct watchpoint {
 };
 
 void breakpoint_clear_target(struct target *target);
-int breakpoint_add(struct target *target,
-		uint32_t address, uint32_t length, enum breakpoint_type type);
-int context_breakpoint_add(struct target *target,
-		uint32_t asid, uint32_t length, enum breakpoint_type type);
-int hybrid_breakpoint_add(struct target *target,
-		uint32_t address, uint32_t asid, uint32_t length, enum breakpoint_type type);
-void breakpoint_remove(struct target *target, uint32_t address);
+#define breakpoint_add breakpoint32_add
+int breakpoint32_add(struct target *target,
+		uint64_t address, uint64_t length, enum breakpoint_type type);
+int breakpoint64_add(struct target *target,
+		const struct target_addr *pAddr, uint64_t length, enum breakpoint_type type);
 
-struct breakpoint *breakpoint_find(struct target *target, uint32_t address);
+#define context_breakpoint_add   contextXX_breakpoint_add 
+#define context32_breakpoint_add contextXX_breakpoint_add 
+#define context64_breakpoint_add contextXX_breakpoint_add 
+int contextXX_breakpoint_add(struct target *target,
+		uint32_t asid, uint64_t length, enum breakpoint_type type);
+
+
+#define hybrid_breakpoint_add hybrid32_breakpoint_add
+int hybrid32_breakpoint_add(struct target *target,
+		uint64_t address, uint32_t asid, uint64_t length, enum breakpoint_type type);
+
+int hybrid64_breakpoint_add(struct target *target,
+		const struct target_addr *pAddr, uint32_t asid, uint64_t length, enum breakpoint_type type);
+
+#define breakpoint_remove breakpoint32_remove
+void breakpoint32_remove(struct target *target, uint64_t address);
+void breakpoint64_remove(struct target *target, const struct target_addr *pAddr );
+
+#define breakpoint_find breakpoint32_find
+struct breakpoint *breakpoint32_find(struct target *target, uint64_t address);
+struct breakpoint *breakpoint64_find(struct target *target, const struct target_addr *pAddr );
 
 void watchpoint_clear_target(struct target *target);
-int watchpoint_add(struct target *target,
-		uint32_t address, uint32_t length,
-		enum watchpoint_rw rw, uint32_t value, uint32_t mask);
-void watchpoint_remove(struct target *target, uint32_t address);
+#define watchpoint_add watchpoint32_add
+int watchpoint32_add(struct target *target,
+		uint64_t address, uint64_t length,
+		enum watchpoint_rw rw, uint64_t value, uint64_t mask);
+int watchpoint64_add(struct target *target,
+		const struct target_addr *pAddr, uint64_t length,
+		enum watchpoint_rw rw, uint64_t value, uint64_t mask);
+
+#define watchpoint_remove watchpoint32_remove
+void watchpoint32_remove(struct target *target, uint64_t address);
+void watchpoint64_remove(struct target *target, const struct target_addr *pAddr );
 
 /* report type and address of just hit watchpoint */
-int watchpoint_hit(struct target *target, enum watchpoint_rw *rw, uint32_t *address);
+#define watchpoint_hit watchpoint32_hit
+int watchpoint32_hit(struct target *target, enum watchpoint_rw *rw, uint32_t *address);
+int watchpoint64_hit(struct target *target, enum watchpoint_rw *rw, struct target_addr *pAddr);
 
 #endif /* BREAKPOINTS_H */
diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index cde3aeb..4273b21 100755
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -2758,16 +2758,32 @@ static const struct command_registration cortex_a_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io32 cortexa_target32 = {
+
+	.read_memory = cortex_a_read_memory,
+	.write_memory = cortex_a_write_memory,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+	.read_phys_memory = cortex_a_read_phys_memory,
+	.write_phys_memory = cortex_a_write_phys_memory,
+	.virt2phys = cortex_a_virt2phys,
+	.resume = cortex_a_resume,
+	.step = cortex_a_step,
+};
+
 struct target_type cortexa_target = {
 	.name = "cortex_a",
 	.deprecated_name = "cortex_a8",
 
+	.pIo32_legacy_api = &cortexa_target32,
+
 	.poll = cortex_a_poll,
 	.arch_state = armv7a_arch_state,
 
 	.halt = cortex_a_halt,
-	.resume = cortex_a_resume,
-	.step = cortex_a_step,
 
 	.assert_reset = cortex_a_assert_reset,
 	.deassert_reset = cortex_a_deassert_reset,
@@ -2775,14 +2791,6 @@ struct target_type cortexa_target = {
 	/* REVISIT allow exporting VFP3 registers ... */
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
-	.read_memory = cortex_a_read_memory,
-	.write_memory = cortex_a_write_memory,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
-
 	.add_breakpoint = cortex_a_add_breakpoint,
 	.add_context_breakpoint = cortex_a_add_context_breakpoint,
 	.add_hybrid_breakpoint = cortex_a_add_hybrid_breakpoint,
@@ -2795,10 +2803,7 @@ struct target_type cortexa_target = {
 	.init_target = cortex_a_init_target,
 	.examine = cortex_a_examine,
 
-	.read_phys_memory = cortex_a_read_phys_memory,
-	.write_phys_memory = cortex_a_write_phys_memory,
 	.mmu = cortex_a_mmu,
-	.virt2phys = cortex_a_virt2phys,
 };
 
 static const struct command_registration cortex_r4_exec_command_handlers[] = {
@@ -2836,15 +2841,29 @@ static const struct command_registration cortex_r4_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io32 cortexr4_target32 = {
+
+  	.read_memory = cortex_a_read_memory,
+	.write_memory = cortex_a_write_memory,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+	.resume = cortex_a_resume,
+	.step = cortex_a_step,
+	.run_algorithm = armv4_5_run_algorithm,
+
+};
+
+
 struct target_type cortexr4_target = {
 	.name = "cortex_r4",
 
+	.pIo32_legacy_api = &cortexr4_target32,
+	
 	.poll = cortex_a_poll,
 	.arch_state = armv7a_arch_state,
 
 	.halt = cortex_a_halt,
-	.resume = cortex_a_resume,
-	.step = cortex_a_step,
 
 	.assert_reset = cortex_a_assert_reset,
 	.deassert_reset = cortex_a_deassert_reset,
@@ -2852,13 +2871,6 @@ struct target_type cortexr4_target = {
 	/* REVISIT allow exporting VFP3 registers ... */
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
-	.read_memory = cortex_a_read_memory,
-	.write_memory = cortex_a_write_memory,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
 
 	.add_breakpoint = cortex_a_add_breakpoint,
 	.add_context_breakpoint = cortex_a_add_context_breakpoint,
diff --git a/src/target/cortex_a.h b/src/target/cortex_a.h
old mode 100644
new mode 100755
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index b35fb61..879b688 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -34,12 +34,10 @@ static int cortex_a53_dap_write_coreregister_u32(struct target *target,
 	uint32_t value, int regnum);
 #endif
 static int cortex_a53_mmu(struct target *target, int *enabled);
-static int cortex_a53_virt2phys(struct target *target,
-	uint32_t virt, uint32_t *phys);
 static int cortex_a53_virt2phys_64(struct target *target,
-	uint64_t virt, uint64_t *phys);
+        const struct target_addr *in_pVirt, struct target_addr *out_pPhys );
 static int cortex_a53_read_apb_ab_memory(struct target *target,
-	uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
+	const struct target_addr *pAddr, uint32_t size, uint32_t count, uint8_t *buffer);
 
 
 /* check whether it is in AArch32 or AArch64 through dscr. Only valid at debug state
@@ -143,26 +141,26 @@ static int cortex_a53_restore_cp15_control_reg(struct target *target)
 
 /*  check address before cortex_a53_apb read write access with mmu on
  *  remove apb predictible data abort */
-static int cortex_a53_check_address(struct target *target, uint32_t address)
+static int cortex_a53_check_address(struct target *target, const struct target_addr *pAddr)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
 
 	uint32_t os_border = armv7a->armv7a_mmu.os_border;
-	if ((address < os_border) &&
+	if ((pAddr->addr < os_border) &&
 		(armv7a->arm.core_mode == ARM_MODE_SVC)) {
-		LOG_ERROR("%" PRIx32 " access in userspace and target in supervisor", address);
+		LOG_ERROR("%" PRIx64 " access in userspace and target in supervisor", pAddr->addr );
 		return ERROR_FAIL;
 	}
-	if ((address >= os_border) &&
+	if ((pAddr->addr >= os_border) &&
 		(cortex_a->curr_mode != ARM_MODE_SVC)) {
 		dpm_modeswitch(&armv7a->dpm, ARM_MODE_SVC);
 		cortex_a->curr_mode = ARM_MODE_SVC;
-		LOG_INFO("%" PRIx32 " access in kernel space and target not in supervisor",
-			address);
+		LOG_INFO("%" PRIx64 " access in kernel space and target not in supervisor",
+			pAddr->addr );
 		return ERROR_OK;
 	}
-	if ((address < os_border) &&
+	if ((pAddr->addr < os_border) &&
 		(cortex_a->curr_mode == ARM_MODE_SVC)) {
 		dpm_modeswitch(&armv7a->dpm, ARM_MODE_ANY);
 		cortex_a->curr_mode = ARM_MODE_ANY;
@@ -797,11 +795,11 @@ static int cortex_a53_instr_read_data_r0(struct arm_dpm *dpm,
 }
 
 static int cortex_a53_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
-	uint32_t addr, uint32_t control)
+	const struct target_addr *pAddr, uint32_t control)
 {
 	struct cortex_a_common *a = dpm_to_a(dpm);
-	uint32_t vr = a->armv7a_common.debug_base;
-	uint32_t cr = a->armv7a_common.debug_base;
+	uint64_t vr = a->armv7a_common.debug_base;
+	uint64_t cr = a->armv7a_common.debug_base;
 	int retval;
 
 	switch (index_t) {
@@ -824,7 +822,7 @@ static int cortex_a53_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
 		(unsigned) vr, (unsigned) cr);
 
 	retval = cortex_a53_dap_write_memap_register_u32(dpm->arm->target,
-			vr, addr);
+			vr, pAddr->addr);
 	if (retval != ERROR_OK)
 		return retval;
     //SQU: assume the addr is 32 bits for now. TODO: fix it
@@ -1096,14 +1094,14 @@ static int cortex_a53_halt(struct target *target)
 		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 6, 1, 1, 0, 0), &dummy); //SCR_EL3=X0
-
-		      cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 4, 1, 1, 0, 0), &dummy); //read HCR_EL2 to X0
-              cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-              retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
-              LOG_USER("Running in AArch64. HCR_EL2=0x%x",dummy);
-/*              mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
-              cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
-              cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 4, 1, 1, 0, 0), &dummy); //HCR_EL2=X0
+
+		      cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 4, 1, 1, 0, 0), &dummy); //read HCR_EL2 to X0
+              cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+              retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+              LOG_USER("Running in AArch64. HCR_EL2=0x%x",dummy);
+/*              mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
+              cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
+              cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 4, 1, 1, 0, 0), &dummy); //HCR_EL2=X0
 */
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 12, 0, 2, 0), &dummy);    // MRS RMR_EL3, R0
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
@@ -1179,7 +1177,7 @@ static int cortex_a53_halt(struct target *target)
 		cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dummy);    //X0=DTRRX
 		cortex_a53_exec_opcode(target, ARMV4_5_MCR(15, 3, 0, 4, 5, 0), &dummy);    // MSR DSPSR_EL0, R0
 
-	    LOG_USER("Asic ROM base is = 0x%08" PRIx32, target->romcbase);
+	    LOG_USER("Asic ROM base is = 0x%08" PRIx64, target->romcbase);
 		// set to 0xFE800000 as PC
 		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, 0);
 //		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x100000); //for 8916
@@ -1234,7 +1232,7 @@ static int cortex_a53_halt(struct target *target)
 }
 
 static int cortex_a53_internal_restore(struct target *target, int current,
-	uint64_t *address, int handle_breakpoints, int debug_execution)
+	struct target_addr *pAddr, int handle_breakpoints, int debug_execution)
 {
 	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
 	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a);
@@ -1252,9 +1250,9 @@ static int cortex_a53_internal_restore(struct target *target, int current,
 		/* current = 1: continue on current pc, otherwise continue at <address> */
 		resume_pc = buf_get_u32(arm->pc->value, 0, 32);
 		if (!current)
-			resume_pc = *address;
+			resume_pc = pAddr->addr;
 		else
-			*address = resume_pc;
+			pAddr->addr = resume_pc;
 
 		/* Make sure that the Armv7 gdb thumb fixups does not
 		 * kill the return address
@@ -1291,9 +1289,9 @@ static int cortex_a53_internal_restore(struct target *target, int current,
 		/* current = 1: continue on current pc, otherwise continue at <address> */
 		resume_pc = buf_get_u64(armv8->pc->value, 0, 64);
 		if (!current)
-			resume_pc = *address;
+			resume_pc = pAddr->addr;
 		else
-			*address = resume_pc;
+			pAddr->addr = resume_pc;
 
 		LOG_DEBUG("resume pc = 0x%" PRIx64, resume_pc);
 		buf_set_u64(armv8->pc->value, 0, 64, resume_pc);
@@ -1411,13 +1409,13 @@ static int cortex_a53_restore_smp(struct target *target, int handle_breakpoints)
 	int retval = 0;
 	struct target_list *head;
 	struct target *curr;
-	uint32_t address;
+	struct target_addr addr;
 	head = target->head;
 	while (head != (struct target_list *)NULL) {
 		curr = head->target;
 		if ((curr != target) && (curr->state != TARGET_RUNNING)) {
 			/*  resume current address , not in step mode */
-			retval += cortex_a53_internal_restore(curr, 1, &address,
+			retval += cortex_a53_internal_restore(curr, 1, &addr,
 					handle_breakpoints, 0);
 			retval += cortex_a53_internal_restart(curr);
 		}
@@ -1428,9 +1426,12 @@ static int cortex_a53_restore_smp(struct target *target, int handle_breakpoints)
 }
 
 static int cortex_a53_resume_64(struct target *target, int current,
-	uint64_t address, int handle_breakpoints, int debug_execution)
+	const struct target_addr *in_pAddr, int handle_breakpoints, int debug_execution)
 {
 	int retval = 0;
+	struct target_addr addr;
+	addr = *in_pAddr;
+
 	/* dummy resume for smp toggle in order to reduce gdb impact  */
 	if ((target->smp) && (target->gdb_service->core[1] != -1)) {
 		/*   simulate a start and halt of target */
@@ -1440,7 +1441,7 @@ static int cortex_a53_resume_64(struct target *target, int current,
 		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
 		return 0;
 	}
-	cortex_a53_internal_restore(target, current, &address, handle_breakpoints, debug_execution);
+	cortex_a53_internal_restore(target, current, &addr, handle_breakpoints, debug_execution);
 	if (target->smp) {
 		target->gdb_service->core[0] = -1;
 		retval = cortex_a53_restore_smp(target, handle_breakpoints);
@@ -1452,21 +1453,16 @@ static int cortex_a53_resume_64(struct target *target, int current,
 	if (!debug_execution) {
 		target->state = TARGET_RUNNING;
 		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
-		LOG_DEBUG("target resumed at 0x%" PRIx64, address);
+		LOG_DEBUG("target resumed at 0x%" PRIx64, addr.addr);
 	} else {
 		target->state = TARGET_DEBUG_RUNNING;
 		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
-		LOG_DEBUG("target debug resumed at 0x%" PRIx64, address);
+		LOG_DEBUG("target debug resumed at 0x%" PRIx64, addr.addr);
 	}
 
 	return ERROR_OK;
 }
 
-static int cortex_a53_resume(struct target *target, int current,
-	uint32_t address, int handle_breakpoints, int debug_execution)
-{
-	return cortex_a53_resume_64(target, current, (uint64_t)address, handle_breakpoints, debug_execution);
-}
 
 static int cortex_a53_debug_entry(struct target *target)
 {
@@ -1533,14 +1529,16 @@ static int cortex_a53_debug_entry(struct target *target)
 	armv8_dpm_report_dscr(&armv7a->dpm, cortex_a53->cpudbg_dscr);
 	/* save address of instruction that triggered the watchpoint? */
 	if (target->debug_reason == DBG_REASON_WATCHPOINT) {
-		uint32_t wfar;
-
+		struct target_addr wfar;
+		uint32_t regval;
 		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
 				armv7a->debug_base + CPUDBG_WFAR,
-				&wfar);
+				&regval);
 		if (retval != ERROR_OK)
 			return retval;
-		armv8_dpm_report_wfar(&armv7a->dpm, wfar);
+		
+		TARGET_ADDR_INIT( &wfar, regval );
+		armv8_dpm_report_wfar(&armv7a->dpm, wfar.addr);
 	}
 
 	/* REVISIT fast_reg_read is never set in original cortex_a code. And many changes needed for support. So just take the code out */
@@ -1605,7 +1603,7 @@ static int cortex_a53_post_debug_entry(struct target *target)
 	return ERROR_OK;
 }
 
-static int cortex_a53_step_64(struct target *target, int current, uint64_t address,
+static int cortex_a53_step_64(struct target *target, int current, const struct target_addr *pAddr,
 	int handle_breakpoints)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
@@ -1615,8 +1613,11 @@ static int cortex_a53_step_64(struct target *target, int current, uint64_t addre
 	struct breakpoint stepbreakpoint;
 	struct reg *r;
 	int retval;
+	struct target_addr addr;
 	//uint32_t dummy,dummy1;
 
+	addr = *pAddr;
+
 	if (target->state != TARGET_HALTED) {
 		LOG_WARNING("target not halted");
 		return ERROR_TARGET_NOT_HALTED;
@@ -1626,9 +1627,9 @@ static int cortex_a53_step_64(struct target *target, int current, uint64_t addre
 	//SQUTODO: change to 64bit pc
 	r = arm->pc;
 	if (!current)
-		buf_set_u32(r->value, 0, 32, address);
+		buf_set_u32(r->value, 0, 32, addr.addr);
 	else
-		address = buf_get_u32(r->value, 0, 32);
+		addr.addr = buf_get_u32(r->value, 0, 32);
 
 	/* The front-end may request us not to handle breakpoints.
 	 * But since Cortex-A8 uses breakpoint for single step,
@@ -1637,7 +1638,7 @@ static int cortex_a53_step_64(struct target *target, int current, uint64_t addre
 	handle_breakpoints = 1;
 	//SQUTODO: update for 64b address
 	if (handle_breakpoints) {
-		breakpoint = breakpoint_find(target, address);
+		breakpoint = breakpoint64_find(target, &addr);
 		if (breakpoint)
 			cortex_a53_unset_breakpoint(target, breakpoint);
 	}
@@ -1653,7 +1654,7 @@ static int cortex_a53_step_64(struct target *target, int current, uint64_t addre
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = cortex_a53_resume(target, 1, address, 0, 0);
+	retval = cortex_a53_resume_64(target, 1, &addr, 0, 0);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1682,11 +1683,6 @@ static int cortex_a53_step_64(struct target *target, int current, uint64_t addre
 	return ERROR_OK;
 }
 
-static int cortex_a53_step(struct target *target, int current, uint32_t address,
-	int handle_breakpoints)
-{
-	return cortex_a53_step_64(target, current, (uint64_t)address, handle_breakpoints);
-}
 
 static int cortex_a53_restore_context(struct target *target, bool bpwp)
 {
@@ -1759,6 +1755,7 @@ static int cortex_a53_set_breakpoint(struct target *target,
 			brp_list[brp_i].value);
 	} else if (breakpoint->type == BKPT_SOFT) {
 		uint8_t code[4];
+		struct target_addr tmp_addr;
 		if (breakpoint->length == 2)
 			buf_set_u32(code, 0, 32, ARMV8_T_HLT(0x11)); //ARMV5_T_BKPT(0x11)
 		else
@@ -1766,14 +1763,16 @@ static int cortex_a53_set_breakpoint(struct target *target,
 			if(target->is_64b) buf_set_u32(code, 0, 32, ARMV8_A64_HLT(0x11));
 			else buf_set_u32(code, 0, 32, ARMV8_A32_HLT(0x11)); //ARMV5_BKPT(0x11)
 		}
-		retval = target_read_memory(target,
-				breakpoint->address & 0xFFFFFFFE,
+		TARGET_ADDR_INIT( &tmp_addr,  breakpoint->address & (~1) );
+		retval = target64_read_memory(target,
+				&tmp_addr,
 				breakpoint->length, 1,
 				breakpoint->orig_instr);
 		if (retval != ERROR_OK)
 			return retval;
-		retval = target_write_memory(target,
-				breakpoint->address & 0xFFFFFFFE,
+		
+		retval = target64_write_memory(target,
+				&tmp_addr,
 				breakpoint->length, 1, code);
 		if (retval != ERROR_OK)
 			return retval;
@@ -2025,15 +2024,17 @@ static int cortex_a53_unset_breakpoint(struct target *target, struct breakpoint
 		}
 	} else {
 		/* restore original instruction (kept in target endianness) */
+		struct target_addr tmp_addr;
+		TARGET_ADDR_INIT( &tmp_addr, breakpoint->address & (~1) );
 		if (breakpoint->length == 4) {
-			retval = target_write_memory(target,
-					breakpoint->address & 0xFFFFFFFE,
+			retval = target64_write_memory(target,
+					&tmp_addr,
 					4, 1, breakpoint->orig_instr);
 			if (retval != ERROR_OK)
 				return retval;
 		} else {
-			retval = target_write_memory(target,
-					breakpoint->address & 0xFFFFFFFE,
+			retval = target64_write_memory(target,
+					&tmp_addr,
 					2, 1, breakpoint->orig_instr);
 			if (retval != ERROR_OK)
 				return retval;
@@ -2166,31 +2167,32 @@ static int cortex_a53_deassert_reset(struct target *target)
 }
 
 static int cortex_a53_write_apb_ab_memory(struct target *target,
-	uint32_t address, uint32_t size,
+	const struct target_addr *pAddr, uint32_t size,
 	uint32_t count, const uint8_t *buffer)
 {
 	/* write memory through APB-AP */
 
+	struct target_addr tmp_addr;
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct arm *arm = &armv7a->arm;
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	int total_bytes = count * size;
 	int total_u32;
-	int start_byte = address & 0x3;
-	int end_byte   = (address + total_bytes) & 0x3;
+	int start_byte = pAddr->addr & 0x3;
+	int end_byte   = (pAddr->addr + total_bytes) & 0x3;
 	struct reg *reg;
 	uint32_t dscr;
 	uint8_t *tmp_buff = NULL;
 
-	LOG_DEBUG("Writing APB-AP memory address 0x%" PRIx32 " size %d"  PRIu32 " count%"  PRIu32,
-			  address, size, count);
+	LOG_DEBUG("Writing APB-AP memory address 0x%" PRIx64 " size %d"  PRIu32 " count%"  PRIu32,
+			  pAddr->addr, (int)size, count);
 	if (target->state != TARGET_HALTED) {
 		LOG_WARNING("target not halted");
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	total_u32 = DIV_ROUND_UP((address & 3) + total_bytes, 4);
+	total_u32 = DIV_ROUND_UP((pAddr->addr & 3) + total_bytes, 4);
 
 	/* Mark register R0 as dirty, as it will be used
 	 * for transferring the data.
@@ -2222,7 +2224,9 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 		/* First bytes not aligned - read the 32 bit word to avoid corrupting
 		 * the other bytes in the word.
 		 */
-		retval = cortex_a53_read_apb_ab_memory(target, (address & ~0x3), 4, 1, tmp_buff);
+		tmp_addr = *pAddr;
+		tmp_addr.addr &= (~0x03);
+		retval = cortex_a53_read_apb_ab_memory(target, &tmp_addr, 4, 1, tmp_buff);
 		if (retval != ERROR_OK)
 			goto error_free_buff_w;
 	}
@@ -2233,7 +2237,9 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 
 		/* Read the last word to avoid corruption during 32 bit write */
 		int mem_offset = (total_u32-1) * 4;
-		retval = cortex_a53_read_apb_ab_memory(target, (address & ~0x3) + mem_offset, 4, 1, &tmp_buff[mem_offset]);
+		tmp_addr = *pAddr;
+		tmp_addr.addr = (pAddr->addr & ~0x3) + mem_offset;
+		retval = cortex_a53_read_apb_ab_memory(target, &tmp_addr, 4, 1, &tmp_buff[mem_offset]);
 		if (retval != ERROR_OK)
 			goto error_free_buff_w;
 	}
@@ -2263,8 +2269,13 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 	/* Write address into DTRRX, which triggers previous instruction */
+
+	/* copy memory properties */
+	tmp_addr = *pAddr;
+	/* round down to 32bits */
+	tmp_addr.addr &= (~0x03);
 	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DTRRX, address & (~0x3));
+				armv7a->debug_base + CPUDBG_DTRRX, tmp_addr.addr );
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
@@ -2321,33 +2332,33 @@ error_free_buff_w:
 }
 
 static int cortex_a53_read_apb_ab_memory(struct target *target,
-	uint32_t address, uint32_t size,
+	const struct target_addr *pAddr, uint32_t size,
 	uint32_t count, uint8_t *buffer)
 {
 	/* read memory through APB-AP */
-
+	struct target_addr tmp_addr;
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	struct arm *arm = &armv7a->arm;
 	int total_bytes = count * size;
 	int total_u32;
-	int start_byte = address & 0x3;
-	int end_byte   = (address + total_bytes) & 0x3;
+	int start_byte = pAddr->addr & 0x3;
+	int end_byte   = (pAddr->addr + total_bytes) & 0x3;
 	struct reg *reg;
 	uint32_t dscr;
 	uint8_t *tmp_buff = NULL;
 	uint8_t buf[8];
 	uint8_t *u8buf_ptr;
 
-	LOG_DEBUG("Reading APB-AP memory address 0x%" PRIx32 " size %d"  PRIu32 " count%"  PRIu32,
-			  address, size, count);
+	LOG_DEBUG("Reading APB-AP memory address 0x%" PRIx64 " size %d"  PRIu32 " count%"  PRIu32,
+			  pAddr->addr, size, count);
 	if (target->state != TARGET_HALTED) {
 		LOG_WARNING("target not halted");
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
-	total_u32 = DIV_ROUND_UP((address & 3) + total_bytes, 4);
+	total_u32 = DIV_ROUND_UP((pAddr->addr & 3) + total_bytes, 4);
 	/* Mark register R0 as dirty, as it will be used
 	 * for transferring the data.
 	 * It will be restored automatically when exiting
@@ -2379,8 +2390,10 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 
 	/* Write R0 with value 'address' using write procedure for stall mode */
 	/*   - Write the address for read access into DTRRX */
+	tmp_addr = *pAddr;
+	tmp_addr.addr &= (~0x03);
 	retval += mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DTRRX, address & ~0x3);
+			armv7a->debug_base + CPUDBG_DTRRX, tmp_addr.addr );
 	/*  - Copy value from DTRRX to R0 using instruction mrc p14, 0, r0, c5, c0 */
 	cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dscr);
 
@@ -2484,7 +2497,7 @@ error_free_buff_r:
  */
 
 static int cortex_a53_read_phys_memory_64(struct target *target,
-	uint64_t address, uint32_t size,
+	const struct target_addr *pAddr, uint32_t size,
 	uint64_t count, uint8_t *buffer)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
@@ -2492,18 +2505,19 @@ static int cortex_a53_read_phys_memory_64(struct target *target,
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
 	uint8_t apsel = swjdp->apsel;
 	LOG_DEBUG("Reading memory at real address 0x%" PRIx64 "; size %d; count %" PRId64,
-		address, size, count);
+		pAddr->addr, size, count);
 
 	if (count && buffer) {
 
 		if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
-			if(address==0)
+			if(pAddr->addr==0)
 			{
 				LOG_ERROR("SQU: trying to read @0x0 will cause exception. Return error directly for now to avoid handling exception");
 				return -107;
 			}
 			/* read memory through AHB-AP */
-			retval = mem_ap_sel_read_buf(swjdp, armv7a->memory_ap, buffer, size, count, address);
+			/* FIXME: Add support for 64bit addresses */
+			retval = mem_ap_sel_read_buf(swjdp, armv7a->memory_ap, buffer, size, count, pAddr->addr);
 		} else {
 
 			/* read memory through APB-AP */
@@ -2513,31 +2527,24 @@ static int cortex_a53_read_phys_memory_64(struct target *target,
 				if (retval != ERROR_OK)
 					return retval;
 			}
-			retval = cortex_a53_read_apb_ab_memory(target, address, size, count, buffer);
+			retval = cortex_a53_read_apb_ab_memory(target, pAddr, size, count, buffer);
 		}
 	}
 	return retval;
 }
 
-static int cortex_a53_read_phys_memory(struct target *target,
-	uint32_t address, uint32_t size,
-	uint32_t count, uint8_t *buffer)
-{
-	return cortex_a53_read_phys_memory_64(target, address, size, count, buffer);
-}
-
-static int cortex_a53_read_memory_64(struct target *target, uint64_t address,
-	uint32_t size, uint64_t count, uint8_t *buffer)
+static int cortex_a53_read_memory_64(struct target *target, const struct target_addr *pAddr,
+	uint64_t size, uint64_t count, uint8_t *buffer)
 {
 	int mmu_enabled = 0;
-	uint64_t virt, phys;
+	struct target_addr v_addr, p_addr;
 	int retval;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	uint8_t apsel = swjdp->apsel;
 
 	/* cortex_a53 handles unaligned memory access */
-	LOG_DEBUG("Reading memory at address 0x%" PRIx64 "; size %d; count %" PRId64, address, size, count);
+	LOG_DEBUG("Reading memory at address 0x%" PRIx64 "; size %d; count %" PRId64, pAddr->addr, (int)size, count);
 
 	/* determine if MMU was enabled on target stop */
 	retval = cortex_a53_mmu(target, &mmu_enabled);
@@ -2552,20 +2559,23 @@ static int cortex_a53_read_memory_64(struct target *target, uint64_t address,
 	}
 	//SQUTODO: change to 64b
 	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
-		if (mmu_enabled) {
-			virt = address;
-			retval = cortex_a53_virt2phys_64(target, virt, &phys);
+		if (!mmu_enabled) {
+			p_addr = *pAddr;
+		} else {
+			v_addr = *pAddr;
+			/* Change to virtual */
+			v_addr.route = TA_ROUTE_VIRTUAL;
+			retval = cortex_a53_virt2phys_64(target, &v_addr, &p_addr );
 			if (retval != ERROR_OK)
 				return retval;
 
 			LOG_DEBUG("Reading at virtual address. Translating v:0x%" PRIx64 " to r:0x%" PRIx64,
-				  virt, phys);
-			address = phys;
+				  v_addr.addr, p_addr.addr );
 		}
-		retval = cortex_a53_read_phys_memory_64(target, address, size, count, buffer);
+		retval = cortex_a53_read_phys_memory_64(target, &p_addr, size, count, buffer);
 	} else {
 		if (mmu_enabled) {
-			retval = cortex_a53_check_address(target, address);
+			retval = cortex_a53_check_address(target, pAddr);
 			if (retval != ERROR_OK)
 				return retval;
 			/* enable MMU as we could have disabled it for phys access */
@@ -2573,24 +2583,15 @@ static int cortex_a53_read_memory_64(struct target *target, uint64_t address,
 			if (retval != ERROR_OK)
 				return retval;
 		}
-		retval = cortex_a53_read_apb_ab_memory(target, address, size, count, buffer);
+		retval = cortex_a53_read_apb_ab_memory(target, pAddr, size, count, buffer);
 	}
 	return retval;
 }
 
-static int cortex_a53_read_memory(struct target *target, uint32_t address,
-	uint32_t size, uint32_t count, uint8_t *buffer)
-{
-	return cortex_a53_read_memory_64(target, address, size, count, buffer);
-}
 
-static int cortex_a53_read_buffer_64(struct target *target, uint64_t address, uint64_t size, uint8_t *buffer)
-{
-	return cortex_a53_read_memory_64(target, address, 1, size, buffer);
-}
 
 static int cortex_a53_write_phys_memory_64(struct target *target,
-	uint64_t address, uint32_t size,
+	const struct target_addr *pAddr, uint32_t size,
 	uint64_t count, const uint8_t *buffer)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
@@ -2598,7 +2599,7 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
 	uint8_t apsel = swjdp->apsel;
 
-	LOG_DEBUG("Writing memory to real address 0x%" PRIx64 "; size %d; count %" PRId64, address,
+	LOG_DEBUG("Writing memory to real address 0x%" PRIx64 "; size %d; count %" PRId64, pAddr->addr,
 		size, count);
 
 	if (count && buffer) {
@@ -2606,7 +2607,8 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 		if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
 
 			/* write memory through AHB-AP */
-			retval = mem_ap_sel_write_buf(swjdp, armv7a->memory_ap, buffer, size, count, address);
+			/* FIXME: Add 64bit support */
+			retval = mem_ap_sel_write_buf(swjdp, armv7a->memory_ap, buffer, size, count, pAddr->addr);
 		} else {
 
 			/* write memory through APB-AP */
@@ -2615,7 +2617,7 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 				if (retval != ERROR_OK)
 					return retval;
 			}
-			return cortex_a53_write_apb_ab_memory(target, address, size, count, buffer);
+			return cortex_a53_write_apb_ab_memory(target, pAddr, size, count, buffer);
 		}
 	}
 
@@ -2643,8 +2645,9 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 			 * with MVA to PoU
 			 *      MCR p15, 0, r0, c7, c5, 1
 			 */
-			for (uint32_t cacheline = address;
-				cacheline < address + size * count;
+			/* FIXME: Handle 64bit cache */
+			for (uint64_t cacheline = pAddr->addr;
+				cacheline < pAddr->addr + size * count;
 				cacheline += 64) {
 				retval = dpm->instr_write_data_r0(dpm,
 						ARMV4_5_MCR(15, 0, 0, 7, 5, 1),
@@ -2660,8 +2663,9 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 			 * with MVA to PoC
 			 *      MCR p15, 0, r0, c7, c6, 1
 			 */
-			for (uint32_t cacheline = address;
-				cacheline < address + size * count;
+			/* FIXME: Handle 64bit cache */
+			for (uint64_t cacheline = pAddr->addr ;
+				cacheline < pAddr->addr + size * count;
 				cacheline += 64) {
 				retval = dpm->instr_write_data_r0(dpm,
 						ARMV4_5_MCR(15, 0, 0, 7, 6, 1),
@@ -2677,26 +2681,24 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 	return retval;
 }
 
-static int cortex_a53_write_phys_memory(struct target *target,
-	uint32_t address, uint32_t size,
-	uint32_t count, const uint8_t *buffer)
-{
-	return cortex_a53_write_phys_memory_64(target, address, size, count, buffer);
-}
 
-static int cortex_a53_write_memory_64(struct target *target, uint64_t address,
-	uint32_t size, uint64_t count, const uint8_t *buffer)
+static int cortex_a53_write_memory_64(struct target *target, const struct target_addr *pAddr,
+	uint64_t size, uint64_t count, const uint8_t *buffer)
 {
 	int mmu_enabled = 0;
-	uint64_t virt, phys;
+	struct target_addr phys_addr;
 	int retval;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	uint8_t apsel = swjdp->apsel;
 
+	if( pAddr->route == TA_ROUTE_PHYSICAL ){
+	  return cortex_a53_write_phys_memory_64( target, pAddr, size, count, buffer );
+	}
+
 	/* cortex_a53 handles unaligned memory access */
-	LOG_DEBUG("Writing memory at address 0x%" PRIx64 "; size %d; count %" PRId64, address,
-		size, count);
+	LOG_DEBUG("Writing memory at address 0x%" PRIx64 "; size %d; count %" PRId64,
+		  pAddr->addr, (int)size, count);
 
 	/* determine if MMU was enabled on target stop */
 	retval = cortex_a53_mmu(target, &mmu_enabled);
@@ -2704,24 +2706,24 @@ static int cortex_a53_write_memory_64(struct target *target, uint64_t address,
 		return retval;
 
 	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
-		LOG_DEBUG("Writing memory to address 0x%" PRIx64 "; size %d; count %" PRId64, address, size,
+		LOG_DEBUG("Writing memory to address 0x%" PRIx64 "; size %d; count %" PRId64, pAddr->addr, (int)size,
 			count);
-		if (mmu_enabled) {
-			virt = address;
-			retval = cortex_a53_virt2phys_64(target, virt, &phys);
+		if (!mmu_enabled) {
+			phys_addr = *pAddr;
+		} else {
+			retval = cortex_a53_virt2phys_64(target, pAddr, &phys_addr);
 			if (retval != ERROR_OK)
 				return retval;
 
 			LOG_DEBUG("Writing to virtual address. Translating v:0x%" PRIx64 " to r:0x%" PRIx64,
-				  virt,
-				  phys);
-			address = phys;
+				  pAddr->addr,
+				  phys_addr.addr );
 		}
-		retval = cortex_a53_write_phys_memory_64(target, address, size,
+		retval = cortex_a53_write_phys_memory_64(target, &phys_addr, size,
 				count, buffer);
 	} else {
 		if (mmu_enabled) {
-			retval = cortex_a53_check_address(target, address);
+			retval = cortex_a53_check_address(target, pAddr);
 			if (retval != ERROR_OK)
 				return retval;
 			/* enable MMU as we could have disabled it for phys access */
@@ -2729,20 +2731,15 @@ static int cortex_a53_write_memory_64(struct target *target, uint64_t address,
 			if (retval != ERROR_OK)
 				return retval;
 		}
-		retval = cortex_a53_write_apb_ab_memory(target, address, size, count, buffer);
+		retval = cortex_a53_write_apb_ab_memory(target, pAddr, size, count, buffer);
 	}
 	return retval;
 }
 
-static int cortex_a53_write_memory(struct target *target, uint32_t address,
-	uint32_t size, uint32_t count, const uint8_t *buffer)
-{
-	return cortex_a53_write_memory_64(target, address, size, count, buffer);
-}
 
-static int cortex_a53_write_buffer_64(struct target *target, uint64_t address, uint64_t size, const uint8_t *buffer)
+static int cortex_a53_write_buffer_64(struct target *target, const struct target_addr *pAddr, uint64_t size, const uint8_t *buffer)
 {
-	return cortex_a53_write_memory_64(target, address, 1, size, buffer);
+	return cortex_a53_write_memory_64(target, pAddr, 1, size, buffer);
 }
 
 static int cortex_a53_handle_target_request(void *priv)
@@ -2923,6 +2920,14 @@ static int cortex_a53_init_target(struct command_context *cmd_ctx,
 	return ERROR_OK;
 }
 
+static int cortex_a53_read_phys_memory_WRAPPER(struct target *target, uint32_t address, uint32_t size,
+			uint32_t count, uint8_t *buffer)
+{
+	/* FIXME:  Do this direct - do not go through the helper */
+	return target32_read_phys_memory( target, address, size, count, buffer );
+}
+
+
 static int cortex_a53_init_arch_info(struct target *target,
 	struct cortex_a_common *cortex_a53)
 {
@@ -2936,7 +2941,7 @@ static int cortex_a53_init_arch_info(struct target *target,
 	armv7a->examine_debug_reason = NULL;
 	armv7a->post_debug_entry = cortex_a53_post_debug_entry;
 	armv7a->pre_restore_context = NULL;
-	armv7a->armv7a_mmu.read_physical_memory = cortex_a53_read_phys_memory;
+	armv7a->armv7a_mmu.read_physical_memory = cortex_a53_read_phys_memory_WRAPPER;
 
 	/* REVISIT v7a setup should be in a v7a-specific routine */
 	armv7a_init_arch_info(target, armv7a);
@@ -2988,35 +2993,33 @@ static int cortex_a53_mmu(struct target *target, int *enabled)
 }
 
 static int cortex_a53_virt2phys_64(struct target *target,
-	uint64_t virt, uint64_t *phys)
+				   const struct target_addr *in_pVirt,
+				   struct target_addr *out_pPhys )
 {
 	int retval = ERROR_FAIL;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
 	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	uint8_t apsel = swjdp->apsel;
+	uint32_t FIXME;
 	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
-		uint32_t ret;
+		
 		retval = armv7a_mmu_translate_va(target,
-				virt, &ret);
+						 in_pVirt->addr, &FIXME );
 		if (retval != ERROR_OK)
 			goto done;
-		*phys = ret;
+		TARGET_ADDR_PHYS( out_pPhys, FIXME );
 	} else {/*  use this method if armv7a->memory_ap not selected
 		 *  mmu must be enable in order to get a correct translation */
 		retval = cortex_a53_mmu_modify(target, 1);
 		if (retval != ERROR_OK)
 			goto done;
-		retval = armv7a_mmu_translate_va_pa(target, virt,  phys, 1);
+		retval = armv7a_mmu_translate_va_pa(target, in_pVirt->addr,  &FIXME, 1);
+		TARGET_ADDR_PHYS( out_pPhys, FIXME );
 	}
 done:
 	return retval;
 }
 
-static int cortex_a53_virt2phys(struct target *target,
-	uint32_t virt, uint32_t *phys)
-{
-	return cortex_a53_virt2phys_64(target, virt, phys);
-}
 
 COMMAND_HANDLER(cortex_a53_handle_cache_info_command)
 {
@@ -3154,33 +3157,41 @@ static const struct command_registration cortex_a53_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io64 cortexa53_target64 = {
+	.read_memory = cortex_a53_read_memory_64,
+	.write_memory = cortex_a53_write_memory_64,
+
+	.checksum_memory = NULL, /* NOT SUPPORTED (64bit reasons) */
+	.blank_check_memory = NULL, /* NOT SUPPORTED (64bit reasons) */
+
+	.read_buffer = target64_read_buffer_default,
+	.write_buffer = cortex_a53_write_buffer_64,
+	.virt2phys = cortex_a53_virt2phys_64,
+	// .run_algorithm = armv4_5_run_algorithm, NOT SUPPORTED (64bit reasons)
+
+	.resume = cortex_a53_resume_64,
+	.step = cortex_a53_step_64,
+
+};
+
+	
 struct target_type cortexa53_target = {
 	.name = "cortex_a53",
 	//.deprecated_name = "cortex_a",
 
+	.pIo64_api = &cortexa53_target64,
+	
 	.poll = cortex_a53_poll,
 	.arch_state = armv7a_arch_state,
 
 	.halt = cortex_a53_halt,
-	.resume = cortex_a53_resume,
-	.resume_64 = cortex_a53_resume_64,
-	.step = cortex_a53_step,
-	.step_64 = cortex_a53_step_64,
 
 	.assert_reset = cortex_a53_assert_reset,
 	.deassert_reset = cortex_a53_deassert_reset,
 
 	.get_gdb_reg_list = armv8_get_gdb_reg_list,
 
-	.read_memory = cortex_a53_read_memory,
-	.read_memory_64 = cortex_a53_read_memory_64,
-	.write_memory = cortex_a53_write_memory,
-	.write_memory_64 = cortex_a53_write_memory_64,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
 
-	.run_algorithm = armv4_5_run_algorithm,
 
 	.add_breakpoint = cortex_a53_add_breakpoint,
 	.add_context_breakpoint = cortex_a53_add_context_breakpoint,
@@ -3194,14 +3205,6 @@ struct target_type cortexa53_target = {
 	.init_target = cortex_a53_init_target,
 	.examine = cortex_a53_examine,
 
-	.read_phys_memory = cortex_a53_read_phys_memory,
-	.read_phys_memory_64 = cortex_a53_read_phys_memory_64,
-	.write_phys_memory = cortex_a53_write_phys_memory,
-	.write_phys_memory_64 = cortex_a53_write_phys_memory_64,
-	.read_buffer_64 = cortex_a53_read_buffer_64,
-	.write_buffer_64 = cortex_a53_write_buffer_64,
 	.mmu = cortex_a53_mmu,
-	.virt2phys = cortex_a53_virt2phys,
-	.virt2phys_64 = cortex_a53_virt2phys_64,
 };
 
diff --git a/src/target/cortex_m.c b/src/target/cortex_m.c
index 4e2dad5..a4f2986 100755
--- a/src/target/cortex_m.c
+++ b/src/target/cortex_m.c
@@ -755,7 +755,7 @@ static int cortex_m_resume(struct target *target, int current,
 		/* Single step past breakpoint at current address */
 		breakpoint = breakpoint_find(target, resume_pc);
 		if (breakpoint) {
-			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 " (ID: %" PRIu32 ")",
+			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx64 " (ID: %" PRIu32 ")",
 				breakpoint->address,
 				breakpoint->unique_id);
 			cortex_m_unset_breakpoint(target, breakpoint);
@@ -1182,7 +1182,7 @@ int cortex_m_set_breakpoint(struct target *target, struct breakpoint *breakpoint
 		breakpoint->set = true;
 	}
 
-	LOG_DEBUG("BPID: %" PRIu32 ", Type: %d, Address: 0x%08" PRIx32 " Length: %d (set=%d)",
+	LOG_DEBUG("BPID: %" PRIu32 ", Type: %d, Address: 0x%08" PRIx64 " Length: %d (set=%d)",
 		breakpoint->unique_id,
 		(int)(breakpoint->type),
 		breakpoint->address,
@@ -1203,7 +1203,7 @@ int cortex_m_unset_breakpoint(struct target *target, struct breakpoint *breakpoi
 		return ERROR_OK;
 	}
 
-	LOG_DEBUG("BPID: %" PRIu32 ", Type: %d, Address: 0x%08" PRIx32 " Length: %d (set=%d)",
+	LOG_DEBUG("BPID: %" PRIu32 ", Type: %d, Address: 0x%08" PRIx64 " Length: %d (set=%d)",
 		breakpoint->unique_id,
 		(int)(breakpoint->type),
 		breakpoint->address,
@@ -2285,18 +2285,31 @@ static const struct command_registration cortex_m_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io32 cortexm_target32 = {
+	.read_memory = cortex_m_read_memory,
+	.write_memory = cortex_m_write_memory,
+	.checksum_memory = armv7m_checksum_memory,
+	.blank_check_memory = armv7m_blank_check_memory,
+
+	.run_algorithm = armv7m_run_algorithm,
+	.start_algorithm = armv7m_start_algorithm,
+	.wait_algorithm = armv7m_wait_algorithm,
+	.step = cortex_m_step,
+	.resume = cortex_m_resume,
+};
+
 struct target_type cortexm_target = {
 	.name = "cortex_m",
 	.deprecated_name = "cortex_m3",
 
+	.pIo32_legacy_api = &cortexm_target32,
+	
 	.poll = cortex_m_poll,
 	.arch_state = armv7m_arch_state,
 
 	.target_request_data = cortex_m_target_request_data,
 
 	.halt = cortex_m_halt,
-	.resume = cortex_m_resume,
-	.step = cortex_m_step,
 
 	.assert_reset = cortex_m_assert_reset,
 	.deassert_reset = cortex_m_deassert_reset,
@@ -2304,14 +2317,6 @@ struct target_type cortexm_target = {
 
 	.get_gdb_reg_list = armv7m_get_gdb_reg_list,
 
-	.read_memory = cortex_m_read_memory,
-	.write_memory = cortex_m_write_memory,
-	.checksum_memory = armv7m_checksum_memory,
-	.blank_check_memory = armv7m_blank_check_memory,
-
-	.run_algorithm = armv7m_run_algorithm,
-	.start_algorithm = armv7m_start_algorithm,
-	.wait_algorithm = armv7m_wait_algorithm,
 
 	.add_breakpoint = cortex_m_add_breakpoint,
 	.remove_breakpoint = cortex_m_remove_breakpoint,
diff --git a/src/target/cortex_m.h b/src/target/cortex_m.h
old mode 100644
new mode 100755
diff --git a/src/target/dsp563xx.c b/src/target/dsp563xx.c
old mode 100644
new mode 100755
index 1cb18cf..243283d
--- a/src/target/dsp563xx.c
+++ b/src/target/dsp563xx.c
@@ -2305,29 +2305,34 @@ static const struct command_registration dsp563xx_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io32 dsp563xx_target32 = {
+	.read_memory = dsp563xx_read_memory_default,
+	.write_memory = dsp563xx_write_memory_default,
+
+	.read_buffer = dsp563xx_read_buffer_default,
+	.write_buffer = dsp563xx_write_buffer_default,
+
+	.run_algorithm = dsp563xx_run_algorithm,
+	.resume = dsp563xx_resume,
+	.step = dsp563xx_step,
+};
+
 /** Holds methods for DSP563XX targets. */
 struct target_type dsp563xx_target = {
 	.name = "dsp563xx",
 
+	.pIo32_legacy_api = &dsp563xx_target32,
+	
 	.poll = dsp563xx_poll,
 	.arch_state = dsp563xx_arch_state,
 
 	.get_gdb_reg_list = dsp563xx_get_gdb_reg_list,
 
 	.halt = dsp563xx_halt,
-	.resume = dsp563xx_resume,
-	.step = dsp563xx_step,
 
 	.assert_reset = dsp563xx_assert_reset,
 	.deassert_reset = dsp563xx_deassert_reset,
 
-	.read_memory = dsp563xx_read_memory_default,
-	.write_memory = dsp563xx_write_memory_default,
-
-	.read_buffer = dsp563xx_read_buffer_default,
-	.write_buffer = dsp563xx_write_buffer_default,
-
-	.run_algorithm = dsp563xx_run_algorithm,
 
 	.add_breakpoint = dsp563xx_add_breakpoint,
 	.remove_breakpoint = dsp563xx_remove_breakpoint,
diff --git a/src/target/dsp563xx.h b/src/target/dsp563xx.h
old mode 100644
new mode 100755
diff --git a/src/target/dsp563xx_once.c b/src/target/dsp563xx_once.c
old mode 100644
new mode 100755
diff --git a/src/target/dsp563xx_once.h b/src/target/dsp563xx_once.h
old mode 100644
new mode 100755
diff --git a/src/target/dsp5680xx.c b/src/target/dsp5680xx.c
old mode 100644
new mode 100755
index 8a58cab..5647f19
--- a/src/target/dsp5680xx.c
+++ b/src/target/dsp5680xx.c
@@ -2271,28 +2271,33 @@ static int dsp5680xx_step(struct target *target, int current, uint32_t address,
 		  "Not implemented yet.");
 }
 
+static struct target_io32 dsp5680x_target32 = {
+	.write_buffer = dsp5680xx_write_buffer,
+	.read_buffer = dsp5680xx_read_buffer,
+
+	.read_memory = dsp5680xx_read,
+	.write_memory = dsp5680xx_write,
+
+	.checksum_memory = dsp5680xx_checksum_memory,
+	.resume = dsp5680xx_resume,
+	.step = dsp5680xx_step,
+};
+
 /** Holds methods for dsp5680xx targets. */
 struct target_type dsp5680xx_target = {
 	.name = "dsp5680xx",
 
+	.pIo32_legacy_api = &dsp5680x_target32,
+	
 	.poll = dsp5680xx_poll,
 	.arch_state = dsp5680xx_arch_state,
 
 	.halt = dsp5680xx_halt,
-	.resume = dsp5680xx_resume,
-	.step = dsp5680xx_step,
-
-	.write_buffer = dsp5680xx_write_buffer,
-	.read_buffer = dsp5680xx_read_buffer,
 
 	.assert_reset = dsp5680xx_assert_reset,
 	.deassert_reset = dsp5680xx_deassert_reset,
 	.soft_reset_halt = dsp5680xx_soft_reset_halt,
 
-	.read_memory = dsp5680xx_read,
-	.write_memory = dsp5680xx_write,
-
-	.checksum_memory = dsp5680xx_checksum_memory,
 
 	.target_create = dsp5680xx_target_create,
 	.init_target = dsp5680xx_init_target,
diff --git a/src/target/dsp5680xx.h b/src/target/dsp5680xx.h
old mode 100644
new mode 100755
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
old mode 100644
new mode 100755
diff --git a/src/target/embeddedice.h b/src/target/embeddedice.h
old mode 100644
new mode 100755
diff --git a/src/target/etb.c b/src/target/etb.c
old mode 100644
new mode 100755
diff --git a/src/target/etb.h b/src/target/etb.h
old mode 100644
new mode 100755
diff --git a/src/target/etm.c b/src/target/etm.c
old mode 100644
new mode 100755
index 0c27bc3..65d80b2
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -1685,7 +1685,7 @@ COMMAND_HANDLER(handle_etm_image_command)
 	/* a base address isn't always necessary, default to 0x0 (i.e. don't relocate) */
 	if (CMD_ARGC >= 2) {
 		etm_ctx->image->base_address_set = 1;
-		COMMAND_PARSE_NUMBER(llong, CMD_ARGV[1], etm_ctx->image->base_address);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], etm_ctx->image->base_address);
 	} else
 		etm_ctx->image->base_address_set = 0;
 
diff --git a/src/target/etm.h b/src/target/etm.h
old mode 100644
new mode 100755
diff --git a/src/target/etm_dummy.c b/src/target/etm_dummy.c
old mode 100644
new mode 100755
diff --git a/src/target/etm_dummy.h b/src/target/etm_dummy.h
old mode 100644
new mode 100755
diff --git a/src/target/fa526.c b/src/target/fa526.c
old mode 100644
new mode 100755
index dfb29b8..7341bc4
--- a/src/target/fa526.c
+++ b/src/target/fa526.c
@@ -349,18 +349,31 @@ static int fa526_target_create(struct target *target, Jim_Interp *interp)
 	return fa526_init_arch_info(target, arm920t, target->tap);
 }
 
+static struct target_io32 fa526_target32 = {
+	.read_memory = arm920t_read_memory,
+	.write_memory = arm7_9_write_memory_opt,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+
+	.resume = arm7_9_resume,
+	.step = arm7_9_step,
+};
+
 /** Holds methods for FA526 targets. */
 struct target_type fa526_target = {
 	.name = "fa526",
 
+	.pIo32_legacy_api = &fa526_target32,
+	
 	.poll = arm7_9_poll,
 	.arch_state = arm920t_arch_state,
 
 	.target_request_data = arm7_9_target_request_data,
 
 	.halt = arm7_9_halt,
-	.resume = arm7_9_resume,
-	.step = arm7_9_step,
 
 	.assert_reset = arm7_9_assert_reset,
 	.deassert_reset = arm7_9_deassert_reset,
@@ -368,13 +381,6 @@ struct target_type fa526_target = {
 
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
-	.read_memory = arm920t_read_memory,
-	.write_memory = arm7_9_write_memory_opt,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
 
 	.add_breakpoint = arm7_9_add_breakpoint,
 	.remove_breakpoint = arm7_9_remove_breakpoint,
diff --git a/src/target/feroceon.c b/src/target/feroceon.c
old mode 100644
new mode 100755
index ee0bafd..45dff0f
--- a/src/target/feroceon.c
+++ b/src/target/feroceon.c
@@ -689,17 +689,30 @@ static int feroceon_examine(struct target *target)
 	return ERROR_OK;
 }
 
+static struct target_io32 feroceon_target32 = {
+	.read_memory = arm7_9_read_memory,
+	.write_memory = arm7_9_write_memory_opt,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+	.resume = arm7_9_resume,
+	.step = arm7_9_step,
+};
+
 struct target_type feroceon_target = {
 	.name = "feroceon",
 
+	.pIo32_legacy_api = &feroceon_target32,
+
+
 	.poll = arm7_9_poll,
 	.arch_state = arm926ejs_arch_state,
 
 	.target_request_data = arm7_9_target_request_data,
 
 	.halt = arm7_9_halt,
-	.resume = arm7_9_resume,
-	.step = arm7_9_step,
 
 	.assert_reset = feroceon_assert_reset,
 	.deassert_reset = arm7_9_deassert_reset,
@@ -707,14 +720,6 @@ struct target_type feroceon_target = {
 
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
-	.read_memory = arm7_9_read_memory,
-	.write_memory = arm7_9_write_memory_opt,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
-
 	.add_breakpoint = arm7_9_add_breakpoint,
 	.remove_breakpoint = arm7_9_remove_breakpoint,
 	.add_watchpoint = arm7_9_add_watchpoint,
@@ -726,17 +731,29 @@ struct target_type feroceon_target = {
 	.examine = feroceon_examine,
 };
 
+static struct target_io32 dragonite_target32 = {
+	.read_memory = arm7_9_read_memory,
+	.write_memory = arm7_9_write_memory_opt,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+
+	.run_algorithm = armv4_5_run_algorithm,
+	.step = arm7_9_step,
+	.resume = arm7_9_resume,
+};
+
 struct target_type dragonite_target = {
 	.name = "dragonite",
 
+	.pIo32_legacy_api = &dragonite_target32,
+	
 	.poll = arm7_9_poll,
 	.arch_state = arm_arch_state,
 
 	.target_request_data = arm7_9_target_request_data,
 
 	.halt = arm7_9_halt,
-	.resume = arm7_9_resume,
-	.step = arm7_9_step,
 
 	.assert_reset = feroceon_assert_reset,
 	.deassert_reset = arm7_9_deassert_reset,
@@ -744,13 +761,6 @@ struct target_type dragonite_target = {
 
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
-	.read_memory = arm7_9_read_memory,
-	.write_memory = arm7_9_write_memory_opt,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
 
 	.add_breakpoint = arm7_9_add_breakpoint,
 	.remove_breakpoint = arm7_9_remove_breakpoint,
diff --git a/src/target/hla_target.c b/src/target/hla_target.c
old mode 100644
new mode 100755
index efc0313..b3cbfec
--- a/src/target/hla_target.c
+++ b/src/target/hla_target.c
@@ -658,7 +658,7 @@ static int adapter_resume(struct target *target, int current,
 		/* Single step past breakpoint at current address */
 		breakpoint = breakpoint_find(target, resume_pc);
 		if (breakpoint) {
-			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 " (ID: %" PRIu32 ")",
+			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx64 " (ID: %" PRIu32 ")",
 					breakpoint->address,
 					breakpoint->unique_id);
 			cortex_m_unset_breakpoint(target, breakpoint);
@@ -789,10 +789,26 @@ static const struct command_registration adapter_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+
+static struct target_io32 hla_target32 = {
+	.read_memory = adapter_read_memory,
+	.write_memory = adapter_write_memory,
+	.checksum_memory = armv7m_checksum_memory,
+	.blank_check_memory = armv7m_blank_check_memory,
+	.run_algorithm = armv7m_run_algorithm,
+	.start_algorithm = armv7m_start_algorithm,
+	.wait_algorithm = armv7m_wait_algorithm,
+	.resume = adapter_resume,
+	.step = adapter_step,
+
+};
+
 struct target_type hla_target = {
 	.name = "hla_target",
 	.deprecated_name = "stm32_stlink",
 
+	.pIo32_legacy_api = &hla_target32,
+	
 	.init_target = adapter_init_target,
 	.target_create = adapter_target_create,
 	.examine = cortex_m_examine,
@@ -806,19 +822,10 @@ struct target_type hla_target = {
 	.deassert_reset = adapter_deassert_reset,
 
 	.halt = adapter_halt,
-	.resume = adapter_resume,
-	.step = adapter_step,
 
 	.get_gdb_reg_list = armv7m_get_gdb_reg_list,
 
-	.read_memory = adapter_read_memory,
-	.write_memory = adapter_write_memory,
-	.checksum_memory = armv7m_checksum_memory,
-	.blank_check_memory = armv7m_blank_check_memory,
 
-	.run_algorithm = armv7m_run_algorithm,
-	.start_algorithm = armv7m_start_algorithm,
-	.wait_algorithm = armv7m_wait_algorithm,
 
 	.add_breakpoint = cortex_m_add_breakpoint,
 	.remove_breakpoint = cortex_m_remove_breakpoint,
diff --git a/src/target/image.c b/src/target/image.c
old mode 100644
new mode 100755
index 07420b1..2246445
--- a/src/target/image.c
+++ b/src/target/image.c
@@ -123,8 +123,8 @@ static int image_ihex_buffer_complete_inner(struct image *image,
 {
 	struct image_ihex *ihex = image->type_private;
 	struct fileio *fileio = &ihex->fileio;
-	uint32_t full_address = 0x0;
-	uint32_t cooked_bytes;
+	uint64_t full_address = 0x0;
+	uint64_t cooked_bytes;
 	int i;
 
 	/* we can't determine the number of sections that we'll have to create ahead of time,
@@ -465,8 +465,8 @@ static int image_elf_read_headers(struct image *image)
 
 static int image_elf_read_section(struct image *image,
 	int section,
-	uint32_t offset,
-	uint32_t size,
+	uint64_t offset,
+	uint64_t size,
 	uint8_t *buffer,
 	size_t *size_read)
 {
@@ -477,13 +477,13 @@ static int image_elf_read_section(struct image *image,
 
 	*size_read = 0;
 
-	LOG_DEBUG("load segment %d at 0x%" PRIx32 " (sz = 0x%" PRIx32 ")", section, offset, size);
+	LOG_DEBUG("load segment %d at 0x%" PRIx64 " (sz = 0x%" PRIx64 ")", section, offset, size);
 
 	/* read initialized data in current segment if any */
 	if (offset < field32(elf, segment->p_filesz)) {
 		/* maximal size present in file for the current segment */
 		read_size = MIN(size, field32(elf, segment->p_filesz) - offset);
-		LOG_DEBUG("read elf: size = 0x%zu at 0x%" PRIx32 "", read_size,
+		LOG_DEBUG("read elf: size = 0x%zu at 0x%" PRIx64 "", read_size,
 			field32(elf, segment->p_offset) + offset);
 		/* read initialized area of the segment */
 		retval = fileio_seek(&elf->fileio, field32(elf, segment->p_offset) + offset);
@@ -809,8 +809,8 @@ int image_open(struct image *image, const char *url, const char *type_string)
 
 int image_read_section(struct image *image,
 	int section,
-	uint32_t offset,
-	uint32_t size,
+	uint64_t offset,
+	uint64_t size,
 	uint8_t *buffer,
 	size_t *size_read)
 {
@@ -819,7 +819,7 @@ int image_read_section(struct image *image,
 	/* don't read past the end of a section */
 	if (offset + size > image->sections[section].size) {
 		LOG_DEBUG(
-			"read past end of section: 0x%8.8" PRIx32 " + 0x%8.8" PRIx32 " > 0x%8.8" PRIx32 "",
+			"read past end of section: 0x%8.8" PRIx64 " + 0x%8.8" PRIx64 " > 0x%8.8" PRIx64 "",
 			offset,
 			size,
 			image->sections[section].size);
@@ -851,12 +851,12 @@ int image_read_section(struct image *image,
 		return image_elf_read_section(image, section, offset, size, buffer, size_read);
 	else if (image->type == IMAGE_MEMORY) {
 		struct image_memory *image_memory = image->type_private;
-		uint32_t address = image->sections[section].base_address + offset;
+		uint64_t address = image->sections[section].base_address + offset;
 
 		*size_read = 0;
 
 		while ((size - *size_read) > 0) {
-			uint32_t size_in_cache;
+			uint64_t size_in_cache;
 
 			if (!image_memory->cache
 				|| (address < image_memory->cache_address)
@@ -902,7 +902,7 @@ int image_read_section(struct image *image,
 	return ERROR_OK;
 }
 
-int image_add_section(struct image *image, uint32_t base, uint32_t size, int flags, uint8_t const *data)
+int image_add_section(struct image *image, uint64_t base, uint64_t size, int flags, uint8_t const *data)
 {
 	struct imagesection *section;
 
@@ -1004,7 +1004,7 @@ void image_close(struct image *image)
 	}
 }
 
-int image_calculate_checksum(uint8_t *buffer, uint32_t nbytes, uint32_t *checksum)
+int image_calculate_checksum(uint8_t *buffer, uint64_t nbytes, uint32_t *checksum)
 {
 	uint32_t crc = 0xffffffff;
 	LOG_DEBUG("Calculating checksum");
@@ -1043,3 +1043,8 @@ int image_calculate_checksum(uint8_t *buffer, uint32_t nbytes, uint32_t *checksu
 	*checksum = crc;
 	return ERROR_OK;
 }
+
+void image_init( struct image *pImage )
+{
+	memset( pImage, 0, sizeof( *pImage ) );
+}
diff --git a/src/target/image.h b/src/target/image.h
old mode 100644
new mode 100755
index 5aeba2f..4167b70
--- a/src/target/image.h
+++ b/src/target/image.h
@@ -43,13 +43,14 @@ enum image_type {
 	IMAGE_IHEX,		/* intel hex-record format */
 	IMAGE_MEMORY,	/* target-memory pseudo-image */
 	IMAGE_ELF,		/* ELF binary */
+/* FIXME: ADD ELF64! */
 	IMAGE_SRECORD,	/* motorola s19 */
 	IMAGE_BUILDER,	/* when building a new image */
 };
 
 struct imagesection {
-	uint32_t base_address;
-	uint32_t size;
+	uint64_t base_address;
+	uint64_t size;
 	int flags;
 	void *private;		/* private data */
 };
@@ -60,9 +61,9 @@ struct image {
 	int num_sections;		/* number of sections contained in the image */
 	struct imagesection *sections;	/* array of sections */
 	int base_address_set;	/* whether the image has a base address set (for relocation purposes) */
-	long long base_address;		/* base address, if one is set */
+	uint64_t base_address;		/* base address, if one is set */
 	int start_address_set;	/* whether the image has a start address (entry point) associated */
-	uint32_t start_address;		/* start address, if one is set */
+	uint64_t start_address;		/* start address, if one is set */
 };
 
 struct image_binary {
@@ -77,7 +78,7 @@ struct image_ihex {
 struct image_memory {
 	struct target *target;
 	uint8_t *cache;
-	uint32_t cache_address;
+	uint64_t cache_address;
 };
 
 struct image_elf {
@@ -94,14 +95,14 @@ struct image_mot {
 };
 
 int image_open(struct image *image, const char *url, const char *type_string);
-int image_read_section(struct image *image, int section, uint32_t offset,
-		uint32_t size, uint8_t *buffer, size_t *size_read);
+int image_read_section(struct image *image, int section, uint64_t offset,
+		uint64_t size, uint8_t *buffer, size_t *size_read);
 void image_close(struct image *image);
 
-int image_add_section(struct image *image, uint32_t base, uint32_t size,
+int image_add_section(struct image *image, uint64_t base, uint64_t size,
 		int flags, uint8_t const *data);
 
-int image_calculate_checksum(uint8_t *buffer, uint32_t nbytes,
+int image_calculate_checksum(uint8_t *buffer, uint64_t nbytes,
 		uint32_t *checksum);
 
 #define ERROR_IMAGE_FORMAT_ERROR	(-1400)
diff --git a/src/target/lakemont.c b/src/target/lakemont.c
old mode 100644
new mode 100755
diff --git a/src/target/lakemont.h b/src/target/lakemont.h
old mode 100644
new mode 100755
diff --git a/src/target/mips32.c b/src/target/mips32.c
old mode 100644
new mode 100755
diff --git a/src/target/mips32.h b/src/target/mips32.h
old mode 100644
new mode 100755
diff --git a/src/target/mips32_dmaacc.c b/src/target/mips32_dmaacc.c
old mode 100644
new mode 100755
diff --git a/src/target/mips32_dmaacc.h b/src/target/mips32_dmaacc.h
old mode 100644
new mode 100755
diff --git a/src/target/mips32_pracc.c b/src/target/mips32_pracc.c
old mode 100644
new mode 100755
index e97626c..68131a8
--- a/src/target/mips32_pracc.c
+++ b/src/target/mips32_pracc.c
@@ -1034,7 +1034,7 @@ int mips32_pracc_fastdata_xfer(struct mips_ejtag *ejtag_info, struct working_are
 		ejtag_info->fast_access_save = write_t;
 	}
 
-	LOG_DEBUG("%s using 0x%.8" PRIx32 " for write handler", __func__, source->address);
+	LOG_DEBUG("%s using 0x%.8" PRIx64 " for write handler", __func__, source->address);
 
 	jmp_code[0] |= UPPER16(source->address);
 	jmp_code[1] |= LOWER16(source->address);
diff --git a/src/target/mips32_pracc.h b/src/target/mips32_pracc.h
old mode 100644
new mode 100755
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
old mode 100644
new mode 100755
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
old mode 100644
new mode 100755
diff --git a/src/target/mips_m4k.c b/src/target/mips_m4k.c
old mode 100644
new mode 100755
index 5b740cc..529b155
--- a/src/target/mips_m4k.c
+++ b/src/target/mips_m4k.c
@@ -464,7 +464,7 @@ static int mips_m4k_internal_restore(struct target *target, int current,
 		/* Single step past breakpoint at current address */
 		breakpoint = breakpoint_find(target, resume_pc);
 		if (breakpoint) {
-			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
+			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx64 "", breakpoint->address);
 			mips_m4k_unset_breakpoint(target, breakpoint);
 			mips_m4k_single_step_core(target);
 			mips_m4k_set_breakpoint(target, breakpoint);
@@ -650,7 +650,7 @@ static int mips_m4k_set_breakpoint(struct target *target,
 			if (retval != ERROR_OK)
 				return retval;
 			if (verify != MIPS32_SDBBP) {
-				LOG_ERROR("Unable to set 32bit breakpoint at address %08" PRIx32
+				LOG_ERROR("Unable to set 32bit breakpoint at address %08" PRIx64
 						" - check that memory is read/writable", breakpoint->address);
 				return ERROR_OK;
 			}
@@ -669,7 +669,7 @@ static int mips_m4k_set_breakpoint(struct target *target,
 			if (retval != ERROR_OK)
 				return retval;
 			if (verify != MIPS16_SDBBP) {
-				LOG_ERROR("Unable to set 16bit breakpoint at address %08" PRIx32
+				LOG_ERROR("Unable to set 16bit breakpoint at address %08" PRIx64
 						" - check that memory is read/writable", breakpoint->address);
 				return ERROR_OK;
 			}
@@ -1170,7 +1170,7 @@ static int mips_m4k_bulk_write_memory(struct target *target, uint32_t address,
 
 	if (address <= fast_data_area->address + fast_data_area->size &&
 			fast_data_area->address <= address + count) {
-		LOG_ERROR("fast_data (0x%8.8" PRIx32 ") is within write area "
+		LOG_ERROR("fast_data (0x%8.8" PRIx64 ") is within write area "
 			  "(0x%8.8" PRIx32 "-0x%8.8" PRIx32 ").",
 			  fast_data_area->address, address, address + count);
 		LOG_ERROR("Change work-area-phys or load_image address!");
@@ -1398,27 +1398,32 @@ const struct command_registration mips_m4k_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io32 mips_m4k_target32 = {
+	.read_memory = mips_m4k_read_memory,
+	.write_memory = mips_m4k_write_memory,
+	.checksum_memory = mips32_checksum_memory,
+	.blank_check_memory = mips32_blank_check_memory,
+
+	.run_algorithm = mips32_run_algorithm,
+	.resume = mips_m4k_resume,
+	.step = mips_m4k_step,
+};
+
 struct target_type mips_m4k_target = {
 	.name = "mips_m4k",
 
+	.pIo32_legacy_api = &mips_m4k_target32,
+	
 	.poll = mips_m4k_poll,
 	.arch_state = mips32_arch_state,
 
 	.halt = mips_m4k_halt,
-	.resume = mips_m4k_resume,
-	.step = mips_m4k_step,
 
 	.assert_reset = mips_m4k_assert_reset,
 	.deassert_reset = mips_m4k_deassert_reset,
 
 	.get_gdb_reg_list = mips32_get_gdb_reg_list,
 
-	.read_memory = mips_m4k_read_memory,
-	.write_memory = mips_m4k_write_memory,
-	.checksum_memory = mips32_checksum_memory,
-	.blank_check_memory = mips32_blank_check_memory,
-
-	.run_algorithm = mips32_run_algorithm,
 
 	.add_breakpoint = mips_m4k_add_breakpoint,
 	.remove_breakpoint = mips_m4k_remove_breakpoint,
diff --git a/src/target/mips_m4k.h b/src/target/mips_m4k.h
old mode 100644
new mode 100755
diff --git a/src/target/nds32.c b/src/target/nds32.c
old mode 100644
new mode 100755
index 8ab2859..41e78b1
--- a/src/target/nds32.c
+++ b/src/target/nds32.c
@@ -1450,7 +1450,7 @@ int nds32_add_software_breakpoint(struct target *target,
 	uint32_t break_insn;
 
 	/* check the breakpoint size */
-	target->type->read_buffer(target, breakpoint->address, 4, (uint8_t *)&data);
+	target_read_buffer( target, breakpoint->address, 4, (uint8_t *)&data);
 
 	/* backup origin instruction
 	 * instruction is big-endian */
@@ -1469,12 +1469,12 @@ int nds32_add_software_breakpoint(struct target *target,
 	memcpy(breakpoint->orig_instr, &data, breakpoint->length);
 
 	/* self-modified code */
-	target->type->write_buffer(target, breakpoint->address, breakpoint->length, (const uint8_t *)&break_insn);
+	target_write_buffer(target, breakpoint->address, breakpoint->length, (const uint8_t *)&break_insn);
 	/* write_back & invalidate dcache & invalidate icache */
 	nds32_cache_sync(target, breakpoint->address, breakpoint->length);
 
 	/* read back to check */
-	target->type->read_buffer(target, breakpoint->address, breakpoint->length, (uint8_t *)&check_data);
+	target_read_buffer(target, breakpoint->address, breakpoint->length, (uint8_t *)&check_data);
 	if (memcmp(&check_data, &break_insn, breakpoint->length) == 0)
 		return ERROR_OK;
 
@@ -1494,7 +1494,7 @@ int nds32_remove_software_breakpoint(struct target *target,
 	else
 		return ERROR_FAIL;
 
-	target->type->read_buffer(target, breakpoint->address, breakpoint->length,
+	target_read_buffer(target, breakpoint->address, breakpoint->length,
 			(uint8_t *)&check_data);
 
 	/* break instruction is modified */
@@ -1502,7 +1502,7 @@ int nds32_remove_software_breakpoint(struct target *target,
 		return ERROR_FAIL;
 
 	/* self-modified code */
-	target->type->write_buffer(target, breakpoint->address, breakpoint->length,
+	target_write_buffer(target, breakpoint->address, breakpoint->length,
 			breakpoint->orig_instr);
 
 	/* write_back & invalidate dcache & invalidate icache */
@@ -1735,7 +1735,7 @@ int nds32_cache_sync(struct target *target, uint32_t address, uint32_t length)
 			 * be physical address.  L1I_VA_INVALIDATE uses PSW.IT to decide
 			 * address translation or not. */
 			uint32_t physical_addr;
-			if (ERROR_FAIL == target->type->virt2phys(target, cur_address,
+			if (ERROR_FAIL == target_virt2phys(target, cur_address,
 						&physical_addr))
 				return ERROR_FAIL;
 
@@ -2344,7 +2344,7 @@ int nds32_get_gdb_fileio_info(struct target *target, struct gdb_fileio_info *fil
 				nds32_get_mapped_reg(nds32, R1, &(fileio_info->param_3));
 				nds32_get_mapped_reg(nds32, R2, &(fileio_info->param_4));
 
-				target->type->read_buffer(target, fileio_info->param_1,
+				target_read_buffer(target, fileio_info->param_1,
 						256, filename);
 				fileio_info->param_2 = strlen((char *)filename) + 1;
 			}
@@ -2383,7 +2383,7 @@ int nds32_get_gdb_fileio_info(struct target *target, struct gdb_fileio_info *fil
 				nds32_get_mapped_reg(nds32, R0, &(fileio_info->param_1));
 				/* reserve fileio_info->param_2 for length of path */
 
-				target->type->read_buffer(target, fileio_info->param_1,
+				target_read_buffer(target, fileio_info->param_1,
 						256, filename);
 				fileio_info->param_2 = strlen((char *)filename) + 1;
 			}
@@ -2398,11 +2398,11 @@ int nds32_get_gdb_fileio_info(struct target *target, struct gdb_fileio_info *fil
 				nds32_get_mapped_reg(nds32, R1, &(fileio_info->param_3));
 				/* reserve fileio_info->param_4 for length of new path */
 
-				target->type->read_buffer(target, fileio_info->param_1,
+				target_read_buffer(target, fileio_info->param_1,
 						256, filename);
 				fileio_info->param_2 = strlen((char *)filename) + 1;
 
-				target->type->read_buffer(target, fileio_info->param_3,
+				target_read_buffer(target, fileio_info->param_3,
 						256, filename);
 				fileio_info->param_4 = strlen((char *)filename) + 1;
 			}
@@ -2422,7 +2422,7 @@ int nds32_get_gdb_fileio_info(struct target *target, struct gdb_fileio_info *fil
 				/* reserve fileio_info->param_2 for length of old path */
 				nds32_get_mapped_reg(nds32, R1, &(fileio_info->param_3));
 
-				target->type->read_buffer(target, fileio_info->param_1,
+				target_read_buffer(target, fileio_info->param_1,
 						256, filename);
 				fileio_info->param_2 = strlen((char *)filename) + 1;
 			}
@@ -2446,7 +2446,7 @@ int nds32_get_gdb_fileio_info(struct target *target, struct gdb_fileio_info *fil
 				nds32_get_mapped_reg(nds32, R0, &(fileio_info->param_1));
 				/* reserve fileio_info->param_2 for length of old path */
 
-				target->type->read_buffer(target, fileio_info->param_1,
+				target_read_buffer(target, fileio_info->param_1,
 						256, command);
 				fileio_info->param_2 = strlen((char *)command) + 1;
 			}
diff --git a/src/target/nds32.h b/src/target/nds32.h
old mode 100644
new mode 100755
diff --git a/src/target/nds32_aice.c b/src/target/nds32_aice.c
old mode 100644
new mode 100755
diff --git a/src/target/nds32_aice.h b/src/target/nds32_aice.h
old mode 100644
new mode 100755
diff --git a/src/target/nds32_cmd.c b/src/target/nds32_cmd.c
old mode 100644
new mode 100755
diff --git a/src/target/nds32_cmd.h b/src/target/nds32_cmd.h
old mode 100644
new mode 100755
diff --git a/src/target/nds32_disassembler.c b/src/target/nds32_disassembler.c
old mode 100644
new mode 100755
diff --git a/src/target/nds32_disassembler.h b/src/target/nds32_disassembler.h
old mode 100644
new mode 100755
diff --git a/src/target/nds32_edm.h b/src/target/nds32_edm.h
old mode 100644
new mode 100755
diff --git a/src/target/nds32_insn.h b/src/target/nds32_insn.h
old mode 100644
new mode 100755
diff --git a/src/target/nds32_reg.c b/src/target/nds32_reg.c
old mode 100644
new mode 100755
diff --git a/src/target/nds32_reg.h b/src/target/nds32_reg.h
old mode 100644
new mode 100755
diff --git a/src/target/nds32_tlb.c b/src/target/nds32_tlb.c
old mode 100644
new mode 100755
diff --git a/src/target/nds32_tlb.h b/src/target/nds32_tlb.h
old mode 100644
new mode 100755
diff --git a/src/target/nds32_v2.c b/src/target/nds32_v2.c
old mode 100644
new mode 100755
index ac2aad0..7d4f3fb
--- a/src/target/nds32_v2.c
+++ b/src/target/nds32_v2.c
@@ -114,7 +114,7 @@ static int nds32_v2_activate_hardware_breakpoint(struct target *target)
 				/* enable breakpoint (physical address) */
 				aice_write_debug_reg(aice, NDS_EDM_SR_BPC0 + hbr_index, 0xA);
 
-			LOG_DEBUG("Add hardware BP %" PRId32 " at %08" PRIx32, hbr_index,
+			LOG_DEBUG("Add hardware BP %" PRId32 " at %08" PRIx64, hbr_index,
 					bp->address);
 
 			hbr_index++;
@@ -141,7 +141,7 @@ static int nds32_v2_deactivate_hardware_breakpoint(struct target *target)
 		else
 			return ERROR_FAIL;
 
-		LOG_DEBUG("Remove hardware BP %" PRId32 " at %08" PRIx32, hbr_index,
+		LOG_DEBUG("Remove hardware BP %" PRId32 " at %08" PRIx64, hbr_index,
 				bp->address);
 
 		hbr_index++;
@@ -186,7 +186,7 @@ static int nds32_v2_activate_hardware_watchpoint(struct target *target)
 		/* set value */
 		aice_write_debug_reg(aice, NDS_EDM_SR_BPV0 + wp_num, 0);
 
-		LOG_DEBUG("Add hardware wathcpoint %" PRId32 " at %08" PRIx32 " mask %08" PRIx32, wp_num,
+		LOG_DEBUG("Add hardware wathcpoint %" PRId32 " at %08" PRIx64 " mask %08" PRIx32, wp_num,
 				wp->address, wp->mask);
 
 	}
@@ -206,7 +206,7 @@ static int nds32_v2_deactivate_hardware_watchpoint(struct target *target)
 		/* disable watchpoint */
 		aice_write_debug_reg(aice, NDS_EDM_SR_BPC0 + wp_num, 0x0);
 
-		LOG_DEBUG("Remove hardware wathcpoint %" PRId32 " at %08" PRIx32 " mask %08" PRIx32,
+		LOG_DEBUG("Remove hardware wathcpoint %" PRId32 " at %08" PRIx64 " mask %08" PRIx32,
 				wp_num, wp->address, wp->mask);
 	}
 
@@ -649,7 +649,7 @@ static int nds32_v2_translate_address(struct target *target, uint32_t *address)
 	if ((NDS_MEMORY_ACC_BUS == memory->access_channel) ||
 			((NDS_MEMORY_ACC_CPU == memory->access_channel) &&
 			 nds32_reach_max_interrupt_level(nds32))) {
-		if (ERROR_OK == target->type->virt2phys(target, *address, &physical_address))
+		if (ERROR_OK == target_virt2phys(target, *address, &physical_address))
 			*address = physical_address;
 		else
 			return ERROR_FAIL;
@@ -738,9 +738,28 @@ static int nds32_v2_write_memory(struct target *target, uint32_t address,
 	return nds32_write_memory(target, address, size, count, buffer);
 }
 
+static struct target_io32 nds32_v2_target32 = {
+	/* memory access */
+	.read_buffer = nds32_v2_read_buffer,
+	.write_buffer = nds32_v2_write_buffer,
+	.read_memory = nds32_v2_read_memory,
+	.write_memory = nds32_v2_write_memory,
+
+	.checksum_memory = nds32_v2_checksum_memory,
+	.virt2phys = nds32_virtual_to_physical,
+	.read_phys_memory = nds32_read_phys_memory,
+	.write_phys_memory = nds32_write_phys_memory,
+	.resume = nds32_resume,
+	.step = nds32_step,
+	.run_algorithm = nds32_v2_run_algorithm,
+
+};
+
 /** Holds methods for V2 targets. */
 struct target_type nds32_v2_target = {
 	.name = "nds32_v2",
+	
+	.pIo32_legacy_api = &nds32_v2_target32,
 
 	.poll = nds32_poll,
 	.arch_state = nds32_arch_state,
@@ -748,8 +767,6 @@ struct target_type nds32_v2_target = {
 	.target_request_data = nds32_v2_target_request_data,
 
 	.halt = nds32_halt,
-	.resume = nds32_resume,
-	.step = nds32_step,
 
 	.assert_reset = nds32_assert_reset,
 	.deassert_reset = nds32_v2_deassert_reset,
@@ -757,13 +774,6 @@ struct target_type nds32_v2_target = {
 	/* register access */
 	.get_gdb_reg_list = nds32_get_gdb_reg_list,
 
-	/* memory access */
-	.read_buffer = nds32_v2_read_buffer,
-	.write_buffer = nds32_v2_write_buffer,
-	.read_memory = nds32_v2_read_memory,
-	.write_memory = nds32_v2_write_memory,
-
-	.checksum_memory = nds32_v2_checksum_memory,
 
 	/* breakpoint/watchpoint */
 	.add_breakpoint = nds32_v2_add_breakpoint,
@@ -774,11 +784,7 @@ struct target_type nds32_v2_target = {
 
 	/* MMU */
 	.mmu = nds32_mmu,
-	.virt2phys = nds32_virtual_to_physical,
-	.read_phys_memory = nds32_read_phys_memory,
-	.write_phys_memory = nds32_write_phys_memory,
 
-	.run_algorithm = nds32_v2_run_algorithm,
 
 	.commands = nds32_command_handlers,
 	.target_create = nds32_v2_target_create,
diff --git a/src/target/nds32_v2.h b/src/target/nds32_v2.h
old mode 100644
new mode 100755
diff --git a/src/target/nds32_v3.c b/src/target/nds32_v3.c
old mode 100644
new mode 100755
index 2246650..336a9d5
--- a/src/target/nds32_v3.c
+++ b/src/target/nds32_v3.c
@@ -55,7 +55,7 @@ static int nds32_v3_activate_hardware_breakpoint(struct target *target)
 				/* enable breakpoint (physical address) */
 				aice_write_debug_reg(aice, NDS_EDM_SR_BPC0 + hbr_index, 0xA);
 
-			LOG_DEBUG("Add hardware BP %" PRId32 " at %08" PRIx32, hbr_index,
+			LOG_DEBUG("Add hardware BP %" PRId32 " at %08" PRIx64, hbr_index,
 					bp->address);
 		} else {
 			return ERROR_FAIL;
@@ -83,7 +83,7 @@ static int nds32_v3_deactivate_hardware_breakpoint(struct target *target)
 			return ERROR_FAIL;
 		}
 
-		LOG_DEBUG("Remove hardware BP %" PRId32 " at %08" PRIx32, hbr_index,
+		LOG_DEBUG("Remove hardware BP %" PRId32 " at %08" PRIx64, hbr_index,
 				bp->address);
 	}
 
@@ -130,7 +130,7 @@ static int nds32_v3_activate_hardware_watchpoint(struct target *target)
 			/* set value */
 			aice_write_debug_reg(aice, NDS_EDM_SR_BPV0 + wp_num, 0);
 
-			LOG_DEBUG("Add hardware wathcpoint %" PRId32 " at %08" PRIx32 " mask %08" PRIx32,
+			LOG_DEBUG("Add hardware wathcpoint %" PRId32 " at %08" PRIx64 " mask %08" PRIx32,
 					wp_num, wp->address, wp->mask);
 
 			wp_num++;
@@ -171,7 +171,7 @@ static int nds32_v3_deactivate_hardware_watchpoint(struct target *target)
 			/* disable watchpoint */
 			aice_write_debug_reg(aice, NDS_EDM_SR_BPC0 + wp_num, 0x0);
 
-			LOG_DEBUG("Remove hardware wathcpoint %" PRId32 " at %08" PRIx32
+			LOG_DEBUG("Remove hardware wathcpoint %" PRId32 " at %08" PRIx64
 					" mask %08" PRIx32, wp_num,
 					wp->address, wp->mask);
 			wp_num++;
@@ -469,18 +469,35 @@ static int nds32_v3_examine(struct target *target)
 	return ERROR_OK;
 }
 
+static struct target_io32 nds32_v3_target32 = {
+	/* memory access */
+	.read_buffer = nds32_v3_read_buffer,
+	.write_buffer = nds32_v3_write_buffer,
+	.read_memory = nds32_v3_read_memory,
+	.write_memory = nds32_v3_write_memory,
+
+	.checksum_memory = nds32_v3_checksum_memory,
+	.virt2phys = nds32_virtual_to_physical,
+	.read_phys_memory = nds32_read_phys_memory,
+	.write_phys_memory = nds32_write_phys_memory,
+
+	.run_algorithm = nds32_v3_run_algorithm,
+	.resume = nds32_resume,
+	.step = nds32_step,
+};
+
 /** Holds methods for Andes1337 targets. */
 struct target_type nds32_v3_target = {
 	.name = "nds32_v3",
 
+	.pIo32_legacy_api = &nds32_v3_target32,
+	
 	.poll = nds32_poll,
 	.arch_state = nds32_arch_state,
 
 	.target_request_data = nds32_v3_target_request_data,
 
 	.halt = nds32_halt,
-	.resume = nds32_resume,
-	.step = nds32_step,
 
 	.assert_reset = nds32_assert_reset,
 	.deassert_reset = nds32_v3_deassert_reset,
@@ -488,13 +505,6 @@ struct target_type nds32_v3_target = {
 	/* register access */
 	.get_gdb_reg_list = nds32_get_gdb_reg_list,
 
-	/* memory access */
-	.read_buffer = nds32_v3_read_buffer,
-	.write_buffer = nds32_v3_write_buffer,
-	.read_memory = nds32_v3_read_memory,
-	.write_memory = nds32_v3_write_memory,
-
-	.checksum_memory = nds32_v3_checksum_memory,
 
 	/* breakpoint/watchpoint */
 	.add_breakpoint = nds32_v3_add_breakpoint,
@@ -505,11 +515,6 @@ struct target_type nds32_v3_target = {
 
 	/* MMU */
 	.mmu = nds32_mmu,
-	.virt2phys = nds32_virtual_to_physical,
-	.read_phys_memory = nds32_read_phys_memory,
-	.write_phys_memory = nds32_write_phys_memory,
-
-	.run_algorithm = nds32_v3_run_algorithm,
 
 	.commands = nds32_command_handlers,
 	.target_create = nds32_v3_target_create,
diff --git a/src/target/nds32_v3.h b/src/target/nds32_v3.h
old mode 100644
new mode 100755
diff --git a/src/target/nds32_v3_common.c b/src/target/nds32_v3_common.c
old mode 100644
new mode 100755
index 6dc2098..f39101b
--- a/src/target/nds32_v3_common.c
+++ b/src/target/nds32_v3_common.c
@@ -476,7 +476,7 @@ int nds32_v3_read_buffer(struct target *target, uint32_t address,
 	 * Because hardware will turn off IT/DT by default, it MUST translate virtual address
 	 * to physical address.
 	 */
-	if (ERROR_OK == target->type->virt2phys(target, address, &physical_address))
+	if (ERROR_OK == target_virt2phys(target, address, &physical_address))
 		address = physical_address;
 	else
 		return ERROR_FAIL;
@@ -534,7 +534,7 @@ int nds32_v3_write_buffer(struct target *target, uint32_t address,
 	 * Because hardware will turn off IT/DT by default, it MUST translate virtual address
 	 * to physical address.
 	 */
-	if (ERROR_OK == target->type->virt2phys(target, address, &physical_address))
+	if (ERROR_OK == target_virt2phys(target, address, &physical_address))
 		address = physical_address;
 	else
 		return ERROR_FAIL;
@@ -596,7 +596,7 @@ int nds32_v3_read_memory(struct target *target, uint32_t address,
 	 * Because hardware will turn off IT/DT by default, it MUST translate virtual address
 	 * to physical address.
 	 */
-	if (ERROR_OK == target->type->virt2phys(target, address, &physical_address))
+	if (ERROR_OK == target_virt2phys(target, address, &physical_address))
 		address = physical_address;
 	else
 		return ERROR_FAIL;
@@ -654,7 +654,7 @@ int nds32_v3_write_memory(struct target *target, uint32_t address,
 	 * Because hardware will turn off IT/DT by default, it MUST translate virtual address
 	 * to physical address.
 	 */
-	if (ERROR_OK == target->type->virt2phys(target, address, &physical_address))
+	if (ERROR_OK == target_virt2phys(target, address, &physical_address))
 		address = physical_address;
 	else
 		return ERROR_FAIL;
diff --git a/src/target/nds32_v3_common.h b/src/target/nds32_v3_common.h
old mode 100644
new mode 100755
diff --git a/src/target/nds32_v3m.c b/src/target/nds32_v3m.c
old mode 100644
new mode 100755
index accc8d0..0795de2
--- a/src/target/nds32_v3m.c
+++ b/src/target/nds32_v3m.c
@@ -52,7 +52,7 @@ static int nds32_v3m_activate_hardware_breakpoint(struct target *target)
 				/* enable breakpoint (physical address) */
 				aice_write_debug_reg(aice, NDS_EDM_SR_BPC0 + brp_num, 0xA);
 
-			LOG_DEBUG("Add hardware BP %u at %08" PRIx32, brp_num,
+			LOG_DEBUG("Add hardware BP %u at %08" PRIx64, brp_num,
 					bp->address);
 
 			brp_num--;
@@ -80,7 +80,7 @@ static int nds32_v3m_deactivate_hardware_breakpoint(struct target *target)
 		else
 			return ERROR_FAIL;
 
-		LOG_DEBUG("Remove hardware BP %u at %08" PRIx32, brp_num,
+		LOG_DEBUG("Remove hardware BP %u at %08" PRIx64, brp_num,
 				bp->address);
 
 		brp_num--;
@@ -127,7 +127,7 @@ static int nds32_v3m_activate_hardware_watchpoint(struct target *target)
 			/* enable watchpoint */
 			aice_write_debug_reg(aice, NDS_EDM_SR_BPC0 + wp_num, wp_config);
 
-			LOG_DEBUG("Add hardware wathcpoint %" PRId32 " at %08" PRIx32
+			LOG_DEBUG("Add hardware wathcpoint %" PRId32 " at %08" PRIx64
 					" mask %08" PRIx32, wp_num, wp->address, wp->mask);
 
 			wp_num++;
@@ -168,7 +168,7 @@ static int nds32_v3m_deactivate_hardware_watchpoint(struct target *target)
 			/* disable watchpoint */
 			aice_write_debug_reg(aice, NDS_EDM_SR_BPC0 + wp_num, 0x0);
 
-			LOG_DEBUG("Remove hardware wathcpoint %" PRId32 " at %08" PRIx32
+			LOG_DEBUG("Remove hardware wathcpoint %" PRId32 " at %08" PRIx64
 					" mask %08" PRIx32, wp_num, wp->address, wp->mask);
 			wp_num++;
 		} else if (nds32_v3m->nds32.global_stop) {
@@ -456,18 +456,39 @@ static int nds32_v3m_examine(struct target *target)
 	return ERROR_OK;
 }
 
+
+static struct target_io32 nds32_v3m_target32 = {
+	/* memory access */
+	.read_buffer = nds32_v3_read_buffer,
+	.write_buffer = nds32_v3_write_buffer,
+	.read_memory = nds32_v3_read_memory,
+	.write_memory = nds32_v3_write_memory,
+
+	.checksum_memory = nds32_v3_checksum_memory,
+
+	.virt2phys = nds32_virtual_to_physical,
+	.read_phys_memory = nds32_read_phys_memory,
+	.write_phys_memory = nds32_write_phys_memory,
+
+	.run_algorithm = nds32_v3_run_algorithm,
+
+	.resume = nds32_resume,
+	.step = nds32_step,
+	
+};
+
 /** Holds methods for NDS32 V3m targets. */
 struct target_type nds32_v3m_target = {
 	.name = "nds32_v3m",
 
+	.pIo32_legacy_api = &nds32_v3m_target32,
+
 	.poll = nds32_poll,
 	.arch_state = nds32_arch_state,
 
 	.target_request_data = nds32_v3_target_request_data,
 
 	.halt = nds32_halt,
-	.resume = nds32_resume,
-	.step = nds32_step,
 
 	.assert_reset = nds32_assert_reset,
 	.deassert_reset = nds32_v3m_deassert_reset,
@@ -475,13 +496,6 @@ struct target_type nds32_v3m_target = {
 	/* register access */
 	.get_gdb_reg_list = nds32_get_gdb_reg_list,
 
-	/* memory access */
-	.read_buffer = nds32_v3_read_buffer,
-	.write_buffer = nds32_v3_write_buffer,
-	.read_memory = nds32_v3_read_memory,
-	.write_memory = nds32_v3_write_memory,
-
-	.checksum_memory = nds32_v3_checksum_memory,
 
 	/* breakpoint/watchpoint */
 	.add_breakpoint = nds32_v3m_add_breakpoint,
@@ -492,11 +506,6 @@ struct target_type nds32_v3m_target = {
 
 	/* MMU */
 	.mmu = nds32_mmu,
-	.virt2phys = nds32_virtual_to_physical,
-	.read_phys_memory = nds32_read_phys_memory,
-	.write_phys_memory = nds32_write_phys_memory,
-
-	.run_algorithm = nds32_v3_run_algorithm,
 
 	.commands = nds32_command_handlers,
 	.target_create = nds32_v3m_target_create,
diff --git a/src/target/nds32_v3m.h b/src/target/nds32_v3m.h
old mode 100644
new mode 100755
diff --git a/src/target/oocd_trace.c b/src/target/oocd_trace.c
old mode 100644
new mode 100755
diff --git a/src/target/oocd_trace.h b/src/target/oocd_trace.h
old mode 100644
new mode 100755
diff --git a/src/target/openrisc/Makefile.am b/src/target/openrisc/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/target/openrisc/jsp_server.c b/src/target/openrisc/jsp_server.c
old mode 100644
new mode 100755
diff --git a/src/target/openrisc/jsp_server.h b/src/target/openrisc/jsp_server.h
old mode 100644
new mode 100755
diff --git a/src/target/openrisc/or1k.c b/src/target/openrisc/or1k.c
old mode 100644
new mode 100755
index aeef0a5..7752266
--- a/src/target/openrisc/or1k.c
+++ b/src/target/openrisc/or1k.c
@@ -862,7 +862,7 @@ static int or1k_resume_or_step(struct target *target, int current,
 		/* Single step past breakpoint at current address */
 		breakpoint = breakpoint_find(target, resume_pc);
 		if (breakpoint) {
-			LOG_DEBUG("Unset breakpoint at 0x%08" PRIx32, breakpoint->address);
+			LOG_DEBUG("Unset breakpoint at 0x%08" PRIx64, breakpoint->address);
 			retval = or1k_remove_breakpoint(target, breakpoint);
 			if (retval != ERROR_OK)
 				return retval;
@@ -923,7 +923,7 @@ static int or1k_add_breakpoint(struct target *target,
 	struct or1k_du *du_core = or1k_to_du(or1k);
 	uint8_t data;
 
-	LOG_DEBUG("Adding breakpoint: addr 0x%08" PRIx32 ", len %d, type %d, set: %d, id: %" PRId32,
+	LOG_DEBUG("Adding breakpoint: addr 0x%08" PRIx64 ", len %d, type %d, set: %d, id: %" PRId32,
 		  breakpoint->address, breakpoint->length, breakpoint->type,
 		  breakpoint->set, breakpoint->unique_id);
 
@@ -938,7 +938,7 @@ static int or1k_add_breakpoint(struct target *target,
 					 1,
 					 &data);
 	if (retval != ERROR_OK) {
-		LOG_ERROR("Error while reading the instruction at 0x%08" PRIx32,
+		LOG_ERROR("Error while reading the instruction at 0x%08" PRIx64,
 			   breakpoint->address);
 		return retval;
 	}
@@ -959,14 +959,17 @@ static int or1k_add_breakpoint(struct target *target,
 					  or1k_trap_insn);
 
 	if (retval != ERROR_OK) {
-		LOG_ERROR("Error while writing OR1K_TRAP_INSTR at 0x%08" PRIx32,
+		LOG_ERROR("Error while writing OR1K_TRAP_INSTR at 0x%08" PRIx64,
 			   breakpoint->address);
 		return retval;
 	}
 
 	/* invalidate instruction cache */
+	uint32_t tmp;
+	tmp = breakpoint->address;
 	retval = du_core->or1k_jtag_write_cpu(&or1k->jtag,
-			OR1K_ICBIR_CPU_REG_ADD, 1, &breakpoint->address);
+			OR1K_ICBIR_CPU_REG_ADD, 1, &tmp);
+	breakpoint->address = tmp;
 	if (retval != ERROR_OK) {
 		LOG_ERROR("Error while invalidating the ICACHE");
 		return retval;
@@ -981,7 +984,7 @@ static int or1k_remove_breakpoint(struct target *target,
 	struct or1k_common *or1k = target_to_or1k(target);
 	struct or1k_du *du_core = or1k_to_du(or1k);
 
-	LOG_DEBUG("Removing breakpoint: addr 0x%08" PRIx32 ", len %d, type %d, set: %d, id: %" PRId32,
+	LOG_DEBUG("Removing breakpoint: addr 0x%08" PRIx64 ", len %d, type %d, set: %d, id: %" PRId32,
 		  breakpoint->address, breakpoint->length, breakpoint->type,
 		  breakpoint->set, breakpoint->unique_id);
 
@@ -997,14 +1000,17 @@ static int or1k_remove_breakpoint(struct target *target,
 					  breakpoint->orig_instr);
 
 	if (retval != ERROR_OK) {
-		LOG_ERROR("Error while writing back the instruction at 0x%08" PRIx32,
+		LOG_ERROR("Error while writing back the instruction at 0x%08" PRIx64,
 			   breakpoint->address);
 		return retval;
 	}
 
 	/* invalidate instruction cache */
+	uint32_t tmp;
+	tmp = breakpoint->address;
 	retval = du_core->or1k_jtag_write_cpu(&or1k->jtag,
-			OR1K_ICBIR_CPU_REG_ADD, 1, &breakpoint->address);
+			OR1K_ICBIR_CPU_REG_ADD, 1, &tmp );
+	breakpoint->address = tmp;
 	if (retval != ERROR_OK) {
 		LOG_ERROR("Error while invalidating the ICACHE");
 		return retval;
@@ -1377,18 +1383,25 @@ static const struct command_registration or1k_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io32 or1k_target32 = {
+	.read_memory = or1k_read_memory,
+	.write_memory = or1k_write_memory,
+	.checksum_memory = or1k_checksum_memory,
+	.step = or1k_step,
+	.resume = or1k_resume,
+};
 
 struct target_type or1k_target = {
 	.name = "or1k",
 
+	.pIo32_legacy_api = &or1k_target32,
+	
 	.poll = or1k_poll,
 	.arch_state = or1k_arch_state,
 
 	.target_request_data = NULL,
 
 	.halt = or1k_halt,
-	.resume = or1k_resume,
-	.step = or1k_step,
 
 	.assert_reset = or1k_assert_reset,
 	.deassert_reset = or1k_deassert_reset,
@@ -1396,9 +1409,6 @@ struct target_type or1k_target = {
 
 	.get_gdb_reg_list = or1k_get_gdb_reg_list,
 
-	.read_memory = or1k_read_memory,
-	.write_memory = or1k_write_memory,
-	.checksum_memory = or1k_checksum_memory,
 
 	.commands = or1k_command_handlers,
 	.add_breakpoint = or1k_add_breakpoint,
diff --git a/src/target/openrisc/or1k.h b/src/target/openrisc/or1k.h
old mode 100644
new mode 100755
diff --git a/src/target/openrisc/or1k_du.h b/src/target/openrisc/or1k_du.h
old mode 100644
new mode 100755
diff --git a/src/target/openrisc/or1k_du_adv.c b/src/target/openrisc/or1k_du_adv.c
old mode 100644
new mode 100755
diff --git a/src/target/openrisc/or1k_tap.h b/src/target/openrisc/or1k_tap.h
old mode 100644
new mode 100755
diff --git a/src/target/openrisc/or1k_tap_mohor.c b/src/target/openrisc/or1k_tap_mohor.c
old mode 100644
new mode 100755
diff --git a/src/target/openrisc/or1k_tap_vjtag.c b/src/target/openrisc/or1k_tap_vjtag.c
old mode 100644
new mode 100755
diff --git a/src/target/openrisc/or1k_tap_xilinx_bscan.c b/src/target/openrisc/or1k_tap_xilinx_bscan.c
old mode 100644
new mode 100755
diff --git a/src/target/quark_x10xx.c b/src/target/quark_x10xx.c
old mode 100644
new mode 100755
index 05818b7..0e06570
--- a/src/target/quark_x10xx.c
+++ b/src/target/quark_x10xx.c
@@ -68,30 +68,36 @@ int quark_x10xx_init_target(struct command_context *cmd_ctx, struct target *t)
 	return lakemont_init_target(cmd_ctx, t);
 }
 
+static struct target_io32 quark_x10xx_target32 = {
+	.read_memory = x86_32_common_read_memory,
+	.write_memory = x86_32_common_write_memory,
+	.virt2phys = x86_32_common_virt2phys,
+	.read_phys_memory = x86_32_common_read_phys_mem,
+	.write_phys_memory = x86_32_common_write_phys_mem,
+	.resume = lakemont_resume,
+	.step = lakemont_step,
+};
+
 struct target_type quark_x10xx_target = {
 	.name = "quark_x10xx",
 	/* Quark X1000 SoC */
+
+	.pIo32_legacy_api = &quark_x10xx_target32,
+	
 	.target_create = quark_x10xx_target_create,
 	.init_target = quark_x10xx_init_target,
 	/* lakemont probemode specific code */
 	.poll = lakemont_poll,
 	.arch_state = lakemont_arch_state,
 	.halt = lakemont_halt,
-	.resume = lakemont_resume,
-	.step = lakemont_step,
 	.assert_reset = lakemont_reset_assert,
 	.deassert_reset = lakemont_reset_deassert,
 	/* common x86 code */
 	.commands = x86_32_command_handlers,
 	.get_gdb_reg_list = x86_32_get_gdb_reg_list,
-	.read_memory = x86_32_common_read_memory,
-	.write_memory = x86_32_common_write_memory,
 	.add_breakpoint = x86_32_common_add_breakpoint,
 	.remove_breakpoint = x86_32_common_remove_breakpoint,
 	.add_watchpoint = x86_32_common_add_watchpoint,
 	.remove_watchpoint = x86_32_common_remove_watchpoint,
-	.virt2phys = x86_32_common_virt2phys,
-	.read_phys_memory = x86_32_common_read_phys_mem,
-	.write_phys_memory = x86_32_common_write_phys_mem,
 	.mmu = x86_32_common_mmu,
 };
diff --git a/src/target/register.c b/src/target/register.c
old mode 100644
new mode 100755
diff --git a/src/target/register.h b/src/target/register.h
old mode 100644
new mode 100755
diff --git a/src/target/smp.c b/src/target/smp.c
old mode 100644
new mode 100755
diff --git a/src/target/smp.h b/src/target/smp.h
old mode 100644
new mode 100755
diff --git a/src/target/startup.tcl b/src/target/startup.tcl
old mode 100644
new mode 100755
diff --git a/src/target/target.c b/src/target/target.c
old mode 100644
new mode 100755
index 0aa77cc..697d8a4
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -60,10 +60,6 @@
 /* default halt wait timeout (ms) */
 #define DEFAULT_HALT_TIMEOUT 5000
 
-static int target_read_buffer_default(struct target *target, uint32_t address,
-		uint32_t count, uint8_t *buffer);
-static int target_write_buffer_default(struct target *target, uint32_t address,
-		uint32_t count, const uint8_t *buffer);
 static int target_array2mem(Jim_Interp *interp, struct target *target,
 		int argc, Jim_Obj * const *argv);
 static int target_mem2array(Jim_Interp *interp, struct target *target,
@@ -384,7 +380,7 @@ static void target_buffer_set_u8(struct target *target, uint8_t *buffer, uint8_t
 }
 
 /* write a uint64_t array to a buffer in target memory endianness */
-void target_buffer_get_u64_array(struct target *target, const uint8_t *buffer, uint32_t count, uint64_t *dstbuf)
+void target_buffer_get_u64_array(struct target *target, const uint8_t *buffer, uint64_t count, uint64_t *dstbuf)
 {
 	uint32_t i;
 	for (i = 0; i < count; i++)
@@ -392,7 +388,7 @@ void target_buffer_get_u64_array(struct target *target, const uint8_t *buffer, u
 }
 
 /* write a uint32_t array to a buffer in target memory endianness */
-void target_buffer_get_u32_array(struct target *target, const uint8_t *buffer, uint32_t count, uint32_t *dstbuf)
+void target_buffer_get_u32_array(struct target *target, const uint8_t *buffer, uint64_t count, uint32_t *dstbuf)
 {
 	uint32_t i;
 	for (i = 0; i < count; i++)
@@ -400,7 +396,7 @@ void target_buffer_get_u32_array(struct target *target, const uint8_t *buffer, u
 }
 
 /* write a uint16_t array to a buffer in target memory endianness */
-void target_buffer_get_u16_array(struct target *target, const uint8_t *buffer, uint32_t count, uint16_t *dstbuf)
+void target_buffer_get_u16_array(struct target *target, const uint8_t *buffer, uint64_t count, uint16_t *dstbuf)
 {
 	uint32_t i;
 	for (i = 0; i < count; i++)
@@ -408,7 +404,7 @@ void target_buffer_get_u16_array(struct target *target, const uint8_t *buffer, u
 }
 
 /* write a uint64_t array to a buffer in target memory endianness */
-void target_buffer_set_u64_array(struct target *target, uint8_t *buffer, uint32_t count, const uint64_t *srcbuf)
+void target_buffer_set_u64_array(struct target *target, uint8_t *buffer, uint64_t count, const uint64_t *srcbuf)
 {
 	uint32_t i;
 	for (i = 0; i < count; i++)
@@ -416,7 +412,7 @@ void target_buffer_set_u64_array(struct target *target, uint8_t *buffer, uint32_
 }
 
 /* write a uint32_t array to a buffer in target memory endianness */
-void target_buffer_set_u32_array(struct target *target, uint8_t *buffer, uint32_t count, const uint32_t *srcbuf)
+void target_buffer_set_u32_array(struct target *target, uint8_t *buffer, uint64_t count, const uint32_t *srcbuf)
 {
 	uint32_t i;
 	for (i = 0; i < count; i++)
@@ -424,7 +420,7 @@ void target_buffer_set_u32_array(struct target *target, uint8_t *buffer, uint32_
 }
 
 /* write a uint16_t array to a buffer in target memory endianness */
-void target_buffer_set_u16_array(struct target *target, uint8_t *buffer, uint32_t count, const uint16_t *srcbuf)
+void target_buffer_set_u16_array(struct target *target, uint8_t *buffer, uint64_t count, const uint16_t *srcbuf)
 {
 	uint32_t i;
 	for (i = 0; i < count; i++)
@@ -567,7 +563,7 @@ int target_halt(struct target *target)
  * hand the infrastructure for running such helpers might use this
  * procedure but rely on hardware breakpoint to detect termination.)
  */
-int target_resume(struct target *target, int current, uint64_t address, int handle_breakpoints, int debug_execution)
+int target64_resume(struct target *target, int current, const struct target_addr *pAddr, int handle_breakpoints, int debug_execution)
 {
 	int retval;
 
@@ -583,10 +579,8 @@ int target_resume(struct target *target, int current, uint64_t address, int hand
 	 * we poll. The CPU can even halt at the current PC as a result of
 	 * a software breakpoint being inserted by (a bug?) the application.
 	 */
-	if(target->is_64b)
-		retval = target->type->resume_64(target, current, address, handle_breakpoints, debug_execution);
-	else
-		retval = target->type->resume(target, current, (uint32_t)address, handle_breakpoints, debug_execution);
+	retval = target->type->pIo64_api->resume(target, current, pAddr, handle_breakpoints, debug_execution);
+
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -637,18 +631,13 @@ static int target_process_reset(struct command_context *cmd_ctx, enum target_res
 	return retval;
 }
 
-static int identity_virt2phys(struct target *target,
-		uint32_t virtual, uint32_t *physical)
+int target_identity_virt2phys64(struct target *target,
+				const struct target_addr *in_pVirt, struct target_addr *out_pPhys )
 {
-	*physical = virtual;
+	*out_pPhys = *in_pVirt;
 	return ERROR_OK;
 }
 
-static int no_mmu(struct target *target, int *enabled)
-{
-	*enabled = 0;
-	return ERROR_OK;
-}
 
 static int default_examine(struct target *target)
 {
@@ -746,10 +735,10 @@ static int target_soft_reset_halt(struct target *target)
  * @param target used to run the algorithm
  * @param arch_info target-specific description of the algorithm.
  */
-int target_run_algorithm(struct target *target,
+int target64_run_algorithm(struct target *target,
 		int num_mem_params, struct mem_param *mem_params,
 		int num_reg_params, struct reg_param *reg_param,
-		uint32_t entry_point, uint32_t exit_point,
+		const struct target_addr *pEntryPoint, const struct target_addr *pExitPoint,
 		int timeout_ms, void *arch_info)
 {
 	int retval = ERROR_FAIL;
@@ -758,17 +747,29 @@ int target_run_algorithm(struct target *target,
 		LOG_ERROR("Target not examined yet");
 		goto done;
 	}
-	if (!target->type->run_algorithm) {
+	int b;
+	b = 0;
+	if( target->type->pIo32_legacy_api ){
+		/* this is a 32bit target */
+		if( target->type->pIo32_legacy_api->run_algorithm ){
+			b = 1;
+		}
+	} else {
+		if( target->type->pIo64_api->run_algorithm) {
+			b = 1;
+		}
+	}
+	if( !b ){
 		LOG_ERROR("Target type '%s' does not support %s",
 				target_type_name(target), __func__);
 		goto done;
 	}
 
 	target->running_alg = true;
-	retval = target->type->run_algorithm(target,
+	retval = target->type->pIo64_api->run_algorithm(target,
 			num_mem_params, mem_params,
 			num_reg_params, reg_param,
-			entry_point, exit_point, timeout_ms, arch_info);
+			pEntryPoint, pExitPoint, timeout_ms, arch_info);
 	target->running_alg = false;
 
 done:
@@ -782,19 +783,33 @@ done:
  * @param target used to run the algorithm
  * @param arch_info target-specific description of the algorithm.
  */
-int target_start_algorithm(struct target *target,
+int target64_start_algorithm(struct target *target,
 		int num_mem_params, struct mem_param *mem_params,
 		int num_reg_params, struct reg_param *reg_params,
-		uint32_t entry_point, uint32_t exit_point,
+		const struct target_addr *pEntryPoint, const struct target_addr *pExitPoint,
 		void *arch_info)
 {
 	int retval = ERROR_FAIL;
+	int b;
 
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
 		goto done;
 	}
-	if (!target->type->start_algorithm) {
+	b = 0;
+	/* Can't do this via wrapper :-( due to this error check */
+	if( target->type->pIo32_legacy_api ){
+	  /* target uses 32bit api */
+	  if( target->type->pIo32_legacy_api->start_algorithm ){
+	    b = 1;
+	  }
+	} else {
+	  if( target->type->pIo64_api->start_algorithm ){
+	    b = 1;
+	  }
+	}
+		 
+	if (!b) {
 		LOG_ERROR("Target type '%s' does not support %s",
 				target_type_name(target), __func__);
 		goto done;
@@ -805,10 +820,10 @@ int target_start_algorithm(struct target *target,
 	}
 
 	target->running_alg = true;
-	retval = target->type->start_algorithm(target,
+	retval = target->type->pIo64_api->start_algorithm(target,
 			num_mem_params, mem_params,
 			num_reg_params, reg_params,
-			entry_point, exit_point, arch_info);
+			pEntryPoint, pExitPoint, arch_info);
 
 done:
 	return retval;
@@ -820,15 +835,29 @@ done:
  * @param target used to run the algorithm
  * @param arch_info target-specific description of the algorithm.
  */
-int target_wait_algorithm(struct target *target,
+int target64_wait_algorithm(struct target *target,
 		int num_mem_params, struct mem_param *mem_params,
 		int num_reg_params, struct reg_param *reg_params,
-		uint32_t exit_point, int timeout_ms,
+		const struct target_addr *pExitPoint, int timeout_ms,
 		void *arch_info)
 {
 	int retval = ERROR_FAIL;
+	int b;
+
+	b = 0;
+	/* Cannot do this via wrapper due to this check */
+	if( target->type->pIo32_legacy_api ){
+	  /* target is a 32bit target */
+	  if( target->type->pIo32_legacy_api->wait_algorithm ){
+	    b = 1;
+	  }
+	} else {
+	  if( target->type->pIo64_api->wait_algorithm ){
+	    b =1;
+	  }
+	}
 
-	if (!target->type->wait_algorithm) {
+	if (!b) {
 		LOG_ERROR("Target type '%s' does not support %s",
 				target_type_name(target), __func__);
 		goto done;
@@ -838,10 +867,10 @@ int target_wait_algorithm(struct target *target,
 		goto done;
 	}
 
-	retval = target->type->wait_algorithm(target,
+	retval = target->type->pIo64_api->wait_algorithm(target,
 			num_mem_params, mem_params,
 			num_reg_params, reg_params,
-			exit_point, timeout_ms, arch_info);
+			pExitPoint, timeout_ms, arch_info);
 	if (retval != ERROR_TARGET_TIMEOUT)
 		target->running_alg = false;
 
@@ -858,12 +887,12 @@ done:
  * @param target used to run the algorithm
  */
 
-int target_run_flash_async_algorithm(struct target *target,
+int target64_run_flash_async_algorithm(struct target *target,
 		const uint8_t *buffer, uint32_t count, int block_size,
 		int num_mem_params, struct mem_param *mem_params,
 		int num_reg_params, struct reg_param *reg_params,
-		uint32_t buffer_start, uint32_t buffer_size,
-		uint32_t entry_point, uint32_t exit_point, void *arch_info)
+		const struct target_addr *pBufferStart, uint64_t buffer_size,
+		const struct target_addr *pEntryPoint, const struct target_addr *pExitPoint, void *arch_info)
 {
 	int retval;
 	int timeout = 0;
@@ -872,29 +901,43 @@ int target_run_flash_async_algorithm(struct target *target,
 
 	/* Set up working area. First word is write pointer, second word is read pointer,
 	 * rest is fifo data area. */
-	uint32_t wp_addr = buffer_start;
-	uint32_t rp_addr = buffer_start + 4;
-	uint32_t fifo_start_addr = buffer_start + 8;
-	uint32_t fifo_end_addr = buffer_start + buffer_size;
-
-	uint32_t wp = fifo_start_addr;
-	uint32_t rp = fifo_start_addr;
-
+	struct target_addr wp_addr;
+	struct target_addr rp_addr;
+	wp_addr = *pBufferStart;
+	rp_addr = *pBufferStart;
+	rp_addr.addr += 4;
+
+	struct target_addr fifo_start_addr;
+	fifo_start_addr = *pBufferStart;
+	fifo_start_addr.addr += 8;
+
+	struct target_addr fifo_end_addr;
+ 	fifo_end_addr = *pBufferStart;
+	fifo_end_addr.addr += buffer_size;
+
+	struct target_addr wp;
+	struct target_addr rp;
+	wp = fifo_start_addr;
+	rp = fifo_start_addr;
+
+	/* FIXME: 64bit - target code assumes 32bit rp/wp */
+	/* FIXME: maybe this is ok? ie: if we set rule that buffer cannot cross 32bit boundary then no problem? */
+	
 	/* validate block_size is 2^n */
 	assert(!block_size || !(block_size & (block_size - 1)));
 
-	retval = target_write_u32(target, wp_addr, wp);
+	retval = target64_write_u32(target, &wp_addr, wp.addr);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = target_write_u32(target, rp_addr, rp);
+	retval = target64_write_u32(target, &rp_addr, rp.addr);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* Start up algorithm on target and let it idle while writing the first chunk */
-	retval = target_start_algorithm(target, num_mem_params, mem_params,
+	retval = target64_start_algorithm(target, num_mem_params, mem_params,
 			num_reg_params, reg_params,
-			entry_point,
-			exit_point,
+			pEntryPoint,
+			pExitPoint,
 			arch_info);
 
 	if (retval != ERROR_OK) {
@@ -903,24 +946,26 @@ int target_run_flash_async_algorithm(struct target *target,
 	}
 
 	while (count > 0) {
-
-		retval = target_read_u32(target, rp_addr, &rp);
+		uint32_t tmp;
+		retval = target64_read_u32(target, &rp_addr, &tmp);
+		rp.addr = tmp;
 		if (retval != ERROR_OK) {
 			LOG_ERROR("failed to get read pointer");
 			break;
 		}
 
-		LOG_DEBUG("offs 0x%zx count 0x%" PRIx32 " wp 0x%" PRIx32 " rp 0x%" PRIx32,
-			(buffer - buffer_orig), count, wp, rp);
+		LOG_DEBUG("offs 0x%zx count 0x%" PRIx32 " wp 0x%s rp %s",
+			(buffer - buffer_orig), count,
+			  target_addr2str1( target, &wp ), target_addr2str2( target, &rp ));
 
-		if (rp == 0) {
+		if (rp.addr == 0) {
 			LOG_ERROR("flash write algorithm aborted by target");
 			retval = ERROR_FLASH_OPERATION_FAILED;
 			break;
 		}
 
-		if ((rp & (block_size - 1)) || rp < fifo_start_addr || rp >= fifo_end_addr) {
-			LOG_ERROR("corrupted fifo read pointer 0x%" PRIx32, rp);
+		if ((rp.addr & (block_size - 1)) || rp.addr < fifo_start_addr.addr || rp.addr >= fifo_end_addr.addr) {
+			LOG_ERROR("corrupted fifo read pointer 0x%s", target_addr2str1( target, &rp));
 			break;
 		}
 
@@ -928,12 +973,12 @@ int target_run_flash_async_algorithm(struct target *target,
 		 * crossing the wrap around. Make sure to not fill it completely,
 		 * because that would make wp == rp and that's the empty condition. */
 		uint32_t thisrun_bytes;
-		if (rp > wp)
-			thisrun_bytes = rp - wp - block_size;
-		else if (rp > fifo_start_addr)
-			thisrun_bytes = fifo_end_addr - wp;
+		if (rp.addr > wp.addr)
+			thisrun_bytes = rp.addr - wp.addr - block_size;
+		else if (rp.addr > fifo_start_addr.addr)
+			thisrun_bytes = fifo_end_addr.addr - wp.addr;
 		else
-			thisrun_bytes = fifo_end_addr - wp - block_size;
+			thisrun_bytes = fifo_end_addr.addr - wp.addr - block_size;
 
 		if (thisrun_bytes == 0) {
 			/* Throttle polling a bit if transfer is (much) faster than flash
@@ -959,31 +1004,31 @@ int target_run_flash_async_algorithm(struct target *target,
 			thisrun_bytes = count * block_size;
 
 		/* Write data to fifo */
-		retval = target_write_buffer(target, wp, thisrun_bytes, buffer);
+		retval = target64_write_buffer(target, &wp, thisrun_bytes, buffer);
 		if (retval != ERROR_OK)
 			break;
 
 		/* Update counters and wrap write pointer */
 		buffer += thisrun_bytes;
 		count -= thisrun_bytes / block_size;
-		wp += thisrun_bytes;
-		if (wp >= fifo_end_addr)
-			wp = fifo_start_addr;
+		wp.addr += thisrun_bytes;
+		if (wp.addr >= fifo_end_addr.addr)
+			wp.addr = fifo_start_addr.addr;
 
 		/* Store updated write pointer to target */
-		retval = target_write_u32(target, wp_addr, wp);
+		retval = target64_write_u32(target, &wp_addr, wp.addr);
 		if (retval != ERROR_OK)
 			break;
 	}
 
 	if (retval != ERROR_OK) {
 		/* abort flash write algorithm on target */
-		target_write_u32(target, wp_addr, 0);
+		target64_write_u32(target, &wp_addr, 0);
 	}
 
-	int retval2 = target_wait_algorithm(target, num_mem_params, mem_params,
+	int retval2 = target64_wait_algorithm(target, num_mem_params, mem_params,
 			num_reg_params, reg_params,
-			exit_point,
+			pExitPoint,
 			10000,
 			arch_info);
 
@@ -995,56 +1040,59 @@ int target_run_flash_async_algorithm(struct target *target,
 	return retval;
 }
 
-int target_read_memory(struct target *target,
-		uint64_t address, uint64_t size, uint64_t count, uint8_t *buffer)
+int target64_read_memory(struct target *target,
+		const struct target_addr *pAddr, uint64_t size, uint64_t count, uint8_t *buffer)
 {
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
 		return ERROR_FAIL;
 	}
-	if(target->is_64b)
-		return target->type->read_memory_64(target, address, size, count, buffer);
-	else
-		return target->type->read_memory(target, (uint32_t)address, (uint32_t)size, (uint32_t)count, buffer);
+	return target->type->pIo64_api->read_memory(target, pAddr, size, count, buffer);
 }
 
-int target_read_phys_memory(struct target *target,
-		uint64_t address, uint64_t size, uint64_t count, uint8_t *buffer)
+int target64_read_phys_memory(struct target *target,
+		const struct target_addr *pAddr, uint64_t size, uint64_t count, uint8_t *buffer)
 {
+	struct target_addr tmp_addr;
+
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
 		return ERROR_FAIL;
 	}
-	if(target->is_64b)
-		return target->type->read_phys_memory_64(target, address, size, count, buffer);
-	else
-		return target->type->read_phys_memory(target, (uint32_t)address, (uint32_t)size, (uint32_t)count, buffer);
+
+	tmp_addr = *pAddr;
+	if( tmp_addr.route == TA_ROUTE_DEFAULT ){
+		tmp_addr.route = TA_ROUTE_PHYSICAL;
+	}
+	return target->type->pIo64_api->read_memory(target, &tmp_addr, size, count, buffer);
 }
 
-int target_write_memory(struct target *target,
-		uint64_t address, uint64_t size, uint64_t count, const uint8_t *buffer)
+
+
+int target64_write_memory(struct target *target,
+		const struct target_addr *pAddr, uint64_t size, uint64_t count, const uint8_t *buffer)
 {
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
 		return ERROR_FAIL;
 	}
-	if(target->is_64b)
-		return target->type->write_memory_64(target, address, size, count, buffer);
-	else
-		return target->type->write_memory(target, (uint32_t)address, (uint32_t)size, (uint32_t)count, buffer);
+	return target->type->pIo64_api->write_memory(target, pAddr, size, count, buffer);
 }
 
-int target_write_phys_memory(struct target *target,
-		uint64_t address, uint64_t size, uint64_t count, const uint8_t *buffer)
+int target64_write_phys_memory(struct target *target,
+		const struct target_addr *pAddr, uint64_t size, uint64_t count, const uint8_t *buffer)
 {
+	struct target_addr tmp_addr;
+
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
 		return ERROR_FAIL;
 	}
-	if(target->is_64b)
-		return target->type->write_phys_memory_64(target, address, size, count, buffer);
-	else
-		return target->type->write_phys_memory(target, (uint32_t)address, (uint32_t)size, (uint32_t)count, buffer);
+	tmp_addr = *pAddr;
+	if( tmp_addr.route == TA_ROUTE_DEFAULT ){
+		tmp_addr.route = TA_ROUTE_PHYSICAL;
+	}
+	return target->type->pIo64_api->write_memory(target, pAddr, size, count, buffer);
 }
 
 int target_add_breakpoint(struct target *target,
@@ -1121,13 +1169,10 @@ int target_get_gdb_reg_list(struct target *target,
 {
 	return target->type->get_gdb_reg_list(target, reg_list, reg_list_size, reg_class);
 }
-int target_step(struct target *target,
-		int current, uint64_t address, int handle_breakpoints)
+int target64_step(struct target *target,
+		int current, const struct target_addr *pAddr, int handle_breakpoints)
 {
-	if(target->is_64b)
-		return target->type->step_64(target, current, address, handle_breakpoints);
-	else
-		return target->type->step(target, current, (uint32_t)address, handle_breakpoints);
+	return target->type->pIo64_api->step(target, current, pAddr, handle_breakpoints);
 }
 
 int target_get_gdb_fileio_info(struct target *target, struct gdb_fileio_info *fileio_info)
@@ -1168,25 +1213,46 @@ static void target_reset_examined(struct target *target)
 	target->examined = false;
 }
 
-static int err_read_phys_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, uint8_t *buffer)
-{
-	LOG_ERROR("Not implemented: %s", __func__);
-	return ERROR_FAIL;
-}
+static int handle_target(void *priv);
 
-static int err_write_phys_memory(struct target *target, uint32_t address,
-		uint32_t size, uint32_t count, const uint8_t *buffer)
+static void io64_init( struct target_type *type )
 {
-	LOG_ERROR("Not implemented: %s", __func__);
-	return ERROR_FAIL;
-}
+	int fail;
+	fail = 0;
+#define CANNOT_BE_NULL( NAME ) \
+	if( type->pIo64_api-> NAME == NULL ){ \
+		fail = 1; \
+		LOG_ERROR("Target: %s - API Function: %s - FATAL - Cannot be NULL pointer\n", type->name, #NAME ); \
+	}
 
-static int handle_target(void *priv);
+	CANNOT_BE_NULL( resume );
+	CANNOT_BE_NULL( step );
+	CANNOT_BE_NULL( read_memory );
+	CANNOT_BE_NULL( write_memory );
+	CANNOT_BE_NULL( read_buffer );
+	CANNOT_BE_NULL( write_buffer );
+	CANNOT_BE_NULL( virt2phys );
+
+	/* CAN BE NULL */
+	/*  checksum_memory */
+	/*  blank_check_memory */
+	/*  run_algorithm */
+	/*  start_algorithm */
+	/*  wait_algorithm */
+	
+	if( fail ){
+		fprintf( stderr, "** FATAL ** - Function pointers are not defined in io64 structure\n");
+	}
+}
 
 static int target_init_one(struct command_context *cmd_ctx,
 		struct target *target)
 {
+	/* All targets get the 64bit wrapper (if needed) */
+	if( target->type->pIo64_api == NULL ){
+		target->type->pIo64_api = &target_64_wrapper;
+	}
+
 	target_reset_examined(target);
 
 	struct target_type *type = target->type;
@@ -1204,52 +1270,18 @@ static int target_init_one(struct command_context *cmd_ctx,
 		return retval;
 	}
 
-	/* Sanity-check MMU support ... stub in what we must, to help
-	 * implement it in stages, but warn if we need to do so.
-	 */
-	if (type->mmu) {
-		if (type->write_phys_memory == NULL) {
-			LOG_ERROR("type '%s' is missing write_phys_memory",
-					type->name);
-			type->write_phys_memory = err_write_phys_memory;
-		}
-		if (type->read_phys_memory == NULL) {
-			LOG_ERROR("type '%s' is missing read_phys_memory",
-					type->name);
-			type->read_phys_memory = err_read_phys_memory;
-		}
-		if (type->virt2phys == NULL) {
-			LOG_ERROR("type '%s' is missing virt2phys", type->name);
-			type->virt2phys = identity_virt2phys;
-		}
-	} else {
-		/* Make sure no-MMU targets all behave the same:  make no
-		 * distinction between physical and virtual addresses, and
-		 * ensure that virt2phys() is always an identity mapping.
-		 */
-		if (type->write_phys_memory || type->read_phys_memory || type->virt2phys)
-			LOG_WARNING("type '%s' has bad MMU hooks", type->name);
-
-		type->mmu = no_mmu;
-		type->write_phys_memory = type->write_memory;
-		type->read_phys_memory = type->read_memory;
-		type->virt2phys = identity_virt2phys;
-	}
-
-	if (target->type->read_buffer == NULL)
-		target->type->read_buffer = target_read_buffer_default;
+	target32_init( target );
+	io64_init( target->type );
 
-	if (target->type->write_buffer == NULL)
-		target->type->write_buffer = target_write_buffer_default;
 
-	if (target->type->get_gdb_fileio_info == NULL)
-		target->type->get_gdb_fileio_info = target_get_gdb_fileio_info_default;
+	if (type->get_gdb_fileio_info == NULL)
+		type->get_gdb_fileio_info = target_get_gdb_fileio_info_default;
 
-	if (target->type->gdb_fileio_end == NULL)
-		target->type->gdb_fileio_end = target_gdb_fileio_end_default;
+	if (type->gdb_fileio_end == NULL)
+		type->gdb_fileio_end = target_gdb_fileio_end_default;
 
-	if (target->type->profiling == NULL)
-		target->type->profiling = target_profiling_default;
+	if (type->profiling == NULL)
+		type->profiling = target_profiling_default;
 
 	return ERROR_OK;
 }
@@ -1507,9 +1539,11 @@ static void print_wa_layout(struct target *target)
 	struct working_area *c = target->working_areas;
 
 	while (c) {
-		LOG_DEBUG("%c%c 0x%08"PRIx32"-0x%08"PRIx32" (%"PRIu32" bytes)",
-			c->backup ? 'b' : ' ', c->free ? ' ' : '*',
-			c->address, c->address + c->size - 1, c->size);
+		LOG_DEBUG("%c%c %s-%s (%"PRIu64" bytes)",
+			c->backup ? 'b' : ' ',
+			c->free ? ' ' : '*',
+			target_addr64str1( target, c->address),
+			target_addr64str2( target, c->address + c->size - 1), c->size);
 		c = c->next;
 	}
 }
@@ -1578,8 +1612,9 @@ static void target_merge_working_areas(struct target *target)
 	}
 }
 
-int target_alloc_working_area_try(struct target *target, uint32_t size, struct working_area **area)
+int target_alloc_working_area_try(struct target *target, uint64_t size, struct working_area **area)
 {
+	struct target_addr tmp_addr;
 	/* Reevaluate working area address based on MMU state*/
 	if (target->working_areas == NULL) {
 		int retval;
@@ -1592,8 +1627,8 @@ int target_alloc_working_area_try(struct target *target, uint32_t size, struct w
 		if (!enabled) {
 			if (target->working_area_phys_spec) {
 				LOG_DEBUG("MMU disabled, using physical "
-					"address for working memory 0x%08"PRIx32,
-					target->working_area_phys);
+					"address for working memory %s",
+					target_addr64str1( target, target->working_area_phys));
 				target->working_area = target->working_area_phys;
 			} else {
 				LOG_ERROR("No working memory available. "
@@ -1603,8 +1638,8 @@ int target_alloc_working_area_try(struct target *target, uint32_t size, struct w
 		} else {
 			if (target->working_area_virt_spec) {
 				LOG_DEBUG("MMU enabled, using virtual "
-					"address for working memory 0x%08"PRIx32,
-					target->working_area_virt);
+					"address for working memory %s",
+					target_addr64str1( target, target->working_area_virt));
 				target->working_area = target->working_area_virt;
 			} else {
 				LOG_ERROR("No working memory available. "
@@ -1646,7 +1681,8 @@ int target_alloc_working_area_try(struct target *target, uint32_t size, struct w
 	/* Split the working area into the requested size */
 	target_split_working_area(c, size);
 
-	LOG_DEBUG("allocated new working area of %"PRIu32" bytes at address 0x%08"PRIx32, size, c->address);
+	LOG_DEBUG("allocated new working area of %"PRIu64" bytes at address %s",
+		  size, target_addr64str1( target, c->address ));
 
 	if (target->backup_working_area) {
 		if (c->backup == NULL) {
@@ -1655,7 +1691,8 @@ int target_alloc_working_area_try(struct target *target, uint32_t size, struct w
 				return ERROR_FAIL;
 		}
 
-		int retval = target_read_memory(target, c->address, 4, c->size / 4, c->backup);
+		TARGET_ADDR_INIT( &tmp_addr, c->address );
+		int retval = target64_read_memory(target, &tmp_addr, 4, c->size / 4, c->backup);
 		if (retval != ERROR_OK)
 			return retval;
 	}
@@ -1672,13 +1709,13 @@ int target_alloc_working_area_try(struct target *target, uint32_t size, struct w
 	return ERROR_OK;
 }
 
-int target_alloc_working_area(struct target *target, uint32_t size, struct working_area **area)
+int target_alloc_working_area(struct target *target, uint64_t size, struct working_area **area)
 {
 	int retval;
 
 	retval = target_alloc_working_area_try(target, size, area);
 	if (retval == ERROR_TARGET_RESOURCE_NOT_AVAILABLE)
-		LOG_WARNING("not enough working area available(requested %"PRIu32")", size);
+		LOG_WARNING("not enough working area available(requested %"PRIu64")", size);
 	return retval;
 
 }
@@ -1688,10 +1725,13 @@ static int target_restore_working_area(struct target *target, struct working_are
 	int retval = ERROR_OK;
 
 	if (target->backup_working_area && area->backup != NULL) {
-		retval = target_write_memory(target, area->address, 4, area->size / 4, area->backup);
+		struct target_addr tmp_addr;
+		TARGET_ADDR_INIT( &tmp_addr,area->address );
+		retval = target64_write_memory(target, &tmp_addr, 4, area->size / 4, area->backup);
 		if (retval != ERROR_OK)
-			LOG_ERROR("failed to restore %"PRIu32" bytes of working area at address 0x%08"PRIx32,
-					area->size, area->address);
+			LOG_ERROR("failed to restore %" PRIu64 " bytes of working area at address 0x%s",
+				area->size, 
+				target_addr2str1( target, &tmp_addr) );
 	}
 
 	return retval;
@@ -1714,8 +1754,8 @@ static int target_free_working_area_restore(struct target *target, struct workin
 
 	area->free = true;
 
-	LOG_DEBUG("freed %"PRIu32" bytes of working area at address 0x%08"PRIx32,
-			area->size, area->address);
+	LOG_DEBUG("freed %"PRIu64" bytes of working area at address %s",
+		area->size, target_addr64str1( target, area->address ));
 
 	/* mark user pointer invalid */
 	/* TODO: Is this really safe? It points to some previous caller's memory.
@@ -1769,7 +1809,7 @@ void target_free_all_working_areas(struct target *target)
 }
 
 /* Find the largest number of bytes that can be allocated */
-uint32_t target_get_working_area_avail(struct target *target)
+uint64_t target_get_working_area_avail(struct target *target)
 {
 	struct working_area *c = target->working_areas;
 	uint32_t max_size = 0;
@@ -1873,10 +1913,10 @@ static int target_profiling_default(struct target *target, uint32_t *samples,
  * mode respectively, otherwise data is handled as quickly as
  * possible
  */
-int target_write_buffer(struct target *target, uint64_t address, uint64_t size, const uint8_t *buffer)
+int target64_write_buffer(struct target *target, const struct target_addr *pAddr, uint64_t size, const uint8_t *buffer)
 {
 	LOG_DEBUG("writing buffer of %" PRIu64 " byte at 0x%" PRIx64,
-			size, address);
+			size, pAddr->addr);
 
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
@@ -1886,31 +1926,31 @@ int target_write_buffer(struct target *target, uint64_t address, uint64_t size,
 	if (size == 0)
 		return ERROR_OK;
 
-	if ((address + size - 1) < address) {
+	if ((pAddr->addr + size - 1) < pAddr->addr) {
 		/* GDB can request this when e.g. PC is 0xfffffffc*/
 		LOG_ERROR("address + size wrapped(0x%" PRIx64 ", 0x%" PRIx64 ")",
-				  address,
+				  pAddr->addr,
 				  size);
 		return ERROR_FAIL;
 	}
-	if(target->is_64b)
-		return target->type->write_buffer_64(target, address, size, buffer);
-	else
-		return target->type->write_buffer(target, (uint32_t)address, (uint32_t)size, buffer);
+	return target->type->pIo64_api->write_buffer(target, pAddr, size, buffer);
 }
 
-static int target_write_buffer_default(struct target *target, uint32_t address, uint32_t count, const uint8_t *buffer)
+int target64_write_buffer_default(struct target *target, struct target_addr *pAddr, uint64_t count, const uint8_t *buffer)
 {
-	uint32_t size;
+	uint64_t size;
+	struct target_addr tmp_addr;
+
+	tmp_addr = *pAddr;
 
 	/* Align up to maximum 4 bytes. The loop condition makes sure the next pass
 	 * will have something to do with the size we leave to it. */
-	for (size = 1; size < 4 && count >= size * 2 + (address & size); size *= 2) {
-		if (address & size) {
-			int retval = target_write_memory(target, address, size, 1, buffer);
+	for (size = 1; size < 4 && count >= size * 2 + (tmp_addr.addr & size); size *= 2) {
+		if (tmp_addr.addr & size) {
+			int retval = target64_write_memory(target, &tmp_addr, size, 1, buffer);
 			if (retval != ERROR_OK)
 				return retval;
-			address += size;
+			tmp_addr.addr += size;
 			count -= size;
 			buffer += size;
 		}
@@ -1920,10 +1960,10 @@ static int target_write_buffer_default(struct target *target, uint32_t address,
 	for (; size > 0; size /= 2) {
 		uint32_t aligned = count - count % size;
 		if (aligned > 0) {
-			int retval = target_write_memory(target, address, size, aligned / size, buffer);
+			int retval = target64_write_memory(target, &tmp_addr, size, aligned / size, buffer);
 			if (retval != ERROR_OK)
 				return retval;
-			address += aligned;
+			tmp_addr.addr += aligned;
 			count -= aligned;
 			buffer += aligned;
 		}
@@ -1936,10 +1976,10 @@ static int target_write_buffer_default(struct target *target, uint32_t address,
  * mode respectively, otherwise data is handled as quickly as
  * possible
  */
-int target_read_buffer(struct target *target, uint64_t address, uint64_t size, uint8_t *buffer)
+int target64_read_buffer(struct target *target, const struct target_addr *pAddr, uint64_t size, uint8_t *buffer)
 {
 	LOG_DEBUG("reading buffer of %" PRIu64 " byte at 0x%" PRIx64,
-			  size, address);
+			  size, pAddr->addr);
 
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
@@ -1949,31 +1989,33 @@ int target_read_buffer(struct target *target, uint64_t address, uint64_t size, u
 	if (size == 0)
 		return ERROR_OK;
 
-	if ((address + size - 1) < address) {
+	if ((pAddr->addr + size - 1) < pAddr->addr) {
 		/* GDB can request this when e.g. PC is 0xfffffffc*/
 		LOG_ERROR("address + size wrapped(0x%" PRIx64 ", 0x%" PRIx64 ")",
-				  address,
+				  pAddr->addr,
 				  size);
 		return ERROR_FAIL;
 	}
-	if(target->is_64b)
-		return target->type->read_buffer_64(target, address, size, buffer);
-	else
-		return target->type->read_buffer(target, (uint32_t)address, (uint32_t)size, buffer);
+
+	return target->type->pIo64_api->read_buffer( target, pAddr, size, buffer );
 }
 
-static int target_read_buffer_default(struct target *target, uint32_t address, uint32_t count, uint8_t *buffer)
+int target64_read_buffer_default(struct target *target, struct target_addr *pAddr, uint64_t count, uint8_t *buffer)
 {
-	uint32_t size;
+	uint64_t size;
+	struct target_addr tmp_addr;
+
+	tmp_addr = *pAddr;
+
 
 	/* Align up to maximum 4 bytes. The loop condition makes sure the next pass
 	 * will have something to do with the size we leave to it. */
-	for (size = 1; size < 4 && count >= size * 2 + (address & size); size *= 2) {
-		if (address & size) {
-			int retval = target_read_memory(target, address, size, 1, buffer);
+	for (size = 1; size < 4 && count >= size * 2 + (tmp_addr.addr & size); size *= 2) {
+		if (tmp_addr.addr & size) {
+			int retval = target64_read_memory(target, &tmp_addr, size, 1, buffer);
 			if (retval != ERROR_OK)
 				return retval;
-			address += size;
+			tmp_addr.addr += size;
 			count -= size;
 			buffer += size;
 		}
@@ -1981,12 +2023,12 @@ static int target_read_buffer_default(struct target *target, uint32_t address, u
 
 	/* Read the data with as large access size as possible. */
 	for (; size > 0; size /= 2) {
-		uint32_t aligned = count - count % size;
+		uint64_t aligned = count - count % size;
 		if (aligned > 0) {
-			int retval = target_read_memory(target, address, size, aligned / size, buffer);
+			int retval = target64_read_memory(target, &tmp_addr, size, aligned / size, buffer);
 			if (retval != ERROR_OK)
 				return retval;
-			address += aligned;
+			tmp_addr.addr += aligned;
 			count -= aligned;
 			buffer += aligned;
 		}
@@ -1995,25 +2037,25 @@ static int target_read_buffer_default(struct target *target, uint32_t address, u
 	return ERROR_OK;
 }
 
-int target_checksum_memory(struct target *target, uint32_t address, uint32_t size, uint32_t* crc)
+int target64_checksum_memory(struct target *target, const struct target_addr *pAddr, uint64_t size, uint32_t* crc)
 {
 	uint8_t *buffer;
 	int retval;
-	uint32_t i;
+	uint64_t i;
 	uint32_t checksum = 0;
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
 		return ERROR_FAIL;
 	}
 
-	retval = target->type->checksum_memory(target, address, size, &checksum);
+	retval = target->type->pIo64_api->checksum_memory(target, pAddr, size, &checksum);
 	if (retval != ERROR_OK) {
 		buffer = malloc(size);
 		if (buffer == NULL) {
 			LOG_ERROR("error allocating buffer for section (%d bytes)", (int)size);
 			return ERROR_COMMAND_SYNTAX_ERROR;
 		}
-		retval = target_read_buffer(target, address, size, buffer);
+		retval = target64_read_buffer(target, pAddr, size, buffer);
 		if (retval != ERROR_OK) {
 			free(buffer);
 			return retval;
@@ -2035,7 +2077,7 @@ int target_checksum_memory(struct target *target, uint32_t address, uint32_t siz
 	return retval;
 }
 
-int target_blank_check_memory(struct target *target, uint32_t address, uint32_t size, uint32_t* blank)
+int target64_blank_check_memory(struct target *target, const struct target_addr *pAddr, uint64_t size, uint32_t* blank)
 {
 	int retval;
 	if (!target_was_examined(target)) {
@@ -2043,15 +2085,15 @@ int target_blank_check_memory(struct target *target, uint32_t address, uint32_t
 		return ERROR_FAIL;
 	}
 
-	if (target->type->blank_check_memory == 0)
+	if (target->type->pIo64_api->blank_check_memory == 0)
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 
-	retval = target->type->blank_check_memory(target, address, size, blank);
+	retval = target->type->pIo64_api->blank_check_memory(target, pAddr, size, blank);
 
 	return retval;
 }
 
-int target_read_u64(struct target *target, uint64_t address, uint64_t *value)
+int target64_read_u64(struct target *target, const struct target_addr *pAddr, uint64_t *value)
 {
 	uint8_t value_buf[8];
 	if (!target_was_examined(target)) {
@@ -2059,23 +2101,23 @@ int target_read_u64(struct target *target, uint64_t address, uint64_t *value)
 		return ERROR_FAIL;
 	}
 
-	int retval = target_read_memory(target, address, 8, 1, value_buf);
+	int retval = target64_read_memory(target, pAddr, 8, 1, value_buf);
 
 	if (retval == ERROR_OK) {
 		*value = target_buffer_get_u64(target, value_buf);
 		LOG_DEBUG("address: 0x%" PRIx64 ", value: 0x%16.16" PRIx64 "",
-				  address,
+				  pAddr->addr,
 				  *value);
 	} else {
 		*value = 0x0;
 		LOG_DEBUG("address: 0x%" PRIx64 " failed",
-				  address);
+				  pAddr->addr);
 	}
 
 	return retval;
 }
 
-int target_read_u32(struct target *target, uint32_t address, uint32_t *value)
+int target64_read_u32(struct target *target, const struct target_addr *pAddr, uint32_t *value)
 {
 	uint8_t value_buf[4];
 	if (!target_was_examined(target)) {
@@ -2083,23 +2125,23 @@ int target_read_u32(struct target *target, uint32_t address, uint32_t *value)
 		return ERROR_FAIL;
 	}
 
-	int retval = target_read_memory(target, address, 4, 1, value_buf);
+	int retval = target64_read_memory(target, pAddr, 4, 1, value_buf);
 
 	if (retval == ERROR_OK) {
 		*value = target_buffer_get_u32(target, value_buf);
-		LOG_DEBUG("address: 0x%8.8" PRIx32 ", value: 0x%8.8" PRIx32 "",
-				  address,
+		LOG_DEBUG("address: 0x%s, value: 0x%8.8" PRIx32 "",
+				  target_addr2str1( target, pAddr ),
 				  *value);
 	} else {
 		*value = 0x0;
-		LOG_DEBUG("address: 0x%8.8" PRIx32 " failed",
-				  address);
+		LOG_DEBUG("address: 0x%s failed",
+				  target_addr2str1( target, pAddr) );
 	}
 
 	return retval;
 }
 
-int target_read_u16(struct target *target, uint32_t address, uint16_t *value)
+int target64_read_u16(struct target *target, const struct target_addr *pAddr, uint16_t *value)
 {
 	uint8_t value_buf[2];
 	if (!target_was_examined(target)) {
@@ -2107,45 +2149,45 @@ int target_read_u16(struct target *target, uint32_t address, uint16_t *value)
 		return ERROR_FAIL;
 	}
 
-	int retval = target_read_memory(target, address, 2, 1, value_buf);
+	int retval = target64_read_memory(target, pAddr, 2, 1, value_buf);
 
 	if (retval == ERROR_OK) {
 		*value = target_buffer_get_u16(target, value_buf);
-		LOG_DEBUG("address: 0x%8.8" PRIx32 ", value: 0x%4.4x",
-				  address,
+		LOG_DEBUG("address: 0x%s, value: 0x%4.4x",
+				  target_addr2str1( target, pAddr ),
 				  *value);
 	} else {
 		*value = 0x0;
-		LOG_DEBUG("address: 0x%8.8" PRIx32 " failed",
-				  address);
+		LOG_DEBUG("address: 0x%s failed",
+				  target_addr2str1( target, pAddr ) );
 	}
 
 	return retval;
 }
 
-int target_read_u8(struct target *target, uint32_t address, uint8_t *value)
+int target64_read_u8(struct target *target, const struct target_addr *pAddr, uint8_t *value)
 {
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
 		return ERROR_FAIL;
 	}
 
-	int retval = target_read_memory(target, address, 1, 1, value);
+	int retval = target64_read_memory(target, pAddr, 1, 1, value);
 
 	if (retval == ERROR_OK) {
-		LOG_DEBUG("address: 0x%8.8" PRIx32 ", value: 0x%2.2x",
-				  address,
+		LOG_DEBUG("address: 0x%s, value: 0x%2.2x",
+				  target_addr2str1( target, pAddr ),
 				  *value);
 	} else {
 		*value = 0x0;
-		LOG_DEBUG("address: 0x%8.8" PRIx32 " failed",
-				  address);
+		LOG_DEBUG("address: 0x%s failed",
+				  target_addr2str1( target, pAddr ));
 	}
 
 	return retval;
 }
 
-int target_write_u64(struct target *target, uint64_t address, uint64_t value)
+int target64_write_u64(struct target *target, const struct target_addr *pAddr, uint64_t value)
 {
 	int retval;
 	uint8_t value_buf[8];
@@ -2155,18 +2197,18 @@ int target_write_u64(struct target *target, uint64_t address, uint64_t value)
 	}
 
 	LOG_DEBUG("address: 0x%" PRIx64 ", value: 0x%16.16" PRIx64 "",
-			  address,
+			  pAddr->addr,
 			  value);
 
 	target_buffer_set_u64(target, value_buf, value);
-	retval = target_write_memory(target, address, 8, 1, value_buf);
+	retval = target64_write_memory(target, pAddr, 8, 1, value_buf);
 	if (retval != ERROR_OK)
 		LOG_DEBUG("failed: %i", retval);
 
 	return retval;
 }
 
-int target_write_u32(struct target *target, uint32_t address, uint32_t value)
+int target64_write_u32(struct target *target, const struct target_addr *pAddr, uint32_t value)
 {
 	int retval;
 	uint8_t value_buf[4];
@@ -2175,19 +2217,19 @@ int target_write_u32(struct target *target, uint32_t address, uint32_t value)
 		return ERROR_FAIL;
 	}
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", value: 0x%8.8" PRIx32 "",
-			  address,
+	LOG_DEBUG("address: 0x%s, value: 0x%8.8" PRIx32 "",
+			  target_addr2str1( target, pAddr ),
 			  value);
 
 	target_buffer_set_u32(target, value_buf, value);
-	retval = target_write_memory(target, address, 4, 1, value_buf);
+	retval = target64_write_memory(target, pAddr, 4, 1, value_buf);
 	if (retval != ERROR_OK)
 		LOG_DEBUG("failed: %i", retval);
 
 	return retval;
 }
 
-int target_write_u16(struct target *target, uint32_t address, uint16_t value)
+int target64_write_u16(struct target *target, const struct target_addr *pAddr, uint16_t value)
 {
 	int retval;
 	uint8_t value_buf[2];
@@ -2196,19 +2238,19 @@ int target_write_u16(struct target *target, uint32_t address, uint16_t value)
 		return ERROR_FAIL;
 	}
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", value: 0x%8.8x",
-			  address,
+	LOG_DEBUG("address: 0x%s, value: 0x%8.8x",
+			  target_addr2str1( target, pAddr ),
 			  value);
 
 	target_buffer_set_u16(target, value_buf, value);
-	retval = target_write_memory(target, address, 2, 1, value_buf);
+	retval = target64_write_memory(target, pAddr, 2, 1, value_buf);
 	if (retval != ERROR_OK)
 		LOG_DEBUG("failed: %i", retval);
 
 	return retval;
 }
 
-int target_write_u8(struct target *target, uint32_t address, uint8_t value)
+int target64_write_u8(struct target *target, const struct target_addr *pAddr, uint8_t value)
 {
 	int retval;
 	if (!target_was_examined(target)) {
@@ -2216,10 +2258,10 @@ int target_write_u8(struct target *target, uint32_t address, uint8_t value)
 		return ERROR_FAIL;
 	}
 
-	LOG_DEBUG("address: 0x%8.8" PRIx32 ", value: 0x%2.2x",
-			  address, value);
+	LOG_DEBUG("address: 0x%s, value: 0x%2.2x",
+			  target_addr2str1( target, pAddr ), value);
 
-	retval = target_write_memory(target, address, 1, 1, &value);
+	retval = target64_write_memory(target, pAddr, 1, 1, &value);
 	if (retval != ERROR_OK)
 		LOG_DEBUG("failed: %i", retval);
 
@@ -2717,6 +2759,7 @@ COMMAND_HANDLER(handle_reset_command)
 COMMAND_HANDLER(handle_resume_command)
 {
 	int current = 1;
+	struct target_addr addr;
 	if (CMD_ARGC > 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
@@ -2725,17 +2768,18 @@ COMMAND_HANDLER(handle_resume_command)
 	/* with no CMD_ARGV, resume from current pc, addr = 0,
 	 * with one arguments, addr = CMD_ARGV[0],
 	 * handle breakpoints, not debugging */
-	uint32_t addr = 0;
+	TARGET_ADDR_INIT( &addr, 0 );
 	if (CMD_ARGC == 1) {
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], addr.addr);
 		current = 0;
 	}
 
-	return target_resume(target, current, addr, 1, 0);
+	return target64_resume(target, current, &addr, 1, 0);
 }
 
 COMMAND_HANDLER(handle_step_command)
 {
+	struct target_addr addr;
 	if (CMD_ARGC > 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
@@ -2744,30 +2788,35 @@ COMMAND_HANDLER(handle_step_command)
 	/* with no CMD_ARGV, step from current pc, addr = 0,
 	 * with one argument addr = CMD_ARGV[0],
 	 * handle breakpoints, debugging */
-	uint32_t addr = 0;
+	TARGET_ADDR_INIT( &addr, 0 );
 	int current_pc = 1;
 	if (CMD_ARGC == 1) {
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], addr.addr);
 		current_pc = 0;
 	}
 
 	struct target *target = get_current_target(CMD_CTX);
 
-	return target->type->step(target, current_pc, addr, 1);
+	return target->type->pIo64_api->step(target, current_pc, &addr, 1);
 }
 
 static void handle_md_output(struct command_context *cmd_ctx,
-		struct target *target, uint32_t address, unsigned size,
+		struct target *target, const struct target_addr *pAddr, unsigned size,
 		unsigned count, const uint8_t *buffer)
 {
+	struct target_addr tmp_addr;
 	const unsigned line_bytecnt = 32;
 	unsigned line_modulo = line_bytecnt / size;
 
 	char output[line_bytecnt * 4 + 1];
 	unsigned output_len = 0;
 
+	tmp_addr = *pAddr;
 	const char *value_fmt;
 	switch (size) {
+	case 8:
+		value_fmt = "%16.16x ";
+		break;
 	case 4:
 		value_fmt = "%8.8x ";
 		break;
@@ -2787,13 +2836,16 @@ static void handle_md_output(struct command_context *cmd_ctx,
 		if (i % line_modulo == 0) {
 			output_len += snprintf(output + output_len,
 					sizeof(output) - output_len,
-					"0x%8.8x: ",
-					(unsigned)(address + (i*size)));
+					"%s: ",
+					target_addr64str1( target, tmp_addr.addr + (i*size)));
 		}
 
-		uint32_t value = 0;
+		uint64_t value = 0;
 		const uint8_t *value_ptr = buffer + i * size;
 		switch (size) {
+		case 8:
+			value = target_buffer_get_u64(target, value_ptr);
+			break;
 		case 4:
 			value = target_buffer_get_u32(target, value_ptr);
 			break;
@@ -2816,11 +2868,15 @@ static void handle_md_output(struct command_context *cmd_ctx,
 
 COMMAND_HANDLER(handle_md_command)
 {
+	struct target_addr addr;
+	TARGET_ADDR_PHYS( &addr, 0 );
+
 	if (CMD_ARGC < 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	unsigned size = 0;
 	switch (CMD_NAME[2]) {
+	/* FIXME: Add 64bit support? what letter do we use? */
 	case 'w':
 		size = 4;
 		break;
@@ -2836,18 +2892,21 @@ COMMAND_HANDLER(handle_md_command)
 
 	bool physical = strcmp(CMD_ARGV[0], "phys") == 0;
 	int (*fn)(struct target *target,
-			uint64_t address, uint64_t size_value, uint64_t count, uint8_t *buffer);
+			const struct target_addr *pAddr, uint64_t size_value, uint64_t count, uint8_t *buffer);
 	if (physical) {
 		CMD_ARGC--;
 		CMD_ARGV++;
-		fn = target_read_phys_memory;
-	} else
-		fn = target_read_memory;
+		fn = target64_read_phys_memory;
+		TARGET_ADDR_PHYS( &addr, 0 );
+	} else {
+		fn = target64_read_memory;
+		TARGET_ADDR_INIT( &addr, 0 );
+	}
+
 	if ((CMD_ARGC < 1) || (CMD_ARGC > 2))
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	uint32_t address;
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], addr.addr);
 
 	unsigned count = 1;
 	if (CMD_ARGC == 2)
@@ -2856,9 +2915,9 @@ COMMAND_HANDLER(handle_md_command)
 	uint8_t *buffer = calloc(count, size);
 
 	struct target *target = get_current_target(CMD_CTX);
-	int retval = fn(target, address, size, count, buffer);
+	int retval = fn(target, &addr, size, count, buffer);
 	if (ERROR_OK == retval)
-		handle_md_output(CMD_CTX, target, address, size, count, buffer);
+		handle_md_output(CMD_CTX, target, &addr, size, count, buffer);
 
 	free(buffer);
 
@@ -2866,19 +2925,20 @@ COMMAND_HANDLER(handle_md_command)
 }
 
 typedef int (*target_write_fn)(struct target *target,
-		uint64_t address, uint64_t size, uint64_t count, const uint8_t *buffer);
+		const struct target_addr *pAddr, uint64_t size, uint64_t count, const uint8_t *buffer);
 
 static int target_fill_mem(struct target *target,
-		uint32_t address,
+		const struct target_addr *pAddr,
 		target_write_fn fn,
 		unsigned data_size,
 		/* value */
-		uint32_t b,
+		uint64_t b,
 		/* count */
 		unsigned c)
 {
 	/* We have to write in reasonably large chunks to be able
 	 * to fill large memory areas with any sane speed */
+	struct target_addr tmp_addr;
 	const unsigned chunk_size = 16384;
 	uint8_t *target_buf = malloc(chunk_size * data_size);
 	if (target_buf == NULL) {
@@ -2888,6 +2948,9 @@ static int target_fill_mem(struct target *target,
 
 	for (unsigned i = 0; i < chunk_size; i++) {
 		switch (data_size) {
+		case 8:
+			target_buffer_set_u64(target, target_buf + i * data_size, b);
+			break;
 		case 4:
 			target_buffer_set_u32(target, target_buf + i * data_size, b);
 			break;
@@ -2909,7 +2972,9 @@ static int target_fill_mem(struct target *target,
 		current = c - x;
 		if (current > chunk_size)
 			current = chunk_size;
-		retval = fn(target, address + x * data_size, data_size, current, target_buf);
+		tmp_addr = *pAddr;
+		tmp_addr.addr += (x * data_size);
+		retval = fn(target, &tmp_addr, data_size, current, target_buf);
 		if (retval != ERROR_OK)
 			break;
 		/* avoid GDB timeouts */
@@ -2923,6 +2988,8 @@ static int target_fill_mem(struct target *target,
 
 COMMAND_HANDLER(handle_mw_command)
 {
+	struct target_addr addr;
+
 	if (CMD_ARGC < 2)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	bool physical = strcmp(CMD_ARGV[0], "phys") == 0;
@@ -2930,17 +2997,20 @@ COMMAND_HANDLER(handle_mw_command)
 	if (physical) {
 		CMD_ARGC--;
 		CMD_ARGV++;
-		fn = target_write_phys_memory;
-	} else
-		fn = target_write_memory;
+		fn = target64_write_phys_memory;
+		TARGET_ADDR_PHYS( &addr, 0 );
+	} else {
+		fn = target64_write_memory;
+		TARGET_ADDR_INIT( &addr, 0 );
+	}
+
 	if ((CMD_ARGC < 2) || (CMD_ARGC > 3))
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	uint32_t address;
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
+	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], addr.addr);
 
-	uint32_t value;
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], value);
+	uint64_t value;
+	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], value);
 
 	unsigned count = 1;
 	if (CMD_ARGC == 3)
@@ -2949,6 +3019,7 @@ COMMAND_HANDLER(handle_mw_command)
 	struct target *target = get_current_target(CMD_CTX);
 	unsigned wordsize;
 	switch (CMD_NAME[2]) {
+		/* FIXME: WHat to use for 64bit? */
 		case 'w':
 			wordsize = 4;
 			break;
@@ -2962,21 +3033,20 @@ COMMAND_HANDLER(handle_mw_command)
 			return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	return target_fill_mem(target, address, fn, wordsize, value, count);
+	return target_fill_mem(target, &addr, fn, wordsize, value, count);
 }
 
 static COMMAND_HELPER(parse_load_image_command_CMD_ARGV, struct image *image,
-		uint32_t *min_address, uint32_t *max_address)
+		struct target_addr *pMinAddr, struct target_addr *pMaxAddr)
 {
 	if (CMD_ARGC < 1 || CMD_ARGC > 5)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	/* a base address isn't always necessary,
 	 * default to 0x0 (i.e. don't relocate) */
+	image->base_address = 0;
 	if (CMD_ARGC >= 2) {
-		uint32_t addr;
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], addr);
-		image->base_address = addr;
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], image->base_address);
 		image->base_address_set = 1;
 	} else
 		image->base_address_set = 0;
@@ -2984,14 +3054,14 @@ static COMMAND_HELPER(parse_load_image_command_CMD_ARGV, struct image *image,
 	image->start_address_set = 0;
 
 	if (CMD_ARGC >= 4)
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[3], *min_address);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[3], pMinAddr->addr);
 	if (CMD_ARGC == 5) {
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[4], *max_address);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[4], pMaxAddr->addr);
 		/* use size (given) to find max (required) */
-		*max_address += *min_address;
+		pMaxAddr->addr += pMinAddr->addr;
 	}
 
-	if (*min_address > *max_address)
+	if (pMinAddr->addr > pMaxAddr->addr)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	return ERROR_OK;
@@ -3002,13 +3072,16 @@ COMMAND_HANDLER(handle_load_image_command)
 	uint8_t *buffer;
 	size_t buf_cnt;
 	uint32_t image_size;
-	uint32_t min_address = 0;
-	uint32_t max_address = 0xffffffff;
+	struct target_addr min_addr;
+	struct target_addr max_addr;
 	int i;
 	struct image image;
 
+	TARGET_ADDR_INIT( &min_addr, 0 );
+	TARGET_ADDR_INIT( &max_addr, (uint64_t)(-1) );
+
 	int retval = CALL_COMMAND_HANDLER(parse_load_image_command_CMD_ARGV,
-			&image, &min_address, &max_address);
+			&image, &min_addr, &max_addr);
 	if (ERROR_OK != retval)
 		return retval;
 
@@ -3042,28 +3115,30 @@ COMMAND_HANDLER(handle_load_image_command)
 
 		/* DANGER!!! beware of unsigned comparision here!!! */
 
-		if ((image.sections[i].base_address + buf_cnt >= min_address) &&
-				(image.sections[i].base_address < max_address)) {
+		if ((image.sections[i].base_address + buf_cnt >= min_addr.addr) &&
+				(image.sections[i].base_address < max_addr.addr)) {
 
-			if (image.sections[i].base_address < min_address) {
+			if (image.sections[i].base_address < min_addr.addr) {
 				/* clip addresses below */
-				offset += min_address-image.sections[i].base_address;
+				offset += min_addr.addr-image.sections[i].base_address;
 				length -= offset;
 			}
 
-			if (image.sections[i].base_address + buf_cnt > max_address)
-				length -= (image.sections[i].base_address + buf_cnt)-max_address;
+			if (image.sections[i].base_address + buf_cnt > max_addr.addr)
+				length -= (image.sections[i].base_address + buf_cnt)-max_addr.addr;
+
+			struct target_addr tmp_addr;
+			TARGET_ADDR_INIT( &tmp_addr , image.sections[i].base_address + offset );
 
-			retval = target_write_buffer(target,
-					image.sections[i].base_address + offset, length, buffer + offset);
+			retval = target64_write_buffer(target, &tmp_addr, length, buffer + offset);
 			if (retval != ERROR_OK) {
 				free(buffer);
 				break;
 			}
 			image_size += length;
-			command_print(CMD_CTX, "%u bytes written at address 0x%8.8" PRIx32 "",
+			command_print(CMD_CTX, "%u bytes written at address %s ",
 					(unsigned int)length,
-					image.sections[i].base_address + offset);
+					target_addr64str1( target, image.sections[i].base_address + offset));
 		}
 
 		free(buffer);
@@ -3086,15 +3161,17 @@ COMMAND_HANDLER(handle_dump_image_command)
 	struct fileio fileio;
 	uint8_t *buffer;
 	int retval, retvaltemp;
-	uint32_t address, size;
+	struct target_addr addr;
+	uint64_t size;
 	struct duration bench;
 	struct target *target = get_current_target(CMD_CTX);
 
 	if (CMD_ARGC != 3)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], address);
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], size);
+	TARGET_ADDR_INIT( &addr, 0 );
+	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], addr.addr);
+	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[2], size);
 
 	uint32_t buf_size = (size > 4096) ? 4096 : size;
 	buffer = malloc(buf_size);
@@ -3112,7 +3189,7 @@ COMMAND_HANDLER(handle_dump_image_command)
 	while (size > 0) {
 		size_t size_written;
 		uint32_t this_run_size = (size > buf_size) ? buf_size : size;
-		retval = target_read_buffer(target, address, this_run_size, buffer);
+		retval = target64_read_buffer(target, &addr, this_run_size, buffer);
 		if (retval != ERROR_OK)
 			break;
 
@@ -3121,7 +3198,7 @@ COMMAND_HANDLER(handle_dump_image_command)
 			break;
 
 		size -= this_run_size;
-		address += this_run_size;
+		addr.addr += this_run_size;
 	}
 
 	free(buffer);
@@ -3145,6 +3222,7 @@ COMMAND_HANDLER(handle_dump_image_command)
 
 static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 {
+	struct target_addr tmp_addr;
 	uint8_t *buffer;
 	size_t buf_cnt;
 	uint32_t image_size;
@@ -3169,9 +3247,7 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 	duration_start(&bench);
 
 	if (CMD_ARGC >= 2) {
-		uint32_t addr;
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], addr);
-		image.base_address = addr;
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], image.base_address);
 		image.base_address_set = 1;
 	} else {
 		image.base_address_set = 0;
@@ -3231,15 +3307,16 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 					size *= 4;
 					count /= 4;
 				}
-				retval = target_read_memory(target, image.sections[i].base_address, size, count, data);
+				TARGET_ADDR_INIT( &tmp_addr, image.sections[i].base_address );
+				retval = target64_read_memory(target, &tmp_addr, size, count, data);
 				if (retval == ERROR_OK) {
 					uint32_t t;
 					for (t = 0; t < buf_cnt; t++) {
 						if (data[t] != buffer[t]) {
 							command_print(CMD_CTX,
-										  "diff %d address 0x%08x. Was 0x%02x instead of 0x%02x",
+										  "diff %d address %s. Was 0x%02x instead of 0x%02x",
 										  diffs,
-										  (unsigned)(t + image.sections[i].base_address),
+										  target_addr64str1(target, t + image.sections[i].base_address ),
 										  data[t],
 										  buffer[t]);
 							if (diffs++ >= 127) {
@@ -3255,8 +3332,8 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 				free(data);
 			}
 		} else {
-			command_print(CMD_CTX, "address 0x%08" PRIx32 " length 0x%08zx",
-						  image.sections[i].base_address,
+			command_print(CMD_CTX, "address %s length 0x%08zx",
+						  target_addr64str1( target, image.sections[i].base_address),
 						  buf_cnt);
 		}
 
@@ -3297,8 +3374,8 @@ static int handle_bp_command_list(struct command_context *cmd_ctx)
 		if (breakpoint->type == BKPT_SOFT) {
 			char *buf = buf_to_str(breakpoint->orig_instr,
 					breakpoint->length, 16);
-			command_print(cmd_ctx, "IVA breakpoint: 0x%8.8" PRIx32 ", 0x%x, %i, 0x%s",
-					breakpoint->address,
+			command_print(cmd_ctx, "IVA breakpoint: %s, 0x%x, %i, 0x%s",
+				      target_addr64str1( target, breakpoint->address ),
 					breakpoint->length,
 					breakpoint->set, buf);
 			free(buf);
@@ -3308,14 +3385,14 @@ static int handle_bp_command_list(struct command_context *cmd_ctx)
 							breakpoint->asid,
 							breakpoint->length, breakpoint->set);
 			else if ((breakpoint->address != 0) && (breakpoint->asid != 0)) {
-				command_print(cmd_ctx, "Hybrid breakpoint(IVA): 0x%8.8" PRIx32 ", 0x%x, %i",
-							breakpoint->address,
+				command_print(cmd_ctx, "Hybrid breakpoint(IVA): %s, 0x%x, %i",
+					      target_addr64str1( target, breakpoint->address ),
 							breakpoint->length, breakpoint->set);
 				command_print(cmd_ctx, "\t|--->linked with ContextID: 0x%8.8" PRIx32,
 							breakpoint->asid);
 			} else
-				command_print(cmd_ctx, "Breakpoint(IVA): 0x%8.8" PRIx32 ", 0x%x, %i",
-							breakpoint->address,
+				command_print(cmd_ctx, "Breakpoint(IVA): %s, 0x%x, %i",
+					        target_addr64str1( target, breakpoint->address),
 							breakpoint->length, breakpoint->set);
 		}
 
@@ -3325,20 +3402,20 @@ static int handle_bp_command_list(struct command_context *cmd_ctx)
 }
 
 static int handle_bp_command_set(struct command_context *cmd_ctx,
-		uint32_t addr, uint32_t asid, uint32_t length, int hw)
+		const struct target_addr *pAddr, uint32_t asid, uint32_t length, int hw)
 {
 	struct target *target = get_current_target(cmd_ctx);
 
 	if (asid == 0) {
-		int retval = breakpoint_add(target, addr, length, hw);
+		int retval = breakpoint64_add(target, pAddr, length, hw);
 		if (ERROR_OK == retval)
-			command_print(cmd_ctx, "breakpoint set at 0x%8.8" PRIx32 "", addr);
+			command_print(cmd_ctx, "breakpoint set at 0x%s", target_addr2str1( target, pAddr ));
 		else {
 			LOG_ERROR("Failure setting breakpoint, the same address(IVA) is already used");
 			return retval;
 		}
-	} else if (addr == 0) {
-		int retval = context_breakpoint_add(target, asid, length, hw);
+	} else if (pAddr->addr == 0) {
+		int retval = context64_breakpoint_add(target, asid, length, hw);
 		if (ERROR_OK == retval)
 			command_print(cmd_ctx, "Context breakpoint set at 0x%8.8" PRIx32 "", asid);
 		else {
@@ -3346,7 +3423,7 @@ static int handle_bp_command_set(struct command_context *cmd_ctx,
 			return retval;
 		}
 	} else {
-		int retval = hybrid_breakpoint_add(target, addr, asid, length, hw);
+		int retval = hybrid64_breakpoint_add(target, pAddr, asid, length, hw);
 		if (ERROR_OK == retval)
 			command_print(cmd_ctx, "Hybrid breakpoint set at 0x%8.8" PRIx32 "", asid);
 		else {
@@ -3359,44 +3436,45 @@ static int handle_bp_command_set(struct command_context *cmd_ctx,
 
 COMMAND_HANDLER(handle_bp_command)
 {
-	uint32_t addr;
+	struct target_addr addr;
 	uint32_t asid;
-	uint32_t length;
+	uint64_t length;
 	int hw = BKPT_SOFT;
 
+	TARGET_ADDR_INIT( &addr, 0 );
 	switch (CMD_ARGC) {
 		case 0:
 			return handle_bp_command_list(CMD_CTX);
 
 		case 2:
 			asid = 0;
-			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
-			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], length);
-			return handle_bp_command_set(CMD_CTX, addr, asid, length, hw);
+			COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], addr.addr);
+			COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], length);
+			return handle_bp_command_set(CMD_CTX, &addr, asid, length, hw);
 
 		case 3:
 			if (strcmp(CMD_ARGV[2], "hw") == 0) {
 				hw = BKPT_HARD;
-				COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+				COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], addr.addr);
 
-				COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], length);
+				COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], length);
 
 				asid = 0;
-				return handle_bp_command_set(CMD_CTX, addr, asid, length, hw);
+				return handle_bp_command_set(CMD_CTX, &addr, asid, length, hw);
 			} else if (strcmp(CMD_ARGV[2], "hw_ctx") == 0) {
 				hw = BKPT_HARD;
 				COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], asid);
-				COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], length);
-				addr = 0;
-				return handle_bp_command_set(CMD_CTX, addr, asid, length, hw);
+				COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], length);
+				TARGET_ADDR_INIT( &addr, 0 );
+				return handle_bp_command_set(CMD_CTX, &addr, asid, length, hw);
 			}
 
 		case 4:
 			hw = BKPT_HARD;
-			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+			COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], addr.addr);
 			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], asid);
-			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], length);
-			return handle_bp_command_set(CMD_CTX, addr, asid, length, hw);
+			COMMAND_PARSE_NUMBER(u64, CMD_ARGV[2], length);
+			return handle_bp_command_set(CMD_CTX, &addr, asid, length, hw);
 
 		default:
 			return ERROR_COMMAND_SYNTAX_ERROR;
@@ -3408,11 +3486,12 @@ COMMAND_HANDLER(handle_rbp_command)
 	if (CMD_ARGC != 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	uint32_t addr;
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+	struct target_addr addr;
+	TARGET_ADDR_INIT( &addr, 0 );
+	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], addr.addr);
 
 	struct target *target = get_current_target(CMD_CTX);
-	breakpoint_remove(target, addr);
+	breakpoint64_remove(target, &addr);
 
 	return ERROR_OK;
 }
@@ -3425,32 +3504,34 @@ COMMAND_HANDLER(handle_wp_command)
 		struct watchpoint *watchpoint = target->watchpoints;
 
 		while (watchpoint) {
-			command_print(CMD_CTX, "address: 0x%8.8" PRIx32
-					", len: 0x%8.8" PRIx32
-					", r/w/a: %i, value: 0x%8.8" PRIx32
-					", mask: 0x%8.8" PRIx32,
-					watchpoint->address,
-					watchpoint->length,
+			char buf3[ TARGET_ADDR2STR_SIZE ];
+			char buf4[ TARGET_ADDR2STR_SIZE ];
+			command_print(CMD_CTX, "address: %s"
+					", len: %s" 
+					", r/w/a: %i, value: %s"
+					", mask: %s",
+				      target_addr64str1( target, watchpoint->address),
+				      target_addr64str2( target, watchpoint->length ),
 					(int)watchpoint->rw,
-					watchpoint->value,
-					watchpoint->mask);
+					target_addr64str( target, watchpoint->value, buf3 ),
+					target_addr64str( target, watchpoint->mask, buf4 ) );
 			watchpoint = watchpoint->next;
 		}
 		return ERROR_OK;
 	}
 
 	enum watchpoint_rw type = WPT_ACCESS;
-	uint32_t addr = 0;
-	uint32_t length = 0;
-	uint32_t data_value = 0x0;
-	uint32_t data_mask = 0xffffffff;
+	uint64_t address = 0;
+	uint64_t length = 0;
+	uint64_t data_value = 0x0;
+	uint64_t data_mask = ((uint64_t)(-1));
 
 	switch (CMD_ARGC) {
 	case 5:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[4], data_mask);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[4], data_mask);
 		/* fall through */
 	case 4:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[3], data_value);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[3], data_value);
 		/* fall through */
 	case 3:
 		switch (CMD_ARGV[2][0]) {
@@ -3469,15 +3550,17 @@ COMMAND_HANDLER(handle_wp_command)
 		}
 		/* fall through */
 	case 2:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[1], length);
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], length);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], address);
 		break;
 
 	default:
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	int retval = watchpoint_add(target, addr, length, type,
+	struct target_addr addr;
+	TARGET_ADDR_INIT( &addr, address );
+	int retval = watchpoint64_add(target, &addr, length, type,
 			data_value, data_mask);
 	if (ERROR_OK != retval)
 		LOG_ERROR("Failure setting watchpoints");
@@ -3490,11 +3573,12 @@ COMMAND_HANDLER(handle_rwp_command)
 	if (CMD_ARGC != 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	uint32_t addr;
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], addr);
+	struct target_addr addr;
+	TARGET_ADDR_INIT( &addr, 0 );
+	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], addr.addr);
 
 	struct target *target = get_current_target(CMD_CTX);
-	watchpoint_remove(target, addr);
+	watchpoint64_remove(target, &addr);
 
 	return ERROR_OK;
 }
@@ -3510,14 +3594,18 @@ COMMAND_HANDLER(handle_virt2phys_command)
 	if (CMD_ARGC != 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	uint32_t va;
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], va);
-	uint32_t pa;
+	struct target_addr in_va;
+	struct target_addr out_pa;
+
+	TARGET_ADDR_INIT( &in_va, 0 );
+	in_va.route = TA_ROUTE_VIRTUAL;
+
+	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], in_va.addr);
 
 	struct target *target = get_current_target(CMD_CTX);
-	int retval = target->type->virt2phys(target, va, &pa);
+	int retval = target64_virt2phys(target, &in_va, &out_pa);
 	if (retval == ERROR_OK)
-		command_print(CMD_CTX, "Physical address 0x%08" PRIx32 "", pa);
+		command_print(CMD_CTX, "Physical address 0x%s", target_addr2str1( target, &out_pa ));
 
 	return retval;
 }
@@ -3548,10 +3636,17 @@ typedef unsigned char UNIT[2];  /* unit of profiling */
 
 /* Dump a gmon.out histogram file. */
 static void write_gmon(uint32_t *samples, uint32_t sampleNum, const char *filename,
-		bool with_range, uint32_t start_address, uint32_t end_address)
+		       bool with_range, const struct target_addr *pStartAddr, const struct target_addr *pEndAddr )
 {
 	uint32_t i;
 	FILE *f = fopen(filename, "w");
+
+	if( target_addr_is64bit( pStartAddr ) ||
+	    target_addr_is64bit( pEndAddr ) ){
+		LOG_ERROR("Sorry 64bit gmon not supported yet\n");
+		return;
+	}
+
 	if (f == NULL)
 		return;
 	writeString(f, "gmon");
@@ -3564,11 +3659,11 @@ static void write_gmon(uint32_t *samples, uint32_t sampleNum, const char *filena
 	writeData(f, &zero, 1);
 
 	/* figure out bucket size */
-	uint32_t min;
-	uint32_t max;
+	uint64_t min;
+	uint64_t max;
 	if (with_range) {
-		min = start_address;
-		max = end_address;
+		min = pStartAddr->addr;
+		max = pEndAddr->addr;
 	} else {
 		min = samples[0];
 		max = samples[0];
@@ -3600,7 +3695,7 @@ static void write_gmon(uint32_t *samples, uint32_t sampleNum, const char *filena
 	}
 	memset(buckets, 0, sizeof(int) * numBuckets);
 	for (i = 0; i < sampleNum; i++) {
-		uint32_t address = samples[i];
+		uint64_t address = samples[i];
 
 		if ((address < min) || (max <= address))
 			continue;
@@ -3653,11 +3748,11 @@ COMMAND_HANDLER(handle_profile_command)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
 	const uint32_t MAX_PROFILE_SAMPLE_NUM = 10000;
-	uint32_t offset;
+	uint64_t offset;
 	uint32_t num_of_samples;
 	int retval = ERROR_OK;
 
-	COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], offset);
+	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], offset);
 
 	uint32_t *samples = malloc(sizeof(uint32_t) * MAX_PROFILE_SAMPLE_NUM);
 	if (samples == NULL) {
@@ -3698,17 +3793,19 @@ COMMAND_HANDLER(handle_profile_command)
 		return retval;
 	}
 
-	uint32_t start_address = 0;
-	uint32_t end_address = 0;
+	struct target_addr start_addr;
+	struct target_addr end_addr;
+	TARGET_ADDR_INIT( &start_addr, 0 );
+	TARGET_ADDR_INIT( &end_addr, 0);
 	bool with_range = false;
 	if (CMD_ARGC == 4) {
 		with_range = true;
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[2], start_address);
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[3], end_address);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[2], start_addr.addr);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[3], end_addr.addr);
 	}
 
 	write_gmon(samples, num_of_samples, CMD_ARGV[1],
-			with_range, start_address, end_address);
+			with_range, &start_addr, &end_addr);
 	command_print(CMD_CTX, "Wrote %s", CMD_ARGV[1]);
 
 	free(samples);
@@ -3764,9 +3861,9 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 	long l;
 	uint32_t width;
 	int len;
-	uint32_t addr;
+	struct target_addr addr;
 	uint32_t count;
-	uint32_t v;
+	uint64_t v;
 	const char *varname;
 	int  n, e, retval;
 	uint32_t i;
@@ -3788,8 +3885,10 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 	if (e != JIM_OK)
 		return e;
 
-	e = Jim_GetLong(interp, argv[2], &l);
-	addr = l;
+	jim_wide tmp_w;
+	e = Jim_GetWide(interp, argv[2], &tmp_w);
+	TARGET_ADDR_INIT( &addr, tmp_w );
+
 	if (e != JIM_OK)
 		return e;
 	e = Jim_GetLong(interp, argv[3], &l);
@@ -3806,9 +3905,12 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 		case 32:
 			width = 4;
 			break;
+		case 64:
+			width = 8;
+			break;
 		default:
 			Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-			Jim_AppendStrings(interp, Jim_GetResult(interp), "Invalid width param, must be 8/16/32", NULL);
+			Jim_AppendStrings(interp, Jim_GetResult(interp), "Invalid width param, must be 8/16/32/64", NULL);
 			return JIM_ERR;
 	}
 	if (len == 0) {
@@ -3816,7 +3918,7 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 		Jim_AppendStrings(interp, Jim_GetResult(interp), "mem2array: zero width read?", NULL);
 		return JIM_ERR;
 	}
-	if ((addr + (len * width)) < addr) {
+	if ((addr.addr + (len * width)) < addr.addr) {
 		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
 		Jim_AppendStrings(interp, Jim_GetResult(interp), "mem2array: addr + len - wraps to zero?", NULL);
 		return JIM_ERR;
@@ -3829,14 +3931,15 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 	}
 
 	if ((width == 1) ||
-		((width == 2) && ((addr & 1) == 0)) ||
-		((width == 4) && ((addr & 3) == 0))) {
+		((width == 2) && ((addr.addr & 1) == 0)) ||
+		((width == 4) && ((addr.addr & 3) == 0)) ||
+		((width == 8) && ((addr.addr & 7) == 0)) ) {
 		/* all is well */
 	} else {
 		char buf[100];
 		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-		sprintf(buf, "mem2array address: 0x%08" PRIx32 " is not aligned for %" PRId32 " byte reads",
-				addr,
+		sprintf(buf, "mem2array address: 0x%s is not aligned for %" PRId32 " byte reads",
+				target_addr2str1( target, &addr ),
 				width);
 		Jim_AppendStrings(interp, Jim_GetResult(interp), buf , NULL);
 		return JIM_ERR;
@@ -3861,11 +3964,11 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 		if (count > (buffersize / width))
 			count = (buffersize / width);
 
-		retval = target_read_memory(target, addr, width, count, buffer);
+		retval = target64_read_memory(target, &addr, width, count, buffer);
 		if (retval != ERROR_OK) {
 			/* BOO !*/
-			LOG_ERROR("mem2array: Read @ 0x%08x, w=%d, cnt=%d, failed",
-					  (unsigned int)addr,
+			LOG_ERROR("mem2array: Read @ 0x%s, w=%d, cnt=%d, failed",
+					  target_addr2str1( target, &addr ),
 					  (int)width,
 					  (int)count);
 			Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
@@ -3876,6 +3979,9 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 			v = 0; /* shut up gcc */
 			for (i = 0; i < count ; i++, n++) {
 				switch (width) {
+					case 8:
+						v = target_buffer_get_u64(target, &buffer[i*width]);
+						break;
 					case 4:
 						v = target_buffer_get_u32(target, &buffer[i*width]);
 						break;
@@ -3889,7 +3995,7 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 				new_int_array_element(interp, varname, n, v);
 			}
 			len -= count;
-			addr += count * width;
+			addr.addr += count * width;
 		}
 	}
 
@@ -3900,12 +4006,12 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 	return e;
 }
 
-static int get_int_array_element(Jim_Interp *interp, const char *varname, int idx, uint32_t *val)
+static int get_u64_array_element(Jim_Interp *interp, const char *varname, int idx, uint64_t *val)
 {
 	char *namebuf;
 	Jim_Obj *nameObjPtr, *valObjPtr;
 	int result;
-	long l;
+	
 
 	namebuf = alloc_printf("%s(%d)", varname, idx);
 	if (!namebuf)
@@ -3924,9 +4030,10 @@ static int get_int_array_element(Jim_Interp *interp, const char *varname, int id
 	if (valObjPtr == NULL)
 		return JIM_ERR;
 
-	result = Jim_GetLong(interp, valObjPtr, &l);
+	jim_wide w;
+	result = Jim_GetWide(interp, valObjPtr, &w);
 	/* printf("%s(%d) => 0%08x\n", varname, idx, val); */
-	*val = l;
+	*val = w;
 	return result;
 }
 
@@ -3953,9 +4060,9 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 	long l;
 	uint32_t width;
 	int len;
-	uint32_t addr;
+	struct target_addr addr;
 	uint32_t count;
-	uint32_t v;
+	uint64_t v;
 	const char *varname;
 	int  n, e, retval;
 	uint32_t i;
@@ -3977,10 +4084,13 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 	if (e != JIM_OK)
 		return e;
 
-	e = Jim_GetLong(interp, argv[2], &l);
-	addr = l;
+	jim_wide w_tmp;
+	e = Jim_GetWide(interp, argv[2], &w_tmp);
 	if (e != JIM_OK)
 		return e;
+	/* FIXME: Add support for security prefixes! */
+	TARGET_ADDR_INIT( &addr, w_tmp );
+	
 	e = Jim_GetLong(interp, argv[3], &l);
 	len = l;
 	if (e != JIM_OK)
@@ -3995,10 +4105,13 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 		case 32:
 			width = 4;
 			break;
+		case 64:
+			width = 8;
+			break;
 		default:
 			Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
 			Jim_AppendStrings(interp, Jim_GetResult(interp),
-					"Invalid width param, must be 8/16/32", NULL);
+					"Invalid width param, must be 8/16/32/64", NULL);
 			return JIM_ERR;
 	}
 	if (len == 0) {
@@ -4007,7 +4120,7 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 				"array2mem: zero width read?", NULL);
 		return JIM_ERR;
 	}
-	if ((addr + (len * width)) < addr) {
+	if ((addr.addr + (len * width)) < addr.addr) {
 		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
 		Jim_AppendStrings(interp, Jim_GetResult(interp),
 				"array2mem: addr + len - wraps to zero?", NULL);
@@ -4022,14 +4135,15 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 	}
 
 	if ((width == 1) ||
-		((width == 2) && ((addr & 1) == 0)) ||
-		((width == 4) && ((addr & 3) == 0))) {
+		((width == 2) && ((addr.addr & 1) == 0)) ||
+		((width == 4) && ((addr.addr & 3) == 0)) ||
+		((width == 8) && ((addr.addr & 7) == 0))) {
 		/* all is well */
 	} else {
 		char buf[100];
 		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-		sprintf(buf, "array2mem address: 0x%08x is not aligned for %d byte reads",
-				(unsigned int)addr,
+		sprintf(buf, "array2mem address: 0x%s is not aligned for %d byte reads",
+				target_addr2str1( target, &addr ),
 				(int)width);
 		Jim_AppendStrings(interp, Jim_GetResult(interp), buf , NULL);
 		return JIM_ERR;
@@ -4056,8 +4170,11 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 
 		v = 0; /* shut up gcc */
 		for (i = 0; i < count; i++, n++) {
-			get_int_array_element(interp, varname, n, &v);
+			get_u64_array_element(interp, varname, n, &v);
 			switch (width) {
+			case 8:
+				target_buffer_set_u64(target, &buffer[i * width], v);
+				break;
 			case 4:
 				target_buffer_set_u32(target, &buffer[i * width], v);
 				break;
@@ -4071,11 +4188,11 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 		}
 		len -= count;
 
-		retval = target_write_memory(target, addr, width, count, buffer);
+		retval = target64_write_memory(target, &addr, width, count, buffer);
 		if (retval != ERROR_OK) {
 			/* BOO !*/
-			LOG_ERROR("array2mem: Write @ 0x%08x, w=%d, cnt=%d, failed",
-					  (unsigned int)addr,
+			LOG_ERROR("array2mem: Write @ 0x%s, w=%d, cnt=%d, failed",
+					  target_addr2str1( target, &addr ),
 					  (int)width,
 					  (int)count);
 			Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
@@ -4083,7 +4200,7 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 			e = JIM_ERR;
 			break;
 		}
-		addr += count * width;
+		addr.addr += count * width;
 	}
 
 	free(buffer);
@@ -4302,7 +4419,7 @@ no_params:
 				if (goi->argc != 0)
 					goto no_params;
 			}
-			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->working_area_virt));
+			Jim_SetResult(goi->interp, Jim_NewWideObj(goi->interp, target->working_area_virt));
 			/* loop for more */
 			break;
 
@@ -4318,7 +4435,7 @@ no_params:
 				if (goi->argc != 0)
 					goto no_params;
 			}
-			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->working_area_phys));
+			Jim_SetResult(goi->interp, Jim_NewWideObj(goi->interp, target->working_area_phys));
 			/* loop for more */
 			break;
 
@@ -4333,7 +4450,7 @@ no_params:
 				if (goi->argc != 0)
 					goto no_params;
 			}
-			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->working_area_size));
+			Jim_SetResult(goi->interp, Jim_NewWideObj(goi->interp, target->working_area_size));
 			/* loop for more */
 			break;
 
@@ -4420,7 +4537,7 @@ no_params:
 				if (goi->argc != 0)
 					goto no_params;
 			}
-			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->dbgbase));
+			Jim_SetResult(goi->interp, Jim_NewWideObj(goi->interp, target->dbgbase));
 			/* loop for more */
 			break;
 		case TCFG_CTIBASE:
@@ -4433,7 +4550,7 @@ no_params:
 				if (goi->argc != 0)
 					goto no_params;
 			}
-			Jim_SetResult(goi->interp, Jim_NewIntObj(goi->interp, target->ctibase));
+			Jim_SetResult(goi->interp, Jim_NewWideObj(goi->interp, target->ctibase));
 			/* loop for more */
 			break;
 
@@ -4475,6 +4592,7 @@ static int jim_target_configure(Jim_Interp *interp, int argc, Jim_Obj * const *a
 static int jim_target_mw(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	const char *cmd_name = Jim_GetString(argv[0], NULL);
+	struct target_addr addr;
 
 	Jim_GetOptInfo goi;
 	Jim_GetOpt_Setup(&goi, interp, argc - 1, argv + 1);
@@ -4486,7 +4604,7 @@ static int jim_target_mw(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	}
 
 	target_write_fn fn;
-	fn = target_write_memory;
+	fn = target64_write_memory;
 
 	int e;
 	if (strcmp(Jim_GetString(argv[1], NULL), "phys") == 0) {
@@ -4496,13 +4614,17 @@ static int jim_target_mw(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		if (e != JIM_OK)
 			return e;
 
-		fn = target_write_phys_memory;
+		TARGET_ADDR_PHYS( &addr, 0 );
+		fn = target64_write_phys_memory;
+	} else {
+		TARGET_ADDR_INIT( &addr, 0 );
 	}
 
 	jim_wide a;
 	e = Jim_GetOpt_Wide(&goi, &a);
 	if (e != JIM_OK)
 		return e;
+	addr.addr = a;
 
 	jim_wide b;
 	e = Jim_GetOpt_Wide(&goi, &b);
@@ -4522,6 +4644,7 @@ static int jim_target_mw(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 
 	struct target *target = Jim_CmdPrivData(goi.interp);
 	unsigned data_size;
+	/* FIXME: what do we use for 64bit? */
 	if (strcasecmp(cmd_name, "mww") == 0)
 		data_size = 4;
 	else if (strcasecmp(cmd_name, "mwh") == 0)
@@ -4533,7 +4656,7 @@ static int jim_target_mw(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		return JIM_ERR;
 	}
 
-	return (target_fill_mem(target, a, fn, data_size, b, c) == ERROR_OK) ? JIM_OK : JIM_ERR;
+	return (target_fill_mem(target, &addr, fn, data_size, b, c) == ERROR_OK) ? JIM_OK : JIM_ERR;
 }
 
 /**
@@ -4567,6 +4690,7 @@ static int jim_target_mw(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	const char *cmd_name = Jim_GetString(argv[0], NULL);
+	struct target_addr addr;
 
 	Jim_GetOptInfo goi;
 	Jim_GetOpt_Setup(&goi, interp, argc - 1, argv + 1);
@@ -4578,26 +4702,30 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	}
 
 	int (*fn)(struct target *target,
-			uint64_t address, uint64_t size, uint64_t count, uint8_t *buffer);
-	fn = target_read_memory;
+			const struct target_addr *pAddr, uint64_t size, uint64_t count, uint8_t *buffer);
+	fn = target64_read_memory;
 
 	int e;
 	if (strcmp(Jim_GetString(argv[1], NULL), "phys") == 0) {
 		/* consume it */
 		struct Jim_Obj *obj;
+		TARGET_ADDR_PHYS( &addr, 0 );
 		e = Jim_GetOpt_Obj(&goi, &obj);
 		if (e != JIM_OK)
 			return e;
 
-		fn = target_read_phys_memory;
+		fn = target64_read_phys_memory;
+	} else {
+		TARGET_ADDR_INIT( &addr, 0 );
 	}
 
 	/* Read address parameter */
-	jim_wide addr;
-	e = Jim_GetOpt_Wide(&goi, &addr);
+	jim_wide a;
+	e = Jim_GetOpt_Wide(&goi, &a);
 	if (e != JIM_OK)
 		return JIM_ERR;
-
+	addr.addr = a;
+	
 	/* If next parameter exists, read it out as the count parameter, if not, set it to 1 (default) */
 	jim_wide count;
 	if (goi.argc == 1) {
@@ -4611,6 +4739,7 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	if (goi.argc != 0)
 		return JIM_ERR;
 
+	/* FIXME: Must add 64bit support, what letter do we want to use? */
 	jim_wide dwidth = 1; /* shut up gcc */
 	if (strcasecmp(cmd_name, "mdw") == 0)
 		dwidth = 4;
@@ -4633,15 +4762,23 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		y = (bytes < 16) ? bytes : 16; /* y = min(bytes, 16); */
 
 		/* Try to read out next block */
-		e = fn(target, addr, dwidth, y / dwidth, target_buf);
+		e = fn(target, &addr, dwidth, y / dwidth, target_buf);
 
 		if (e != ERROR_OK) {
-			Jim_SetResultFormatted(interp, "error reading target @ 0x%08lx", (long)addr);
+			Jim_SetResultFormatted(interp, "error reading target @ 0x%s", target_addr2str1( target, &addr ) );
 			return JIM_ERR;
 		}
 
-		command_print_sameline(NULL, "0x%08x ", (int)(addr));
+		command_print_sameline(NULL, "0x%s ", target_addr2str1( target, &addr ));
 		switch (dwidth) {
+		case 8:
+			for (x = 0; x < 16 && x < y; x += 8) {
+				z = target_buffer_get_u64(target, &(target_buf[x]));
+				command_print_sameline(NULL, "%08x ", (int)(z));
+			}
+			for (; (x < 16) ; x += 8)
+				command_print_sameline(NULL, "                 ");
+			break;
 		case 4:
 			for (x = 0; x < 16 && x < y; x += 4) {
 				z = target_buffer_get_u32(target, &(target_buf[x]));
@@ -4689,7 +4826,7 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		command_print_sameline(NULL, "%s\n", target_buf);
 		/* NEXT... */
 		bytes -= 16;
-		addr += 16;
+		addr.addr += 16;
 	}
 	return JIM_OK;
 }
@@ -4935,6 +5072,7 @@ static const struct command_registration target_instance_command_handlers[] = {
 		.help  = "returns the specified target attribute",
 		.usage = "target_attribute",
 	},
+	/* FIXME: ADD 64bit command support! */
 	{
 		.name = "mww",
 		.mode = COMMAND_EXEC,
@@ -4981,7 +5119,7 @@ static const struct command_registration target_instance_command_handlers[] = {
 		.name = "array2mem",
 		.mode = COMMAND_EXEC,
 		.jim_handler = jim_target_array2mem,
-		.help = "Writes Tcl array of 8/16/32 bit numbers "
+		.help = "Writes Tcl array of 8/16/32/64 bit numbers "
 			"to target memory",
 		.usage = "arrayname bitwidth address count",
 	},
@@ -4989,7 +5127,7 @@ static const struct command_registration target_instance_command_handlers[] = {
 		.name = "mem2array",
 		.mode = COMMAND_EXEC,
 		.jim_handler = jim_target_mem2array,
-		.help = "Loads Tcl array of 8/16/32 bit numbers "
+		.help = "Loads Tcl array of 8/16/32/64 bit numbers "
 			"from target memory",
 		.usage = "arrayname bitwidth address count",
 	},
@@ -5469,7 +5607,7 @@ static const struct command_registration target_subcommand_handlers[] = {
 };
 
 struct FastLoad {
-	uint32_t address;
+	struct target_addr addr;
 	uint8_t *data;
 	int length;
 
@@ -5495,15 +5633,19 @@ COMMAND_HANDLER(handle_fast_load_image_command)
 {
 	uint8_t *buffer;
 	size_t buf_cnt;
-	uint32_t image_size;
-	uint32_t min_address = 0;
-	uint32_t max_address = 0xffffffff;
+	uint64_t image_size;
+	struct target_addr min_addr;
+	struct target_addr max_addr;
 	int i;
+	struct target *target = get_current_target(CMD_CTX);			
+
+	TARGET_ADDR_INIT( &min_addr, 0 );
+	TARGET_ADDR_INIT( &max_addr, ((uint64_t)(-1)));
 
 	struct image image;
 
 	int retval = CALL_COMMAND_HANDLER(parse_load_image_command_CMD_ARGV,
-			&image, &min_address, &max_address);
+			&image, &min_addr, &max_addr);
 	if (ERROR_OK != retval)
 		return retval;
 
@@ -5539,27 +5681,27 @@ COMMAND_HANDLER(handle_fast_load_image_command)
 			break;
 		}
 
-		uint32_t offset = 0;
-		uint32_t length = buf_cnt;
+		uint64_t offset = 0;
+		uint64_t length = buf_cnt;
 
 		/* DANGER!!! beware of unsigned comparision here!!! */
 
-		if ((image.sections[i].base_address + buf_cnt >= min_address) &&
-				(image.sections[i].base_address < max_address)) {
-			if (image.sections[i].base_address < min_address) {
+		if ((image.sections[i].base_address + buf_cnt >= min_addr.addr) &&
+				(image.sections[i].base_address < max_addr.addr)) {
+			if (image.sections[i].base_address < min_addr.addr) {
 				/* clip addresses below */
-				offset += min_address-image.sections[i].base_address;
+				offset += min_addr.addr-image.sections[i].base_address;
 				length -= offset;
 			}
 
-			if (image.sections[i].base_address + buf_cnt > max_address)
-				length -= (image.sections[i].base_address + buf_cnt)-max_address;
+			if (image.sections[i].base_address + buf_cnt > max_addr.addr)
+				length -= (image.sections[i].base_address + buf_cnt)-max_addr.addr;
 
-			fastload[i].address = image.sections[i].base_address + offset;
+			TARGET_ADDR_INIT( &fastload[i].addr, image.sections[i].base_address + offset );
 			fastload[i].data = malloc(length);
 			if (fastload[i].data == NULL) {
 				free(buffer);
-				command_print(CMD_CTX, "error allocating buffer for section (%" PRIu32 " bytes)",
+				command_print(CMD_CTX, "error allocating buffer for section (%" PRIu64 " bytes)",
 							  length);
 				retval = ERROR_FAIL;
 				break;
@@ -5568,16 +5710,16 @@ COMMAND_HANDLER(handle_fast_load_image_command)
 			fastload[i].length = length;
 
 			image_size += length;
-			command_print(CMD_CTX, "%u bytes written at address 0x%8.8x",
+			command_print(CMD_CTX, "%u bytes written at address %s",
 						  (unsigned int)length,
-						  ((unsigned int)(image.sections[i].base_address + offset)));
+						  target_addr64str1( target, image.sections[i].base_address + offset) );
 		}
 
 		free(buffer);
 	}
 
 	if ((ERROR_OK == retval) && (duration_measure(&bench) == ERROR_OK)) {
-		command_print(CMD_CTX, "Loaded %" PRIu32 " bytes "
+		command_print(CMD_CTX, "Loaded %" PRIu64 " bytes "
 				"in %fs (%0.3f KiB/s)", image_size,
 				duration_elapsed(&bench), duration_kbps(&bench, image_size));
 
@@ -5606,12 +5748,12 @@ COMMAND_HANDLER(handle_fast_load_command)
 	int ms = timeval_ms();
 	int size = 0;
 	int retval = ERROR_OK;
+	struct target *target = get_current_target(CMD_CTX);
 	for (i = 0; i < fastload_num; i++) {
-		struct target *target = get_current_target(CMD_CTX);
-		command_print(CMD_CTX, "Write to 0x%08x, length 0x%08x",
-					  (unsigned int)(fastload[i].address),
+		command_print(CMD_CTX, "Write to 0x%s, length 0x%08x",
+					  target_addr2str1( target, &fastload[i].addr ),
 					  (unsigned int)(fastload[i].length));
-		retval = target_write_buffer(target, fastload[i].address, fastload[i].length, fastload[i].data);
+		retval = target64_write_buffer(target, &fastload[i].addr, fastload[i].length, fastload[i].data);
 		if (retval != ERROR_OK)
 			break;
 		size += fastload[i].length;
@@ -5695,6 +5837,7 @@ COMMAND_HANDLER(handle_test_mem_access_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
 	uint32_t test_size;
+	struct target_addr tmp_addr;
 	int retval = ERROR_OK;
 
 	if (target->state != TARGET_HALTED) {
@@ -5722,7 +5865,8 @@ COMMAND_HANDLER(handle_test_mem_access_command)
 	for (size_t i = 0; i < num_bytes; i++)
 		test_pattern[i] = rand();
 
-	retval = target_write_memory(target, wa->address, 1, num_bytes, test_pattern);
+	TARGET_ADDR_INIT( &tmp_addr,wa->address );
+	retval = target64_write_memory(target,&tmp_addr , 1, num_bytes, test_pattern);
 	if (retval != ERROR_OK) {
 		LOG_ERROR("Test pattern write failed");
 		goto out;
@@ -5740,14 +5884,18 @@ COMMAND_HANDLER(handle_test_mem_access_command)
 					read_ref[i] = rand();
 					read_buf[i] = read_ref[i];
 				}
+				TARGET_ADDR_INIT( &tmp_addr, offset );
 				command_print_sameline(CMD_CTX,
-						"Test read %" PRIu32 " x %d @ %d to %saligned buffer: ", count,
-						size, offset, host_offset ? "un" : "");
+						"Test read %" PRIu32 " x %d @ 0x%s to %saligned buffer: ",
+						count, size, target_addr2str1( target, &tmp_addr ),
+						host_offset ? "un" : "");
 
 				struct duration bench;
 				duration_start(&bench);
 
-				retval = target_read_memory(target, wa->address + offset, size, count,
+				TARGET_ADDR_INIT( &tmp_addr , wa->address );
+				tmp_addr.addr += offset;
+				retval = target64_read_memory(target, &tmp_addr, size, count,
 						read_buf + size + host_offset);
 
 				duration_measure(&bench);
@@ -5812,11 +5960,13 @@ out:
 
 				for (size_t i = 0; i < host_bufsiz; i++)
 					write_buf[i] = rand();
+				TARGET_ADDR_INIT( &tmp_addr, offset );
 				command_print_sameline(CMD_CTX,
-						"Test write %" PRIu32 " x %d @ %d from %saligned buffer: ", count,
-						size, offset, host_offset ? "un" : "");
+						"Test write %" PRIu32 " x %d @ 0x%s from %saligned buffer: ", count,
+						size, target_addr2str1( target, &tmp_addr ), host_offset ? "un" : "");
 
-				retval = target_write_memory(target, wa->address, 1, num_bytes, test_pattern);
+				TARGET_ADDR_INIT( &tmp_addr, wa->address );
+				retval = target64_write_memory(target, &tmp_addr, 1, num_bytes, test_pattern);
 				if (retval != ERROR_OK) {
 					command_print(CMD_CTX, "Test pattern write failed");
 					goto nextw;
@@ -5829,7 +5979,8 @@ out:
 				struct duration bench;
 				duration_start(&bench);
 
-				retval = target_write_memory(target, wa->address + size + offset, size, count,
+				TARGET_ADDR_INIT( &tmp_addr, wa->address + size + offset );
+				retval = target64_write_memory(target, &tmp_addr, size, count,
 						write_buf + host_offset);
 
 				duration_measure(&bench);
@@ -5843,7 +5994,7 @@ out:
 				}
 
 				/* read back */
-				retval = target_read_memory(target, wa->address, 1, num_bytes, read_buf);
+				retval = target64_read_memory(target, &tmp_addr, 1, num_bytes, read_buf);
 				if (retval != ERROR_OK) {
 					command_print(CMD_CTX, "Test pattern write failed");
 					goto nextw;
@@ -6103,6 +6254,7 @@ static const struct command_registration target_exec_command_handlers[] = {
 
 	COMMAND_REGISTRATION_DONE
 };
+
 static int target_register_user_commands(struct command_context *cmd_ctx)
 {
 	int retval = ERROR_OK;
@@ -6117,3 +6269,198 @@ static int target_register_user_commands(struct command_context *cmd_ctx)
 
 	return register_commands(cmd_ctx, NULL, target_exec_command_handlers);
 }
+
+const char *target_addr64str( struct target *target, uint64_t a, char *buf )
+{
+	int w;
+	/* Determine if this address should be represented as 64 or 32 bit */
+	if( target->is_64b | target->force_addr64 | target_addr64_is64bit( a ) ){
+		w = 16;
+	} else {
+		w = 8;
+	}
+	snprintf( buf, TARGET_ADDR2STR_SIZE, "%0*" PRIx64, w, a );
+	return buf;
+}
+
+const char *target_addr2str( struct target *target, const struct target_addr *pAddr, char *buf )
+{
+	return target_addr64str( target, pAddr->addr, buf );
+}
+
+	  
+
+const char *target_addr64str1( struct target *target, uint64_t address )
+{
+	return target_addr64str( target, address, target->adr2str1 );
+}
+
+const char *target_addr64str2( struct target *target, uint64_t address )
+{
+	return target_addr64str( target, address, target->adr2str2 );
+}
+
+const char *target_addr2str1( struct target *target, const struct target_addr *pA )
+{
+	return target_addr64str( target, pA->addr, target->adr2str1 );
+}
+
+const char *target_addr2str2( struct target *target, const struct target_addr *pA )
+{
+	return target_addr64str( target, pA->addr, target->adr2str2 );
+}
+
+struct target_addr *__target_addr_init( struct target_addr *pAddr, uint64_t addr )
+{
+	memset( pAddr, 0, sizeof(*pAddr) );
+	pAddr->addr  = addr;
+	pAddr->route = TA_ROUTE_DEFAULT;
+	pAddr->route_attributes = 0;
+	return pAddr;
+}
+
+
+struct target_addr *__target_addr_phys( struct target_addr *pAddr, uint64_t addr )
+{
+	__target_addr_init( pAddr, addr );
+	pAddr->route = TA_ROUTE_PHYSICAL;
+	return pAddr;
+}
+
+		
+int target64_virt2phys( struct target *target, const struct target_addr *in_pVirt, struct target_addr *out_pPhys )
+{
+	return target->type->pIo64_api->virt2phys( target, in_pVirt, out_pPhys );
+}
+
+static int t64_resume_wrap(struct target *target, int current, const struct target_addr *pAddr,
+			int handle_breakpoints, int debug_execution)
+{
+	return target->type->pIo32_legacy_api->resume( target, current, pAddr->addr, handle_breakpoints, debug_execution );
+}
+static int t64_step_wrap( struct target *target, int current, const struct target_addr *pAddr,
+			int handle_breakpoints)
+{
+	return target->type->pIo32_legacy_api->step( target, current, pAddr->addr, handle_breakpoints );
+}
+
+static int t64_rm_wrap( struct target *target, const struct target_addr *pAddr,
+			uint64_t size, uint64_t count, uint8_t *buffer)
+{
+	return target->type->pIo32_legacy_api->read_memory( target, pAddr->addr, size, count, buffer );
+}
+
+static int t64_wm_wrap (struct target *target, const struct target_addr *pAddr,
+			uint64_t size, uint64_t count, const uint8_t *buffer)
+{
+	return target->type->pIo32_legacy_api->write_memory( target, pAddr->addr, size, count, buffer );
+}
+
+static int t64_rb_wrap(struct target *target, const struct target_addr *pAddr,
+			uint64_t size, uint8_t *buffer)
+{
+	return target->type->pIo32_legacy_api->read_buffer( target, pAddr->addr, size, buffer );
+}
+
+static int t64_wb_wrap(struct target *target, const struct target_addr *pAddr,
+			uint64_t size, const uint8_t *buffer)
+{
+	return target->type->pIo32_legacy_api->write_buffer( target, pAddr->addr, size, buffer );
+}
+
+static int t64_cs_wrap(struct target *target, const struct target_addr *pAddr,
+			uint64_t count, uint32_t *checksum)
+{
+	return target->type->pIo32_legacy_api->checksum_memory( target, pAddr->addr, count, checksum );
+}
+
+static int t64_bc_wrap(struct target *target, const struct target_addr *pAddr,
+			uint64_t count, uint32_t *checksum)
+{
+	return target->type->pIo32_legacy_api->blank_check_memory( target, pAddr->addr, count, checksum );
+}
+
+static int t64_ra_wrap(struct target *target, int num_mem_params,
+			struct mem_param *mem_params, int num_reg_params,
+			struct reg_param *reg_param, const struct target_addr *pEntryPoint,
+			const struct target_addr *pExitPoint, int timeout_ms, void *arch_info)
+{
+	return target->type->pIo32_legacy_api->run_algorithm( target,
+							      num_mem_params,
+							      mem_params,
+							      num_reg_params,
+							      reg_param,
+							      pEntryPoint->addr,
+							      pExitPoint->addr,
+							      timeout_ms,
+							      arch_info );
+}
+
+static int t64_sa_wrap(struct target *target, int num_mem_params,
+			struct mem_param *mem_params, int num_reg_params,
+			struct reg_param *reg_param, const struct target_addr *pEntryPoint,
+			const struct target_addr *pExitPoint, void *arch_info)
+{
+	return target->type->pIo32_legacy_api->start_algorithm( target,
+							      num_mem_params,
+							      mem_params,
+							      num_reg_params,
+							      reg_param,
+							      pEntryPoint->addr,
+							      pExitPoint->addr,
+							      arch_info );
+}
+
+static int t64_wa_wrap(struct target *target, int num_mem_params,
+			struct mem_param *mem_params, int num_reg_params,
+			struct reg_param *reg_param, 
+			const struct target_addr *pExitPoint, int timeout_ms, void *arch_info)
+{
+	return target->type->pIo32_legacy_api->wait_algorithm( target,
+							      num_mem_params,
+							      mem_params,
+							      num_reg_params,
+							      reg_param,
+							      pExitPoint->addr,
+							      timeout_ms,
+							      arch_info );
+}
+
+static int t64_v2p_wrap( struct target *target,
+			 const struct target_addr *in_pVirt,
+			 struct target_addr *out_pPhys )
+{
+	uint32_t pa;
+	int r;
+
+	r = target->type->pIo32_legacy_api->virt2phys( target, in_pVirt->addr, &pa );
+	out_pPhys->addr = pa;
+	return r;
+}
+
+
+const struct target_io64 target_64_wrapper = {
+	.resume			= t64_resume_wrap,
+	.step			= t64_step_wrap,
+	.read_memory		= t64_rm_wrap,
+	.write_memory		= t64_wm_wrap,
+	.read_buffer		= t64_rb_wrap,
+	.write_buffer		= t64_wb_wrap,
+	.checksum_memory	= t64_cs_wrap,
+	.blank_check_memory	= t64_bc_wrap,
+	.run_algorithm		= t64_ra_wrap,
+	.start_algorithm	= t64_sa_wrap,
+	.wait_algorithm		= t64_wa_wrap,
+	.virt2phys		= t64_v2p_wrap
+};
+
+bool target_addr_is64bit( const struct target_addr *pAddr )
+{
+	return pAddr->addr > 0x0FFFFFFFFULL;
+}
+
+bool target_addr64_is64bit( uint64_t address )
+{
+	return address > 0x0FFFFFFFFULL;
+}
+ 
diff --git a/src/target/target.h b/src/target/target.h
old mode 100644
new mode 100755
index f09e93f..b968bbb
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -43,6 +43,8 @@ struct reg_param;
 struct target_list;
 struct gdb_fileio_info;
 
+#include "target_addr.h"
+
 /*
  * TARGET_UNKNOWN = 0: we don't know anything about the target yet
  * TARGET_RUNNING = 1: the target is executing user code
@@ -93,8 +95,8 @@ enum target_endianness {
 };
 
 struct working_area {
-	uint32_t address;
-	uint32_t size;
+	uint64_t address;
+	uint64_t size;
 	bool free;
 	uint8_t *backup;
 	struct working_area **user;
@@ -150,13 +152,13 @@ struct target {
 	struct target_event_action *event_action;
 
 	int reset_halt;						/* attempt resetting the CPU into the halted mode? */
-	uint32_t working_area;				/* working area (initialised RAM). Evaluated
+	uint64_t working_area;				/* working area (initialised RAM). Evaluated
 										 * upon first allocation from virtual/physical address. */
 	bool working_area_virt_spec;		/* virtual address specified? */
-	uint32_t working_area_virt;			/* virtual address */
+	uint64_t working_area_virt;			/* virtual address */
 	bool working_area_phys_spec;		/* virtual address specified? */
-	uint32_t working_area_phys;			/* physical address */
-	uint32_t working_area_size;			/* size in bytes */
+	uint64_t working_area_phys;			/* physical address */
+	uint64_t working_area_size;			/* size in bytes */
 	uint32_t backup_working_area;		/* whether the content of the working area has to be preserved */
 	struct working_area *working_areas;/* list of allocated working areas */
 	enum target_debug_reason debug_reason;/* reason why the target entered debug state */
@@ -178,14 +180,16 @@ struct target {
 	long long halt_issued_time;			/* Note time when halt was issued */
 
 	bool dbgbase_set;					/* By default the debug base is not set */
-	uint32_t dbgbase;					/* Really a Cortex-A specific option, but there is no
+	uint32_t dbgbase;					/* Really ARM Cortex-A specific option, but there is no
 										 * system in place to support target specific options
 										 * currently. */
 	uint32_t ctibase;					/* added to support ARMv8 by SQU*/
-	bool is_64b;						/* added to support 64bit architecture by SQU */
-	uint32_t romcbase;					/* ROM base code for different Asic*/
+	
+	bool is_64b;						/* Is target in 64bit or 32bit mode? */
+	bool force_addr64;					/* if true, force all addresses into 64bit mode */
+	uint64_t romcbase;					/* ROM base code for different Asic*/
 	bool mode_switch;					/* 64bit to 32 bit mode switch support */
-	uint32_t codebase;					/* Code start address for loading axf*/
+	uint64_t codebase;					/* Code start address for loading axf*/
 	bool is_semihostskip;				/* semihost skip enable/disable */
 
 	struct rtos *rtos;					/* Instance of Real Time Operating System support */
@@ -202,6 +206,13 @@ struct target {
 
 	/* file-I/O information for host to do syscall */
 	struct gdb_fileio_info *fileio_info;
+	/* string buffers to print addresses as either 32 or 64bit 
+	 * See: target_addr64str1(), target_addr64str2(), target_addr64str(),
+	 * See: target_addr2str1(), target_addr2str2(), target_addr2str(),
+	*/
+#define TARGET_ADDR2STR_SIZE 40
+	char adr2str1[ TARGET_ADDR2STR_SIZE ]; 
+	char adr2str2[ TARGET_ADDR2STR_SIZE ]; 
 };
 
 struct target_list {
@@ -323,7 +334,10 @@ int target_unregister_event_callback(
  * yet it is possible to detect error conditions.
  */
 int target_poll(struct target *target);
-int target_resume(struct target *target, int current, uint64_t address,
+int target64_resume(struct target *target, int current, const struct target_addr *pAddr,
+		int handle_breakpoints, int debug_execution);
+#define target_resume target32_resume
+int target32_resume(struct target *target, int current, uint64_t addr,
 		int handle_breakpoints, int debug_execution);
 int target_halt(struct target *target);
 int target_call_event_callbacks(struct target *target, enum target_event event);
@@ -440,17 +454,28 @@ int target_get_gdb_reg_list(struct target *target,
  *
  * This routine is a wrapper for target->type->step.
  */
-int target_step(struct target *target,
+int target64_step(struct target *target,
+		int current, const struct target_addr *pAddr, int handle_breakpoints);
+
+#define target_step target32_step
+int target32_step(struct target *target,
 		int current, uint64_t address, int handle_breakpoints);
 /**
  * Run an algorithm on the @a target given.
  *
  * This routine is a wrapper for target->type->run_algorithm.
  */
-int target_run_algorithm(struct target *target,
+int target64_run_algorithm(struct target *target,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_param,
+		const struct target_addr *pEntryPoint, const struct target_addr *pExitPoint,
+		int timeout_ms, void *arch_info);
+
+#define target_run_algorithm target32_run_algorithm 
+int target32_run_algorithm(struct target *target,
 		int num_mem_params, struct mem_param *mem_params,
 		int num_reg_params, struct reg_param *reg_param,
-		uint32_t entry_point, uint32_t exit_point,
+		uint64_t entry_point, uint64_t exit_point,
 		int timeout_ms, void *arch_info);
 
 /**
@@ -458,45 +483,89 @@ int target_run_algorithm(struct target *target,
  *
  * This routine is a wrapper for target->type->start_algorithm.
  */
-int target_start_algorithm(struct target *target,
+int target64_start_algorithm(struct target *target,
 		int num_mem_params, struct mem_param *mem_params,
 		int num_reg_params, struct reg_param *reg_params,
-		uint32_t entry_point, uint32_t exit_point,
+		const struct target_addr *pEntryPoint, const struct target_addr *pExitPoint,	   
 		void *arch_info);
 
+#define target_start_algorithm target32_start_algorithm
+int target32_start_algorithm(struct target *target,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_params,
+		uint64_t entry_point, uint64_t exit_point,
+		void *arch_info);
 /**
  * Wait for an algorithm on the @a target given.
  *
  * This routine is a wrapper for target->type->wait_algorithm.
  */
-int target_wait_algorithm(struct target *target,
+int target64_wait_algorithm(struct target *target,
 		int num_mem_params, struct mem_param *mem_params,
 		int num_reg_params, struct reg_param *reg_params,
-		uint32_t exit_point, int timeout_ms,
+		const struct target_addr *pExitPoint, int timeout_ms,
+		void *arch_info);
+
+#define target_wait target32_wait
+int target32_wait_algorithm(struct target *target,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_params,
+		uint64_t exit_point, int timeout_ms,
 		void *arch_info);
 
 /**
  * This routine is a wrapper for asynchronous algorithms.
  *
  */
-int target_run_flash_async_algorithm(struct target *target,
+int target64_run_flash_async_algorithm(struct target *target,
 		const uint8_t *buffer, uint32_t count, int block_size,
 		int num_mem_params, struct mem_param *mem_params,
 		int num_reg_params, struct reg_param *reg_params,
-		uint32_t buffer_start, uint32_t buffer_size,
-		uint32_t entry_point, uint32_t exit_point,
+		const struct target_addr *pBufferStart, uint64_t buffer_size,
+		const struct target_addr *pEntryPoint, const struct target_addr *pExitPoint,
 		void *arch_info);
 
+#define target_run_flash_async_algorithm target32_run_flash_async_algorithm
+int target32_run_flash_async_algorithm(struct target *target,
+		const uint8_t *buffer, uint32_t count, int block_size,
+		int num_mem_params, struct mem_param *mem_params,
+		int num_reg_params, struct reg_param *reg_params,
+		uint64_t buffer_start, uint64_t buffer_size,
+		uint64_t entry_point, uint64_t exit_point,
+		void *arch_info);
+
+int target64_virt2phys( struct target *target,
+		      const struct target_addr *in_pAddr,
+		      struct target_addr *out_pAddr );
+
+#define target_virt2phys target32_virt2phys
+int target32_virt2phys( struct target *target, uint64_t in_virt, uint32_t *out_32 );
+
+
+int target64_identity_virt2phys( struct target *target,
+		      const struct target_addr *in_pAddr,
+		      struct target_addr *out_pAddr );
+
 /**
  * Read @a count items of @a size bytes from the memory of @a target at
  * the @a address given.
  *
  * This routine is a wrapper for target->type->read_memory.
  */
-int target_read_memory(struct target *target,
-		uint64_t address, uint64_t size, uint64_t count, uint8_t *buffer);
-int target_read_phys_memory(struct target *target,
-		uint64_t address, uint64_t size, uint64_t count, uint8_t *buffer);
+int target64_read_memory(struct target *target,
+		const struct target_addr *pAddr, uint64_t size, uint64_t count, uint8_t *buffer);
+
+#define target_read_memory target32_read_memory
+int target32_read_memory(struct target *target,
+		uint64_t addr, uint64_t size, uint64_t count, uint8_t *buffer);
+
+
+int target64_read_phys_memory(struct target *target,
+		const struct target_addr *pAddr, uint64_t size, uint64_t count, uint8_t *buffer);
+
+#define target_read_phys_memory target32_read_phys_memory
+int target32_read_phys_memory(struct target *target,
+		uint64_t addr, uint64_t size, uint64_t count, uint8_t *buffer);
 
 /**
  * Write @a count items of @a size bytes to the memory of @a target at
@@ -515,10 +584,19 @@ int target_read_phys_memory(struct target *target,
  *
  * This routine is wrapper for target->type->write_memory.
  */
-int target_write_memory(struct target *target,
-		uint64_t address, uint64_t size, uint64_t count, const uint8_t *buffer);
-int target_write_phys_memory(struct target *target,
-		uint64_t address, uint64_t size, uint64_t count, const uint8_t *buffer);
+int target64_write_memory(struct target *target,
+		const struct target_addr *pAddr, uint64_t size, uint64_t count, const uint8_t *buffer);
+
+#define target_write_memory target32_write_memory
+int target32_write_memory(struct target *target,
+		uint64_t addr, uint64_t size, uint64_t count, const uint8_t *buffer);
+
+int target64_write_phys_memory(struct target *target,
+		const struct target_addr *pAddr, uint64_t size, uint64_t count, const uint8_t *buffer);
+
+#define target_write_phys_memory target32_write_phys_memory
+int target32_write_phys_memory(struct target *target,
+		uint64_t addr, uint64_t size, uint64_t count, const uint8_t *buffer);
 
 /*
  * Write to target memory using the virtual address.
@@ -544,14 +622,40 @@ int target_write_phys_memory(struct target *target,
  * write operation, thus making this fn suitable to e.g. write to special
  * peripheral registers which do not support byte operations.
  */
-int target_write_buffer(struct target *target,
+int target64_write_buffer(struct target *target,
+		const struct target_addr *pAddr, uint64_t size, const uint8_t *buffer);
+int target64_write_buffer_default(struct target *target, struct target_addr *pAddr, uint64_t count, const uint8_t *buffer);
+
+#define target_write_buffer target32_write_buffer
+int target32_write_buffer(struct target *target,
 		uint64_t address, uint64_t size, const uint8_t *buffer);
-int target_read_buffer(struct target *target,
+
+
+int target64_read_buffer_default(struct target *target, struct target_addr *pAddr, uint64_t count, uint8_t *buffer);
+
+int target64_read_buffer(struct target *target,
+		const struct target_addr *pAddr, uint64_t size, uint8_t *buffer);
+
+#define target_read_buffer target32_read_buffer
+int target32_read_buffer(struct target *target,
 		uint64_t address, uint64_t size, uint8_t *buffer);
-int target_checksum_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t *crc);
-int target_blank_check_memory(struct target *target,
-		uint32_t address, uint32_t size, uint32_t *blank);
+
+
+int target64_checksum_memory(struct target *target,
+		const struct target_addr *pAddr, uint64_t size, uint32_t *crc);
+
+#define target_checksum_memory target32_checksum_memory
+int target32_checksum_memory(struct target *target,
+		uint64_t address, uint64_t size, uint32_t *crc);
+
+
+int target64_blank_check_memory(struct target *target,
+		const struct target_addr *pAddr, uint64_t size, uint32_t *blank);
+
+#define target_blank_check_memory target32_blank_check_memory
+int target32_blank_check_memory(struct target *target,
+		uint64_t address, uint64_t size, uint32_t *blank);
+
 int target_wait_state(struct target *target, enum target_state state, int ms);
 
 /**
@@ -585,7 +689,7 @@ const char *target_state_name(struct target *target);
  *
  */
 int target_alloc_working_area(struct target *target,
-		uint32_t size, struct working_area **area);
+		uint64_t size, struct working_area **area);
 /* Same as target_alloc_working_area, except that no error is logged
  * when ERROR_TARGET_RESOURCE_NOT_AVAILABLE is returned.
  *
@@ -593,10 +697,10 @@ int target_alloc_working_area(struct target *target,
  * and have a fallback to another behaviour(slower?).
  */
 int target_alloc_working_area_try(struct target *target,
-		uint32_t size, struct working_area **area);
+		uint64_t size, struct working_area **area);
 int target_free_working_area(struct target *target, struct working_area *area);
 void target_free_all_working_areas(struct target *target);
-uint32_t target_get_working_area_avail(struct target *target);
+uint64_t target_get_working_area_avail(struct target *target);
 
 extern struct target *all_targets;
 
@@ -609,21 +713,45 @@ void target_buffer_set_u32(struct target *target, uint8_t *buffer, uint32_t valu
 void target_buffer_set_u24(struct target *target, uint8_t *buffer, uint32_t value);
 void target_buffer_set_u16(struct target *target, uint8_t *buffer, uint16_t value);
 
-void target_buffer_get_u64_array(struct target *target, const uint8_t *buffer, uint32_t count, uint64_t *dstbuf);
-void target_buffer_get_u32_array(struct target *target, const uint8_t *buffer, uint32_t count, uint32_t *dstbuf);
-void target_buffer_get_u16_array(struct target *target, const uint8_t *buffer, uint32_t count, uint16_t *dstbuf);
-void target_buffer_set_u64_array(struct target *target, uint8_t *buffer, uint32_t count, const uint64_t *srcbuf);
-void target_buffer_set_u32_array(struct target *target, uint8_t *buffer, uint32_t count, const uint32_t *srcbuf);
-void target_buffer_set_u16_array(struct target *target, uint8_t *buffer, uint32_t count, const uint16_t *srcbuf);
-
-int target_read_u64(struct target *target, uint64_t address, uint64_t *value);
-int target_read_u32(struct target *target, uint32_t address, uint32_t *value);
-int target_read_u16(struct target *target, uint32_t address, uint16_t *value);
-int target_read_u8(struct target *target, uint32_t address, uint8_t *value);
-int target_write_u64(struct target *target, uint64_t address, uint64_t value);
-int target_write_u32(struct target *target, uint32_t address, uint32_t value);
-int target_write_u16(struct target *target, uint32_t address, uint16_t value);
-int target_write_u8(struct target *target, uint32_t address, uint8_t value);
+void target_buffer_get_u64_array(struct target *target, const uint8_t *buffer, uint64_t count, uint64_t *dstbuf);
+void target_buffer_get_u32_array(struct target *target, const uint8_t *buffer, uint64_t count, uint32_t *dstbuf);
+void target_buffer_get_u16_array(struct target *target, const uint8_t *buffer, uint64_t count, uint16_t *dstbuf);
+void target_buffer_set_u64_array(struct target *target, uint8_t *buffer, uint64_t count, const uint64_t *srcbuf);
+void target_buffer_set_u32_array(struct target *target, uint8_t *buffer, uint64_t count, const uint32_t *srcbuf);
+void target_buffer_set_u16_array(struct target *target, uint8_t *buffer, uint64_t count, const uint16_t *srcbuf);
+
+int target64_read_u16(struct target *target, const struct target_addr *pAddr, uint16_t *value);
+int target64_read_u32(struct target *target, const struct target_addr *pAddr, uint32_t *value);
+int target64_read_u64(struct target *target, const struct target_addr *pAddr, uint64_t *value);
+int target64_read_u8(struct target *target, const struct target_addr *pAddr, uint8_t *value);
+int target64_write_u16(struct target *target, const struct target_addr *pAddr, uint16_t value);
+int target64_write_u32(struct target *target, const struct target_addr *pAddr, uint32_t value);
+int target64_write_u64(struct target *target, const struct target_addr *pAddr, uint64_t value);
+int target64_write_u8(struct target *target, const struct target_addr *pAddr, uint8_t value);
+
+#define target_read_u16 target32_read_u16
+int target32_read_u16(struct target *target, uint64_t addr, uint16_t *value);
+
+#define target_read_u32 target32_read_u32
+int target32_read_u32(struct target *target, uint64_t addr, uint32_t *value);
+
+#define target_read_u64 target32_read_u64
+int target32_read_u64(struct target *target, uint64_t addr, uint64_t *value);
+
+#define target_read_u8 target32_read_u8
+int target32_read_u8(struct target *target, uint64_t addr, uint8_t *value);
+
+#define target_write_u16 target32_write_u16
+int target32_write_u16(struct target *target, uint64_t addr, uint16_t value);
+
+#define target_write_u32 target32_write_u32
+int target32_write_u32(struct target *target, uint64_t addr, uint32_t value);
+
+#define target_write_u64 target32_write_u64
+int target32_write_u64(struct target *target, uint64_t addr, uint64_t value);
+
+#define target_write_u8 target32_write_u8
+int target32_write_u8(struct target *target, uint64_t addr, uint8_t value);
 
 /* Issues USER() statements with target state information */
 int target_arch_state(struct target *target);
@@ -644,4 +772,28 @@ void target_handle_event(struct target *t, enum target_event e);
 
 extern bool get_target_reset_nag(void);
 
+/* Converts address into <ascii-hexnumber> based on target state
+ * Specifically, the <ascii-hexnumber> does not have the 0x prefix.
+ * Where <number> is either 8 digits, or 16 digits
+ * For some targets, the size may change dynamically at runtime.
+ * For example: ARMv8 -> AARCH32 vrs AARCH64 can switch 
+ *
+ * Also in a multi-arch chip, there may be mixed 32/64 bit targets.
+ * And some address schemes (ie: ARM DAP AXI interface) may be 64bit
+ * while the current target is 32bit (ie: cortexM3)
+ * Specific example: Qualcomm Snapdragon SOCs.
+ */
+const char *target_addr64str1(struct target *target, uint64_t address );
+const char *target_addr64str2(struct target *target, uint64_t address );
+const char *target_addr64str(struct target *target, uint64_t address, char *buf );
+
+const char *target_addr2str1( struct target *target, const struct target_addr *pAddr );
+const char *target_addr2str2( struct target *target, const struct target_addr *pAddr );
+const char *target_addr2str( struct target *target, const struct target_addr *pAddr, char *buf );
+
+bool target_addr_is64bit( const struct target_addr *pAddr );
+bool target_addr64_is64bit( uint64_t address );
+
+void target32_init( struct target *target );
+
 #endif /* TARGET_H */
diff --git a/src/target/target32.c b/src/target/target32.c
old mode 100644
new mode 100755
diff --git a/src/target/target_addr.h b/src/target/target_addr.h
old mode 100644
new mode 100755
diff --git a/src/target/target_request.c b/src/target/target_request.c
old mode 100644
new mode 100755
diff --git a/src/target/target_request.h b/src/target/target_request.h
old mode 100644
new mode 100755
diff --git a/src/target/target_type.h b/src/target/target_type.h
old mode 100644
new mode 100755
index e249875..390666d
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -31,6 +31,149 @@
 
 struct target;
 
+
+struct target_io32 {
+	int (*resume)(struct target *target, int current, uint32_t address,
+			int handle_breakpoints, int debug_execution);
+	int (*step)(struct target *target, int current, uint32_t address,
+			int handle_breakpoints);
+
+  	/* target memory access
+	* size: 1 = byte (8bit), 2 = half-word (16bit), 4 = word (32bit)
+	* count: number of items of <size>
+	*/
+
+	/**
+	 * Target memory read callback.  Do @b not call this function
+	 * directly, use target_read_memory() instead.
+	 */
+	int (*read_memory)(struct target *target, uint32_t address,
+			uint32_t size, uint32_t count, uint8_t *buffer);
+	/**
+	 * Target memory write callback.  Do @b not call this function
+	 * directly, use target_write_memory() instead.
+	 */
+	int (*write_memory)(struct target *target, uint32_t address,
+			uint32_t size, uint32_t count, const uint8_t *buffer);
+
+	/* Default implementation will do some fancy alignment to improve performance, target can override */
+	int (*read_buffer)(struct target *target, uint32_t address,
+			uint32_t size, uint8_t *buffer);
+
+	/* Default implementation will do some fancy alignment to improve performance, target can override */
+	int (*write_buffer)(struct target *target, uint32_t address,
+			uint32_t size, const uint8_t *buffer);
+
+	int (*checksum_memory)(struct target *target, uint32_t address,
+			uint32_t count, uint32_t *checksum);
+	int (*blank_check_memory)(struct target *target, uint32_t address,
+			uint32_t count, uint32_t *blank);
+
+  	/**
+	 * Target algorithm support.  Do @b not call this method directly,
+	 * use target_run_algorithm() instead.
+	 */
+	int (*run_algorithm)(struct target *target, int num_mem_params,
+			struct mem_param *mem_params, int num_reg_params,
+			struct reg_param *reg_param, uint32_t entry_point,
+			uint32_t exit_point, int timeout_ms, void *arch_info);
+	int (*start_algorithm)(struct target *target, int num_mem_params,
+			struct mem_param *mem_params, int num_reg_params,
+			struct reg_param *reg_param, uint32_t entry_point,
+			uint32_t exit_point, void *arch_info);
+	int (*wait_algorithm)(struct target *target, int num_mem_params,
+			struct mem_param *mem_params, int num_reg_params,
+			struct reg_param *reg_param, uint32_t exit_point,
+			int timeout_ms, void *arch_info);
+
+  	/* translate from virtual to physical address. Default implementation is successful
+	 * no-op(i.e. virtual==physical).
+	 */
+	int (*virt2phys)(struct target *target, uint32_t address, uint32_t *physical);
+
+  	/* read directly from physical memory. caches are bypassed and untouched.
+	 *
+	 * If the target does not support disabling caches, leaving them untouched,
+	 * then minimally the actual physical memory location will be read even
+	 * if cache states are unchanged, flushed, etc.
+	 *
+	 * Default implementation is to call read_memory.
+	 */
+	int (*read_phys_memory)(struct target *target, uint32_t phys_address,
+			uint32_t size, uint32_t count, uint8_t *buffer);
+
+	/*
+	 * same as read_phys_memory, except that it writes...
+	 */
+	int (*write_phys_memory)(struct target *target, uint32_t phys_address,
+			uint32_t size, uint32_t count, const uint8_t *buffer);
+};
+
+extern const struct target_io64 target_64_wrapper;
+
+struct target_io64 {
+
+	int (*resume)(struct target *target, int current, const struct target_addr *pAddr,
+			int handle_breakpoints, int debug_execution);
+	
+	int (*step)(struct target *target, int current, const struct target_addr *pAddr,
+			int handle_breakpoints);
+
+  	/* target memory access
+	* size: 1 = byte (8bit), 2 = half-word (16bit), 4 = word (32bit)
+	* count: number of items of <size>
+	*/
+
+	/**
+	 * Target memory read callback.  Do @b not call this function
+	 * directly, use target_read_memory() instead.
+	 */
+	int (*read_memory)(struct target *target, const struct target_addr *pAddr,
+			uint64_t size, uint64_t count, uint8_t *buffer);
+	/**
+	 * Target memory write callback.  Do @b not call this function
+	 * directly, use target_write_memory() instead.
+	 */
+	int (*write_memory)(struct target *target, const struct target_addr *pAddr,
+			uint64_t size, uint64_t count, const uint8_t *buffer);
+
+	/* Default implementation will do some fancy alignment to improve performance, target can override */
+	int (*read_buffer)(struct target *target, const struct target_addr *pAddr,
+			uint64_t size, uint8_t *buffer);
+
+	/* Default implementation will do some fancy alignment to improve performance, target can override */
+	int (*write_buffer)(struct target *target, const struct target_addr *pAddr,
+			uint64_t size, const uint8_t *buffer);
+
+	int (*checksum_memory)(struct target *target, const struct target_addr *pAddr,
+			uint64_t count, uint32_t *checksum);
+	int (*blank_check_memory)(struct target *target, const struct target_addr *pAddr,
+			uint64_t count, uint32_t *blank);
+
+  	/**
+	 * Target algorithm support.  Do @b not call this method directly,
+	 * use target_run_algorithm() instead.
+	 */
+	int (*run_algorithm)(struct target *target, int num_mem_params,
+			struct mem_param *mem_params, int num_reg_params,
+			struct reg_param *reg_param, const struct target_addr *pEntryPoint,
+			const struct target_addr *pExitPoint, int timeout_ms, void *arch_info);
+	int (*start_algorithm)(struct target *target, int num_mem_params,
+			struct mem_param *mem_params, int num_reg_params,
+			struct reg_param *reg_param, const struct target_addr *pEntryPoint,
+			const struct target_addr *pExitPoint, void *arch_info);
+	int (*wait_algorithm)(struct target *target, int num_mem_params,
+			struct mem_param *mem_params, int num_reg_params,
+			struct reg_param *reg_param, const struct target_addr *pExitPoint,
+			int timeout_ms, void *arch_info);
+
+  	/* translate from virtual to physical address. Default implementation is successful
+	 * no-op(i.e. virtual==physical).
+	 */
+	int (*virt2phys)(struct target *target, const struct target_addr *in_pVirtAddr, struct target_addr *out_pPhysAddr);
+};
+
+
 /**
  * This holds methods shared between all instances of a given target
  * type.  For example, all Cortex-M3 targets on a scan chain share
@@ -44,6 +187,12 @@ struct target_type {
 	const char *name;
 	const char *deprecated_name;
 
+	/* legacy code */
+	struct target_io32 *pIo32_legacy_api;
+	/* All new IO should be written using the 64bit api */
+	/* And should be fully populated! */
+	const struct target_io64 *pIo64_api;
+
 	/* poll current target status */
 	int (*poll)(struct target *target);
 	/* Invoked only from target_arch_state().
@@ -55,14 +204,6 @@ struct target_type {
 
 	/* halt will log a warning, but return ERROR_OK if the target is already halted. */
 	int (*halt)(struct target *target);
-	int (*resume)(struct target *target, int current, uint32_t address,
-			int handle_breakpoints, int debug_execution);
-	int (*resume_64)(struct target *target, int current, uint64_t address,
-			int handle_breakpoints, int debug_execution);
-	int (*step)(struct target *target, int current, uint32_t address,
-			int handle_breakpoints);
-	int (*step_64)(struct target *target, int current, uint64_t address,
-			int handle_breakpoints);
 
 	/* target reset control. assert reset can be invoked when OpenOCD and
 	 * the target is out of sync.
@@ -108,44 +249,6 @@ struct target_type {
 	int (*get_gdb_reg_list)(struct target *target, struct reg **reg_list[],
 			int *reg_list_size, enum target_register_class reg_class);
 
-	/* target memory access
-	* size: 1 = byte (8bit), 2 = half-word (16bit), 4 = word (32bit)
-	* count: number of items of <size>
-	*/
-
-	/**
-	 * Target memory read callback.  Do @b not call this function
-	 * directly, use target_read_memory() instead.
-	 */
-	int (*read_memory)(struct target *target, uint32_t address,
-			uint32_t size, uint32_t count, uint8_t *buffer);
-	int (*read_memory_64)(struct target *target, uint64_t address,
-			uint32_t size, uint64_t count, uint8_t *buffer);
-	/**
-	 * Target memory write callback.  Do @b not call this function
-	 * directly, use target_write_memory() instead.
-	 */
-	int (*write_memory)(struct target *target, uint32_t address,
-			uint32_t size, uint32_t count, const uint8_t *buffer);
-	int (*write_memory_64)(struct target *target, uint64_t address,
-			uint32_t size, uint64_t count, const uint8_t *buffer);
-
-	/* Default implementation will do some fancy alignment to improve performance, target can override */
-	int (*read_buffer)(struct target *target, uint32_t address,
-			uint32_t size, uint8_t *buffer);
-	int (*read_buffer_64)(struct target *target, uint64_t address,
-			uint64_t size, uint8_t *buffer);
-
-	/* Default implementation will do some fancy alignment to improve performance, target can override */
-	int (*write_buffer)(struct target *target, uint32_t address,
-			uint32_t size, const uint8_t *buffer);
-	int (*write_buffer_64)(struct target *target, uint64_t address,
-			uint64_t size, const uint8_t *buffer);
-
-	int (*checksum_memory)(struct target *target, uint32_t address,
-			uint32_t count, uint32_t *checksum);
-	int (*blank_check_memory)(struct target *target, uint32_t address,
-			uint32_t count, uint32_t *blank);
 
 	/*
 	 * target break-/watchpoint control
@@ -183,22 +286,6 @@ struct target_type {
 	 */
 	int (*hit_watchpoint)(struct target *target, struct watchpoint **hit_watchpoint);
 
-	/**
-	 * Target algorithm support.  Do @b not call this method directly,
-	 * use target_run_algorithm() instead.
-	 */
-	int (*run_algorithm)(struct target *target, int num_mem_params,
-			struct mem_param *mem_params, int num_reg_params,
-			struct reg_param *reg_param, uint32_t entry_point,
-			uint32_t exit_point, int timeout_ms, void *arch_info);
-	int (*start_algorithm)(struct target *target, int num_mem_params,
-			struct mem_param *mem_params, int num_reg_params,
-			struct reg_param *reg_param, uint32_t entry_point,
-			uint32_t exit_point, void *arch_info);
-	int (*wait_algorithm)(struct target *target, int num_mem_params,
-			struct mem_param *mem_params, int num_reg_params,
-			struct reg_param *reg_param, uint32_t exit_point,
-			int timeout_ms, void *arch_info);
 
 	const struct command_registration *commands;
 
@@ -237,33 +324,6 @@ struct target_type {
 	 * */
 	int (*init_target)(struct command_context *cmd_ctx, struct target *target);
 
-	/* translate from virtual to physical address. Default implementation is successful
-	 * no-op(i.e. virtual==physical).
-	 */
-	int (*virt2phys)(struct target *target, uint32_t address, uint32_t *physical);
-	int (*virt2phys_64)(struct target *target, uint64_t address, uint64_t *physical);
-
-	/* read directly from physical memory. caches are bypassed and untouched.
-	 *
-	 * If the target does not support disabling caches, leaving them untouched,
-	 * then minimally the actual physical memory location will be read even
-	 * if cache states are unchanged, flushed, etc.
-	 *
-	 * Default implementation is to call read_memory.
-	 */
-	int (*read_phys_memory)(struct target *target, uint32_t phys_address,
-			uint32_t size, uint32_t count, uint8_t *buffer);
-	int (*read_phys_memory_64)(struct target *target, uint64_t phys_address,
-			uint32_t size, uint64_t count, uint8_t *buffer);
-
-	/*
-	 * same as read_phys_memory, except that it writes...
-	 */
-	int (*write_phys_memory)(struct target *target, uint32_t phys_address,
-			uint32_t size, uint32_t count, const uint8_t *buffer);
-	int (*write_phys_memory_64)(struct target *target, uint64_t phys_address,
-			uint32_t size, uint64_t count, const uint8_t *buffer);
-
 	int (*mmu)(struct target *target, int *enabled);
 
 	/* after reset is complete, the target can check if things are properly set up.
diff --git a/src/target/testee.c b/src/target/testee.c
old mode 100644
new mode 100755
diff --git a/src/target/trace.c b/src/target/trace.c
old mode 100644
new mode 100755
diff --git a/src/target/trace.h b/src/target/trace.h
old mode 100644
new mode 100755
diff --git a/src/target/x86_32_common.c b/src/target/x86_32_common.c
old mode 100644
new mode 100755
index 6bcd4af..b4cb84d
--- a/src/target/x86_32_common.c
+++ b/src/target/x86_32_common.c
@@ -852,7 +852,7 @@ int x86_32_common_remove_watchpoint(struct target *t, struct watchpoint *wp)
 
 int x86_32_common_add_breakpoint(struct target *t, struct breakpoint *bp)
 {
-	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, bp->type, bp->address);
+	LOG_DEBUG("type=%d, addr=0x%08" PRIx64, bp->type, bp->address);
 	if (check_not_halted(t))
 		return ERROR_TARGET_NOT_HALTED;
 	/* set_breakpoint() will return ERROR_TARGET_RESOURCE_NOT_AVAILABLE if all
@@ -863,7 +863,7 @@ int x86_32_common_add_breakpoint(struct target *t, struct breakpoint *bp)
 
 int x86_32_common_remove_breakpoint(struct target *t, struct breakpoint *bp)
 {
-	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, bp->type, bp->address);
+	LOG_DEBUG("type=%d, addr=0x%08" PRIx64, bp->type, bp->address);
 	if (check_not_halted(t))
 		return ERROR_TARGET_NOT_HALTED;
 	if (bp->set)
@@ -1003,7 +1003,7 @@ static int unset_hwbp(struct target *t, struct breakpoint *bp)
 	debug_reg_list[hwbp_num].used = 0;
 	debug_reg_list[hwbp_num].bp_value = 0;
 
-	LOG_USER("%s hardware breakpoint %" PRIu32 " removed from 0x%08" PRIx32 " (hwreg=%d)",
+	LOG_USER("%s hardware breakpoint %" PRIu32 " removed from 0x%08" PRIx64 " (hwreg=%d)",
 			__func__, bp->unique_id, bp->address, hwbp_num);
 	return ERROR_OK;
 }
@@ -1032,7 +1032,7 @@ static int set_swbp(struct target *t, struct breakpoint *bp)
 		return ERROR_FAIL;
 
 	if (readback != SW_BP_OPCODE) {
-		LOG_ERROR("%s software breakpoint error at 0x%08" PRIx32 ", check memory",
+		LOG_ERROR("%s software breakpoint error at 0x%08" PRIx64 ", check memory",
 				__func__, bp->address);
 		LOG_ERROR("%s readback=0x%02" PRIx8 " orig=0x%02" PRIx8 "",
 				__func__, readback, *bp->orig_instr);
@@ -1059,7 +1059,7 @@ static int set_swbp(struct target *t, struct breakpoint *bp)
 			addto = addto->next;
 		addto->next = new_patch;
 	}
-	LOG_USER("%s software breakpoint %" PRIu32 " set at 0x%08" PRIx32,
+	LOG_USER("%s software breakpoint %" PRIu32 " set at 0x%08" PRIx64,
 			__func__, bp->unique_id, bp->address);
 	return ERROR_OK;
 }
@@ -1081,7 +1081,7 @@ static int unset_swbp(struct target *t, struct breakpoint *bp)
 		if (write_phys_mem(t, physaddr, 1, 1, bp->orig_instr))
 			return ERROR_FAIL;
 	} else {
-		LOG_ERROR("%s software breakpoint remove error at 0x%08" PRIx32 ", check memory",
+		LOG_ERROR("%s software breakpoint remove error at 0x%" PRIx64 ", check memory",
 				__func__, bp->address);
 		LOG_ERROR("%s current=0x%02" PRIx8 " orig=0x%02" PRIx8 "",
 				__func__, current_instr, *bp->orig_instr);
@@ -1107,7 +1107,7 @@ static int unset_swbp(struct target *t, struct breakpoint *bp)
 		}
 	}
 
-	LOG_USER("%s software breakpoint %" PRIu32 " removed from 0x%08" PRIx32,
+	LOG_USER("%s software breakpoint %" PRIu32 " removed from 0x%08" PRIx64,
 			__func__, bp->unique_id, bp->address);
 	return ERROR_OK;
 }
@@ -1116,7 +1116,7 @@ static int set_breakpoint(struct target *t, struct breakpoint *bp)
 {
 	int error = ERROR_OK;
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
-	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, bp->type, bp->address);
+	LOG_DEBUG("type=%d, addr=0x%08" PRIx64, bp->type, bp->address);
 	if (bp->set) {
 		LOG_ERROR("breakpoint already set");
 		return error;
@@ -1124,7 +1124,7 @@ static int set_breakpoint(struct target *t, struct breakpoint *bp)
 	if (bp->type == BKPT_HARD) {
 		error = set_hwbp(t, bp);
 		if (error != ERROR_OK) {
-			LOG_ERROR("%s error setting hardware breakpoint at 0x%08" PRIx32,
+			LOG_ERROR("%s error setting hardware breakpoint at 0x%08" PRIx64,
 					__func__, bp->address);
 			return error;
 		}
@@ -1132,7 +1132,7 @@ static int set_breakpoint(struct target *t, struct breakpoint *bp)
 		if (x86_32->sw_bpts_supported(t)) {
 			error = set_swbp(t, bp);
 			if (error != ERROR_OK) {
-				LOG_ERROR("%s error setting software breakpoint at 0x%08" PRIx32,
+				LOG_ERROR("%s error setting software breakpoint at 0x%08" PRIx64,
 						__func__, bp->address);
 				return error;
 			}
@@ -1147,7 +1147,7 @@ static int set_breakpoint(struct target *t, struct breakpoint *bp)
 
 static int unset_breakpoint(struct target *t, struct breakpoint *bp)
 {
-	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, bp->type, bp->address);
+	LOG_DEBUG("type=%d, addr=0x%08" PRIx64, bp->type, bp->address);
 	if (!bp->set) {
 		LOG_WARNING("breakpoint not set");
 		return ERROR_OK;
@@ -1155,13 +1155,13 @@ static int unset_breakpoint(struct target *t, struct breakpoint *bp)
 
 	if (bp->type == BKPT_HARD) {
 		if (unset_hwbp(t, bp) != ERROR_OK) {
-			LOG_ERROR("%s error removing hardware breakpoint at 0x%08" PRIx32,
+			LOG_ERROR("%s error removing hardware breakpoint at 0x%08" PRIx64,
 					__func__, bp->address);
 			return ERROR_FAIL;
 		}
 	} else {
 		if (unset_swbp(t, bp) != ERROR_OK) {
-			LOG_ERROR("%s error removing software breakpoint at 0x%08" PRIx32,
+			LOG_ERROR("%s error removing software breakpoint at 0x%08" PRIx64,
 					__func__, bp->address);
 			return ERROR_FAIL;
 		}
@@ -1175,7 +1175,7 @@ static int set_watchpoint(struct target *t, struct watchpoint *wp)
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
 	struct x86_32_dbg_reg *debug_reg_list = x86_32->hw_break_list;
 	int wp_num = 0;
-	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, wp->rw, wp->address);
+	LOG_DEBUG("type=%d, addr=0x%08" PRIx64, wp->rw, wp->address);
 
 	if (wp->set) {
 		LOG_ERROR("%s watchpoint already set", __func__);
@@ -1220,7 +1220,7 @@ static int set_watchpoint(struct target *t, struct watchpoint *wp)
 	wp->set = wp_num + 1;
 	debug_reg_list[wp_num].used = 1;
 	debug_reg_list[wp_num].bp_value = wp->address;
-	LOG_USER("'%s' watchpoint %d set at 0x%08" PRIx32 " with length %" PRIu32 " (hwreg=%d)",
+	LOG_USER("'%s' watchpoint %d set at 0x%08" PRIx64 " with length %" PRIu64 " (hwreg=%d)",
 			wp->rw == WPT_READ ? "read" : wp->rw == WPT_WRITE ?
 			"write" : wp->rw == WPT_ACCESS ? "access" : "?",
 			wp->unique_id, wp->address, wp->length, wp_num);
@@ -1231,7 +1231,7 @@ static int unset_watchpoint(struct target *t, struct watchpoint *wp)
 {
 	struct x86_32_common *x86_32 = target_to_x86_32(t);
 	struct x86_32_dbg_reg *debug_reg_list = x86_32->hw_break_list;
-	LOG_DEBUG("type=%d, addr=0x%08" PRIx32, wp->rw, wp->address);
+	LOG_DEBUG("type=%d, addr=0x%08" PRIx64, wp->rw, wp->address);
 	if (!wp->set) {
 		LOG_WARNING("watchpoint not set");
 		return ERROR_OK;
@@ -1249,7 +1249,7 @@ static int unset_watchpoint(struct target *t, struct watchpoint *wp)
 	debug_reg_list[wp_num].bp_value = 0;
 	wp->set = 0;
 
-	LOG_USER("'%s' watchpoint %d removed from 0x%08" PRIx32 " with length %" PRIu32 " (hwreg=%d)",
+	LOG_USER("'%s' watchpoint %d removed from 0x%08" PRIx64 " with length %" PRIu64 " (hwreg=%d)",
 			wp->rw == WPT_READ ? "read" : wp->rw == WPT_WRITE ?
 			"write" : wp->rw == WPT_ACCESS ? "access" : "?",
 			wp->unique_id, wp->address, wp->length, wp_num);
diff --git a/src/target/x86_32_common.h b/src/target/x86_32_common.h
old mode 100644
new mode 100755
diff --git a/src/target/xscale.c b/src/target/xscale.c
old mode 100644
new mode 100755
index 8d97a89..edb18fc
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -1167,7 +1167,7 @@ static int xscale_resume(struct target *target, int current,
 			enum trace_mode saved_trace_mode;
 
 			/* there's a breakpoint at the current PC, we have to step over it */
-			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
+			LOG_DEBUG("unset breakpoint at 0x%8.8" PRIx64 "", breakpoint->address);
 			xscale_unset_breakpoint(target, breakpoint);
 
 			/* calculate PC of next instruction */
@@ -1224,7 +1224,7 @@ static int xscale_resume(struct target *target, int current,
 			LOG_DEBUG("disable single-step");
 			xscale_disable_single_step(target);
 
-			LOG_DEBUG("set breakpoint at 0x%8.8" PRIx32 "", breakpoint->address);
+			LOG_DEBUG("set breakpoint at 0x%8.8" PRIx64 "", breakpoint->address);
 			xscale_set_breakpoint(target, breakpoint);
 		}
 	}
@@ -3407,7 +3407,7 @@ COMMAND_HANDLER(xscale_handle_trace_image_command)
 	/* a base address isn't always necessary, default to 0x0 (i.e. don't relocate) */
 	if (CMD_ARGC >= 2) {
 		xscale->trace.image->base_address_set = 1;
-		COMMAND_PARSE_NUMBER(llong, CMD_ARGV[1], xscale->trace.image->base_address);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], xscale->trace.image->base_address);
 	} else
 		xscale->trace.image->base_address_set = 0;
 
@@ -3684,15 +3684,30 @@ static const struct command_registration xscale_command_handlers[] = {
 	COMMAND_REGISTRATION_DONE
 };
 
+static struct target_io32 xscale_target32 = {
+	.read_memory = xscale_read_memory,
+	.read_phys_memory = xscale_read_phys_memory,
+	.write_memory = xscale_write_memory,
+	.write_phys_memory = xscale_write_phys_memory,
+
+	.checksum_memory = arm_checksum_memory,
+	.blank_check_memory = arm_blank_check_memory,
+	.run_algorithm = armv4_5_run_algorithm,
+	.virt2phys = xscale_virt2phys,
+	.resume = xscale_resume,
+	.step = xscale_step,
+
+};
+
 struct target_type xscale_target = {
 	.name = "xscale",
 
+	.pIo32_legacy_api = &xscale_target32,
+	
 	.poll = xscale_poll,
 	.arch_state = xscale_arch_state,
 
 	.halt = xscale_halt,
-	.resume = xscale_resume,
-	.step = xscale_step,
 
 	.assert_reset = xscale_assert_reset,
 	.deassert_reset = xscale_deassert_reset,
@@ -3700,15 +3715,6 @@ struct target_type xscale_target = {
 	/* REVISIT on some cores, allow exporting iwmmxt registers ... */
 	.get_gdb_reg_list = arm_get_gdb_reg_list,
 
-	.read_memory = xscale_read_memory,
-	.read_phys_memory = xscale_read_phys_memory,
-	.write_memory = xscale_write_memory,
-	.write_phys_memory = xscale_write_phys_memory,
-
-	.checksum_memory = arm_checksum_memory,
-	.blank_check_memory = arm_blank_check_memory,
-
-	.run_algorithm = armv4_5_run_algorithm,
 
 	.add_breakpoint = xscale_add_breakpoint,
 	.remove_breakpoint = xscale_remove_breakpoint,
@@ -3719,6 +3725,5 @@ struct target_type xscale_target = {
 	.target_create = xscale_target_create,
 	.init_target = xscale_init_target,
 
-	.virt2phys = xscale_virt2phys,
 	.mmu = xscale_mmu
 };
diff --git a/src/target/xscale.h b/src/target/xscale.h
old mode 100644
new mode 100755
diff --git a/src/target/xscale/debug_handler.S b/src/target/xscale/debug_handler.S
old mode 100644
new mode 100755
diff --git a/src/target/xscale/debug_handler.cmd b/src/target/xscale/debug_handler.cmd
old mode 100644
new mode 100755
diff --git a/src/target/xscale/protocol.h b/src/target/xscale/protocol.h
old mode 100644
new mode 100755
diff --git a/src/transport/Makefile.am b/src/transport/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/transport/transport.c b/src/transport/transport.c
old mode 100644
new mode 100755
diff --git a/src/transport/transport.h b/src/transport/transport.h
old mode 100644
new mode 100755
diff --git a/src/xsvf/Makefile.am b/src/xsvf/Makefile.am
old mode 100644
new mode 100755
diff --git a/src/xsvf/xsvf.c b/src/xsvf/xsvf.c
old mode 100644
new mode 100755
diff --git a/src/xsvf/xsvf.h b/src/xsvf/xsvf.h
old mode 100644
new mode 100755
diff --git a/tcl/bitsbytes.tcl b/tcl/bitsbytes.tcl
old mode 100644
new mode 100755
diff --git a/tcl/board/actux3.cfg b/tcl/board/actux3.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/altera_sockit.cfg b/tcl/board/altera_sockit.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/am3517evm.cfg b/tcl/board/am3517evm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/arm_evaluator7t.cfg b/tcl/board/arm_evaluator7t.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/asus-rt-n16.cfg b/tcl/board/asus-rt-n16.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/asus-rt-n66u.cfg b/tcl/board/asus-rt-n66u.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/at91cap7a-stk-sdram.cfg b/tcl/board/at91cap7a-stk-sdram.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/at91eb40a.cfg b/tcl/board/at91eb40a.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/at91rm9200-dk.cfg b/tcl/board/at91rm9200-dk.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/at91rm9200-ek.cfg b/tcl/board/at91rm9200-ek.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/at91sam9261-ek.cfg b/tcl/board/at91sam9261-ek.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/at91sam9263-ek.cfg b/tcl/board/at91sam9263-ek.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/at91sam9g20-ek.cfg b/tcl/board/at91sam9g20-ek.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_at91sam7s-ek.cfg b/tcl/board/atmel_at91sam7s-ek.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_at91sam9260-ek.cfg b/tcl/board/atmel_at91sam9260-ek.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_at91sam9rl-ek.cfg b/tcl/board/atmel_at91sam9rl-ek.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_sam3n_ek.cfg b/tcl/board/atmel_sam3n_ek.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_sam3s_ek.cfg b/tcl/board/atmel_sam3s_ek.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_sam3u_ek.cfg b/tcl/board/atmel_sam3u_ek.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_sam3x_ek.cfg b/tcl/board/atmel_sam3x_ek.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_sam4e_ek.cfg b/tcl/board/atmel_sam4e_ek.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_sam4l8_xplained_pro.cfg b/tcl/board/atmel_sam4l8_xplained_pro.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_sam4s_ek.cfg b/tcl/board/atmel_sam4s_ek.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_sam4s_xplained_pro.cfg b/tcl/board/atmel_sam4s_xplained_pro.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_samd20_xplained_pro.cfg b/tcl/board/atmel_samd20_xplained_pro.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_samd21_xplained_pro.cfg b/tcl/board/atmel_samd21_xplained_pro.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_samg53_xplained_pro.cfg b/tcl/board/atmel_samg53_xplained_pro.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/atmel_samr21_xplained_pro.cfg b/tcl/board/atmel_samr21_xplained_pro.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/balloon3-cpu.cfg b/tcl/board/balloon3-cpu.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/bcm28155_ap.cfg b/tcl/board/bcm28155_ap.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/bt-homehubv1.cfg b/tcl/board/bt-homehubv1.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/colibri.cfg b/tcl/board/colibri.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/crossbow_tech_imote2.cfg b/tcl/board/crossbow_tech_imote2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/csb337.cfg b/tcl/board/csb337.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/csb732.cfg b/tcl/board/csb732.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/da850evm.cfg b/tcl/board/da850evm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/digi_connectcore_wi-9c.cfg b/tcl/board/digi_connectcore_wi-9c.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/digilent_zedboard.cfg b/tcl/board/digilent_zedboard.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/diolan_lpc4350-db1.cfg b/tcl/board/diolan_lpc4350-db1.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/dm355evm.cfg b/tcl/board/dm355evm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/dm365evm.cfg b/tcl/board/dm365evm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/dm6446evm.cfg b/tcl/board/dm6446evm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/dp_busblaster_v3.cfg b/tcl/board/dp_busblaster_v3.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/efikamx.cfg b/tcl/board/efikamx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/eir.cfg b/tcl/board/eir.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ek-lm3s1968.cfg b/tcl/board/ek-lm3s1968.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ek-lm3s3748.cfg b/tcl/board/ek-lm3s3748.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ek-lm3s6965.cfg b/tcl/board/ek-lm3s6965.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ek-lm3s811-revb.cfg b/tcl/board/ek-lm3s811-revb.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ek-lm3s811.cfg b/tcl/board/ek-lm3s811.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ek-lm3s8962.cfg b/tcl/board/ek-lm3s8962.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ek-lm3s9b9x.cfg b/tcl/board/ek-lm3s9b9x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ek-lm3s9d92.cfg b/tcl/board/ek-lm3s9d92.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ek-lm4f120xl.cfg b/tcl/board/ek-lm4f120xl.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ek-lm4f232.cfg b/tcl/board/ek-lm4f232.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ek-tm4c123gxl.cfg b/tcl/board/ek-tm4c123gxl.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ek-tm4c1294xl.cfg b/tcl/board/ek-tm4c1294xl.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/embedded-artists_lpc2478-32.cfg b/tcl/board/embedded-artists_lpc2478-32.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ethernut3.cfg b/tcl/board/ethernut3.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/frdm-kl25z.cfg b/tcl/board/frdm-kl25z.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/frdm-kl46z.cfg b/tcl/board/frdm-kl46z.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/glyn_tonga2.cfg b/tcl/board/glyn_tonga2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/gumstix-aerocore.cfg b/tcl/board/gumstix-aerocore.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/hammer.cfg b/tcl/board/hammer.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/hilscher_nxdb500sys.cfg b/tcl/board/hilscher_nxdb500sys.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/hilscher_nxeb500hmi.cfg b/tcl/board/hilscher_nxeb500hmi.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/hilscher_nxhx10.cfg b/tcl/board/hilscher_nxhx10.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/hilscher_nxhx50.cfg b/tcl/board/hilscher_nxhx50.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/hilscher_nxhx500.cfg b/tcl/board/hilscher_nxhx500.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/hilscher_nxsb100.cfg b/tcl/board/hilscher_nxsb100.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/hitex_lpc1768stick.cfg b/tcl/board/hitex_lpc1768stick.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/hitex_lpc2929.cfg b/tcl/board/hitex_lpc2929.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/hitex_stm32-performancestick.cfg b/tcl/board/hitex_stm32-performancestick.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/hitex_str9-comstick.cfg b/tcl/board/hitex_str9-comstick.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/iar_lpc1768.cfg b/tcl/board/iar_lpc1768.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/iar_str912_sk.cfg b/tcl/board/iar_str912_sk.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/icnova_imx53_sodimm.cfg b/tcl/board/icnova_imx53_sodimm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/icnova_sam9g45_sodimm.cfg b/tcl/board/icnova_sam9g45_sodimm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/imx27ads.cfg b/tcl/board/imx27ads.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/imx27lnst.cfg b/tcl/board/imx27lnst.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/imx28evk.cfg b/tcl/board/imx28evk.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/imx31pdk.cfg b/tcl/board/imx31pdk.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/imx35pdk.cfg b/tcl/board/imx35pdk.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/imx53-m53evk.cfg b/tcl/board/imx53-m53evk.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/imx53loco.cfg b/tcl/board/imx53loco.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/keil_mcb1700.cfg b/tcl/board/keil_mcb1700.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/keil_mcb2140.cfg b/tcl/board/keil_mcb2140.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/kwikstik.cfg b/tcl/board/kwikstik.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/linksys-wrt54gl.cfg b/tcl/board/linksys-wrt54gl.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/linksys_nslu2.cfg b/tcl/board/linksys_nslu2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/lisa-l.cfg b/tcl/board/lisa-l.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/logicpd_imx27.cfg b/tcl/board/logicpd_imx27.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/lpc1850_spifi_generic.cfg b/tcl/board/lpc1850_spifi_generic.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/lpc4350_spifi_generic.cfg b/tcl/board/lpc4350_spifi_generic.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/lubbock.cfg b/tcl/board/lubbock.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/mbed-lpc11u24.cfg b/tcl/board/mbed-lpc11u24.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/mbed-lpc1768.cfg b/tcl/board/mbed-lpc1768.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/mcb1700.cfg b/tcl/board/mcb1700.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/microchip_explorer16.cfg b/tcl/board/microchip_explorer16.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/mini2440.cfg b/tcl/board/mini2440.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/mini6410.cfg b/tcl/board/mini6410.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/nds32_xc5.cfg b/tcl/board/nds32_xc5.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/netgear-dg834v3.cfg b/tcl/board/netgear-dg834v3.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/nordic_nrf51822_mkit.cfg b/tcl/board/nordic_nrf51822_mkit.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/olimex_LPC2378STK.cfg b/tcl/board/olimex_LPC2378STK.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/olimex_lpc_h2148.cfg b/tcl/board/olimex_lpc_h2148.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/olimex_sam7_ex256.cfg b/tcl/board/olimex_sam7_ex256.cfg
old mode 100644
new mode 100755
index 5f83629..449b01d
--- a/tcl/board/olimex_sam7_ex256.cfg
+++ b/tcl/board/olimex_sam7_ex256.cfg
@@ -1,4 +1,4 @@
 # Olimex SAM7-EX256 has a single Atmel at91sam7ex256 on it.
 
-source [find target/sam7x256.cfg]
+source [find target/at91sam7x256.cfg]
 
diff --git a/tcl/board/olimex_sam9_l9260.cfg b/tcl/board/olimex_sam9_l9260.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/olimex_stm32_h103.cfg b/tcl/board/olimex_stm32_h103.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/olimex_stm32_h107.cfg b/tcl/board/olimex_stm32_h107.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/olimex_stm32_p107.cfg b/tcl/board/olimex_stm32_p107.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/omap2420_h4.cfg b/tcl/board/omap2420_h4.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/open-bldc.cfg b/tcl/board/open-bldc.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/openrd.cfg b/tcl/board/openrd.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/or1k_generic.cfg b/tcl/board/or1k_generic.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/osk5912.cfg b/tcl/board/osk5912.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/phone_se_j100i.cfg b/tcl/board/phone_se_j100i.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/phytec_lpc3250.cfg b/tcl/board/phytec_lpc3250.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/pic-p32mx.cfg b/tcl/board/pic-p32mx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/propox_mmnet1001.cfg b/tcl/board/propox_mmnet1001.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/pxa255_sst.cfg b/tcl/board/pxa255_sst.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/quark_x10xx_board.cfg b/tcl/board/quark_x10xx_board.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/redbee.cfg b/tcl/board/redbee.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/rsc-w910.cfg b/tcl/board/rsc-w910.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/sheevaplug.cfg b/tcl/board/sheevaplug.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/smdk6410.cfg b/tcl/board/smdk6410.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/spear300evb.cfg b/tcl/board/spear300evb.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/spear300evb_mod.cfg b/tcl/board/spear300evb_mod.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/spear310evb20.cfg b/tcl/board/spear310evb20.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/spear310evb20_mod.cfg b/tcl/board/spear310evb20_mod.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/spear320cpu.cfg b/tcl/board/spear320cpu.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/spear320cpu_mod.cfg b/tcl/board/spear320cpu_mod.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/st_nucleo_f030r8.cfg b/tcl/board/st_nucleo_f030r8.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/st_nucleo_f103rb.cfg b/tcl/board/st_nucleo_f103rb.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/st_nucleo_f334r8.cfg b/tcl/board/st_nucleo_f334r8.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/st_nucleo_f401re.cfg b/tcl/board/st_nucleo_f401re.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/st_nucleo_f411re.cfg b/tcl/board/st_nucleo_f411re.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/steval_pcc010.cfg b/tcl/board/steval_pcc010.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm320518_eval.cfg b/tcl/board/stm320518_eval.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm320518_eval_stlink.cfg b/tcl/board/stm320518_eval_stlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm32100b_eval.cfg b/tcl/board/stm32100b_eval.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm3210b_eval.cfg b/tcl/board/stm3210b_eval.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm3210c_eval.cfg b/tcl/board/stm3210c_eval.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm3210e_eval.cfg b/tcl/board/stm3210e_eval.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm3220g_eval.cfg b/tcl/board/stm3220g_eval.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm3220g_eval_stlink.cfg b/tcl/board/stm3220g_eval_stlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm3241g_eval.cfg b/tcl/board/stm3241g_eval.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm3241g_eval_stlink.cfg b/tcl/board/stm3241g_eval_stlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm32429i_eval.cfg b/tcl/board/stm32429i_eval.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm32429i_eval_stlink.cfg b/tcl/board/stm32429i_eval_stlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm32439i_eval.cfg b/tcl/board/stm32439i_eval.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm32439i_eval_stlink.cfg b/tcl/board/stm32439i_eval_stlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm32f0discovery.cfg b/tcl/board/stm32f0discovery.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm32f3discovery.cfg b/tcl/board/stm32f3discovery.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm32f429discovery.cfg b/tcl/board/stm32f429discovery.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm32f4discovery.cfg b/tcl/board/stm32f4discovery.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm32l0discovery.cfg b/tcl/board/stm32l0discovery.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm32ldiscovery.cfg b/tcl/board/stm32ldiscovery.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/stm32vldiscovery.cfg b/tcl/board/stm32vldiscovery.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/str910-eval.cfg b/tcl/board/str910-eval.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/telo.cfg b/tcl/board/telo.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ti_am335xevm.cfg b/tcl/board/ti_am335xevm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ti_am43xx_evm.cfg b/tcl/board/ti_am43xx_evm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ti_beagleboard.cfg b/tcl/board/ti_beagleboard.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ti_beagleboard_xm.cfg b/tcl/board/ti_beagleboard_xm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ti_beaglebone.cfg b/tcl/board/ti_beaglebone.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ti_blaze.cfg b/tcl/board/ti_blaze.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ti_pandaboard.cfg b/tcl/board/ti_pandaboard.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ti_pandaboard_es.cfg b/tcl/board/ti_pandaboard_es.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/ti_tmdx570ls31usb.cfg b/tcl/board/ti_tmdx570ls31usb.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/topas910.cfg b/tcl/board/topas910.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/topasa900.cfg b/tcl/board/topasa900.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/twr-k60f120m.cfg b/tcl/board/twr-k60f120m.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/twr-k60n512.cfg b/tcl/board/twr-k60n512.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/tx25_stk5.cfg b/tcl/board/tx25_stk5.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/tx27_stk5.cfg b/tcl/board/tx27_stk5.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/unknown_at91sam9260.cfg b/tcl/board/unknown_at91sam9260.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/uptech_2410.cfg b/tcl/board/uptech_2410.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/verdex.cfg b/tcl/board/verdex.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/voipac.cfg b/tcl/board/voipac.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/voltcraft_dso-3062c.cfg b/tcl/board/voltcraft_dso-3062c.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/x300t.cfg b/tcl/board/x300t.cfg
old mode 100644
new mode 100755
diff --git a/tcl/board/zy1000.cfg b/tcl/board/zy1000.cfg
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/aic.tcl b/tcl/chip/atmel/at91/aic.tcl
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/at91_pio.cfg b/tcl/chip/atmel/at91/at91_pio.cfg
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/at91_pmc.cfg b/tcl/chip/atmel/at91/at91_pmc.cfg
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/at91_rstc.cfg b/tcl/chip/atmel/at91/at91_rstc.cfg
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/at91_wdt.cfg b/tcl/chip/atmel/at91/at91_wdt.cfg
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/at91sam7x128.tcl b/tcl/chip/atmel/at91/at91sam7x128.tcl
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/at91sam7x256.tcl b/tcl/chip/atmel/at91/at91sam7x256.tcl
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/at91sam9261.cfg b/tcl/chip/atmel/at91/at91sam9261.cfg
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/at91sam9261_matrix.cfg b/tcl/chip/atmel/at91/at91sam9261_matrix.cfg
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/at91sam9263.cfg b/tcl/chip/atmel/at91/at91sam9263.cfg
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/at91sam9263_matrix.cfg b/tcl/chip/atmel/at91/at91sam9263_matrix.cfg
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/at91sam9_init.cfg b/tcl/chip/atmel/at91/at91sam9_init.cfg
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/at91sam9_sdramc.cfg b/tcl/chip/atmel/at91/at91sam9_sdramc.cfg
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/at91sam9_smc.cfg b/tcl/chip/atmel/at91/at91sam9_smc.cfg
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/hardware.cfg b/tcl/chip/atmel/at91/hardware.cfg
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/pmc.tcl b/tcl/chip/atmel/at91/pmc.tcl
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/rtt.tcl b/tcl/chip/atmel/at91/rtt.tcl
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/sam9_smc.cfg b/tcl/chip/atmel/at91/sam9_smc.cfg
old mode 100644
new mode 100755
diff --git a/tcl/chip/atmel/at91/usarts.tcl b/tcl/chip/atmel/at91/usarts.tcl
old mode 100644
new mode 100755
diff --git a/tcl/chip/st/spear/quirk_no_srst.tcl b/tcl/chip/st/spear/quirk_no_srst.tcl
old mode 100644
new mode 100755
diff --git a/tcl/chip/st/spear/spear3xx.tcl b/tcl/chip/st/spear/spear3xx.tcl
old mode 100644
new mode 100755
diff --git a/tcl/chip/st/spear/spear3xx_ddr.tcl b/tcl/chip/st/spear/spear3xx_ddr.tcl
old mode 100644
new mode 100755
diff --git a/tcl/chip/st/stm32/stm32.tcl b/tcl/chip/st/stm32/stm32.tcl
old mode 100644
new mode 100755
diff --git a/tcl/chip/st/stm32/stm32_rcc.tcl b/tcl/chip/st/stm32/stm32_rcc.tcl
old mode 100644
new mode 100755
diff --git a/tcl/chip/st/stm32/stm32_regs.tcl b/tcl/chip/st/stm32/stm32_regs.tcl
old mode 100644
new mode 100755
diff --git a/tcl/chip/ti/lm3s/lm3s.tcl b/tcl/chip/ti/lm3s/lm3s.tcl
old mode 100644
new mode 100755
diff --git a/tcl/chip/ti/lm3s/lm3s_regs.tcl b/tcl/chip/ti/lm3s/lm3s_regs.tcl
old mode 100644
new mode 100755
diff --git a/tcl/cpld/lattice-lc4032ze.cfg b/tcl/cpld/lattice-lc4032ze.cfg
old mode 100644
new mode 100755
diff --git a/tcl/cpld/xilinx-xcr3256.cfg b/tcl/cpld/xilinx-xcr3256.cfg
old mode 100644
new mode 100755
diff --git a/tcl/cpu/arm/arm7tdmi.tcl b/tcl/cpu/arm/arm7tdmi.tcl
old mode 100644
new mode 100755
diff --git a/tcl/cpu/arm/arm920.tcl b/tcl/cpu/arm/arm920.tcl
old mode 100644
new mode 100755
diff --git a/tcl/cpu/arm/arm946.tcl b/tcl/cpu/arm/arm946.tcl
old mode 100644
new mode 100755
diff --git a/tcl/cpu/arm/arm966.tcl b/tcl/cpu/arm/arm966.tcl
old mode 100644
new mode 100755
diff --git a/tcl/cpu/arm/cortex_m3.tcl b/tcl/cpu/arm/cortex_m3.tcl
old mode 100644
new mode 100755
diff --git a/tcl/interface/altera-usb-blaster.cfg b/tcl/interface/altera-usb-blaster.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/altera-usb-blaster2.cfg b/tcl/interface/altera-usb-blaster2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/arm-jtag-ew.cfg b/tcl/interface/arm-jtag-ew.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/at91rm9200.cfg b/tcl/interface/at91rm9200.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/axm0432.cfg b/tcl/interface/axm0432.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/busblaster.cfg b/tcl/interface/busblaster.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/buspirate.cfg b/tcl/interface/buspirate.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/calao-usb-a9260-c01.cfg b/tcl/interface/calao-usb-a9260-c01.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/calao-usb-a9260-c02.cfg b/tcl/interface/calao-usb-a9260-c02.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/calao-usb-a9260.cfg b/tcl/interface/calao-usb-a9260.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/chameleon.cfg b/tcl/interface/chameleon.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/cmsis-dap.cfg b/tcl/interface/cmsis-dap.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/cortino.cfg b/tcl/interface/cortino.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/digilent-hs1.cfg b/tcl/interface/digilent-hs1.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/dlp-usb1232h.cfg b/tcl/interface/dlp-usb1232h.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/dummy.cfg b/tcl/interface/dummy.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/estick.cfg b/tcl/interface/estick.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/flashlink.cfg b/tcl/interface/flashlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/flossjtag-noeeprom.cfg b/tcl/interface/flossjtag-noeeprom.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/flossjtag.cfg b/tcl/interface/flossjtag.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/flyswatter.cfg b/tcl/interface/flyswatter.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/flyswatter2.cfg b/tcl/interface/flyswatter2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/axm0432.cfg b/tcl/interface/ftdi/axm0432.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/calao-usb-a9260-c01.cfg b/tcl/interface/ftdi/calao-usb-a9260-c01.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/calao-usb-a9260-c02.cfg b/tcl/interface/ftdi/calao-usb-a9260-c02.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/cortino.cfg b/tcl/interface/ftdi/cortino.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/digilent_jtag_smt2.cfg b/tcl/interface/ftdi/digilent_jtag_smt2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/dlp-usb1232h.cfg b/tcl/interface/ftdi/dlp-usb1232h.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/dp_busblaster.cfg b/tcl/interface/ftdi/dp_busblaster.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/dp_busblaster_kt-link.cfg b/tcl/interface/ftdi/dp_busblaster_kt-link.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/flossjtag-noeeprom.cfg b/tcl/interface/ftdi/flossjtag-noeeprom.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/flossjtag.cfg b/tcl/interface/ftdi/flossjtag.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/flyswatter.cfg b/tcl/interface/ftdi/flyswatter.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/flyswatter2.cfg b/tcl/interface/ftdi/flyswatter2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/gw16042.cfg b/tcl/interface/ftdi/gw16042.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/hilscher_nxhx10_etm.cfg b/tcl/interface/ftdi/hilscher_nxhx10_etm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/hilscher_nxhx500_etm.cfg b/tcl/interface/ftdi/hilscher_nxhx500_etm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/hilscher_nxhx500_re.cfg b/tcl/interface/ftdi/hilscher_nxhx500_re.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/hilscher_nxhx50_etm.cfg b/tcl/interface/ftdi/hilscher_nxhx50_etm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/hilscher_nxhx50_re.cfg b/tcl/interface/ftdi/hilscher_nxhx50_re.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/hitex_lpc1768stick.cfg b/tcl/interface/ftdi/hitex_lpc1768stick.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/hitex_str9-comstick.cfg b/tcl/interface/ftdi/hitex_str9-comstick.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/icebear.cfg b/tcl/interface/ftdi/icebear.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/jtag-lock-pick_tiny_2.cfg b/tcl/interface/ftdi/jtag-lock-pick_tiny_2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/jtagkey.cfg b/tcl/interface/ftdi/jtagkey.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/jtagkey2.cfg b/tcl/interface/ftdi/jtagkey2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/jtagkey2p.cfg b/tcl/interface/ftdi/jtagkey2p.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/kt-link.cfg b/tcl/interface/ftdi/kt-link.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/lisa-l.cfg b/tcl/interface/ftdi/lisa-l.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/luminary-icdi.cfg b/tcl/interface/ftdi/luminary-icdi.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/luminary-lm3s811.cfg b/tcl/interface/ftdi/luminary-lm3s811.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/luminary.cfg b/tcl/interface/ftdi/luminary.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/m53evk.cfg b/tcl/interface/ftdi/m53evk.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/minimodule.cfg b/tcl/interface/ftdi/minimodule.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/neodb.cfg b/tcl/interface/ftdi/neodb.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/ngxtech.cfg b/tcl/interface/ftdi/ngxtech.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/olimex-arm-jtag-swd.cfg b/tcl/interface/ftdi/olimex-arm-jtag-swd.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/olimex-arm-usb-ocd-h.cfg b/tcl/interface/ftdi/olimex-arm-usb-ocd-h.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/olimex-arm-usb-ocd.cfg b/tcl/interface/ftdi/olimex-arm-usb-ocd.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/olimex-arm-usb-tiny-h.cfg b/tcl/interface/ftdi/olimex-arm-usb-tiny-h.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/olimex-jtag-tiny.cfg b/tcl/interface/ftdi/olimex-jtag-tiny.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/oocdlink.cfg b/tcl/interface/ftdi/oocdlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/opendous_ftdi.cfg b/tcl/interface/ftdi/opendous_ftdi.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/openocd-usb-hs.cfg b/tcl/interface/ftdi/openocd-usb-hs.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/openocd-usb.cfg b/tcl/interface/ftdi/openocd-usb.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/openrd.cfg b/tcl/interface/ftdi/openrd.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/redbee-econotag.cfg b/tcl/interface/ftdi/redbee-econotag.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/redbee-usb.cfg b/tcl/interface/ftdi/redbee-usb.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/rowley-cc-arm-swd.cfg b/tcl/interface/ftdi/rowley-cc-arm-swd.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/sheevaplug.cfg b/tcl/interface/ftdi/sheevaplug.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/signalyzer-lite.cfg b/tcl/interface/ftdi/signalyzer-lite.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/signalyzer.cfg b/tcl/interface/ftdi/signalyzer.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/stm32-stick.cfg b/tcl/interface/ftdi/stm32-stick.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/swd-resistor-hack.cfg b/tcl/interface/ftdi/swd-resistor-hack.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/tumpa-lite.cfg b/tcl/interface/ftdi/tumpa-lite.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/tumpa.cfg b/tcl/interface/ftdi/tumpa.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/turtelizer2-revB.cfg b/tcl/interface/ftdi/turtelizer2-revB.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/turtelizer2-revC.cfg b/tcl/interface/ftdi/turtelizer2-revC.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/vpaclink.cfg b/tcl/interface/ftdi/vpaclink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ftdi/xds100v2.cfg b/tcl/interface/ftdi/xds100v2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/hilscher_nxhx10_etm.cfg b/tcl/interface/hilscher_nxhx10_etm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/hilscher_nxhx500_etm.cfg b/tcl/interface/hilscher_nxhx500_etm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/hilscher_nxhx500_re.cfg b/tcl/interface/hilscher_nxhx500_re.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/hilscher_nxhx50_etm.cfg b/tcl/interface/hilscher_nxhx50_etm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/hilscher_nxhx50_re.cfg b/tcl/interface/hilscher_nxhx50_re.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/hitex_str9-comstick.cfg b/tcl/interface/hitex_str9-comstick.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/icebear.cfg b/tcl/interface/icebear.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/jlink.cfg b/tcl/interface/jlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/jtag-lock-pick_tiny_2.cfg b/tcl/interface/jtag-lock-pick_tiny_2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/jtag_vpi.cfg b/tcl/interface/jtag_vpi.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/jtagkey-tiny.cfg b/tcl/interface/jtagkey-tiny.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/jtagkey.cfg b/tcl/interface/jtagkey.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/jtagkey2.cfg b/tcl/interface/jtagkey2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/jtagkey2p.cfg b/tcl/interface/jtagkey2p.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/kt-link.cfg b/tcl/interface/kt-link.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/lisa-l.cfg b/tcl/interface/lisa-l.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/luminary-icdi.cfg b/tcl/interface/luminary-icdi.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/luminary-lm3s811.cfg b/tcl/interface/luminary-lm3s811.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/luminary.cfg b/tcl/interface/luminary.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/minimodule.cfg b/tcl/interface/minimodule.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/nds32-aice.cfg b/tcl/interface/nds32-aice.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/neodb.cfg b/tcl/interface/neodb.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ngxtech.cfg b/tcl/interface/ngxtech.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/olimex-arm-usb-ocd-h.cfg b/tcl/interface/olimex-arm-usb-ocd-h.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/olimex-arm-usb-ocd.cfg b/tcl/interface/olimex-arm-usb-ocd.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/olimex-arm-usb-tiny-h.cfg b/tcl/interface/olimex-arm-usb-tiny-h.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/olimex-jtag-tiny.cfg b/tcl/interface/olimex-jtag-tiny.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/oocdlink.cfg b/tcl/interface/oocdlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/opendous.cfg b/tcl/interface/opendous.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/opendous_ftdi.cfg b/tcl/interface/opendous_ftdi.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/openjtag.cfg b/tcl/interface/openjtag.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/openocd-usb-hs.cfg b/tcl/interface/openocd-usb-hs.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/openocd-usb.cfg b/tcl/interface/openocd-usb.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/openrd.cfg b/tcl/interface/openrd.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/osbdm.cfg b/tcl/interface/osbdm.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/parport.cfg b/tcl/interface/parport.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/parport_dlc5.cfg b/tcl/interface/parport_dlc5.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/raspberrypi-native.cfg b/tcl/interface/raspberrypi-native.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/redbee-econotag.cfg b/tcl/interface/redbee-econotag.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/redbee-usb.cfg b/tcl/interface/redbee-usb.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/rlink.cfg b/tcl/interface/rlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/sheevaplug.cfg b/tcl/interface/sheevaplug.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/signalyzer-h2.cfg b/tcl/interface/signalyzer-h2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/signalyzer-h4.cfg b/tcl/interface/signalyzer-h4.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/signalyzer-lite.cfg b/tcl/interface/signalyzer-lite.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/signalyzer.cfg b/tcl/interface/signalyzer.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/stlink-v1.cfg b/tcl/interface/stlink-v1.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/stlink-v2-1.cfg b/tcl/interface/stlink-v2-1.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/stlink-v2.cfg b/tcl/interface/stlink-v2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/stm32-stick.cfg b/tcl/interface/stm32-stick.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/sysfsgpio-raspberrypi.cfg b/tcl/interface/sysfsgpio-raspberrypi.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ti-icdi.cfg b/tcl/interface/ti-icdi.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/turtelizer2.cfg b/tcl/interface/turtelizer2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/ulink.cfg b/tcl/interface/ulink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/usb-jtag.cfg b/tcl/interface/usb-jtag.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/usbprog.cfg b/tcl/interface/usbprog.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/vpaclink.cfg b/tcl/interface/vpaclink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/vsllink.cfg b/tcl/interface/vsllink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/interface/xds100v2.cfg b/tcl/interface/xds100v2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/mem_helper.tcl b/tcl/mem_helper.tcl
old mode 100644
new mode 100755
diff --git a/tcl/memory.tcl b/tcl/memory.tcl
old mode 100644
new mode 100755
diff --git a/tcl/mmr_helpers.tcl b/tcl/mmr_helpers.tcl
old mode 100644
new mode 100755
diff --git "a/tcl/target/1986\320\262\320\2651\321\202.cfg" "b/tcl/target/1986\320\262\320\2651\321\202.cfg"
old mode 100644
new mode 100755
diff --git a/tcl/target/aduc702x.cfg b/tcl/target/aduc702x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/altera_fpgasoc.cfg b/tcl/target/altera_fpgasoc.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/am335x.cfg b/tcl/target/am335x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/am437x.cfg b/tcl/target/am437x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/amdm37x.cfg b/tcl/target/amdm37x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/ar71xx.cfg b/tcl/target/ar71xx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/armada370.cfg b/tcl/target/armada370.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at32ap7000.cfg b/tcl/target/at32ap7000.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91r40008.cfg b/tcl/target/at91r40008.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91rm9200.cfg b/tcl/target/at91rm9200.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam3XXX.cfg b/tcl/target/at91sam3XXX.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam3ax_4x.cfg b/tcl/target/at91sam3ax_4x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam3ax_8x.cfg b/tcl/target/at91sam3ax_8x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam3ax_xx.cfg b/tcl/target/at91sam3ax_xx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam3nXX.cfg b/tcl/target/at91sam3nXX.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam3sXX.cfg b/tcl/target/at91sam3sXX.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam3u1c.cfg b/tcl/target/at91sam3u1c.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam3u1e.cfg b/tcl/target/at91sam3u1e.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam3u2c.cfg b/tcl/target/at91sam3u2c.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam3u2e.cfg b/tcl/target/at91sam3u2e.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam3u4c.cfg b/tcl/target/at91sam3u4c.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam3u4e.cfg b/tcl/target/at91sam3u4e.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam3uxx.cfg b/tcl/target/at91sam3uxx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam4XXX.cfg b/tcl/target/at91sam4XXX.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam4lXX.cfg b/tcl/target/at91sam4lXX.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam4sXX.cfg b/tcl/target/at91sam4sXX.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam4sd32x.cfg b/tcl/target/at91sam4sd32x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam7se512.cfg b/tcl/target/at91sam7se512.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam7sx.cfg b/tcl/target/at91sam7sx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam7x256.cfg b/tcl/target/at91sam7x256.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam7x512.cfg b/tcl/target/at91sam7x512.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam9.cfg b/tcl/target/at91sam9.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam9260.cfg b/tcl/target/at91sam9260.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg b/tcl/target/at91sam9260_ext_RAM_ext_flash.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam9261.cfg b/tcl/target/at91sam9261.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam9263.cfg b/tcl/target/at91sam9263.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam9g10.cfg b/tcl/target/at91sam9g10.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam9g20.cfg b/tcl/target/at91sam9g20.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam9g45.cfg b/tcl/target/at91sam9g45.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91sam9rl.cfg b/tcl/target/at91sam9rl.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91samdXX.cfg b/tcl/target/at91samdXX.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/at91samg5x.cfg b/tcl/target/at91samg5x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/atmega128.cfg b/tcl/target/atmega128.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/avr32.cfg b/tcl/target/avr32.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/bcm281xx.cfg b/tcl/target/bcm281xx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/bcm4706.cfg b/tcl/target/bcm4706.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/bcm4718.cfg b/tcl/target/bcm4718.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/bcm47xx.cfg b/tcl/target/bcm47xx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/bcm5352e.cfg b/tcl/target/bcm5352e.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/bcm6348.cfg b/tcl/target/bcm6348.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/c100.cfg b/tcl/target/c100.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/c100config.tcl b/tcl/target/c100config.tcl
old mode 100644
new mode 100755
diff --git a/tcl/target/c100helper.tcl b/tcl/target/c100helper.tcl
old mode 100644
new mode 100755
diff --git a/tcl/target/c100regs.tcl b/tcl/target/c100regs.tcl
old mode 100644
new mode 100755
diff --git a/tcl/target/cs351x.cfg b/tcl/target/cs351x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/davinci.cfg b/tcl/target/davinci.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/dragonite.cfg b/tcl/target/dragonite.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/dsp56321.cfg b/tcl/target/dsp56321.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/dsp568013.cfg b/tcl/target/dsp568013.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/dsp568037.cfg b/tcl/target/dsp568037.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/efm32.cfg b/tcl/target/efm32.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/efm32_stlink.cfg b/tcl/target/efm32_stlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/epc9301.cfg b/tcl/target/epc9301.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/faux.cfg b/tcl/target/faux.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/feroceon.cfg b/tcl/target/feroceon.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/fm3.cfg b/tcl/target/fm3.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/gp326xxxa.cfg b/tcl/target/gp326xxxa.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/hilscher_netx10.cfg b/tcl/target/hilscher_netx10.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/hilscher_netx50.cfg b/tcl/target/hilscher_netx50.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/hilscher_netx500.cfg b/tcl/target/hilscher_netx500.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/icepick.cfg b/tcl/target/icepick.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/imx.cfg b/tcl/target/imx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/imx21.cfg b/tcl/target/imx21.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/imx25.cfg b/tcl/target/imx25.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/imx27.cfg b/tcl/target/imx27.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/imx28.cfg b/tcl/target/imx28.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/imx31.cfg b/tcl/target/imx31.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/imx35.cfg b/tcl/target/imx35.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/imx51.cfg b/tcl/target/imx51.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/imx53.cfg b/tcl/target/imx53.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/imx6.cfg b/tcl/target/imx6.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/is5114.cfg b/tcl/target/is5114.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/ixp42x.cfg b/tcl/target/ixp42x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/k40.cfg b/tcl/target/k40.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/k60.cfg b/tcl/target/k60.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/kl25.cfg b/tcl/target/kl25.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/kl25z_hla.cfg b/tcl/target/kl25z_hla.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/kl46.cfg b/tcl/target/kl46.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/ks869x.cfg b/tcl/target/ks869x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc11xx.cfg b/tcl/target/lpc11xx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc12xx.cfg b/tcl/target/lpc12xx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc13xx.cfg b/tcl/target/lpc13xx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc17xx.cfg b/tcl/target/lpc17xx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc1850.cfg b/tcl/target/lpc1850.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc1xxx.cfg b/tcl/target/lpc1xxx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc2103.cfg b/tcl/target/lpc2103.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc2124.cfg b/tcl/target/lpc2124.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc2129.cfg b/tcl/target/lpc2129.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc2148.cfg b/tcl/target/lpc2148.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc2294.cfg b/tcl/target/lpc2294.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc2378.cfg b/tcl/target/lpc2378.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc2460.cfg b/tcl/target/lpc2460.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc2478.cfg b/tcl/target/lpc2478.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc2900.cfg b/tcl/target/lpc2900.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc2xxx.cfg b/tcl/target/lpc2xxx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc3131.cfg b/tcl/target/lpc3131.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc3250.cfg b/tcl/target/lpc3250.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/lpc4350.cfg b/tcl/target/lpc4350.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/mc13224v.cfg b/tcl/target/mc13224v.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/mdr32f9q2i.cfg b/tcl/target/mdr32f9q2i.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/nds32v2.cfg b/tcl/target/nds32v2.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/nds32v3.cfg b/tcl/target/nds32v3.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/nds32v3m.cfg b/tcl/target/nds32v3m.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/nrf51.cfg b/tcl/target/nrf51.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/nrf51_stlink.tcl b/tcl/target/nrf51_stlink.tcl
old mode 100644
new mode 100755
diff --git a/tcl/target/nuc910.cfg b/tcl/target/nuc910.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/omap2420.cfg b/tcl/target/omap2420.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/omap3530.cfg b/tcl/target/omap3530.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/omap4430.cfg b/tcl/target/omap4430.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/omap4460.cfg b/tcl/target/omap4460.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/omap5912.cfg b/tcl/target/omap5912.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/omapl138.cfg b/tcl/target/omapl138.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/or1k.cfg b/tcl/target/or1k.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/pic32mx.cfg b/tcl/target/pic32mx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/pxa255.cfg b/tcl/target/pxa255.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/pxa270.cfg b/tcl/target/pxa270.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/pxa3xx.cfg b/tcl/target/pxa3xx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/quark_x10xx.cfg b/tcl/target/quark_x10xx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/readme.txt b/tcl/target/readme.txt
old mode 100644
new mode 100755
diff --git a/tcl/target/samsung_s3c2410.cfg b/tcl/target/samsung_s3c2410.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/samsung_s3c2440.cfg b/tcl/target/samsung_s3c2440.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/samsung_s3c2450.cfg b/tcl/target/samsung_s3c2450.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/samsung_s3c4510.cfg b/tcl/target/samsung_s3c4510.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/samsung_s3c6410.cfg b/tcl/target/samsung_s3c6410.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/sharp_lh79532.cfg b/tcl/target/sharp_lh79532.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/smp8634.cfg b/tcl/target/smp8634.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/spear3xx.cfg b/tcl/target/spear3xx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stellaris.cfg b/tcl/target/stellaris.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stellaris_icdi.cfg b/tcl/target/stellaris_icdi.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32_stlink.cfg b/tcl/target/stm32_stlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32f0x.cfg b/tcl/target/stm32f0x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32f0x_stlink.cfg b/tcl/target/stm32f0x_stlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32f1x.cfg b/tcl/target/stm32f1x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32f1x_stlink.cfg b/tcl/target/stm32f1x_stlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32f2x.cfg b/tcl/target/stm32f2x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32f2x_stlink.cfg b/tcl/target/stm32f2x_stlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32f3x.cfg b/tcl/target/stm32f3x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32f3x_stlink.cfg b/tcl/target/stm32f3x_stlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32f4x.cfg b/tcl/target/stm32f4x.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32f4x_stlink.cfg b/tcl/target/stm32f4x_stlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32l.cfg b/tcl/target/stm32l.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32lx_dual_bank.cfg b/tcl/target/stm32lx_dual_bank.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32lx_stlink.cfg b/tcl/target/stm32lx_stlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32w108_stlink.cfg b/tcl/target/stm32w108_stlink.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32w108xx.cfg b/tcl/target/stm32w108xx.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/stm32xl.cfg b/tcl/target/stm32xl.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/str710.cfg b/tcl/target/str710.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/str730.cfg b/tcl/target/str730.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/str750.cfg b/tcl/target/str750.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/str912.cfg b/tcl/target/str912.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/swj-dp.tcl b/tcl/target/swj-dp.tcl
old mode 100644
new mode 100755
diff --git a/tcl/target/test_reset_syntax_error.cfg b/tcl/target/test_reset_syntax_error.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/test_syntax_error.cfg b/tcl/target/test_syntax_error.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/ti-ar7.cfg b/tcl/target/ti-ar7.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/ti_calypso.cfg b/tcl/target/ti_calypso.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/ti_dm355.cfg b/tcl/target/ti_dm355.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/ti_dm365.cfg b/tcl/target/ti_dm365.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/ti_dm6446.cfg b/tcl/target/ti_dm6446.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/ti_tms570.cfg b/tcl/target/ti_tms570.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/tmpa900.cfg b/tcl/target/tmpa900.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/tmpa910.cfg b/tcl/target/tmpa910.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/u8500.cfg b/tcl/target/u8500.cfg
old mode 100644
new mode 100755
diff --git a/tcl/target/zynq_7000.cfg b/tcl/target/zynq_7000.cfg
old mode 100644
new mode 100755
diff --git "a/tcl/target/\320\2721879x\320\2611\321\217.cfg" "b/tcl/target/\320\2721879x\320\2611\321\217.cfg"
old mode 100644
new mode 100755
diff --git a/tcl/test/syntax1.cfg b/tcl/test/syntax1.cfg
old mode 100644
new mode 100755
diff --git a/tcl/tools/firmware-recovery.tcl b/tcl/tools/firmware-recovery.tcl
old mode 100644
new mode 100755
diff --git a/tcl/tools/memtest.tcl b/tcl/tools/memtest.tcl
old mode 100644
new mode 100755
diff --git a/testing/build.test1/Makefile b/testing/build.test1/Makefile
old mode 100644
new mode 100755
diff --git a/testing/build.test1/Makefile.confuse b/testing/build.test1/Makefile.confuse
old mode 100644
new mode 100755
diff --git a/testing/build.test1/Makefile.ftd2xx b/testing/build.test1/Makefile.ftd2xx
old mode 100644
new mode 100755
diff --git a/testing/build.test1/Makefile.libftdi b/testing/build.test1/Makefile.libftdi
old mode 100644
new mode 100755
diff --git a/testing/build.test1/Makefile.libusb b/testing/build.test1/Makefile.libusb
old mode 100644
new mode 100755
diff --git a/testing/build.test1/Makefile.openocd b/testing/build.test1/Makefile.openocd
old mode 100644
new mode 100755
diff --git a/testing/build.test1/README.TXT b/testing/build.test1/README.TXT
old mode 100644
new mode 100755
diff --git a/testing/build.test1/local.uses b/testing/build.test1/local.uses
old mode 100644
new mode 100755
diff --git a/testing/build.test1/mingw32_help/include/elf.h b/testing/build.test1/mingw32_help/include/elf.h
old mode 100644
new mode 100755
diff --git a/testing/build.test1/mingw32_help/include/sys/cdefs.h b/testing/build.test1/mingw32_help/include/sys/cdefs.h
old mode 100644
new mode 100755
diff --git a/testing/build.test1/mingw32_help/include/sys/elf32.h b/testing/build.test1/mingw32_help/include/sys/elf32.h
old mode 100644
new mode 100755
diff --git a/testing/build.test1/mingw32_help/include/sys/elf64.h b/testing/build.test1/mingw32_help/include/sys/elf64.h
old mode 100644
new mode 100755
diff --git a/testing/build.test1/mingw32_help/include/sys/elf_common.h b/testing/build.test1/mingw32_help/include/sys/elf_common.h
old mode 100644
new mode 100755
diff --git a/testing/build.test1/mingw32_help/include/sys/elf_generic.h b/testing/build.test1/mingw32_help/include/sys/elf_generic.h
old mode 100644
new mode 100755
diff --git a/testing/build.test2/Makefile b/testing/build.test2/Makefile
old mode 100644
new mode 100755
diff --git a/testing/build.test2/README.txt b/testing/build.test2/README.txt
old mode 100644
new mode 100755
diff --git a/testing/build.test2/local.uses b/testing/build.test2/local.uses
old mode 100644
new mode 100755
diff --git a/testing/examples/AT91R40008Test/inc/typedefs.h b/testing/examples/AT91R40008Test/inc/typedefs.h
old mode 100644
new mode 100755
diff --git a/testing/examples/AT91R40008Test/makefile b/testing/examples/AT91R40008Test/makefile
old mode 100644
new mode 100755
diff --git a/testing/examples/AT91R40008Test/prj/at91r40008_reset.script b/testing/examples/AT91R40008Test/prj/at91r40008_reset.script
old mode 100644
new mode 100755
diff --git a/testing/examples/AT91R40008Test/prj/at91r40008_turtle.cfg b/testing/examples/AT91R40008Test/prj/at91r40008_turtle.cfg
old mode 100644
new mode 100755
diff --git a/testing/examples/AT91R40008Test/prj/eclipse_ram.gdb b/testing/examples/AT91R40008Test/prj/eclipse_ram.gdb
old mode 100644
new mode 100755
diff --git a/testing/examples/AT91R40008Test/prj/ethernut3_ram.ld b/testing/examples/AT91R40008Test/prj/ethernut3_ram.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/AT91R40008Test/src/crt.s b/testing/examples/AT91R40008Test/src/crt.s
old mode 100644
new mode 100755
diff --git a/testing/examples/AT91R40008Test/src/main.c b/testing/examples/AT91R40008Test/src/main.c
old mode 100644
new mode 100755
diff --git a/testing/examples/AT91R40008Test/test_ram.elf b/testing/examples/AT91R40008Test/test_ram.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/AT91R40008Test/test_ram.hex b/testing/examples/AT91R40008Test/test_ram.hex
old mode 100644
new mode 100755
diff --git a/testing/examples/AT91R40008Test/test_ram.map b/testing/examples/AT91R40008Test/test_ram.map
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/inc/typedefs.h b/testing/examples/LPC2148Test/inc/typedefs.h
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/makefile b/testing/examples/LPC2148Test/makefile
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/prj/eclipse_ram.gdb b/testing/examples/LPC2148Test/prj/eclipse_ram.gdb
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/prj/eclipse_rom.gdb b/testing/examples/LPC2148Test/prj/eclipse_rom.gdb
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/prj/lpc2148_jtagkey.cfg b/testing/examples/LPC2148Test/prj/lpc2148_jtagkey.cfg
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/prj/lpc2148_ram.ld b/testing/examples/LPC2148Test/prj/lpc2148_ram.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/prj/lpc2148_rom.ld b/testing/examples/LPC2148Test/prj/lpc2148_rom.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/src/crt.s b/testing/examples/LPC2148Test/src/crt.s
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/src/main.c b/testing/examples/LPC2148Test/src/main.c
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/test_ram.elf b/testing/examples/LPC2148Test/test_ram.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/test_ram.hex b/testing/examples/LPC2148Test/test_ram.hex
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/test_ram.map b/testing/examples/LPC2148Test/test_ram.map
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/test_rom.elf b/testing/examples/LPC2148Test/test_rom.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/test_rom.hex b/testing/examples/LPC2148Test/test_rom.hex
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2148Test/test_rom.map b/testing/examples/LPC2148Test/test_rom.map
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/inc/typedefs.h b/testing/examples/LPC2294Test/inc/typedefs.h
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/makefile b/testing/examples/LPC2294Test/makefile
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/prj/eclipse_ram.gdb b/testing/examples/LPC2294Test/prj/eclipse_ram.gdb
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/prj/eclipse_rom.gdb b/testing/examples/LPC2294Test/prj/eclipse_rom.gdb
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/prj/lpc2294_jtagkey.cfg b/testing/examples/LPC2294Test/prj/lpc2294_jtagkey.cfg
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/prj/lpc2294_ram.ld b/testing/examples/LPC2294Test/prj/lpc2294_ram.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/prj/lpc2294_rom.ld b/testing/examples/LPC2294Test/prj/lpc2294_rom.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/src/crt.s b/testing/examples/LPC2294Test/src/crt.s
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/src/main.c b/testing/examples/LPC2294Test/src/main.c
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/test_ram.elf b/testing/examples/LPC2294Test/test_ram.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/test_ram.hex b/testing/examples/LPC2294Test/test_ram.hex
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/test_ram.map b/testing/examples/LPC2294Test/test_ram.map
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/test_rom.elf b/testing/examples/LPC2294Test/test_rom.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/test_rom.hex b/testing/examples/LPC2294Test/test_rom.hex
old mode 100644
new mode 100755
diff --git a/testing/examples/LPC2294Test/test_rom.map b/testing/examples/LPC2294Test/test_rom.map
old mode 100644
new mode 100755
diff --git a/testing/examples/PIC32/BlinkingLeds.c b/testing/examples/PIC32/BlinkingLeds.c
old mode 100644
new mode 100755
diff --git a/testing/examples/PIC32/BlinkingLeds.elf b/testing/examples/PIC32/BlinkingLeds.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/PIC32/readme.txt b/testing/examples/PIC32/readme.txt
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/inc/typedefs.h b/testing/examples/SAM7S256Test/inc/typedefs.h
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/makefile b/testing/examples/SAM7S256Test/makefile
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/prj/eclipse_ram.gdb b/testing/examples/SAM7S256Test/prj/eclipse_ram.gdb
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/prj/eclipse_rom.gdb b/testing/examples/SAM7S256Test/prj/eclipse_rom.gdb
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/prj/sam7s256_jtagkey.cfg b/testing/examples/SAM7S256Test/prj/sam7s256_jtagkey.cfg
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/prj/sam7s256_ram.ld b/testing/examples/SAM7S256Test/prj/sam7s256_ram.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/prj/sam7s256_reset.script b/testing/examples/SAM7S256Test/prj/sam7s256_reset.script
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/prj/sam7s256_rom.ld b/testing/examples/SAM7S256Test/prj/sam7s256_rom.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/results/607.html b/testing/examples/SAM7S256Test/results/607.html
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/src/crt.s b/testing/examples/SAM7S256Test/src/crt.s
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/src/main.c b/testing/examples/SAM7S256Test/src/main.c
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/test_ram.elf b/testing/examples/SAM7S256Test/test_ram.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/test_ram.hex b/testing/examples/SAM7S256Test/test_ram.hex
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/test_ram.map b/testing/examples/SAM7S256Test/test_ram.map
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/test_rom.elf b/testing/examples/SAM7S256Test/test_rom.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/test_rom.hex b/testing/examples/SAM7S256Test/test_rom.hex
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7S256Test/test_rom.map b/testing/examples/SAM7S256Test/test_rom.map
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/inc/typedefs.h b/testing/examples/SAM7X256Test/inc/typedefs.h
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/makefile b/testing/examples/SAM7X256Test/makefile
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/prj/eclipse_ram.gdb b/testing/examples/SAM7X256Test/prj/eclipse_ram.gdb
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/prj/eclipse_rom.gdb b/testing/examples/SAM7X256Test/prj/eclipse_rom.gdb
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/prj/sam7x256_jtagkey.cfg b/testing/examples/SAM7X256Test/prj/sam7x256_jtagkey.cfg
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/prj/sam7x256_ram.ld b/testing/examples/SAM7X256Test/prj/sam7x256_ram.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/prj/sam7x256_reset.script b/testing/examples/SAM7X256Test/prj/sam7x256_reset.script
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/prj/sam7x256_rom.ld b/testing/examples/SAM7X256Test/prj/sam7x256_rom.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/src/crt.s b/testing/examples/SAM7X256Test/src/crt.s
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/src/main.c b/testing/examples/SAM7X256Test/src/main.c
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/test_ram.elf b/testing/examples/SAM7X256Test/test_ram.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/test_ram.hex b/testing/examples/SAM7X256Test/test_ram.hex
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/test_ram.map b/testing/examples/SAM7X256Test/test_ram.map
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/test_rom.elf b/testing/examples/SAM7X256Test/test_rom.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/test_rom.hex b/testing/examples/SAM7X256Test/test_rom.hex
old mode 100644
new mode 100755
diff --git a/testing/examples/SAM7X256Test/test_rom.map b/testing/examples/SAM7X256Test/test_rom.map
old mode 100644
new mode 100755
diff --git a/testing/examples/STM32-103/main.elf b/testing/examples/STM32-103/main.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/STM32-103/readme.txt b/testing/examples/STM32-103/readme.txt
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710JtagSpeed/inc/typedefs.h b/testing/examples/STR710JtagSpeed/inc/typedefs.h
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710JtagSpeed/makefile b/testing/examples/STR710JtagSpeed/makefile
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710JtagSpeed/prj/eclipse_ft2232_ram.gdb b/testing/examples/STR710JtagSpeed/prj/eclipse_ft2232_ram.gdb
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710JtagSpeed/prj/str710_jtagkey.cfg b/testing/examples/STR710JtagSpeed/prj/str710_jtagkey.cfg
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710JtagSpeed/prj/str7_ram.ld b/testing/examples/STR710JtagSpeed/prj/str7_ram.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710JtagSpeed/src/crt.s b/testing/examples/STR710JtagSpeed/src/crt.s
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710JtagSpeed/src/main.c b/testing/examples/STR710JtagSpeed/src/main.c
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710JtagSpeed/test.elf b/testing/examples/STR710JtagSpeed/test.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710JtagSpeed/test.hex b/testing/examples/STR710JtagSpeed/test.hex
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710JtagSpeed/test.map b/testing/examples/STR710JtagSpeed/test.map
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/.gitignore b/testing/examples/STR710Test/.gitignore
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/inc/typedefs.h b/testing/examples/STR710Test/inc/typedefs.h
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/makefile b/testing/examples/STR710Test/makefile
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/prj/eclipse_ram.gdb b/testing/examples/STR710Test/prj/eclipse_ram.gdb
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/prj/eclipse_rom.gdb b/testing/examples/STR710Test/prj/eclipse_rom.gdb
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/prj/hitex_str7_ram.ld b/testing/examples/STR710Test/prj/hitex_str7_ram.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/prj/hitex_str7_rom.ld b/testing/examples/STR710Test/prj/hitex_str7_rom.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/prj/str710_jtagkey.cfg b/testing/examples/STR710Test/prj/str710_jtagkey.cfg
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/prj/str710_program.script b/testing/examples/STR710Test/prj/str710_program.script
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/src/crt.s b/testing/examples/STR710Test/src/crt.s
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/src/main.c b/testing/examples/STR710Test/src/main.c
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/test_ram.elf b/testing/examples/STR710Test/test_ram.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/test_ram.hex b/testing/examples/STR710Test/test_ram.hex
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/test_ram.map b/testing/examples/STR710Test/test_ram.map
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/test_rom.elf b/testing/examples/STR710Test/test_rom.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/test_rom.hex b/testing/examples/STR710Test/test_rom.hex
old mode 100644
new mode 100755
diff --git a/testing/examples/STR710Test/test_rom.map b/testing/examples/STR710Test/test_rom.map
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/inc/typedefs.h b/testing/examples/STR912Test/inc/typedefs.h
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/makefile b/testing/examples/STR912Test/makefile
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/prj/eclipse_ram.gdb b/testing/examples/STR912Test/prj/eclipse_ram.gdb
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/prj/eclipse_rom.gdb b/testing/examples/STR912Test/prj/eclipse_rom.gdb
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/prj/str912_jtagkey.cfg b/testing/examples/STR912Test/prj/str912_jtagkey.cfg
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/prj/str912_program.script b/testing/examples/STR912Test/prj/str912_program.script
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/prj/str912_ram.ld b/testing/examples/STR912Test/prj/str912_ram.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/prj/str912_rom.ld b/testing/examples/STR912Test/prj/str912_rom.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/src/main.c b/testing/examples/STR912Test/src/main.c
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/src/startup.s b/testing/examples/STR912Test/src/startup.s
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/test_ram.elf b/testing/examples/STR912Test/test_ram.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/test_ram.hex b/testing/examples/STR912Test/test_ram.hex
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/test_ram.map b/testing/examples/STR912Test/test_ram.map
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/test_rom.elf b/testing/examples/STR912Test/test_rom.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/test_rom.hex b/testing/examples/STR912Test/test_rom.hex
old mode 100644
new mode 100755
diff --git a/testing/examples/STR912Test/test_rom.map b/testing/examples/STR912Test/test_rom.map
old mode 100644
new mode 100755
diff --git a/testing/examples/cortex/cm3-ftest.cfg b/testing/examples/cortex/cm3-ftest.cfg
old mode 100644
new mode 100755
diff --git a/testing/examples/cortex/fault.c b/testing/examples/cortex/fault.c
old mode 100644
new mode 100755
diff --git a/testing/examples/cortex/lm3s3748.elf b/testing/examples/cortex/lm3s3748.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/cortex/test.c b/testing/examples/cortex/test.c
old mode 100644
new mode 100755
diff --git a/testing/examples/cortex/test.ld b/testing/examples/cortex/test.ld
old mode 100644
new mode 100755
diff --git a/testing/examples/ledtest-imx27ads/Makefile b/testing/examples/ledtest-imx27ads/Makefile
old mode 100644
new mode 100755
diff --git a/testing/examples/ledtest-imx27ads/crt0.S b/testing/examples/ledtest-imx27ads/crt0.S
old mode 100644
new mode 100755
diff --git a/testing/examples/ledtest-imx27ads/gdbinit-imx27ads b/testing/examples/ledtest-imx27ads/gdbinit-imx27ads
old mode 100644
new mode 100755
diff --git a/testing/examples/ledtest-imx27ads/ldscript b/testing/examples/ledtest-imx27ads/ldscript
old mode 100644
new mode 100755
diff --git a/testing/examples/ledtest-imx27ads/test.c b/testing/examples/ledtest-imx27ads/test.c
old mode 100644
new mode 100755
diff --git a/testing/examples/ledtest-imx27ads/test.elf b/testing/examples/ledtest-imx27ads/test.elf
old mode 100644
new mode 100755
diff --git a/testing/examples/ledtest-imx31pdk/Makefile b/testing/examples/ledtest-imx31pdk/Makefile
old mode 100644
new mode 100755
diff --git a/testing/examples/ledtest-imx31pdk/crt0.S b/testing/examples/ledtest-imx31pdk/crt0.S
old mode 100644
new mode 100755
diff --git a/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk b/testing/examples/ledtest-imx31pdk/gdbinit-imx31pdk
old mode 100644
new mode 100755
diff --git a/testing/examples/ledtest-imx31pdk/ldscript b/testing/examples/ledtest-imx31pdk/ldscript
old mode 100644
new mode 100755
diff --git a/testing/examples/ledtest-imx31pdk/test.c b/testing/examples/ledtest-imx31pdk/test.c
old mode 100644
new mode 100755
diff --git a/testing/examples/ledtest-imx31pdk/test.elf b/testing/examples/ledtest-imx31pdk/test.elf
old mode 100644
new mode 100755
diff --git a/testing/index.html b/testing/index.html
old mode 100644
new mode 100755
diff --git a/testing/profile_stm32.txt b/testing/profile_stm32.txt
old mode 100644
new mode 100755
diff --git a/testing/results/template.html b/testing/results/template.html
old mode 100644
new mode 100755
diff --git a/testing/smoketests.html b/testing/smoketests.html
old mode 100644
new mode 100755
diff --git a/testing/tcl_server.tcl b/testing/tcl_server.tcl
old mode 100644
new mode 100755
diff --git a/testing/tcl_test.tcl b/testing/tcl_test.tcl
old mode 100644
new mode 100755
diff --git a/testing/testcases.html b/testing/testcases.html
old mode 100644
new mode 100755
diff --git a/tools/logger.pl b/tools/logger.pl
old mode 100644
new mode 100755
diff --git a/tools/release/helpers.sh b/tools/release/helpers.sh
old mode 100644
new mode 100755
diff --git a/uncrustify.cfg b/uncrustify.cfg
old mode 100644
new mode 100755
-- 
1.9.1


From 0ea894f64fa084fe222310fcad62226b6fc4086a Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 27/94] Fix for ST-link after changing DAP to pointer which
 broke STLink

---
 src/target/cortex_m.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/target/cortex_m.c b/src/target/cortex_m.c
index a4f2986..cc80a8a 100755
--- a/src/target/cortex_m.c
+++ b/src/target/cortex_m.c
@@ -1835,7 +1835,7 @@ int cortex_m_examine(struct target *target)
 			armv7m->arm.is_armv6m = true;
 		}
 
-		if (i == 4 || i == 3) {
+		if ((!armv7m->stlink) && (i == 4 || i == 3)) {
 			/* Cortex-M3/M4 has 4096 bytes autoincrement range */
 			armv7m->arm.dap->tar_autoincr_block = (1 << 12);
 		}
-- 
1.9.1


From 07e8f6c5d48a50e2ae3500db5f65855c9d6b5b4a Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 28/94] Added 64bit prefix commands

---
 contrib/99-openocd.rules |  18 ++
 src/helper/jim-nvp.c     | 105 +++++++
 src/helper/jim-nvp.h     |  21 ++
 src/openocd.c            |   1 +
 src/server/server.c      |   2 +-
 src/target/Makefile.am   |   1 +
 src/target/mematts.c     | 697 +++++++++++++++++++++++++++++++++++++++++++++++
 src/target/target.c      | 368 +++++++++++++------------
 src/target/target_addr.h |  64 ++++-
 9 files changed, 1092 insertions(+), 185 deletions(-)
 create mode 100644 src/target/mematts.c

diff --git a/contrib/99-openocd.rules b/contrib/99-openocd.rules
index acdfade..83a47a2 100755
--- a/contrib/99-openocd.rules
+++ b/contrib/99-openocd.rules
@@ -5,6 +5,24 @@ SUBSYSTEM!="usb|tty|hidraw", GOTO="openocd_rules_end"
 
 # Please keep this list sorted by VID:PID
 
+# Qualcomm ftdi
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="9530", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="9531", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="9532", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="9533", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="9534", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="9535", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="9536", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="9537", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="9538", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="9539", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="953a", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="953b", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="953c", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="953d", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="953e", MODE="664", GROUP="plugdev"
+ATTRS{idVendor}=="05c6", ATTRS{idProduct}=="953f", MODE="664", GROUP="plugdev"
+
 # opendous and estick
 ATTRS{idVendor}=="03eb", ATTRS{idProduct}=="204f", MODE="664", GROUP="plugdev"
 
diff --git a/src/helper/jim-nvp.c b/src/helper/jim-nvp.c
index 4602a8d..ecc0cf4 100755
--- a/src/helper/jim-nvp.c
+++ b/src/helper/jim-nvp.c
@@ -41,8 +41,14 @@
  * official policies, either expressed or implied, of the Jim Tcl Project.
  */
 
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include <string.h>
 #include <jim-nvp.h>
+#include <target/target.h>
+
 
 int Jim_GetNvp(Jim_Interp *interp,
 	Jim_Obj *objPtr, const Jim_Nvp *nvp_table, const Jim_Nvp **result)
@@ -172,6 +178,7 @@ int Jim_GetOpt_Setup(Jim_GetOptInfo *p, Jim_Interp *interp, int argc, Jim_Obj *c
 	p->interp = interp;
 	p->argc = argc;
 	p->argv = argv;
+	p->ngot = 0;
 
 	return JIM_OK;
 }
@@ -195,6 +202,7 @@ int Jim_GetOpt_Obj(Jim_GetOptInfo *goi, Jim_Obj **puthere)
 		/* success */
 		o = goi->argv[0];
 		goi->argc -= 1;
+		goi->ngot += 1;
 		goi->argv += 1;
 	}
 	if (puthere)
@@ -205,6 +213,20 @@ int Jim_GetOpt_Obj(Jim_GetOptInfo *goi, Jim_Obj **puthere)
 		return JIM_ERR;
 }
 
+int Jim_GetOpt_Unget(Jim_GetOptInfo *goi)
+{
+	if( goi->ngot ){
+		/* yea, we can backup! */
+		goi->ngot--;
+		goi->argc++;
+		goi->argv--;
+		return JIM_OK;
+	} else {
+		/* Hmm do not backup too far! */
+		return JIM_ERR;
+	}
+}
+
 int Jim_GetOpt_String(Jim_GetOptInfo *goi, char **puthere, int *len)
 {
 	int r;
@@ -255,6 +277,89 @@ int Jim_GetOpt_Wide(Jim_GetOptInfo *goi, jim_wide *puthere)
 	return r;
 }
 
+int Jim_GetOpt_Addr( Jim_GetOptInfo *goi, struct target_addr *addr )
+{
+	char *cp;
+	char *ep;
+	char *cp2;
+	int e;
+	const struct memattr_name *att;
+
+	/* always init */
+	TARGET_ADDR_INIT( addr, 0 );
+
+	e = Jim_GetOpt_String( goi, &cp, NULL );
+	if( e != JIM_OK ){
+		Jim_SetResultFormatted( goi->interp, "?address missing parameter");
+		return e;
+	}
+
+	/* support these:
+	 *    address
+	 *    prefix <whitespace> address
+	 *    prefix:address (lauterbach)
+	 * But not:
+	 *   C++   class::member
+	 */
+
+	/* test for the : */
+	cp2 = strchr( cp, ':' );
+
+	if( cp2 ){
+		if( cp2[1] == ':' ){
+			/* C++ class::member
+			 * should not be mistaken for a prefix
+			 */
+			cp2 = NULL;
+		}
+	}
+
+	if( cp2 ){
+		/* Lookup the prefix */
+		att = mem_att_find_name( cp, cp2 - cp );
+		if( att ){
+			/* we have a prefix! */
+			cp = cp2+1;
+		}
+	} else {
+		/* test: Is this a prefix? */
+		att = mem_att_find_name( cp, -1 );
+		if( att ){
+			/* Yes it is, then get the address component */
+			e = Jim_GetOpt_String( goi, &cp, NULL );
+			if( e != JIM_OK ){
+				Jim_SetResultFormatted( goi->interp, "?address missing parameter");
+				return e;
+			}
+		}
+	}
+
+	/* override the route & attributes */
+	if( att ){
+		*addr = att->tmplate;
+	}
+
+	/* parse the address */
+	/* FIXME:  Do we check for 32bit overflows?
+	 *  Answer: NO because, the SOC may have
+	 *  a 32bit (cortex-m3) + a 64bit DAP
+	 *
+	 * AND
+	 *  Current target might be CortexM3 (32bit)
+	 *  But the address specifier might be 'via-dap'
+	 *  and the DAP addresses are possibly 64bit!
+	 */
+	addr->addr = strtoll( cp, &ep, 0 );
+	/* FIXME: Support symbols at some point */
+	/* remember: Symbols can have prefixes "built-in" */
+	if( *ep || (ep == cp) ){
+		Jim_SetResultFormatted( goi->interp, "?address not a number");
+		return JIM_ERR;
+	}
+	return JIM_OK;
+}
+
+
 int Jim_GetOpt_Nvp(Jim_GetOptInfo *goi, const Jim_Nvp *nvp, Jim_Nvp **puthere)
 {
 	Jim_Nvp *_safe;
diff --git a/src/helper/jim-nvp.h b/src/helper/jim-nvp.h
index 05d79c4..3d00799 100755
--- a/src/helper/jim-nvp.h
+++ b/src/helper/jim-nvp.h
@@ -162,6 +162,7 @@ typedef struct jim_getopt {
 	int argc;
 	Jim_Obj *const *argv;
 	int isconfigure;		/* non-zero if configure */
+	int ngot;
 } Jim_GetOptInfo;
 
 /** GetOpt - how to.
@@ -239,6 +240,11 @@ void Jim_GetOpt_Debug(Jim_GetOptInfo *goi);
  */
 int Jim_GetOpt_Obj(Jim_GetOptInfo *goi, Jim_Obj **puthere);
 
+/** Unget something
+ * \param goi    - get opt info
+ */
+int Jim_GetOpt_Unget( Jim_GetOptInfo *goi );
+
 /** Remove argv[0] as string.
  *
  * \param goi     - get opt info
@@ -316,6 +322,21 @@ int Jim_GetOpt_Nvp(Jim_GetOptInfo *goi, const Jim_Nvp *lookup, Jim_Nvp **puthere
  */
 void Jim_GetOpt_NvpUnknown(Jim_GetOptInfo *goi, const Jim_Nvp *lookup, int hadprefix);
 
+/* forward */
+struct target_addr;
+/** Get An address option
+ * Supports several flavors of address specification
+ *
+ *   <number>
+ *   <attribtue>(whitespace)<number>
+ *   <attribute>:<number>
+ *
+ * FUTURE:
+ *   <symbol>
+ *   <attribtue>(whitespace)<symbol>
+ *   <attribute>:<symbol>
+ */
+int Jim_GetOpt_Addr( Jim_GetOptInfo *goi, struct target_addr *addr );
 
 /** Remove argv[0] as Enum
  *
diff --git a/src/openocd.c b/src/openocd.c
index de30e0c..6b5018d 100755
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -245,6 +245,7 @@ struct command_context *setup_command_handler(Jim_Interp *interp)
 		&transport_register_commands,
 		&interface_register_commands,
 		&target_register_commands,
+		&mematt_register_commands,
 		&flash_register_commands,
 		&nand_register_commands,
 		&pld_register_commands,
diff --git a/src/server/server.c b/src/server/server.c
index 7fbceb1..a6947df 100755
--- a/src/server/server.c
+++ b/src/server/server.c
@@ -239,7 +239,7 @@ int add_service(char *name,
 		c->sin.sin_port = htons(c->portnumber);
 
 		if (bind(c->fd, (struct sockaddr *)&c->sin, sizeof(c->sin)) == -1) {
-			LOG_ERROR("couldn't bind to socket: %s", strerror(errno));
+			LOG_ERROR("couldn't bind to socket (port: %d): %s", c->portnumber, strerror(errno));
 			exit(-1);
 		}
 
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 97db1f4..009ac97 100755
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -50,6 +50,7 @@ TARGET_CORE_SRC = \
 	breakpoints.c \
 	target.c \
 	target32.c \
+	mematts.c \
 	target_request.c \
 	testee.c \
 	smp.c
diff --git a/src/target/mematts.c b/src/target/mematts.c
new file mode 100644
index 0000000..a2f3465
--- /dev/null
+++ b/src/target/mematts.c
@@ -0,0 +1,697 @@
+/***************************************************************************
+ *   Copyright (C) 2016 by Eric Katzfey                                    *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "target.h"
+#include "jim-nvp.h"
+#include "log.h"
+#include "jim-subcmd.h"
+
+static struct memattr_name *mem_att_list;
+
+static int att_notfound( Jim_GetOptInfo *goi, const char *name )
+{
+	Jim_SetResultFormatted( goi->interp, "%s: not found", name );
+	return JIM_ERR;
+}
+
+/* this is here for code readablity - by reducing the number of cast occurances */
+static struct memattr_name *_mem_att_unconst(const struct memattr_name *p)
+{
+	return (struct memattr_name *)(p);
+}
+
+/* this is here for code readablity - by reducing the number of cast occurances */
+static struct memattr_name **_mem_att_unconst_pp(const struct memattr_name **  pp)
+{
+	return (struct memattr_name **)(pp);
+}
+
+static struct memattr_name *_mem_att_find_name_RAW( const char *name, int len )
+{
+	struct memattr_name *p;
+
+	if( len < 0 ){
+		len = strlen(name);
+	}
+	p = mem_att_list;
+	while(p){
+		if( 0 == strncmp( name, p->name, len ) ){
+			if( p->name[ len ] == 0 ){
+				break;
+			}
+		}
+		p = _mem_att_unconst(p->next);
+	}
+	return p;
+}
+
+const struct memattr_name *mem_att_find_name_RAW( const char *name, int len )
+{
+	return _mem_att_find_name_RAW( name,len );
+}
+
+
+static struct memattr_name *_mem_att_find_name( const char *name, int len )
+{
+	struct memattr_name *p;
+
+	p = _mem_att_find_name_RAW( name, len );
+	if( p ){
+		/* resolve all aliases */
+		while( p->alias_of != NULL ){
+			p = _mem_att_unconst(p->alias_of);
+		}
+	}
+	return p;
+}
+
+const struct memattr_name *mem_att_find_name( const char *name, int len )
+{
+	return _mem_att_find_name( name, len );
+}
+
+int mem_att_create( const char *name, const struct target_addr *addr )
+{
+	struct memattr_name *att;
+
+	/* remove const */
+	att = _mem_att_find_name( name, -1 );
+	if( att ){
+		/* duplicate! */
+		return ERROR_FAIL;
+	}
+	att = calloc( sizeof(*att) , 1 );
+	if( !att ){
+		return ERROR_FAIL;
+	}
+	TARGET_ADDR_INIT( &(att->tmplate),0 );
+	att->tmplate = *addr;
+	att->name = strdup( name );
+	if( att->name == NULL ){
+		free(att);
+		return ERROR_FAIL;
+	}
+
+
+	att->next = mem_att_list;
+	mem_att_list = att;
+	return ERROR_OK;
+}
+
+int mem_att_create_alias( const char *from_name, const char *to_name )
+{
+	struct memattr_name *att_new;
+	struct memattr_name *att_old;
+
+	att_new = _mem_att_find_name(from_name,-1);
+	att_old = _mem_att_find_name_RAW(to_name,-1);
+	if( (att_new != NULL) || (att_old == NULL) ){
+		return ERROR_FAIL;
+	}
+
+	att_new = calloc( sizeof(*att_new), 1 );
+	if( att_new == NULL ){
+		return ERROR_FAIL;
+	}
+	att_new->name = strdup( from_name );
+	if( att_new->name == NULL ){
+		free( att_new );
+		return ERROR_FAIL;
+	}
+
+	att_new->alias_of = att_old;
+	att_new->next = mem_att_list;
+	mem_att_list = att_new;
+	return ERROR_OK;
+}
+
+
+
+/* Delete any attribute and delete any aliases of the attribute */
+void mem_att_delete( const struct memattr_name *_att )
+{
+	struct memattr_name **pp;
+	struct memattr_name *att;
+
+	att = _mem_att_unconst(_att);
+	/*
+	 * Consider:   (A) -> (B) -> (C)
+	 * And         (D) -> (E) -> (C)
+	 *
+	 * Delete (C) - all are deleted.
+	 * Delete (B), only (A) and (B) are deleted.
+	 * Delete (A), only (A) is deleted.
+	 *
+	 * Hence, we have this "again" label.
+	 * And we use recursion to help.
+	 */
+
+
+ again:
+	pp = &(mem_att_list);
+	/* FIRST: delete any aliases of this item */
+	/* this makes sure we have no dangling alias pointers! */
+	while( *pp ){
+		if( (*pp)->alias_of == att ){
+			/* delete the alias name first */
+			mem_att_delete( *pp );
+			/* then search again */
+			goto again;
+		}
+		pp = _mem_att_unconst_pp( (&( (*pp)->next )) );
+	}
+
+	/* now search the list of normal names */
+	pp = &(mem_att_list);
+	/* find it */
+	while( *pp ){
+		if( *pp == att ){
+			break;
+		}
+		pp = _mem_att_unconst_pp( (&( (*pp)->next )) );
+	}
+	/* if found, delete it */
+	if( *pp ){
+		*pp = _mem_att_unconst( att->next );
+		free( (void *)(att->name) );
+		att->name = NULL;
+		memset( att, 0, sizeof(*att) );
+		free((void *)att);
+	}
+}
+
+
+const struct memattr_name *mem_att_find_route( enum ta_route route )
+{
+	const struct memattr_name *p;
+
+	p = mem_att_list;
+
+	while(p){
+		if( p->alias_of == NULL ){
+			if( p->tmplate.route == route ){
+				break;
+			}
+		}
+		p = p->next;
+	}
+	return p;
+}
+
+const struct memattr_name *mem_att_find_addr( const struct target_addr *pAddr )
+{
+	const struct memattr_name *p;
+
+	p = mem_att_list;
+	while(p){
+		if( p->alias_of == NULL ){
+			if( p->tmplate.route == pAddr->route ){
+				if( p->tmplate.route_attributes == pAddr->route_attributes ){
+					break;
+				}
+			}
+		}
+	}
+	return p;
+}
+
+
+static int jim_mematt_deleteall(Jim_Interp *_interp, int argc, Jim_Obj *const *argv )
+{
+	Jim_SetEmptyResult( _interp );
+	/* just loop till they are all deleted */
+	while( mem_att_list ){
+		mem_att_delete( mem_att_list );
+	}
+	return JIM_OK;
+}
+
+
+static int jim_mematt_list( Jim_Interp *interp, int argc, Jim_Obj *const *argv )
+{
+	const struct memattr_name *p;
+	/* create a list of names */
+	Jim_SetResult( interp, Jim_NewListObj( interp, NULL, 0 ));
+	p = mem_att_list;
+	/* loop through adding them to the list */
+	while( p ){
+		Jim_ListAppendElement( interp, Jim_GetResult(interp),
+				       Jim_NewStringObj( interp, p->name, -1 ) );
+		p = p->next;
+	}
+	return JIM_OK;
+}
+
+static int jim_mematt_delete(Jim_Interp *_interp, int argc, Jim_Obj *const *argv )
+{
+	int e;
+	int force;
+	const struct memattr_name *delete_me;
+	Jim_GetOptInfo goi;
+	char *name;
+
+	Jim_GetOpt_Setup(&goi, _interp, argc, argv);
+
+	e = Jim_GetOpt_String( &goi, &name, NULL );
+	if( e != JIM_OK ){
+		return e;
+	}
+	if( 0 == strcmp( "-f", name ) ){
+		force = 1;
+		e = Jim_GetOpt_String( &goi, &name, NULL );
+		if( e != JIM_OK ){
+			return e;
+		}
+	} else {
+		force = 0;
+	}
+
+	/* get the unaliased name */
+	delete_me = mem_att_find_name_RAW( name,-1 );
+	e = JIM_OK;
+	if( delete_me ){
+		mem_att_delete( delete_me );
+	} else {
+		if( !force ){
+			att_notfound( &goi, name );
+			e = JIM_ERR;
+		}
+	}
+	return e;
+}
+
+static const Jim_Nvp nvp_routenames[] = {
+	{ "default", .value = TA_ROUTE_DEFAULT },
+	{ "phys"   , .value = TA_ROUTE_PHYSICAL },
+	/* secondary name */
+	{ "physical", .value = TA_ROUTE_PHYSICAL },
+	{ "virt"    , .value = TA_ROUTE_VIRTUAL  },
+	/* secondary name */
+	{ "virtual" , .value = TA_ROUTE_VIRTUAL  },
+	{ "arm.tz"  , .value = TA_ROUTE_arm_tz },
+	{ "arm.hyp"  , .value = TA_ROUTE_arm_hyp },
+	{ "arm.el0"  , .value = TA_ROUTE_arm_el0 },
+	{ "arm.el1"  , .value = TA_ROUTE_arm_el1 },
+	{ "arm.el2"  , .value = TA_ROUTE_arm_el2 },
+	{ "arm.el3"  , .value = TA_ROUTE_arm_el3 },
+
+	{ "arm.dap0"  , .value = TA_ROUTE_arm_dap0 },
+	{ "arm.dap1"  , .value = TA_ROUTE_arm_dap1 },
+	{ "arm.dap2"  , .value = TA_ROUTE_arm_dap2 },
+	{ "arm.dap3"  , .value = TA_ROUTE_arm_dap3 },
+	{ "arm.dap4"  , .value = TA_ROUTE_arm_dap4 },
+	{ "arm.dap5"  , .value = TA_ROUTE_arm_dap5 },
+	{ "arm.dap6"  , .value = TA_ROUTE_arm_dap6 },
+	{ "arm.dap7"  , .value = TA_ROUTE_arm_dap7 },
+	/* terminate */
+	{ .name = NULL, .value = -1 }
+};
+
+const char *target_addr_routename( const struct target_addr *pAddr )
+{
+	const Jim_Nvp *p;
+
+	p = Jim_Nvp_value2name_simple( nvp_routenames, pAddr->route );
+	if( p == NULL ){
+		return "unknown";
+	} else {
+		return p->name;
+	}
+}
+
+
+
+static int jim_mematt_create( Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+{
+	int e;
+	Jim_GetOptInfo goi;
+	char *name;
+	jim_wide attribute;
+	struct target_addr tmp;
+	Jim_Nvp *route_nvp;
+
+	Jim_GetOpt_Setup(&goi, interp, argc, argv);
+	/*
+	 * argv[0] = name
+	 * argv[1] = routename
+	 * argv[2] = attributevalue
+	 */
+	e = Jim_GetOpt_String( &goi, &name, NULL );
+	if( e != JIM_OK ){
+		Jim_SetResultFormatted(goi.interp, "?name missing");
+		return e;
+	}
+
+	const struct memattr_name *att;
+	att = mem_att_find_name( name, -1 );
+
+	if( att != NULL ){
+		Jim_SetResultFormatted(goi.interp,"%s: already exists", name);
+		return JIM_ERR;
+	}
+
+	e = Jim_GetOpt_Nvp( &goi, nvp_routenames, &route_nvp );
+	if( e != JIM_OK ){
+		Jim_GetOpt_NvpUnknown( &goi, nvp_routenames, 0 );
+		return e;
+	}
+	e = Jim_GetOpt_Wide( &goi, &attribute );
+	if( e != JIM_OK ){
+		return e;
+	}
+
+	TARGET_ADDR_INIT( &tmp, 0 );
+	tmp.addr  = 0;
+	tmp.route = (enum ta_route)(route_nvp->value);
+	tmp.route_attributes = attribute;
+
+	e = mem_att_create( name, &tmp );
+	if( e != ERROR_OK ){
+		Jim_SetResultFormatted(goi.interp,"%s: cannot create", name );
+		e = JIM_ERR;
+	} else {
+		Jim_SetEmptyResult(goi.interp);
+		e = JIM_OK;
+	}
+	return e;
+}
+
+static int jim_mematt_alias(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+{
+	int e;
+	char *cp_to;
+	char *cp_from;
+	Jim_GetOptInfo goi;
+	Jim_GetOpt_Setup(&goi, interp, argc, argv);
+
+	e = Jim_GetOpt_String( &goi, &cp_from, NULL );
+	if( e != JIM_OK ){
+		return e;
+	}
+
+	e = Jim_GetOpt_String( &goi, &cp_to, NULL );
+	if( e != JIM_OK ){
+		return e;
+	}
+	const struct memattr_name *att;
+	att = mem_att_find_name( cp_to, -1 );
+	if( att == NULL ){
+		return att_notfound( &goi, cp_to );
+	}
+
+	e = mem_att_create_alias( cp_from, cp_to );
+	if( e != ERROR_OK ){
+		Jim_SetResultFormatted( interp, "%s -> %s: Cannot create", cp_from, cp_to );
+		e = JIM_ERR;
+	} else {
+		Jim_SetEmptyResult(goi.interp);
+		e = JIM_OK;
+	}
+	return e;
+}
+
+static const Jim_Nvp mematt_cget_names[] = {
+	{ .name = "name",      .value = 0 },
+	{ .name = "route",     .value = 1 },
+	{ .name = "attribute", .value = 2 },
+	{ .name = "isalias",   .value = 3 },
+	{ .name = "aliasof",   .value = 4 },
+	/* note: the 'addr->address' is meaningless in this context */
+	/* hence we do not offer it as a configuration option */
+	{ .name = NULL, .value = -1 }
+};
+
+static int jim_mematt_name_cget( Jim_Interp *_interp, int argc, Jim_Obj *const *argv)
+{
+	int e;
+	Jim_Nvp *cget;
+	Jim_GetOptInfo goi;
+	char *name;
+	const struct memattr_name *resolved;
+	const struct memattr_name *raw_att;
+
+	Jim_GetOpt_Setup(&goi, _interp, argc, argv);
+
+	e = Jim_GetOpt_Nvp( &goi, mematt_cget_names, &cget );
+	if( e != JIM_OK ){
+		Jim_GetOpt_NvpUnknown( &goi, mematt_cget_names, 0 );
+		return e;
+	}
+
+	e = Jim_GetOpt_String( &goi, &name, NULL );
+	if( e != JIM_OK ){
+		return e;
+	}
+
+	raw_att = mem_att_find_name_RAW( name, -1 );
+	if( raw_att == NULL ){
+		return att_notfound( &goi, name );
+	}
+
+	resolved = raw_att;
+
+	while( resolved->alias_of ){
+		resolved = resolved->alias_of;
+	}
+
+
+	switch( cget->value ){
+	case 0:
+		Jim_SetResultString( goi.interp, raw_att->name,-1 );
+		break;
+	case 1:
+		Jim_SetResultString( goi.interp, target_addr_routename( &(resolved->tmplate) ),-1);
+		break;
+	case 2:
+		Jim_SetResultInt( goi.interp, resolved->tmplate.route_attributes );
+		break;
+	case 3:
+		Jim_SetResultBool( goi.interp, (raw_att == resolved) ? 0 : 1 );
+		break;
+	case 4:
+		/* resolve one done */
+		if( raw_att->alias_of ){
+			raw_att = raw_att->alias_of;
+		}
+		Jim_SetResultString( goi.interp, raw_att->name,-1 );
+		break;
+	}
+	return JIM_OK;
+}
+
+static int jim_mematt_show( Jim_Interp *interp, int argc, Jim_Obj *const *argv )
+{
+	const struct memattr_name *a;
+	Jim_Obj *result;
+	char buf[100];
+
+	Jim_SetResultString( interp,      "Name      | Route     | Attribute\n", -1 );
+ 	result = Jim_GetResult(interp);
+	Jim_AppendString( interp, result, "==========+===========+=============\n",-1);
+
+	a = mem_att_list;
+	while( a ){
+		if( a->alias_of == NULL ){
+			snprintf( buf, sizeof(buf), "%-10s| %-10s| 0x%08x\n",
+					  a->name,
+					  target_addr_routename( &(a->tmplate) ),
+					  a->tmplate.route_attributes );
+		} else {
+			snprintf( buf, sizeof(buf), "%-10s| %-10s| %s\n",
+					  a->name,
+					  "alias_of:",
+					  a->alias_of->name );
+		}
+		Jim_AppendString( interp, result, buf, -1 );
+		a = a->next;
+	}
+	return JIM_OK;
+}
+
+
+static const jim_subcmd_type memattribute_cmds[] = {
+	{
+		.cmd = "show", /* human readable */
+		.args = "<no parameters>",
+		.function = jim_mematt_show,
+		.minargs = 0, .maxargs=0
+	},
+	{
+		.cmd = "list", /* in tcl list format */
+		.args = "<no parameters>",
+		.function = jim_mematt_list,
+		.minargs =0, .maxargs=0
+	},
+	{
+		.cmd = "deleteall",
+		.args = "<no parameters>",
+		.function = jim_mematt_deleteall,
+		.minargs =0, .maxargs=0
+	},
+	{
+		.cmd = "cget",
+		.args = "?what ?name",
+		.function = jim_mematt_name_cget,
+		.minargs =2, .maxargs=2
+	},
+	{
+		.cmd = "delete",
+		.args = "?name",
+		.function = jim_mematt_delete,
+		.minargs =1, .maxargs=1
+	},
+	{
+		.cmd = "create",
+		.args = "?name ?route ?attributevalue",
+		.function = jim_mematt_create,
+		.minargs =3, .maxargs=3
+	},
+	{
+		.cmd = "alias",
+		.args = "?aliasname ?existingname",
+		.function = jim_mematt_alias,
+		.minargs =2, .maxargs=2
+	},
+	/* end */
+	{
+		.cmd = NULL
+	}
+};
+
+
+
+static int jim_mematt( Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+{
+	if( argc < 1 ){
+		Jim_WrongNumArgs( interp, 1, argv, "list|name|delete|create|alias");
+		return JIM_ERR;
+	}
+
+	const jim_subcmd_type *ct = Jim_ParseSubCmd( interp, memattribute_cmds, argc, argv );
+
+	return Jim_CallSubCmd( interp, ct, argc, argv );
+}
+
+static const struct command_registration mematt_command_handlers[] = {
+	{ .name = "mematt",
+	  .jim_handler = jim_mematt,
+	  .help = "manage memory attribute defintions",
+	  .usage = "?subcmd ?parameters .."
+	},
+	COMMAND_REGISTRATION_DONE
+};
+
+int mematt_register_commands(struct command_context *cmd_ctx)
+{
+	/* FIRST: we need to add our default modes */
+	struct target_addr addr;
+
+	TARGET_ADDR_INIT( &addr, 0 );
+	mem_att_create( "default", &addr );
+	TARGET_ADDR_PHYS( &addr, 0 );
+	mem_att_create( "phys", &addr );
+	TARGET_ADDR_VIRT( &addr, 0 );
+	mem_att_create( "virt", &addr );
+
+
+	return register_commands(cmd_ctx, NULL, mematt_command_handlers);
+}
+
+
+
+int parse_memory_address( struct command_invocation *cmd, unsigned *argn, struct target_addr *addr )
+{
+	const struct memattr_name *atts;
+	const char *cp;
+	const char *cp2;
+	int r;
+
+	/* NOTE: ALSO SEE:  Jim_GetOpt_Addr() */
+	/* always initialize */
+	TARGET_ADDR_INIT( addr, 0 );
+
+	if( *argn >= CMD_ARGC ){
+		command_print( cmd->ctx, "Missing address parameter\n");
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	/* support these:
+	 *    address
+	 *    prefix <whitespace> address
+	 *    prefix:address (lauterbach)
+	 * But not:
+	 *   C++   class::member
+	 */
+
+	/* Assume *NONE* */
+	atts = NULL;
+	/* look for ':' */
+	cp = CMD_ARGV[ *argn ];
+	*argn += 1;
+	cp2 = strchr( cp, ':' );
+	if( cp2 ){
+		if( cp2[1] == ':' ){
+			/* NOPE: this is a C++ symbol  */
+			cp2 = NULL;
+		}
+	}
+
+	/* Is there a prefix? */
+	if( cp2 ){
+		/* Yes: In this form NAME:SOMETHING */
+		atts = mem_att_find_name( cp, cp2 - cp );
+		/* go past the ":" */
+		cp = cp2+1;
+	} else {
+		/* We have NAME <whitespace> SOMETHING */
+		/* not lauterbach style, test what we have */
+		atts = mem_att_find_name( cp, -1 );
+		if( atts ){
+			/* CONFIRMED:  name whitespace address */
+			if( *argn >= CMD_ARGC ){
+				command_print( cmd->ctx, "Missing address parameter\n");
+				return ERROR_COMMAND_SYNTAX_ERROR;
+			}
+			cp = CMD_ARGV[ *argn ];
+			*argn += 1;
+		}
+	}
+
+	if( atts == NULL ){
+		/* assume default */
+		TARGET_ADDR_INIT( addr, 0 );
+	} else {
+		/* initialize via the specified attributes */
+		*addr = atts->tmplate;
+		addr->addr = 0;
+	}
+
+	/* Parse the number .. */
+	/* Try the foobar NUMBER */
+	r = parse_u64( cp, &(addr->addr) );
+	if( r != ERROR_OK ){
+		/* FUTURE: FIXME: This could be a *SYMBOL */
+		/* and that symbol could have an attribute */
+	}
+	return r;
+}
diff --git a/src/target/target.c b/src/target/target.c
index 697d8a4..ffa8633 100755
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -60,10 +60,8 @@
 /* default halt wait timeout (ms) */
 #define DEFAULT_HALT_TIMEOUT 5000
 
-static int target_array2mem(Jim_Interp *interp, struct target *target,
-		int argc, Jim_Obj * const *argv);
-static int target_mem2array(Jim_Interp *interp, struct target *target,
-		int argc, Jim_Obj * const *argv);
+static int target_array2mem(struct target *target, Jim_GetOptInfo *goi );
+static int target_mem2array(struct target *target, Jim_GetOptInfo *goi );
 static int target_register_user_commands(struct command_context *cmd_ctx);
 static int target_get_gdb_fileio_info_default(struct target *target,
 		struct gdb_fileio_info *fileio_info);
@@ -2868,6 +2866,8 @@ static void handle_md_output(struct command_context *cmd_ctx,
 
 COMMAND_HANDLER(handle_md_command)
 {
+	int r;
+	unsigned argn;
 	struct target_addr addr;
 	TARGET_ADDR_PHYS( &addr, 0 );
 
@@ -2890,27 +2890,29 @@ COMMAND_HANDLER(handle_md_command)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	bool physical = strcmp(CMD_ARGV[0], "phys") == 0;
+	argn = 0;
+	r = parse_memory_address(cmd, &argn, &addr );
+	if( r != ERROR_OK ){
+		return r;
+	}
+
 	int (*fn)(struct target *target,
 			const struct target_addr *pAddr, uint64_t size_value, uint64_t count, uint8_t *buffer);
-	if (physical) {
-		CMD_ARGC--;
-		CMD_ARGV++;
+
+	if( addr.route == TA_ROUTE_PHYSICAL ){
 		fn = target64_read_phys_memory;
-		TARGET_ADDR_PHYS( &addr, 0 );
 	} else {
 		fn = target64_read_memory;
-		TARGET_ADDR_INIT( &addr, 0 );
 	}
 
-	if ((CMD_ARGC < 1) || (CMD_ARGC > 2))
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
-	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], addr.addr);
-
 	unsigned count = 1;
-	if (CMD_ARGC == 2)
-		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[1], count);
+	if (argn < CMD_ARGC){
+		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[argn], count);
+		argn++;
+	}
+	if( argn != CMD_ARGC ){
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
 
 	uint8_t *buffer = calloc(count, size);
 
@@ -2988,33 +2990,39 @@ static int target_fill_mem(struct target *target,
 
 COMMAND_HANDLER(handle_mw_command)
 {
+	int r;
+	unsigned argn;
 	struct target_addr addr;
-
-	if (CMD_ARGC < 2)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	bool physical = strcmp(CMD_ARGV[0], "phys") == 0;
 	target_write_fn fn;
-	if (physical) {
-		CMD_ARGC--;
-		CMD_ARGV++;
+
+	argn = 0;
+	r = parse_memory_address(cmd, &argn, &addr );
+	if( r != ERROR_OK ){
+		return r;
+	}
+
+	if( addr.route == TA_ROUTE_PHYSICAL ){
 		fn = target64_write_phys_memory;
-		TARGET_ADDR_PHYS( &addr, 0 );
 	} else {
 		fn = target64_write_memory;
-		TARGET_ADDR_INIT( &addr, 0 );
 	}
 
-	if ((CMD_ARGC < 2) || (CMD_ARGC > 3))
+	uint64_t value;
+	if( argn >= CMD_ARGC ){
 		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
 
-	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[0], addr.addr);
-
-	uint64_t value;
-	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], value);
+	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[argn], value);
+	argn++;
 
 	unsigned count = 1;
-	if (CMD_ARGC == 3)
-		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[2], count);
+	if (argn < CMD_ARGC){
+		COMMAND_PARSE_NUMBER(uint, CMD_ARGV[argn], count);
+		argn++;
+	}
+	if( argn != CMD_ARGC ){
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
 
 	struct target *target = get_current_target(CMD_CTX);
 	unsigned wordsize;
@@ -3158,6 +3166,8 @@ COMMAND_HANDLER(handle_load_image_command)
 
 COMMAND_HANDLER(handle_dump_image_command)
 {
+	unsigned argn;
+	const char *filename;
 	struct fileio fileio;
 	uint8_t *buffer;
 	int retval, retvaltemp;
@@ -3165,20 +3175,31 @@ COMMAND_HANDLER(handle_dump_image_command)
 	uint64_t size;
 	struct duration bench;
 	struct target *target = get_current_target(CMD_CTX);
+	int r;
+
+	/* ARGV[0] = Filename */
+	argn = 0;
+	filename = CMD_ARGV[argn];
+	argn++;
+	r = parse_memory_address(cmd, &argn, &addr );
+	if( r != ERROR_OK ){
+		return r;
+	}
+
+	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[argn], size);
+	argn++;
 
-	if (CMD_ARGC != 3)
+	/* we should have no more params remaining */
+	if (argn != CMD_ARGC)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	TARGET_ADDR_INIT( &addr, 0 );
-	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], addr.addr);
-	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[2], size);
 
 	uint32_t buf_size = (size > 4096) ? 4096 : size;
 	buffer = malloc(buf_size);
 	if (!buffer)
 		return ERROR_FAIL;
 
-	retval = fileio_open(&fileio, CMD_ARGV[0], FILEIO_WRITE, FILEIO_BINARY);
+	retval = fileio_open(&fileio, filename, FILEIO_WRITE, FILEIO_BINARY);
 	if (retval != ERROR_OK) {
 		free(buffer);
 		return retval;
@@ -3189,6 +3210,7 @@ COMMAND_HANDLER(handle_dump_image_command)
 	while (size > 0) {
 		size_t size_written;
 		uint32_t this_run_size = (size > buf_size) ? buf_size : size;
+		/* underlying code needs to understand possible: route=phys */
 		retval = target64_read_buffer(target, &addr, this_run_size, buffer);
 		if (retval != ERROR_OK)
 			break;
@@ -3246,6 +3268,7 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 	struct duration bench;
 	duration_start(&bench);
 
+	/* FIXME: Support attribute:address? */
 	if (CMD_ARGC >= 2) {
 		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], image.base_address);
 		image.base_address_set = 1;
@@ -3839,12 +3862,16 @@ static int new_int_array_element(Jim_Interp *interp, const char *varname, int id
 	return result;
 }
 
-static int jim_mem2array(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+static int jim_mem2array(Jim_Interp *_interp, int argc, Jim_Obj *const *argv)
 {
+	Jim_GetOptInfo goi;
 	struct command_context *context;
 	struct target *target;
 
-	context = current_command_context(interp);
+	/* burn the command name */
+	Jim_GetOpt_Setup( &goi, _interp, argc-1, argv+1 );
+
+	context = current_command_context(goi.interp);
 	assert(context != NULL);
 
 	target = get_current_target(context);
@@ -3853,48 +3880,54 @@ static int jim_mem2array(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		return JIM_ERR;
 	}
 
-	return target_mem2array(interp, target, argc - 1, argv + 1);
+	return target_mem2array(target, &goi );
 }
 
-static int target_mem2array(Jim_Interp *interp, struct target *target, int argc, Jim_Obj *const *argv)
+static int target_mem2array(  struct target *target, Jim_GetOptInfo *goi)
 {
-	long l;
+	jim_wide tmp_w;
 	uint32_t width;
 	int len;
 	struct target_addr addr;
 	uint32_t count;
 	uint64_t v;
-	const char *varname;
+	char *varname;
 	int  n, e, retval;
 	uint32_t i;
 
 	/* argv[1] = name of array to receive the data
 	 * argv[2] = desired width
-	 * argv[3] = memory address
-	 * argv[4] = count of times to read
+	 * argv[3/4] = memory address  (With possible attribute)
+	 * argv[4/5] = count of times to read
 	 */
-	if (argc != 4) {
-		Jim_WrongNumArgs(interp, 1, argv, "varname width addr nelems");
+	if( (goi->argc == 4) || (goi->argc==5) ){
+		/* all is well */
+	} else {
+		Jim_WrongNumArgs(goi->interp, 0, goi->argv, "varname width addr nelems");
 		return JIM_ERR;
 	}
-	varname = Jim_GetString(argv[0], &len);
-	/* given "foo" get space for worse case "foo(%d)" .. add 20 */
 
-	e = Jim_GetLong(interp, argv[1], &l);
-	width = l;
-	if (e != JIM_OK)
+
+	e = Jim_GetOpt_String( goi, &varname, NULL );
+	if( e != JIM_OK ){
 		return e;
+	}
 
-	jim_wide tmp_w;
-	e = Jim_GetWide(interp, argv[2], &tmp_w);
-	TARGET_ADDR_INIT( &addr, tmp_w );
+	e = Jim_GetOpt_Wide( goi, &tmp_w );
+	if( e != JIM_OK ){
+		return e;
+	}
+	width = tmp_w;
 
-	if (e != JIM_OK)
+	e = Jim_GetOpt_Addr( goi, &addr );
+	if( e != JIM_OK ){
 		return e;
-	e = Jim_GetLong(interp, argv[3], &l);
-	len = l;
+	}
+
+	e = Jim_GetOpt_Wide( goi, &tmp_w );
 	if (e != JIM_OK)
 		return e;
+	len = tmp_w;
 	switch (width) {
 		case 8:
 			width = 1;
@@ -3909,24 +3942,24 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 			width = 8;
 			break;
 		default:
-			Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-			Jim_AppendStrings(interp, Jim_GetResult(interp), "Invalid width param, must be 8/16/32/64", NULL);
+			Jim_SetResult(goi->interp, Jim_NewEmptyStringObj(goi->interp));
+			Jim_AppendStrings(goi->interp, Jim_GetResult(goi->interp), "Invalid width param, must be 8/16/32/64", NULL);
 			return JIM_ERR;
 	}
 	if (len == 0) {
-		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-		Jim_AppendStrings(interp, Jim_GetResult(interp), "mem2array: zero width read?", NULL);
+		Jim_SetResult(goi->interp, Jim_NewEmptyStringObj(goi->interp));
+		Jim_AppendStrings(goi->interp, Jim_GetResult(goi->interp), "mem2array: zero width read?", NULL);
 		return JIM_ERR;
 	}
 	if ((addr.addr + (len * width)) < addr.addr) {
-		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-		Jim_AppendStrings(interp, Jim_GetResult(interp), "mem2array: addr + len - wraps to zero?", NULL);
+		Jim_SetResult(goi->interp, Jim_NewEmptyStringObj(goi->interp));
+		Jim_AppendStrings(goi->interp, Jim_GetResult(goi->interp), "mem2array: addr + len - wraps to zero?", NULL);
 		return JIM_ERR;
 	}
 	/* absurd transfer size? */
 	if (len > 65536) {
-		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-		Jim_AppendStrings(interp, Jim_GetResult(interp), "mem2array: absurd > 64K item request", NULL);
+		Jim_SetResult(goi->interp, Jim_NewEmptyStringObj(goi->interp));
+		Jim_AppendStrings(goi->interp, Jim_GetResult(goi->interp), "mem2array: absurd > 64K item request", NULL);
 		return JIM_ERR;
 	}
 
@@ -3937,11 +3970,11 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 		/* all is well */
 	} else {
 		char buf[100];
-		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
+		Jim_SetResult(goi->interp, Jim_NewEmptyStringObj(goi->interp));
 		sprintf(buf, "mem2array address: 0x%s is not aligned for %" PRId32 " byte reads",
 				target_addr2str1( target, &addr ),
 				width);
-		Jim_AppendStrings(interp, Jim_GetResult(interp), buf , NULL);
+		Jim_AppendStrings(goi->interp, Jim_GetResult(goi->interp), buf , NULL);
 		return JIM_ERR;
 	}
 
@@ -3971,8 +4004,8 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 					  target_addr2str1( target, &addr ),
 					  (int)width,
 					  (int)count);
-			Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-			Jim_AppendStrings(interp, Jim_GetResult(interp), "mem2array: cannot read memory", NULL);
+			Jim_SetResult(goi->interp, Jim_NewEmptyStringObj(goi->interp));
+			Jim_AppendStrings(goi->interp, Jim_GetResult(goi->interp), "mem2array: cannot read memory", NULL);
 			e = JIM_ERR;
 			break;
 		} else {
@@ -3992,7 +4025,7 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 						v = buffer[i] & 0x0ff;
 						break;
 				}
-				new_int_array_element(interp, varname, n, v);
+				new_int_array_element(goi->interp, varname, n, v);
 			}
 			len -= count;
 			addr.addr += count * width;
@@ -4001,7 +4034,7 @@ static int target_mem2array(Jim_Interp *interp, struct target *target, int argc,
 
 	free(buffer);
 
-	Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
+	Jim_SetResult(goi->interp, Jim_NewEmptyStringObj(goi->interp));
 
 	return e;
 }
@@ -4039,9 +4072,12 @@ static int get_u64_array_element(Jim_Interp *interp, const char *varname, int id
 
 static int jim_array2mem(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
+	Jim_GetOptInfo goi;
 	struct command_context *context;
 	struct target *target;
 
+	/* burn the first parameter, the command name */
+	Jim_GetOpt_Setup( &goi, interp, argc-1, argv+1 );
 	context = current_command_context(interp);
 	assert(context != NULL);
 
@@ -4051,19 +4087,18 @@ static int jim_array2mem(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		return JIM_ERR;
 	}
 
-	return target_array2mem(interp, target, argc-1, argv + 1);
+	return target_array2mem(target, &goi );
 }
 
-static int target_array2mem(Jim_Interp *interp, struct target *target,
-		int argc, Jim_Obj *const *argv)
+static int target_array2mem(struct target *target, Jim_GetOptInfo *goi )
 {
-	long l;
+	jim_wide tmp_w;
 	uint32_t width;
 	int len;
 	struct target_addr addr;
 	uint32_t count;
 	uint64_t v;
-	const char *varname;
+	char *varname;
 	int  n, e, retval;
 	uint32_t i;
 
@@ -4072,29 +4107,31 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 	 * argv[3] = memory address
 	 * argv[4] = count to write
 	 */
-	if (argc != 4) {
-		Jim_WrongNumArgs(interp, 0, argv, "varname width addr nelems");
+	e = Jim_GetOpt_String( goi, &varname, NULL );
+	if( e != JIM_OK ){
 		return JIM_ERR;
 	}
-	varname = Jim_GetString(argv[0], &len);
-	/* given "foo" get space for worse case "foo(%d)" .. add 20 */
 
-	e = Jim_GetLong(interp, argv[1], &l);
-	width = l;
+	e = Jim_GetOpt_Wide(goi, &tmp_w);
+	width = tmp_w;
 	if (e != JIM_OK)
 		return e;
 
-	jim_wide w_tmp;
-	e = Jim_GetWide(interp, argv[2], &w_tmp);
+	e = Jim_GetOpt_Addr(goi, &addr );
 	if (e != JIM_OK)
 		return e;
-	/* FIXME: Add support for security prefixes! */
-	TARGET_ADDR_INIT( &addr, w_tmp );
 	
-	e = Jim_GetLong(interp, argv[3], &l);
-	len = l;
+	e = Jim_GetOpt_Wide( goi, &tmp_w );
+	len = tmp_w;
 	if (e != JIM_OK)
 		return e;
+
+	/* all args used up? */
+	if( goi->argc != 0 ){
+		Jim_WrongNumArgs(goi->interp, 1, goi->argv, "varname width addr nelems");
+		return JIM_ERR;
+	}
+
 	switch (width) {
 		case 8:
 			width = 1;
@@ -4109,27 +4146,27 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 			width = 8;
 			break;
 		default:
-			Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-			Jim_AppendStrings(interp, Jim_GetResult(interp),
+			Jim_SetResult(goi->interp, Jim_NewEmptyStringObj(goi->interp));
+			Jim_AppendStrings(goi->interp, Jim_GetResult(goi->interp),
 					"Invalid width param, must be 8/16/32/64", NULL);
 			return JIM_ERR;
 	}
 	if (len == 0) {
-		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-		Jim_AppendStrings(interp, Jim_GetResult(interp),
+		Jim_SetResult(goi->interp, Jim_NewEmptyStringObj(goi->interp));
+		Jim_AppendStrings(goi->interp, Jim_GetResult(goi->interp),
 				"array2mem: zero width read?", NULL);
 		return JIM_ERR;
 	}
 	if ((addr.addr + (len * width)) < addr.addr) {
-		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-		Jim_AppendStrings(interp, Jim_GetResult(interp),
+		Jim_SetResult(goi->interp, Jim_NewEmptyStringObj(goi->interp));
+		Jim_AppendStrings(goi->interp, Jim_GetResult(goi->interp),
 				"array2mem: addr + len - wraps to zero?", NULL);
 		return JIM_ERR;
 	}
 	/* absurd transfer size? */
 	if (len > 65536) {
-		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-		Jim_AppendStrings(interp, Jim_GetResult(interp),
+		Jim_SetResult(goi->interp, Jim_NewEmptyStringObj(goi->interp));
+		Jim_AppendStrings(goi->interp, Jim_GetResult(goi->interp),
 				"array2mem: absurd > 64K item request", NULL);
 		return JIM_ERR;
 	}
@@ -4141,11 +4178,11 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 		/* all is well */
 	} else {
 		char buf[100];
-		Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
+		Jim_SetResult(goi->interp, Jim_NewEmptyStringObj(goi->interp));
 		sprintf(buf, "array2mem address: 0x%s is not aligned for %d byte reads",
 				target_addr2str1( target, &addr ),
 				(int)width);
-		Jim_AppendStrings(interp, Jim_GetResult(interp), buf , NULL);
+		Jim_AppendStrings(goi->interp, Jim_GetResult(goi->interp), buf , NULL);
 		return JIM_ERR;
 	}
 
@@ -4170,7 +4207,7 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 
 		v = 0; /* shut up gcc */
 		for (i = 0; i < count; i++, n++) {
-			get_u64_array_element(interp, varname, n, &v);
+			get_u64_array_element(goi->interp, varname, n, &v);
 			switch (width) {
 			case 8:
 				target_buffer_set_u64(target, &buffer[i * width], v);
@@ -4195,8 +4232,8 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 					  target_addr2str1( target, &addr ),
 					  (int)width,
 					  (int)count);
-			Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
-			Jim_AppendStrings(interp, Jim_GetResult(interp), "array2mem: cannot read memory", NULL);
+			Jim_SetResult(goi->interp, Jim_NewEmptyStringObj(goi->interp));
+			Jim_AppendStrings(goi->interp, Jim_GetResult(goi->interp), "array2mem: cannot read memory", NULL);
 			e = JIM_ERR;
 			break;
 		}
@@ -4205,7 +4242,7 @@ static int target_array2mem(Jim_Interp *interp, struct target *target,
 
 	free(buffer);
 
-	Jim_SetResult(interp, Jim_NewEmptyStringObj(interp));
+	Jim_SetResult(goi->interp, Jim_NewEmptyStringObj(goi->interp));
 
 	return e;
 }
@@ -4589,43 +4626,31 @@ static int jim_target_configure(Jim_Interp *interp, int argc, Jim_Obj * const *a
 	return target_configure(&goi, target);
 }
 
-static int jim_target_mw(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
+static int jim_target_mw(Jim_Interp *_interp, int argc, Jim_Obj *const *argv)
 {
-	const char *cmd_name = Jim_GetString(argv[0], NULL);
+	int e;
+	Jim_GetOptInfo goi;
 	struct target_addr addr;
+	char *cmd_name;
+	target_write_fn fn;
 
-	Jim_GetOptInfo goi;
-	Jim_GetOpt_Setup(&goi, interp, argc - 1, argv + 1);
+	Jim_GetOpt_Setup( &goi, _interp, argc, argv );
 
-	if (goi.argc < 2 || goi.argc > 4) {
-		Jim_SetResultFormatted(goi.interp,
-				"usage: %s [phys] <address> <data> [<count>]", cmd_name);
-		return JIM_ERR;
-	}
+	/* get command name so we can determine size */
+	Jim_GetOpt_String( &goi, &cmd_name, NULL );
 
-	target_write_fn fn;
 	fn = target64_write_memory;
+	e = Jim_GetOpt_Addr( &goi, &addr );
+	if( e != JIM_OK ){
+		return e;
+	}
 
-	int e;
-	if (strcmp(Jim_GetString(argv[1], NULL), "phys") == 0) {
-		/* consume it */
-		struct Jim_Obj *obj;
-		e = Jim_GetOpt_Obj(&goi, &obj);
-		if (e != JIM_OK)
-			return e;
-
-		TARGET_ADDR_PHYS( &addr, 0 );
+	if( addr.route == TA_ROUTE_PHYSICAL ){
 		fn = target64_write_phys_memory;
 	} else {
-		TARGET_ADDR_INIT( &addr, 0 );
+		fn = target64_write_memory;
 	}
 
-	jim_wide a;
-	e = Jim_GetOpt_Wide(&goi, &a);
-	if (e != JIM_OK)
-		return e;
-	addr.addr = a;
-
 	jim_wide b;
 	e = Jim_GetOpt_Wide(&goi, &b);
 	if (e != JIM_OK)
@@ -4639,9 +4664,11 @@ static int jim_target_mw(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	}
 
 	/* all args must be consumed */
-	if (goi.argc != 0)
+	if (goi.argc != 0){
+		Jim_SetResultFormatted(goi.interp,
+				       "usage: %s [phys] <address> <data> [<count>]", cmd_name);
 		return JIM_ERR;
-
+	}
 	struct target *target = Jim_CmdPrivData(goi.interp);
 	unsigned data_size;
 	/* FIXME: what do we use for 64bit? */
@@ -4691,53 +4718,37 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	const char *cmd_name = Jim_GetString(argv[0], NULL);
 	struct target_addr addr;
+	int e;
 
 	Jim_GetOptInfo goi;
 	Jim_GetOpt_Setup(&goi, interp, argc - 1, argv + 1);
 
-	if ((goi.argc < 1) || (goi.argc > 3)) {
-		Jim_SetResultFormatted(goi.interp,
-				"usage: %s [phys] <address> [<count>]", cmd_name);
-		return JIM_ERR;
-	}
-
 	int (*fn)(struct target *target,
 			const struct target_addr *pAddr, uint64_t size, uint64_t count, uint8_t *buffer);
 	fn = target64_read_memory;
 
-	int e;
-	if (strcmp(Jim_GetString(argv[1], NULL), "phys") == 0) {
-		/* consume it */
-		struct Jim_Obj *obj;
-		TARGET_ADDR_PHYS( &addr, 0 );
-		e = Jim_GetOpt_Obj(&goi, &obj);
-		if (e != JIM_OK)
-			return e;
-
-		fn = target64_read_phys_memory;
-	} else {
-		TARGET_ADDR_INIT( &addr, 0 );
+	e = Jim_GetOpt_Addr( &goi, &addr );
+	if( e != JIM_OK ){
+	  return e;
 	}
-
-	/* Read address parameter */
-	jim_wide a;
-	e = Jim_GetOpt_Wide(&goi, &a);
-	if (e != JIM_OK)
-		return JIM_ERR;
-	addr.addr = a;
 	
 	/* If next parameter exists, read it out as the count parameter, if not, set it to 1 (default) */
 	jim_wide count;
-	if (goi.argc == 1) {
+	switch( goi.argc ){
+	default:
+		Jim_SetResultFormatted(goi.interp,
+				"usage: %s <address> [<count>]", cmd_name);
+		return JIM_ERR;
+	case 0:
+		/* all params used up */
+		count = 1;
+		break;
+	case 1:
 		e = Jim_GetOpt_Wide(&goi, &count);
 		if (e != JIM_OK)
 			return JIM_ERR;
-	} else
-		count = 1;
-
-	/* all args must be consumed */
-	if (goi.argc != 0)
-		return JIM_ERR;
+		break;
+	} 
 
 	/* FIXME: Must add 64bit support, what letter do we want to use? */
 	jim_wide dwidth = 1; /* shut up gcc */
@@ -4834,15 +4845,20 @@ static int jim_target_md(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 static int jim_target_mem2array(Jim_Interp *interp,
 		int argc, Jim_Obj *const *argv)
 {
+	Jim_GetOptInfo goi;
 	struct target *target = Jim_CmdPrivData(interp);
-	return target_mem2array(interp, target, argc - 1, argv + 1);
+	/* burn the name */
+	Jim_GetOpt_Setup( &goi, interp, argc-1, argv+1 );
+	return target_mem2array(target, &goi);
 }
 
 static int jim_target_array2mem(Jim_Interp *interp,
 		int argc, Jim_Obj *const *argv)
 {
+	Jim_GetOptInfo goi;
 	struct target *target = Jim_CmdPrivData(interp);
-	return target_array2mem(interp, target, argc - 1, argv + 1);
+	Jim_GetOpt_Setup( &goi, interp, argc-1, argv+1 );
+	return target_array2mem( target, &goi );
 }
 
 static int jim_target_tap_disabled(Jim_Interp *interp)
@@ -6123,42 +6139,42 @@ static const struct command_registration target_exec_command_handlers[] = {
 		.handler = handle_md_command,
 		.mode = COMMAND_EXEC,
 		.help = "display memory words",
-		.usage = "['phys'] address [count]",
+		.usage = "[prefix] address [count]",
 	},
 	{
 		.name = "mdh",
 		.handler = handle_md_command,
 		.mode = COMMAND_EXEC,
 		.help = "display memory half-words",
-		.usage = "['phys'] address [count]",
+		.usage = "[prefix] address [count]",
 	},
 	{
 		.name = "mdb",
 		.handler = handle_md_command,
 		.mode = COMMAND_EXEC,
 		.help = "display memory bytes",
-		.usage = "['phys'] address [count]",
+		.usage = "[prefix] address [count]",
 	},
 	{
 		.name = "mww",
 		.handler = handle_mw_command,
 		.mode = COMMAND_EXEC,
 		.help = "write memory word",
-		.usage = "['phys'] address value [count]",
+		.usage = "[prefix] address value [count]",
 	},
 	{
 		.name = "mwh",
 		.handler = handle_mw_command,
 		.mode = COMMAND_EXEC,
 		.help = "write memory half-word",
-		.usage = "['phys'] address value [count]",
+		.usage = "[prefix] address value [count]",
 	},
 	{
 		.name = "mwb",
 		.handler = handle_mw_command,
 		.mode = COMMAND_EXEC,
 		.help = "write memory byte",
-		.usage = "['phys'] address value [count]",
+		.usage = "[prefix] address value [count]",
 	},
 	{
 		.name = "bp",
@@ -6327,6 +6343,13 @@ struct target_addr *__target_addr_phys( struct target_addr *pAddr, uint64_t addr
 	return pAddr;
 }
 
+struct target_addr *__target_addr_virt( struct target_addr *pAddr, uint64_t addr )
+{
+	__target_addr_init( pAddr, addr );
+	pAddr->route = TA_ROUTE_VIRTUAL;
+	return pAddr;
+}
+
 		
 int target64_virt2phys( struct target *target, const struct target_addr *in_pVirt, struct target_addr *out_pPhys )
 {
@@ -6463,4 +6486,3 @@ bool target_addr64_is64bit( uint64_t address )
 {
 	return address > 0x0FFFFFFFFULL;
 }
- 
diff --git a/src/target/target_addr.h b/src/target/target_addr.h
index a085913..738c857 100755
--- a/src/target/target_addr.h
+++ b/src/target/target_addr.h
@@ -1,23 +1,34 @@
 #if !defined(TARGET_ADDR_H)
 #define TARGET_ADDR_H
 
+#include <jim.h>
+#include "jim-nvp.h"
+
 enum ta_route {
+	/* first 3 are generic */
 	TA_ROUTE_DEFAULT,
 	TA_ROUTE_PHYSICAL,
 	TA_ROUTE_VIRTUAL,
-	TA_ROUTE_TRUSTZONE,
-	TA_ROUTE_HYPERVISOR,
+
 	
-	TA_ROUTE_arm_dap_port0 = 0x100,
-	TA_ROUTE_arm_dap_port1 = 0x101,
-	TA_ROUTE_arm_dap_port2 = 0x102,
-	TA_ROUTE_arm_dap_port3 = 0x103,
-	TA_ROUTE_arm_dap_port4 = 0x104,
-	TA_ROUTE_arm_dap_port5 = 0x105,
-	TA_ROUTE_arm_dap_port6 = 0x106,
-	TA_ROUTE_arm_dap_port7 = 0x107,
+	TA_ROUTE_arm_tz   = 0x100,
+	TA_ROUTE_arm_hyp  = 0x101,
+	TA_ROUTE_arm_el0  = 0x102,
+	TA_ROUTE_arm_el1  = 0x103,
+	TA_ROUTE_arm_el2  = 0x104,
+	TA_ROUTE_arm_el3  = 0x105,
+	TA_ROUTE_arm_dap0 = 0x200,
+	TA_ROUTE_arm_dap1 = 0x201,
+	TA_ROUTE_arm_dap2 = 0x202,
+	TA_ROUTE_arm_dap3 = 0x203,
+	TA_ROUTE_arm_dap4 = 0x204,
+	TA_ROUTE_arm_dap5 = 0x205,
+	TA_ROUTE_arm_dap6 = 0x206,
+	TA_ROUTE_arm_dap7 = 0x207,
 	/* ... */
-	TA_ROUTE_dap_port255 = 0x1ff,
+	TA_ROUTE_arm_dap255 = 0x2ff,
+
+	/* Non ARM solutions should add starting at 0x300 */
 
 	TA_force_32bit = 0x12345678
 };
@@ -29,9 +40,40 @@ struct target_addr {
 	uint32_t route_attributes;
 };
 
+
+struct memattr_name {
+	const char *name;
+	/* use: tmplate because template is C++ reserved word! */
+	struct target_addr tmplate;
+	const struct memattr_name *alias_of;
+	const struct memattr_name *next;
+};
+
+void mem_att_delete( const struct memattr_name *att );
+/* return ERROR_OK on successful creation */
+int  mem_att_create( const char *name, const struct target_addr *tmplate );
+/* return ERROR_OK on successful creation */
+int  mem_att_create_alias( const char *alias_name, const char *base_name );
+
+const char *target_addr_routename( const struct target_addr *pAddr );
+
+const struct memattr_name *mem_att_find_route( enum ta_route route );
+const struct memattr_name *mem_att_find_addr( const struct target_addr *pAddr );
+const struct memattr_name *mem_att_find_name( const char *name, int len );
+const struct memattr_name *mem_att_find_name_RAW( const char *name, int len );
+int jim_memattribute( Jim_Interp *interp, int argc, Jim_Obj *const *argv);
+
+/* forward decloration */
+struct command_invocation;
+int parse_memory_address(struct command_invocation *cmd, unsigned *argc, struct target_addr *addr );
+
+struct command_context;
+int mematt_register_commands(struct command_context *cmd_ctx);
 extern struct target_addr *__target_addr_init( struct target_addr *pAddr, uint64_t addr );
 extern struct target_addr *__target_addr_phys( struct target_addr *pAddr, uint64_t addr );
+extern struct target_addr *__target_addr_virt( struct target_addr *pAddr, uint64_t addr );
 #define TARGET_ADDR_INIT( P, A )  __target_addr_init( P, A )
 #define TARGET_ADDR_PHYS( P, A )  __target_addr_phys( P, A )
+#define TARGET_ADDR_VIRT( P, A )  __target_addr_virt( P, A )
 
 #endif
-- 
1.9.1


From ab83b092618f280e309ee914118e9d2dde1e83b5 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 29/94] Add log hex dump for debug purposes

---
 src/helper/log.c | 86 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/helper/log.h |  5 ++++
 2 files changed, 91 insertions(+)

diff --git a/src/helper/log.c b/src/helper/log.c
index c15b95d..fcda13b 100755
--- a/src/helper/log.c
+++ b/src/helper/log.c
@@ -467,3 +467,89 @@ void busy_sleep(uint64_t ms)
 		 */
 	}
 }
+
+void log_hexdump( uint32_t address,
+		  const void *data,
+		  size_t len )
+{
+	const uint8_t *pu8;
+	char line[ 90 ];
+	char *cp;
+	size_t x;
+	int c;
+
+	pu8 = (const uint8_t *)data;
+	while( len > 16 ){
+		log_hexdump( address, pu8, 16 );
+		len     -= 16;
+		address += 16;
+		pu8     += 16;
+	}
+
+	/* done? */
+	if( len == 0 ){
+		return;
+	}
+
+	
+	cp = line;
+
+	/* simple hex dump with ascii text */
+	sprintf( cp, "%08" PRIx32 ": ", address );
+	cp = strchr(cp,0);
+	
+	for( x = 0 ; (x < 16) && (x < len) ; x++ ){
+		sprintf( cp, "%02x", pu8[x] & 0x0ff );
+		cp+= 2;
+		c = ' ';
+		if( x == 7 ){
+			c = '-';
+		}
+		if( x != 15 ){
+			*cp++ = c;
+		}
+	}
+
+	while( x < 16 ){
+		c = ' ';
+		*cp++ = c;
+		*cp++ = c;
+		if( x == 7 ){
+			c = '-';
+		}
+		if( x != 15 ){
+			*cp++ = c;
+		}
+		x++;
+	}
+
+	*cp++ = ' ';
+	*cp++ = '|';
+
+	for( x = 0 ; (x < 16) && (x < len) ; x++ ){
+		c = pu8[x];
+		if( (c < 0x20) || (c>=0x7f) ){
+			c = '.';
+		}
+		*cp++ = c;
+		if( x == 7 ){
+			*cp++ = '-';
+		}
+	}
+	while( x < 16 ){
+		*cp++ = ' ';
+		if( x == 7 ){
+			*cp++ = '-';
+		}
+		x++;
+	}
+	*cp++ = '|';
+	*cp++ = '\n';
+	*cp = 0;
+
+	/* put dummy values in for filename and lineno */
+	log_puts( LOG_LVL_OUTPUT, "hex", 0, "dump", line );
+}
+
+   
+    
diff --git a/src/helper/log.h b/src/helper/log.h
index 7f9f32c..deafe49 100755
--- a/src/helper/log.h
+++ b/src/helper/log.h
@@ -80,6 +80,11 @@ void kept_alive(void);
 void alive_sleep(uint64_t ms);
 void busy_sleep(uint64_t ms);
 
+/* simple hex dump for debug purposes to the log */
+void log_hexdump( uint32_t address,
+		  const void *data,
+		  size_t len );
+
 typedef void (*log_callback_fn)(void *priv, const char *file, unsigned line,
 		const char *function, const char *string);
 
-- 
1.9.1


From 8545668b7f3a2927a884f7b0ecc617c1e754bcc3 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 30/94] Warning removal

---
 src/target/cortex_a53.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 879b688..e5aa8e0 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -14,6 +14,7 @@
 #include "target_type.h"
 #include "arm_opcodes.h"
 #include "armv8.h"
+#include "arm_semihosting.h"
 #include <helper/time_support.h>
 
 static int cortex_a53_poll(struct target *target);
-- 
1.9.1


From 603e2bca45e1bf3f7007ac5a0492cdc26f86d6b5 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 31/94] Memory Atts through to the dap

---
 common.mk                             |    4 +
 configure.ac                          |    1 +
 src/Makefile.am                       |    1 +
 src/flash/nand/arm_io.c               |    4 +-
 src/flash/nor/cfi.c                   |    2 +-
 src/flash/nor/efm32.c                 |    2 +-
 src/flash/nor/em357.c                 |    2 +-
 src/flash/nor/fm3.c                   |    6 +-
 src/flash/nor/kinetis.c               |   15 +-
 src/flash/nor/lpc2000.c               |    4 +-
 src/flash/nor/lpcspifi.c              |    6 +-
 src/flash/nor/mdr.c                   |    2 +-
 src/flash/nor/mrvlqspi.c              |    2 +-
 src/flash/nor/stellaris.c             |    2 +-
 src/flash/nor/stm32f1x.c              |    2 +-
 src/flash/nor/stm32f2x.c              |    2 +-
 src/flash/nor/stm32lx.c               |    2 +-
 src/helper/command.h                  |    3 +
 src/helper/jim-nvp.c                  |  135 +-
 src/helper/jim-nvp.h                  |    7 +
 src/helper/options.c                  |   21 +-
 src/jtag/drivers/ftdi.c               |    2 +-
 src/target/Makefile.am                |    3 +
 src/target/adi_v5_cmsis_dap.c         |   19 +-
 src/target/adi_v5_jtag.c              |  116 +-
 src/target/adi_v5_swd.c               |   27 +-
 src/target/arm.h                      |   45 +-
 src/target/arm11.c                    |   18 +-
 src/target/arm11_dbgtap.c             |   28 +-
 src/target/arm7_9_common.c            |    4 +-
 src/target/arm7_9_common.h            |    4 +-
 src/target/arm9tdmi.c                 |    2 +-
 src/target/arm_adi_v5.c               | 2339 ++++++++++++++++++++++++---------
 src/target/arm_adi_v5.h               |  599 +++++++--
 src/target/arm_adi_v5_debug.c         |  403 ++++++
 src/target/arm_adi_v5_debug.h         |   69 +
 src/target/arm_adi_v5_mem_ap.c        |   85 ++
 src/target/arm_dpm.c                  |   34 +-
 src/target/arm_dpm.h                  |   19 +-
 src/target/arm_semihosting.c          |    6 +-
 src/target/armv4_5.c                  |    6 +-
 src/target/armv7a.c                   |   38 +-
 src/target/armv7a.h                   |   55 +-
 src/target/armv7m.c                   |   14 +-
 src/target/armv7m.h                   |   32 +-
 src/target/armv8.c                    | 1030 +--------------
 src/target/armv8.h                    |  135 +-
 src/target/armv8_cpudbg_regs.h        |  118 ++
 src/target/armv8_ctidbg_regs.h        |   42 +
 src/target/armv8_dpm.c                |   94 +-
 src/target/armv8_dpm.h                |    8 +-
 src/target/coresight_io.c             |  662 ++++++++++
 src/target/cortex_a.c                 |  806 +++++-------
 src/target/cortex_a.h                 |   54 +-
 src/target/cortex_a53.c               | 1672 +++++++++++------------
 src/target/cortex_m.c                 |  215 ++-
 src/target/cortex_m.h                 |   23 +-
 src/target/hla_target.c               |    3 +-
 src/target/mematts.c                  |  492 ++++---
 src/target/target.c                   |  219 ++-
 src/target/target.h                   |   25 +-
 src/target/target64.c                 |   48 +
 src/target/target_addr.h              |   86 +-
 src/target/target_type.h              |    1 +
 src/target/xscale.c                   |    4 +-
 tcl/qualcomm/common/jtag_dap_cfg0.cfg |   15 +
 tcl/qualcomm/common/jtag_dap_cfg1.cfg |   19 +
 tcl/qualcomm/common/tcpip.ports.cfg   |    3 +
 tcl/qualcomm/msm8994/apps_core0.cfg   |    7 +
 tcl/qualcomm/msm8994/apps_coreX.cfg   |   12 +
 tcl/qualcomm/msm8994/common.cfg       |   22 +
 tcl/qualcomm/msm8994/memmap.cfg       |  260 ++++
 tcl/qualcomm/msm8994/rpm_apps0.cfg    |   24 +
 tcl/qualcomm/msm8994/rpm_core.cfg     |   23 +
 tcl/qualcomm/msm8994/rpm_only.cfg     |   16 +
 tcl/qualcomm/msm8x26/common.cfg       |    7 +
 tcl/qualcomm/msm8x26/memmap.cfg       |  209 +++
 tcl/qualcomm/msm8x26/rpm_core.cfg     |   11 +
 tcl/qualcomm/msm8x26/rpm_only.cfg     |   16 +
 79 files changed, 6861 insertions(+), 3712 deletions(-)
 create mode 100644 src/target/arm_adi_v5_debug.c
 create mode 100644 src/target/arm_adi_v5_debug.h
 create mode 100644 src/target/arm_adi_v5_mem_ap.c
 create mode 100644 src/target/armv8_cpudbg_regs.h
 create mode 100644 src/target/armv8_ctidbg_regs.h
 create mode 100644 src/target/coresight_io.c
 create mode 100755 src/target/target64.c
 create mode 100644 tcl/qualcomm/common/jtag_dap_cfg0.cfg
 create mode 100644 tcl/qualcomm/common/jtag_dap_cfg1.cfg
 create mode 100644 tcl/qualcomm/common/tcpip.ports.cfg
 create mode 100644 tcl/qualcomm/msm8994/apps_core0.cfg
 create mode 100644 tcl/qualcomm/msm8994/apps_coreX.cfg
 create mode 100644 tcl/qualcomm/msm8994/common.cfg
 create mode 100644 tcl/qualcomm/msm8994/memmap.cfg
 create mode 100644 tcl/qualcomm/msm8994/rpm_apps0.cfg
 create mode 100644 tcl/qualcomm/msm8994/rpm_core.cfg
 create mode 100644 tcl/qualcomm/msm8994/rpm_only.cfg
 create mode 100644 tcl/qualcomm/msm8x26/common.cfg
 create mode 100644 tcl/qualcomm/msm8x26/memmap.cfg
 create mode 100644 tcl/qualcomm/msm8x26/rpm_core.cfg
 create mode 100644 tcl/qualcomm/msm8x26/rpm_only.cfg

diff --git a/common.mk b/common.mk
index f301c3a..f191c62 100755
--- a/common.mk
+++ b/common.mk
@@ -1,4 +1,5 @@
 
+
 # common flags used in openocd build
 AM_CPPFLAGS = -I$(top_srcdir)/src \
 			  -I$(top_builddir)/src \
@@ -10,3 +11,6 @@ if INTERNAL_JIMTCL
 AM_CPPFLAGS += -I$(top_srcdir)/jimtcl \
 			   -I$(top_builddir)/jimtcl
 endif
+
+AM_CPPFLAGS +=  -DSRCDIR=\"$(abs_top_srcdir)\" 
+
diff --git a/configure.ac b/configure.ac
index 6b61b1b..23a0652 100755
--- a/configure.ac
+++ b/configure.ac
@@ -3,6 +3,7 @@ AC_INIT([openocd], [0.9.0-dev],
   [OpenOCD Mailing List <openocd-devel@lists.sourceforge.net>])
 AC_CONFIG_SRCDIR([src/openocd.c])
 
+AC_SUBST([abs_top_srcdir])
 m4_include([config_subdir.m4])dnl
 
 AM_INIT_AUTOMAKE([-Wall -Wno-portability dist-bzip2 dist-zip subdir-objects])
diff --git a/src/Makefile.am b/src/Makefile.am
index 7d67e3d..f063be9 100755
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1,3 +1,4 @@
+abs_top_srcdir=@abs_top_srcdir@
 include $(top_srcdir)/common.mk
 
 SUBDIRS = \
diff --git a/src/flash/nand/arm_io.c b/src/flash/nand/arm_io.c
index d54958a..7793664 100755
--- a/src/flash/nand/arm_io.c
+++ b/src/flash/nand/arm_io.c
@@ -136,7 +136,7 @@ int arm_nandwrite(struct arm_nand_data *nand, uint8_t *data, int size)
 
 	/* set up algorithm */
 	if (is_armv7m(target_to_armv7m(target))) {  /* armv7m target */
-		armv7m_algo.common_magic = ARMV7M_COMMON_MAGIC;
+		armv7m_algo.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 		armv7m_algo.core_mode = ARM_MODE_THREAD;
 		arm_algo = &armv7m_algo;
 		target_code_size = sizeof(code_armv7m);
@@ -246,7 +246,7 @@ int arm_nandread(struct arm_nand_data *nand, uint8_t *data, uint32_t size)
 
 	/* set up algorithm */
 	if (is_armv7m(target_to_armv7m(target))) {  /* armv7m target */
-		armv7m_algo.common_magic = ARMV7M_COMMON_MAGIC;
+		armv7m_algo.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 		armv7m_algo.core_mode = ARM_MODE_THREAD;
 		arm_algo = &armv7m_algo;
 		target_code_size = sizeof(code_armv7m);
diff --git a/src/flash/nor/cfi.c b/src/flash/nor/cfi.c
index cd935d7..e9599d2 100755
--- a/src/flash/nor/cfi.c
+++ b/src/flash/nor/cfi.c
@@ -1800,7 +1800,7 @@ static int cfi_spansion_write_block(struct flash_bank *bank, const uint8_t *buff
 		return cfi_spansion_write_block_mips(bank, buffer, address, count);
 
 	if (is_armv7m(target_to_armv7m(target))) {	/* armv7m target */
-		armv7m_algo.common_magic = ARMV7M_COMMON_MAGIC;
+		armv7m_algo.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 		armv7m_algo.core_mode = ARM_MODE_THREAD;
 		arm_algo = &armv7m_algo;
 	} else if (is_arm(target_to_arm(target))) {
diff --git a/src/flash/nor/efm32.c b/src/flash/nor/efm32.c
index 35c0732..930a9f2 100755
--- a/src/flash/nor/efm32.c
+++ b/src/flash/nor/efm32.c
@@ -631,7 +631,7 @@ static int efm32x_write_block(struct flash_bank *bank, const uint8_t *buf,
 	buf_set_u32(reg_params[3].value, 0, 32, source->address + source->size);
 	buf_set_u32(reg_params[4].value, 0, 32, address);
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 	ret = target_run_flash_async_algorithm(target, buf, count, 4,
diff --git a/src/flash/nor/em357.c b/src/flash/nor/em357.c
index 70a5431..e47e791 100755
--- a/src/flash/nor/em357.c
+++ b/src/flash/nor/em357.c
@@ -523,7 +523,7 @@ static int em357_write_block(struct flash_bank *bank, const uint8_t *buffer,
 		}
 	}
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
diff --git a/src/flash/nor/fm3.c b/src/flash/nor/fm3.c
index d3d143f..2b3ec3a 100755
--- a/src/flash/nor/fm3.c
+++ b/src/flash/nor/fm3.c
@@ -298,7 +298,7 @@ static int fm3_erase(struct flash_bank *bank, int first, int last)
 	if (retval != ERROR_OK)
 		return retval;
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT); /* u32FlashSeqAddress1 */
@@ -574,7 +574,7 @@ static int fm3_write_block(struct flash_bank *bank, const uint8_t *buffer,
 		}
 	}
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT); /* source start address */
@@ -907,7 +907,7 @@ static int fm3_chip_erase(struct flash_bank *bank)
 	if (retval != ERROR_OK)
 		return retval;
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT); /* u32FlashSeqAddress1 */
diff --git a/src/flash/nor/kinetis.c b/src/flash/nor/kinetis.c
index e8917c7..7f570ec 100755
--- a/src/flash/nor/kinetis.c
+++ b/src/flash/nor/kinetis.c
@@ -295,8 +295,7 @@ static int kinetis_mdm_poll_register(struct adiv5_dap *dap, unsigned reg, uint32
 COMMAND_HANDLER(kinetis_mdm_mass_erase)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	struct cortex_m_common *cortex_m = target_to_cm(target);
-	struct adiv5_dap *dap = cortex_m->armv7m.arm.dap;
+	struct adiv5_dap *dap = target_cs_to_dap(target);
 
 	if (!dap) {
 		LOG_ERROR("Cannot perform mass erase with a high-level adapter");
@@ -304,7 +303,6 @@ COMMAND_HANDLER(kinetis_mdm_mass_erase)
 	}
 
 	int retval;
-	const uint8_t original_ap = dap->ap_current;
 
 	/*
 	 * ... Power on the processor, or if power has already been
@@ -313,7 +311,7 @@ COMMAND_HANDLER(kinetis_mdm_mass_erase)
 	 * Reset Request bit in the MDM-AP control register after
 	 * establishing communication...
 	 */
-	dap_ap_select(dap, 1);
+	dap_ap_select(dap, 1 );
 
 	retval = kinetis_mdm_write_register(dap, MDM_REG_CTRL, MEM_CTRL_SYS_RES_REQ);
 	if (retval != ERROR_OK)
@@ -364,7 +362,6 @@ COMMAND_HANDLER(kinetis_mdm_mass_erase)
 	if (retval != ERROR_OK)
 		return retval;
 
-	dap_ap_select(dap, original_ap);
 	return ERROR_OK;
 }
 
@@ -382,8 +379,7 @@ static const uint32_t kinetis_known_mdm_ids[] = {
 COMMAND_HANDLER(kinetis_check_flash_security_status)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	struct cortex_m_common *cortex_m = target_to_cm(target);
-	struct adiv5_dap *dap = cortex_m->armv7m.arm.dap;
+	struct adiv5_dap *dap = target_cs_to_dap(target);
 
 	if (!dap) {
 		LOG_WARNING("Cannot check flash security status with a high-level adapter");
@@ -392,7 +388,6 @@ COMMAND_HANDLER(kinetis_check_flash_security_status)
 
 	uint32_t val;
 	int retval;
-	const uint8_t origninal_ap = dap->ap_current;
 
 	dap_ap_select(dap, 1);
 
@@ -459,8 +454,6 @@ COMMAND_HANDLER(kinetis_check_flash_security_status)
 		jtag_poll_set_enabled(true);
 	}
 
-	dap_ap_select(dap, origninal_ap);
-
 	return ERROR_OK;
 
 fail:
@@ -610,7 +603,7 @@ static int kinetis_write_block(struct flash_bank *bank, const uint8_t *buffer,
 		}
 	}
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT); /* *pLW (*buffer) */
diff --git a/src/flash/nor/lpc2000.c b/src/flash/nor/lpc2000.c
index 433973f..8a210ea 100755
--- a/src/flash/nor/lpc2000.c
+++ b/src/flash/nor/lpc2000.c
@@ -603,7 +603,7 @@ static int lpc2000_iap_call(struct flash_bank *bank, struct working_area *iap_wo
 		case lpc1100:
 		case lpc1700:
 		case lpc_auto:
-			armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+			armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 			armv7m_info.core_mode = ARM_MODE_THREAD;
 			iap_entry_point = 0x1fff1ff1;
 			break;
@@ -615,7 +615,7 @@ static int lpc2000_iap_call(struct flash_bank *bank, struct working_area *iap_wo
 			iap_entry_point = 0x7ffffff1;
 			break;
 		case lpc4300:
-			armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+			armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 			armv7m_info.core_mode = ARM_MODE_THREAD;
 			/* read out IAP entry point from ROM driver table at 0x10400100 */
 			target_read_u32(target, 0x10400100, &iap_entry_point);
diff --git a/src/flash/nor/lpcspifi.c b/src/flash/nor/lpcspifi.c
index 502ae26..7b0d4b2 100755
--- a/src/flash/nor/lpcspifi.c
+++ b/src/flash/nor/lpcspifi.c
@@ -185,7 +185,7 @@ static int lpcspifi_set_hw_mode(struct flash_bank *bank)
 		0xa0, 0x47, 0x00, 0xf0, 0x00, 0xb8, 0x00, 0xbe
 	};
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 
@@ -528,7 +528,7 @@ static int lpcspifi_erase(struct flash_bank *bank, int first, int last)
 		0x70, 0x47, 0x00, 0x20, 0x00, 0xbe, 0xff, 0xff
 	};
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 
@@ -735,7 +735,7 @@ static int lpcspifi_write(struct flash_bank *bank, const uint8_t *buffer,
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);		/* buffer start, status (out) */
diff --git a/src/flash/nor/mdr.c b/src/flash/nor/mdr.c
index ed76aab..fa90528 100755
--- a/src/flash/nor/mdr.c
+++ b/src/flash/nor/mdr.c
@@ -288,7 +288,7 @@ static int mdr_write_block(struct flash_bank *bank, const uint8_t *buffer,
 	buf_set_u32(reg_params[3].value, 0, 32, source->address + source->size);
 	buf_set_u32(reg_params[4].value, 0, 32, address);
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 	retval = target_run_flash_async_algorithm(target, buffer, count, 4,
diff --git a/src/flash/nor/mrvlqspi.c b/src/flash/nor/mrvlqspi.c
index a5cc1ca..5ca7772 100755
--- a/src/flash/nor/mrvlqspi.c
+++ b/src/flash/nor/mrvlqspi.c
@@ -715,7 +715,7 @@ static int mrvlqspi_flash_write(struct flash_bank *bank, const uint8_t *buffer,
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	};
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);	/* buffer start, status (out) */
diff --git a/src/flash/nor/stellaris.c b/src/flash/nor/stellaris.c
index c4fe3be..92da4dc 100755
--- a/src/flash/nor/stellaris.c
+++ b/src/flash/nor/stellaris.c
@@ -1086,7 +1086,7 @@ static int stellaris_write_block(struct flash_bank *bank,
 			sizeof(stellaris_write_code),
 			stellaris_write_code);
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
diff --git a/src/flash/nor/stm32f1x.c b/src/flash/nor/stm32f1x.c
index c9757d8..4a23757 100755
--- a/src/flash/nor/stm32f1x.c
+++ b/src/flash/nor/stm32f1x.c
@@ -653,7 +653,7 @@ static int stm32x_write_block(struct flash_bank *bank, const uint8_t *buffer,
 	buf_set_u32(reg_params[3].value, 0, 32, source->address + source->size);
 	buf_set_u32(reg_params[4].value, 0, 32, address);
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 	retval = target_run_flash_async_algorithm(target, buffer, count, 2,
diff --git a/src/flash/nor/stm32f2x.c b/src/flash/nor/stm32f2x.c
index 8f35845..ec1d837 100755
--- a/src/flash/nor/stm32f2x.c
+++ b/src/flash/nor/stm32f2x.c
@@ -558,7 +558,7 @@ static int stm32x_write_block(struct flash_bank *bank, const uint8_t *buffer,
 		}
 	};
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);		/* buffer start, status (out) */
diff --git a/src/flash/nor/stm32lx.c b/src/flash/nor/stm32lx.c
index e5b66cf..2afa1e4 100755
--- a/src/flash/nor/stm32lx.c
+++ b/src/flash/nor/stm32lx.c
@@ -404,7 +404,7 @@ static int stm32lx_write_half_pages(struct flash_bank *bank, const uint8_t *buff
 		}
 	}
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
 	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
diff --git a/src/helper/command.h b/src/helper/command.h
index 0eda5b5..16517f1 100755
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -299,10 +299,13 @@ void command_set_output_handler(struct command_context *context,
 
 int command_context_mode(struct command_context *context, enum command_mode mode);
 
+struct target *get_current_target(struct command_context *cmd_ctx);
+
 /* Return the current command context associated with the Jim interpreter or
  * alternatively the global default command interpreter
  */
 struct command_context *current_command_context(Jim_Interp *interp);
+
 /**
  * Creates a new command context using the startup TCL provided and
  * the existing Jim interpreter, if any. If interp == NULL, then command_init
diff --git a/src/helper/jim-nvp.c b/src/helper/jim-nvp.c
index ecc0cf4..f67811a 100755
--- a/src/helper/jim-nvp.c
+++ b/src/helper/jim-nvp.c
@@ -277,86 +277,46 @@ int Jim_GetOpt_Wide(Jim_GetOptInfo *goi, jim_wide *puthere)
 	return r;
 }
 
-int Jim_GetOpt_Addr( Jim_GetOptInfo *goi, struct target_addr *addr )
+int Jim_GetOpt_Addr( Jim_GetOptInfo *goi, struct target_addr *pAddr )
 {
-	char *cp;
-	char *ep;
-	char *cp2;
+	char *str1;
+	char *str2;
 	int e;
-	const struct memattr_name *att;
-
-	/* always init */
-	TARGET_ADDR_INIT( addr, 0 );
-
-	e = Jim_GetOpt_String( goi, &cp, NULL );
+	
+	e = Jim_GetOpt_String( goi, &str1, NULL );
 	if( e != JIM_OK ){
-		Jim_SetResultFormatted( goi->interp, "?address missing parameter");
 		return e;
 	}
-
-	/* support these:
-	 *    address
-	 *    prefix <whitespace> address
-	 *    prefix:address (lauterbach)
-	 * But not:
-	 *   C++   class::member
-	 */
-
-	/* test for the : */
-	cp2 = strchr( cp, ':' );
-
-	if( cp2 ){
-		if( cp2[1] == ':' ){
-			/* C++ class::member
-			 * should not be mistaken for a prefix
-			 */
-			cp2 = NULL;
+	/* if there is another item */
+	str2 = NULL;
+	if( goi->argc ){
+		/* get that string */
+		e = Jim_GetOpt_String( goi, &str2, NULL );
+		if( e != JIM_OK ){
+			return e;
 		}
 	}
 
-	if( cp2 ){
-		/* Lookup the prefix */
-		att = mem_att_find_name( cp, cp2 - cp );
-		if( att ){
-			/* we have a prefix! */
-			cp = cp2+1;
-		}
-	} else {
-		/* test: Is this a prefix? */
-		att = mem_att_find_name( cp, -1 );
-		if( att ){
-			/* Yes it is, then get the address component */
-			e = Jim_GetOpt_String( goi, &cp, NULL );
-			if( e != JIM_OK ){
-				Jim_SetResultFormatted( goi->interp, "?address missing parameter");
-				return e;
-			}
+	e = parse_memory_address( pAddr, str1, str2 );
+	switch(e){
+	default:
+		Jim_SetResultString( goi->interp, "?address invalid",-1);
+		e = JIM_ERR;
+		break;
+	case 1:
+		/* only 1 param was used */
+		if( str2 ){
+			Jim_GetOpt_Unget( goi );
 		}
+		e = JIM_OK;
+		break;
+		
+	case 2:
+		/* Both where used */
+		e = JIM_OK;
+		break;
 	}
-
-	/* override the route & attributes */
-	if( att ){
-		*addr = att->tmplate;
-	}
-
-	/* parse the address */
-	/* FIXME:  Do we check for 32bit overflows?
-	 *  Answer: NO because, the SOC may have
-	 *  a 32bit (cortex-m3) + a 64bit DAP
-	 *
-	 * AND
-	 *  Current target might be CortexM3 (32bit)
-	 *  But the address specifier might be 'via-dap'
-	 *  and the DAP addresses are possibly 64bit!
-	 */
-	addr->addr = strtoll( cp, &ep, 0 );
-	/* FIXME: Support symbols at some point */
-	/* remember: Symbols can have prefixes "built-in" */
-	if( *ep || (ep == cp) ){
-		Jim_SetResultFormatted( goi->interp, "?address not a number");
-		return JIM_ERR;
-	}
-	return JIM_OK;
+	return e;
 }
 
 
@@ -445,3 +405,38 @@ int Jim_nvpInit(Jim_Interp *interp)
 	/* This is really a helper library, not an extension, but this is the easy way */
 	return JIM_OK;
 }
+
+int Jim_GetOpt_ArmDapPort( Jim_GetOptInfo *goi, int *portnum )
+{
+	char *cp;
+	char *ep;
+	long l;
+	int e;
+
+	if( portnum ){
+		*portnum = 0;
+	}
+	
+	e = Jim_GetOpt_String( goi, &cp, NULL );
+	if( e != JIM_OK ){
+		return e;
+	}
+
+	/* we are expecting:  "arm.dap<NUMBER>" */
+	if( 0 != strncmp( cp, "arm.dap", 7 ) ){
+		Jim_SetResultString( goi->interp, "?arm.dapNUMBER ...", -1);
+		return JIM_ERR;
+	}
+	cp = cp + 7;
+	/* and this shall be base 10! */
+	l = strtol( cp, &ep, 10 );
+	if( (cp==ep) || (*ep) || (l < 0) || (l > 255) ){
+		Jim_SetResultString( goi->interp, "?arm.dapNUMBER ...",-1);
+		return JIM_ERR;
+	}
+	if( portnum ){
+		*portnum = l;
+	}
+	
+	return JIM_OK;
+}
diff --git a/src/helper/jim-nvp.h b/src/helper/jim-nvp.h
index 3d00799..70c932c 100755
--- a/src/helper/jim-nvp.h
+++ b/src/helper/jim-nvp.h
@@ -338,6 +338,13 @@ struct target_addr;
  */
 int Jim_GetOpt_Addr( Jim_GetOptInfo *goi, struct target_addr *addr );
 
+/** Get an ARM DAP Port in this form: arm.dapX
+ *
+ * Value of x must be 0 to 255 inclusive.
+ *
+ */
+int Jim_GetOpt_ArmDapPort( Jim_GetOptInfo *goi, int *portnum );
+
 /** Remove argv[0] as Enum
  *
  * \param goi     - get opt info
diff --git a/src/helper/options.c b/src/helper/options.c
index 5351e82..ea97205 100755
--- a/src/helper/options.c
+++ b/src/helper/options.c
@@ -31,9 +31,10 @@
 
 #include <getopt.h>
 
-static int help_flag, version_flag;
+static int help_flag, version_flag, dev_flag;
 
 static const struct option long_options[] = {
+	{"devmode",     no_argument,            &dev_flag,      'D'},
 	{"help",		no_argument,			&help_flag,		1},
 	{"version",		no_argument,			&version_flag,	1},
 	{"debug",		optional_argument,		0,				'd'},
@@ -98,7 +99,20 @@ static void add_default_dirs(void)
 	LOG_DEBUG("bindir=%s", BINDIR);
 	LOG_DEBUG("pkgdatadir=%s", PKGDATADIR);
 	LOG_DEBUG("run_prefix=%s", run_prefix);
+	LOG_DEBUG("srcdir=%s", SRCDIR );
 
+	/* in developer mode ..
+	 * it is very handy to put the
+	 * source tree for scripts first!
+	 */
+	if( dev_flag ){
+		path = alloc_printf("%s/tcl", SRCDIR );
+		if( path ){
+			add_script_search_dir( path );
+			free(path);
+		}
+	}
+	
 	/*
 	 * The directory containing OpenOCD-supplied scripts should be
 	 * listed last in the built-in search order, so the user can
@@ -146,7 +160,7 @@ int parse_cmdline_args(struct command_context *cmd_ctx, int argc, char *argv[])
 		/* getopt_long stores the option index here. */
 		int option_index = 0;
 
-		c = getopt_long(argc, argv, "hvd::l:f:s:c:p", long_options, &option_index);
+		c = getopt_long(argc, argv, "Dhvd::l:f:s:c:p", long_options, &option_index);
 
 		/* Detect the end of the options. */
 		if (c == -1)
@@ -155,6 +169,9 @@ int parse_cmdline_args(struct command_context *cmd_ctx, int argc, char *argv[])
 		switch (c) {
 			case 0:
 				break;
+			case 'D':
+				dev_flag = 1;
+				break;
 			case 'h':		/* --help | -h */
 				help_flag = 1;
 				break;
diff --git a/src/jtag/drivers/ftdi.c b/src/jtag/drivers/ftdi.c
index 6406406..9960c5d 100755
--- a/src/jtag/drivers/ftdi.c
+++ b/src/jtag/drivers/ftdi.c
@@ -1060,7 +1060,7 @@ static void ftdi_swd_queue_cmd(struct adiv5_dap *dap, uint8_t cmd, uint32_t *dst
 
 	/* Insert idle cycles after AP accesses to avoid WAIT */
 	if (cmd & SWD_CMD_APnDP)
-		mpsse_clock_data_out(mpsse_ctx, NULL, 0, dap->memaccess_tck, SWD_MODE);
+		mpsse_clock_data_out(mpsse_ctx, NULL, 0, dap->port[ dap->cached_ap_port].memaccess_tck, SWD_MODE);
 
 }
 
diff --git a/src/target/Makefile.am b/src/target/Makefile.am
index 009ac97..f2f1586 100755
--- a/src/target/Makefile.am
+++ b/src/target/Makefile.am
@@ -98,6 +98,9 @@ ARM_DEBUG_SRC = \
 	arm_simulator.c \
 	arm_semihosting.c \
 	arm_adi_v5.c \
+	arm_adi_v5_mem_ap.c \
+	arm_adi_v5_debug.c \
+	coresight_io.c \
 	adi_v5_jtag.c \
 	adi_v5_swd.c \
 	adi_v5_cmsis_dap.c \
diff --git a/src/target/adi_v5_cmsis_dap.c b/src/target/adi_v5_cmsis_dap.c
index 4fb3886..4ac72d9 100755
--- a/src/target/adi_v5_cmsis_dap.c
+++ b/src/target/adi_v5_cmsis_dap.c
@@ -112,11 +112,11 @@ static int cmsis_dap_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
 {
 	uint32_t select_ap_bank = reg & 0x000000F0;
 
-	if (select_ap_bank == dap->ap_bank_value)
+	if (select_ap_bank == dap->cached_ap_bank_value)
 		return ERROR_OK;
 
-	dap->ap_bank_value = select_ap_bank;
-	select_ap_bank |= dap->ap_current<<24;
+	dap->cached_ap_bank_value = select_ap_bank;
+	select_ap_bank |= dap->cached_ap_port<<24;
 
 	cmsis_dap_queue_dp_write(dap, DP_SELECT, select_ap_bank);
 	return ERROR_OK;
@@ -140,9 +140,12 @@ static int (cmsis_dap_queue_ap_write)(struct adiv5_dap *dap, unsigned reg, uint3
 {
 	/* TODO: CSW_DBGSWENABLE (bit31) causes issues for some targets
 	 * disable until we find out why */
-	if (reg == AP_REG_CSW)
-		data &= ~CSW_DBGSWENABLE;
-
+	if (reg == AP_MEM_REG_CSW){
+		/* no macro for this, because this bit does not
+		 * exist for all DAP port types */
+		data &= ~(1UL << 31);
+	}
+	
 	cmsis_dap_ap_q_bankselect(dap, reg);
 
 	LOG_DEBUG("reg = %d, data = 0x%08" PRIx32, reg, data);
@@ -257,7 +260,7 @@ static int cmsis_dap_init(struct command_context *ctx)
 {
 	struct target *target = get_current_target(ctx);
 	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
+	struct adiv5_dap *dap = arm_to_dap(arm);
 	uint32_t idcode;
 	int status;
 
@@ -265,7 +268,7 @@ static int cmsis_dap_init(struct command_context *ctx)
 
 	/* Force the DAP's ops vector for CMSIS-DAP mode.
 	 * messy - is there a better way? */
-	arm->dap->ops = &cmsis_dap_ops;
+	dap->ops = &cmsis_dap_ops;
 
 	/* FIXME validate transport config ... is the
 	 * configured DAP present (check IDCODE)?
diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 105fba2..2025522 100755
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -50,6 +50,8 @@
 #define JTAG_ACK_OK_FAULT	0x2
 #define JTAG_ACK_WAIT		0x1
 
+int dap_jtag_debug = 0;
+
 struct adiv5_jtag_dap {
 	struct adiv5_dap dap;
 	struct jtag_tap *tap;
@@ -127,13 +129,28 @@ static int adi_jtag_dp_scan(struct adiv5_dap *dap,
 	 * They provide more time for the (MEM) AP to complete the read ...
 	 * See "Minimum Response Time" for JTAG-DP, in the ADIv5 spec.
 	 */
-	if ((instr == JTAG_DP_APACC)
-			&& ((reg_addr == AP_REG_DRW)
-				|| ((reg_addr & 0xF0) == AP_REG_BD0))
-			&& (dap->memaccess_tck != 0))
-		jtag_add_runtest(dap->memaccess_tck,
-				TAP_IDLE);
 
+	/* if not a memory transaction */
+	if( instr != JTAG_DP_APACC ){
+		/* we are done */
+		return ERROR_OK;
+	}
+
+	/* not a memory register */
+	if( ! ((reg_addr == AP_MEM_REG_DRW) || ((reg_addr & 0xF0) == AP_MEM_REG_BD0)) ){
+		/* we are done */
+		return ERROR_OK;
+	}
+
+	int n;
+	n = dap->port[ dap->cached_ap_port].memaccess_tck;
+	if( n < 8 ){
+		n = 8;
+	}
+	if( n ){
+		/* only add idle if specified */
+		jtag_add_runtest(n, TAP_IDLE);
+	}
 	return ERROR_OK;
 }
 
@@ -149,9 +166,53 @@ static int adi_jtag_dp_scan_u32(struct adiv5_dap *dap,
 {
 	uint8_t out_value_buf[4];
 	int retval;
+	const char *rw;
+	const char *rname;
 
 	buf_set_u32(out_value_buf, 0, 32, outvalue);
 
+
+
+	if( dap_jtag_debug ){
+		if( RnW ){
+			rw = "rd";
+		} else {
+			rw = "wr";
+		}
+		switch( instr ){
+		default:
+			rname = "unknown";
+			break;
+		case 8:
+			rname = "abort";
+			break;
+		case 9:
+			rname = "reserved9";
+			break;
+		case 10:
+			rname ="dpacc";
+			break;
+		case 11:
+			rname = "apacc";
+			break;
+		case 12:
+			rname = "reserved12";
+			break;
+		case 13:
+			rname = "reserved13";
+			break;
+		case 14:
+			rname = "idcode";
+			break;
+		case 15:
+			rname = "bypass";
+			break;
+		}
+		LOG_DEBUG( "jtag-dap: %s: %-10s: 0x%08" PRIx32 " in: %s",
+				   rw, rname, outvalue, invalue ? "real" : "dummy" );
+	}
+	
+	
 	retval = adi_jtag_dp_scan(dap, instr, reg_addr, RnW,
 			out_value_buf, (uint8_t *)invalue, ack);
 	if (retval != ERROR_OK)
@@ -174,6 +235,7 @@ static inline int adi_jtag_ap_write_check(struct adiv5_dap *dap,
 			outvalue, NULL, NULL);
 }
 
+
 static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *dap,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint32_t outvalue, uint32_t *invalue)
@@ -284,24 +346,19 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 		LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32, ctrlstat);
 		/* Check power to debug regions */
 		if ((ctrlstat & 0xf0000000) != 0xf0000000) {
-			retval = ahbap_debugport_init(dap);
+
+			retval = dap_debugport_init(dap);
 			if (retval != ERROR_OK)
 				return retval;
 		} else {
-			uint32_t mem_ap_csw, mem_ap_tar;
+			uint32_t mem_ap_csw;
+			uint64_t mem_ap_tar;
+			uint32_t mem_ap_tar_l,mem_ap_tar_h;
 
 			/* Maybe print information about last intended
 			 * MEM-AP access; but not if autoincrementing.
 			 * *Real* CSW and TAR values are always shown.
 			 */
-			if (dap->ap_tar_value != (uint32_t) -1)
-				LOG_DEBUG("MEM-AP Cached values: "
-					"ap_bank 0x%" PRIx32
-					", ap_csw 0x%" PRIx32
-					", ap_tar 0x%" PRIx32,
-					dap->ap_bank_value,
-					dap->ap_csw_value,
-					dap->ap_tar_value);
 
 			if (ctrlstat & SSTICKYORUN)
 				LOG_ERROR("JTAG-DP OVERRUN - check clock, "
@@ -328,20 +385,27 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 			LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
 
 			retval = dap_queue_ap_read(dap,
-					AP_REG_CSW, &mem_ap_csw);
+					AP_MEM_REG_CSW, &mem_ap_csw);
 			if (retval != ERROR_OK)
 				return retval;
 
 			retval = dap_queue_ap_read(dap,
-					AP_REG_TAR, &mem_ap_tar);
+					AP_MEM_REG_TAR_lo, &mem_ap_tar_l);
 			if (retval != ERROR_OK)
 				return retval;
+			if( dap->port[ dap->cached_ap_port ].addr_64bit ){
+				retval = dap_queue_ap_read(dap,
+										   AP_MEM_REG_TAR_lo, &mem_ap_tar_h);
+			}
 
 			retval = jtag_execute_queue();
 			if (retval != ERROR_OK)
 				return retval;
+			mem_ap_tar = mem_ap_tar_h;
+			mem_ap_tar = mem_ap_tar << 32;
+			mem_ap_tar += mem_ap_tar_l;
 			LOG_ERROR("MEM_AP_CSW 0x%" PRIx32 ", MEM_AP_TAR 0x%"
-					PRIx32, mem_ap_csw, mem_ap_tar);
+					PRIx64, mem_ap_csw, mem_ap_tar);
 
 		}
 		retval = jtag_execute_queue();
@@ -373,12 +437,17 @@ static int jtag_dp_q_write(struct adiv5_dap *dap, unsigned reg,
 static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
 {
 	uint32_t select_ap_bank = reg & 0x000000F0;
-
-	if (select_ap_bank == dap->ap_bank_value)
+#if DAP_REG_CACHE
+	if (select_ap_bank == dap->cached_ap_bank_value){
+		LOG_DEBUG("ap-q-bank: 0x%02" PRIx32 " (cached)", (uint32_t)(reg));
 		return ERROR_OK;
-	dap->ap_bank_value = select_ap_bank;
+	} else {
+		LOG_DEBUG("ap-q-bank: 0x%02" PRIx32 " *new*", (uint32_t)(reg));
+	}
+#endif
+	dap->cached_ap_bank_value = select_ap_bank;
 
-	select_ap_bank |= dap->ap_current<<24;
+	select_ap_bank |= dap->cached_ap_port<<24;
 
 	return jtag_dp_q_write(dap, DP_SELECT, select_ap_bank);
 }
@@ -496,5 +565,6 @@ struct adiv5_dap *adiv5_jtag_dap_new(struct jtag_tap *tap)
 		return NULL;
 
 	adiv5_jtag_dap_create(jtag_dap, tap);
+	adiv5_dap_init_common( &(jtag_dap->dap) );
 	return &jtag_dap->dap;
 }
diff --git a/src/target/adi_v5_swd.c b/src/target/adi_v5_swd.c
index 59f0906..d4206e2 100755
--- a/src/target/adi_v5_swd.c
+++ b/src/target/adi_v5_swd.c
@@ -121,11 +121,13 @@ static void swd_queue_dp_bankselect(struct adiv5_dap *dap, unsigned reg)
 	if (reg == DP_SELECT)
 		return;
 
-	if (select_dp_bank == dap->dp_bank_value)
+#if DAP_REG_CACHE
+	if (select_dp_bank == dap->cached_dp_bank_value)
 		return;
-
-	dap->dp_bank_value = select_dp_bank;
-	select_dp_bank |= dap->ap_current | dap->ap_bank_value;
+#endif
+	
+	dap->cached_dp_bank_value = select_dp_bank;
+	select_dp_bank |= dap->cached_ap_port | dap->cached_ap_bank_value;
 
 	swd_queue_dp_write(dap, DP_SELECT, select_dp_bank);
 }
@@ -163,11 +165,11 @@ static void swd_queue_ap_bankselect(struct adiv5_dap *dap, unsigned reg)
 {
 	uint32_t select_ap_bank = reg & 0x000000F0;
 
-	if (select_ap_bank == dap->ap_bank_value)
+	if (select_ap_bank == dap->cached_ap_bank_value)
 		return;
 
-	dap->ap_bank_value = select_ap_bank;
-	select_ap_bank |= dap->ap_current | dap->dp_bank_value;
+	dap->cached_ap_bank_value = select_ap_bank;
+	select_ap_bank |= dap->cached_ap_port | dap->cached_dp_bank_value;
 
 	swd_queue_dp_write(dap, DP_SELECT, select_ap_bank);
 }
@@ -258,10 +260,10 @@ static const uint8_t jtag2swd_bitseq[] = {
  */
 int dap_to_swd(struct target *target)
 {
-    struct arm *arm = target_to_arm(target);
+	struct arm *arm = target_to_arm(target);
 	int retval;
 
-	if (!arm->dap) {
+	if (! arm_to_dap(arm) ) {
 		LOG_ERROR("SWD mode is not available");
 		return ERROR_FAIL;
 	}
@@ -285,7 +287,7 @@ COMMAND_HANDLER(handle_swd_wcr)
 	int retval;
 	struct target *target = get_current_target(CMD_CTX);
 	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
+	struct adiv5_dap *dap = arm_to_dap(arm);
 	uint32_t wcr;
 	unsigned trn, scale = 0;
 
@@ -382,7 +384,7 @@ static int swd_select(struct command_context *ctx)
 
 	struct target *target = get_current_target(ctx);
 	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
+	struct adiv5_dap *dap = arm_to_dap(arm);
 	struct adiv5_swd_dap *swd_dap = container_of(dap, struct adiv5_swd_dap, dap);
 	const struct swd_driver *swd = swd_dap->swd;
 
@@ -418,7 +420,7 @@ static int swd_init(struct command_context *ctx)
 {
 	struct target *target = get_current_target(ctx);
 	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
+	struct adiv5_dap *dap = arm_to_dap(arm);
 	uint32_t idcode;
 	int status;
 
@@ -478,5 +480,6 @@ struct adiv5_dap *adiv5_swd_dap_new(const struct swd_driver *swd)
 		return NULL;
 
 	adiv5_swd_dap_create(swd_dap, swd);
+	adiv5_dap_init_common( &(swd_dap->dap) );
 	return &swd_dap->dap;
 }
diff --git a/src/target/arm.h b/src/target/arm.h
index 88b5902..b4ec57c 100755
--- a/src/target/arm.h
+++ b/src/target/arm.h
@@ -29,7 +29,7 @@
 
 #include <helper/command.h>
 #include "target.h"
-
+#include "arm_adi_v5.h"
 
 /**
  * @file
@@ -83,6 +83,11 @@ enum arm_state {
 
 #define ARM_COMMON_MAGIC 0x0A450A45
 
+
+struct adiv5_dap;
+struct coresight_settings;
+
+
 /**
  * Represents a generic ARM core, with standard application registers.
  *
@@ -91,7 +96,7 @@ enum arm_state {
  * registers as traditional ARM cores, and only support Thumb2 instructions.
  */
 struct arm {
-	int common_magic;
+	int common_arm_magic;
 	struct reg_cache *core_cache;
 
 	/** Handle to the PC; valid in all core modes. */
@@ -137,7 +142,7 @@ struct arm {
 	int (*setup_semihosting)(struct target *target, int enable);
 
 	/** Backpointer to the target. */
-	struct target *target;
+	struct target *HIDE_target;
 
 	/** Handle for the debug module, if one is present. */
 	struct arm_dpm *dpm;
@@ -154,7 +159,7 @@ struct arm {
 	int (*read_core_reg)(struct target *target, struct reg *reg,
 			int num, enum arm_mode mode);
 	int (*write_core_reg)(struct target *target, struct reg *reg,
-			int num, enum arm_mode mode, uint32_t value);
+			int num, enum arm_mode mode, uint64_t value);
 
 	/** Read coprocessor register.  */
 	int (*mrc)(struct target *target, int cpnum,
@@ -170,13 +175,33 @@ struct arm {
 
 	void *arch_info;
 
-	/** For targets conforming to ARM Debug Interface v5,
-	 * this handle references the Debug Access Port (DAP)
-	 * used to make requests to the target.
-	 */
-	struct adiv5_dap *dap;
 };
 
+
+static inline struct target *arm_to_target( struct arm *arm )
+{
+	return arm->HIDE_target;
+}
+/* YUCK, I have a catch-22 problem ... with this damn function */
+struct coresight_settings *target_to_coresight( struct target *target );
+
+static inline struct coresight_settings *arm_to_coresight( struct arm *arm )
+{
+	return target_to_coresight(arm_to_target(arm));
+}
+
+static inline struct adiv5_dap *arm_to_dap( struct arm *arm )
+{
+	return target_cs_to_dap( arm_to_target(arm) );
+}
+
+static inline struct arm_dpm *arm_to_arm_dpm( struct arm *arm )
+{
+    return arm->dpm;
+}
+
+
+
 /** Convert target handle to generic ARM target state handle. */
 static inline struct arm *target_to_arm(struct target *target)
 {
@@ -187,7 +212,7 @@ static inline struct arm *target_to_arm(struct target *target)
 static inline bool is_arm(struct arm *arm)
 {
 	assert(arm != NULL);
-	return arm->common_magic == ARM_COMMON_MAGIC;
+	return arm->common_arm_magic == ARM_COMMON_MAGIC;
 }
 
 struct arm_algorithm {
diff --git a/src/target/arm11.c b/src/target/arm11.c
index aa5931e..19308c3 100755
--- a/src/target/arm11.c
+++ b/src/target/arm11.c
@@ -73,11 +73,11 @@ static int arm11_check_init(struct arm11_common *arm11)
 			  * the target.
 			  */
 
-			arm11->arm.target->state = TARGET_HALTED;
+			arm_to_target(&(arm11->arm))->state = TARGET_HALTED;
 			arm_dpm_report_dscr(arm11->arm.dpm, arm11->dscr);
 		} else {
-			arm11->arm.target->state = TARGET_RUNNING;
-			arm11->arm.target->debug_reason = DBG_REASON_NOTHALTED;
+			arm_to_target(&(arm11->arm))->state = TARGET_RUNNING;
+			arm_to_target(&(arm11->arm))->debug_reason = DBG_REASON_NOTHALTED;
 		}
 
 		CHECK_RETVAL(arm11_sc7_clear_vbw(arm11));
@@ -95,7 +95,7 @@ static int arm11_debug_entry(struct arm11_common *arm11)
 {
 	int retval;
 
-	arm11->arm.target->state = TARGET_HALTED;
+	arm_to_target(&(arm11->arm))->state = TARGET_HALTED;
 	arm_dpm_report_dscr(arm11->arm.dpm, arm11->dscr);
 
 	/* REVISIT entire cache should already be invalid !!! */
@@ -117,7 +117,7 @@ static int arm11_debug_entry(struct arm11_common *arm11)
 		arm11_setup_field(arm11,  1, NULL, NULL, chain5_fields + 1);
 		arm11_setup_field(arm11,  1, NULL, NULL, chain5_fields + 2);
 
-		arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(
+		arm11_add_dr_scan_vc(arm_to_target(&(arm11->arm))->tap, ARRAY_SIZE(
 				chain5_fields), chain5_fields, TAP_DRPAUSE);
 
 	}
@@ -202,7 +202,7 @@ static int arm11_debug_entry(struct arm11_common *arm11)
 
 	}
 
-	if (arm11->arm.target->debug_reason == DBG_REASON_WATCHPOINT) {
+	if (arm_to_target(&(arm11->arm))->debug_reason == DBG_REASON_WATCHPOINT) {
 		uint32_t wfar;
 
 		/* MRC p15, 0, <Rd>, c6, c0, 1 ; Read WFAR */
@@ -305,7 +305,7 @@ static int arm11_leave_debug_state(struct arm11_common *arm11, bool bpwp)
 		arm11_setup_field(arm11,  1, &Ready,    NULL, chain5_fields + 1);
 		arm11_setup_field(arm11,  1, &Valid,    NULL, chain5_fields + 2);
 
-		arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(
+		arm11_add_dr_scan_vc(arm_to_target(&(arm11->arm))->tap, ARRAY_SIZE(
 				chain5_fields), chain5_fields, TAP_DRPAUSE);
 	}
 
@@ -1119,7 +1119,7 @@ static int arm11_examine(struct target *target)
 
 	arm11_setup_field(arm11, 32, NULL, &device_id, &idcode_field);
 
-	arm11_add_dr_scan_vc(arm11->arm.target->tap, 1, &idcode_field, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(arm_to_target(&(arm11->arm))->tap, 1, &idcode_field, TAP_DRPAUSE);
 
 	/* check DIDR */
 
@@ -1132,7 +1132,7 @@ static int arm11_examine(struct target *target)
 	arm11_setup_field(arm11, 32, NULL, &didr, chain0_fields + 0);
 	arm11_setup_field(arm11,  8, NULL, &implementor, chain0_fields + 1);
 
-	arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(
+	arm11_add_dr_scan_vc(arm_to_target(&(arm11->arm))->tap, ARRAY_SIZE(
 			chain0_fields), chain0_fields, TAP_IDLE);
 
 	CHECK_RETVAL(jtag_execute_queue());
diff --git a/src/target/arm11_dbgtap.c b/src/target/arm11_dbgtap.c
index 9271a2b..5c64800 100755
--- a/src/target/arm11_dbgtap.c
+++ b/src/target/arm11_dbgtap.c
@@ -37,6 +37,8 @@
 					     LOG_DEBUG(expr); } while (0)
 #endif
 
+
+
 /*
 This pathmove goes from Pause-IR to Shift-IR while avoiding RTI. The
 behavior of the FTDI driver IIRC was to go via RTI.
@@ -136,7 +138,7 @@ static const char *arm11_ir_to_string(uint8_t ir)
  */
 void arm11_add_IR(struct arm11_common *arm11, uint8_t instr, tap_state_t state)
 {
-	struct jtag_tap *tap = arm11->arm.target->tap;
+	struct jtag_tap *tap = arm_to_target(&(arm11->arm))->tap;
 
 	if (buf_get_u32(tap->cur_instr, 0, 5) == instr) {
 		JTAG_DEBUG("IR <= 0x%02x SKIPPED", instr);
@@ -149,7 +151,7 @@ void arm11_add_IR(struct arm11_common *arm11, uint8_t instr, tap_state_t state)
 
 	arm11_setup_field(arm11, 5, &instr, NULL, &field);
 
-	arm11_add_ir_scan_vc(arm11->arm.target->tap,
+	arm11_add_ir_scan_vc(arm_to_target(&(arm11->arm))->tap,
 		&field,
 		state == ARM11_TAP_DEFAULT ? TAP_IRPAUSE : state);
 }
@@ -220,7 +222,7 @@ int arm11_add_debug_SCAN_N(struct arm11_common *arm11,
 	uint8_t tmp[1];
 	arm11_setup_field(arm11, 5, &chain, &tmp, &field);
 
-	arm11_add_dr_scan_vc(arm11->arm.target->tap,
+	arm11_add_dr_scan_vc(arm_to_target(&(arm11->arm))->tap,
 		1,
 		&field,
 		state == ARM11_TAP_DEFAULT ? TAP_DRPAUSE : state);
@@ -262,7 +264,7 @@ static void arm11_add_debug_INST(struct arm11_common *arm11,
 	arm11_setup_field(arm11, 32, &inst, NULL, itr + 0);
 	arm11_setup_field(arm11, 1, NULL, flag, itr + 1);
 
-	arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(itr), itr, state);
+	arm11_add_dr_scan_vc(arm_to_target(&(arm11->arm))->tap, ARRAY_SIZE(itr), itr, state);
 }
 
 /**
@@ -290,7 +292,7 @@ int arm11_read_DSCR(struct arm11_common *arm11)
 
 	arm11_setup_field(arm11, 32, NULL, &dscr, &chain1_field);
 
-	arm11_add_dr_scan_vc(arm11->arm.target->tap, 1, &chain1_field, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(arm_to_target(&(arm11->arm))->tap, 1, &chain1_field, TAP_DRPAUSE);
 
 	CHECK_RETVAL(jtag_execute_queue());
 
@@ -326,7 +328,7 @@ int arm11_write_DSCR(struct arm11_common *arm11, uint32_t dscr)
 
 	arm11_setup_field(arm11, 32, &dscr, NULL, &chain1_field);
 
-	arm11_add_dr_scan_vc(arm11->arm.target->tap, 1, &chain1_field, TAP_DRPAUSE);
+	arm11_add_dr_scan_vc(arm_to_target(&(arm11->arm))->tap, 1, &chain1_field, TAP_DRPAUSE);
 
 	CHECK_RETVAL(jtag_execute_queue());
 
@@ -486,7 +488,7 @@ int arm11_run_instr_data_to_core(struct arm11_common *arm11,
 		do {
 			Data        = *data;
 
-			arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(
+			arm11_add_dr_scan_vc(arm_to_target(&(arm11->arm))->tap, ARRAY_SIZE(
 					chain5_fields), chain5_fields, TAP_IDLE);
 
 			CHECK_RETVAL(jtag_execute_queue());
@@ -517,7 +519,7 @@ int arm11_run_instr_data_to_core(struct arm11_common *arm11,
 	do {
 		Data        = 0;
 
-		arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(
+		arm11_add_dr_scan_vc(arm_to_target(&(arm11->arm))->tap, ARRAY_SIZE(
 				chain5_fields), chain5_fields, TAP_DRPAUSE);
 
 		CHECK_RETVAL(jtag_execute_queue());
@@ -676,7 +678,7 @@ int arm11_run_instr_data_to_core_noack(struct arm11_common *arm11,
 
 	arm11_add_IR(arm11, ARM11_EXTEST, ARM11_TAP_DEFAULT);
 
-	int retval = arm11_run_instr_data_to_core_noack_inner(arm11->arm.target->tap,
+	int retval = arm11_run_instr_data_to_core_noack_inner(arm_to_target(&(arm11->arm))->tap,
 			opcode,
 			data,
 			count);
@@ -707,7 +709,7 @@ int arm11_run_instr_data_to_core_noack(struct arm11_common *arm11,
 	uint8_t ready_flag;
 	chain5_fields[1].in_value   = &ready_flag;
 
-	arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(
+	arm11_add_dr_scan_vc(arm_to_target(&(arm11->arm))->tap, ARRAY_SIZE(
 			chain5_fields), chain5_fields, TAP_DRPAUSE);
 
 	retval = jtag_execute_queue();
@@ -780,7 +782,7 @@ int arm11_run_instr_data_from_core(struct arm11_common *arm11,
 	while (count--) {
 		int i = 0;
 		do {
-			arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(
+			arm11_add_dr_scan_vc(arm_to_target(&(arm11->arm))->tap, ARRAY_SIZE(
 					chain5_fields), chain5_fields,
 				count ? TAP_IDLE : TAP_DRPAUSE);
 
@@ -915,7 +917,7 @@ int arm11_sc7_run(struct arm11_common *arm11, struct arm11_sc7_action *actions,
 				(unsigned) DataOut,
 				nRW ? "write" : "read");
 
-			arm11_add_dr_scan_vc(arm11->arm.target->tap, ARRAY_SIZE(chain7_fields),
+			arm11_add_dr_scan_vc(arm_to_target(&(arm11->arm))->tap, ARRAY_SIZE(chain7_fields),
 				chain7_fields, TAP_DRPAUSE);
 
 			CHECK_RETVAL(jtag_execute_queue());
@@ -1080,7 +1082,7 @@ static int arm11_dpm_instr_read_data_r0(struct arm_dpm *dpm,
  * pre-allocated our vector, we don't need to worry about space.
  */
 static int arm11_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
-	uint32_t addr, uint32_t control)
+	uint64_t addr, uint32_t control)
 {
 	struct arm11_common *arm11 = dpm_to_arm11(dpm);
 	struct arm11_sc7_action *action;
diff --git a/src/target/arm7_9_common.c b/src/target/arm7_9_common.c
index 2cc683b..1c3e67a 100755
--- a/src/target/arm7_9_common.c
+++ b/src/target/arm7_9_common.c
@@ -2033,7 +2033,7 @@ static int arm7_9_read_core_reg(struct target *target, struct reg *r,
 }
 
 static int arm7_9_write_core_reg(struct target *target, struct reg *r,
-	int num, enum arm_mode mode, uint32_t value)
+	int num, enum arm_mode mode, uint64_t value)
 {
 	uint32_t reg[16];
 	struct arm_reg *areg = r->arch_info;
@@ -2825,7 +2825,7 @@ int arm7_9_init_arch_info(struct target *target, struct arm7_9_common *arm7_9)
 	int retval = ERROR_OK;
 	struct arm *arm = &arm7_9->arm;
 
-	arm7_9->common_magic = ARM7_9_COMMON_MAGIC;
+	arm7_9->common_79_magic = ARM7_9_COMMON_MAGIC;
 
 	retval = arm_jtag_setup_connection(&arm7_9->jtag_info);
 	if (retval != ERROR_OK)
diff --git a/src/target/arm7_9_common.h b/src/target/arm7_9_common.h
index 5821e13..26be720 100755
--- a/src/target/arm7_9_common.h
+++ b/src/target/arm7_9_common.h
@@ -40,7 +40,7 @@
  */
 struct arm7_9_common {
 	struct arm arm;
-	uint32_t common_magic;
+	uint32_t common_79_magic;
 
 	struct arm_jtag jtag_info; /**< JTAG information for target */
 	struct reg_cache *eice_cache; /**< Embedded ICE register cache */
@@ -141,7 +141,7 @@ static inline struct arm7_9_common *target_to_arm7_9(struct target *target)
 
 static inline bool is_arm7_9(struct arm7_9_common *arm7_9)
 {
-	return arm7_9->common_magic == ARM7_9_COMMON_MAGIC;
+	return arm7_9->common_79_magic == ARM7_9_COMMON_MAGIC;
 }
 
 extern const struct command_registration arm7_9_command_handlers[];
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 0f8f1d0..9d0d7f3 100755
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -799,7 +799,7 @@ COMMAND_HANDLER(handle_arm9tdmi_catch_vectors_command)
 	}
 
 	/* it's uncommon, but some ARM7 chips can support this */
-	if (arm7_9->common_magic != ARM7_9_COMMON_MAGIC
+	if ( !is_arm7_9(arm7_9)
 			|| !arm7_9->has_vector_catch) {
 		command_print(CMD_CTX, "target doesn't have EmbeddedICE "
 				"with vector_catch");
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 95a18bc..ff6d96a 100755
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -73,22 +73,13 @@
 #endif
 
 #include "jtag/interface.h"
+#include "log.h"
 #include "arm.h"
 #include "arm_adi_v5.h"
 #include <helper/time_support.h>
 
 struct adiv5_dap *global_dap;
 
-/* ARM ADI Specification requires at least 10 bits used for TAR autoincrement  */
-
-/*
-	uint32_t tar_block_size(uint32_t address)
-	Return the largest block starting at address that does not cross a tar block size alignment boundary
-*/
-static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address)
-{
-	return tar_autoincr_block - ((tar_autoincr_block - 1) & address);
-}
 
 /***************************************************************************
  *                                                                         *
@@ -96,6 +87,59 @@ static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address
  *                                                                         *
 ***************************************************************************/
 
+void dap_invalidate_port_cache( struct adiv5_dap *dap )
+{
+	struct adiv5_dap_port *p;
+	if( (dap->cached_ap_port < 0) || (dap->cached_ap_port > 255) ){
+		/* maybe the AP CURRENT is invalid */
+		/* like set to -1? to make it invalid */
+		return;
+	}
+
+	p = &(dap->port[ dap->cached_ap_port ]);
+
+	p->cached_tar_valid = false;
+	p->cached_tar_reg   = (uint64_t)(-1);
+	p->cached_csw_reg   = (uint32_t)(-1);
+	p->cached_csw_valid = false;
+}
+
+
+int target_addr_to_dap_port( const struct target_addr *pAddr )
+{
+	int r;
+
+	r = pAddr->route - TA_ROUTE_arm_dap0;
+	if( (r < 0) || (r > 255) ){
+		r = -1;
+	}
+	return r;
+}
+
+/* write (now) this dap register */
+static int dap_ap_write( struct adiv5_dap *dap, int reg, uint32_t val )
+{
+	int r;
+	
+	r = dap_queue_ap_write(dap, reg, val);
+	if( r == ERROR_OK ){
+		r = dap_run( dap );
+	}
+	return r;
+}
+
+static int dap_ap_read( struct adiv5_dap *dap, int reg, uint32_t *val )
+{
+	int r;
+	
+	r = dap_queue_ap_read(dap, reg, val);
+	if( r == ERROR_OK ){
+		r = dap_run( dap );
+	}
+	return r;
+}
+
+
 /**
  * Select one of the APs connected to the specified DAP.  The
  * selection is implicitly used with future AP transactions.
@@ -105,44 +149,113 @@ static uint32_t max_tar_block_size(uint32_t tar_autoincr_block, uint32_t address
  * @param apsel Number of the AP to (implicitly) use with further
  *	transactions.  This normally identifies a MEM-AP.
  */
-void dap_ap_select(struct adiv5_dap *dap, uint8_t ap)
+void dap_ap_select(struct adiv5_dap *dap, int ap )
 {
-	if (ap != dap->ap_current) {
-		dap->ap_current = ap;
-		/* Switching AP invalidates cached values.
-		 * Values MUST BE UPDATED BEFORE AP ACCESS.
-		 */
-		dap->ap_bank_value = -1;
-		dap->ap_csw_value = -1;
-		dap->ap_tar_value = -1;
+	if( (ap < 0) || (ap > 255) ){
+		LOG_ERROR("dap: invalid PORT %d", ap );
+		return;
+	}
+
+#if DAP_REG_CACHE	
+	if ( ap == dap->cached_ap_port) {
+		LOG_DEBUG("select-ap = %d cached\n", ap );
+		return;
 	}
+	LOG_DEBUG("select-ap = %d *new*\n", ap );
+#endif
+	dap->cached_ap_port = ap;
+	/* invalidate where we are now */
+	dap_invalidate_port_cache( dap );
 }
 
-static int dap_setup_accessport_csw(struct adiv5_dap *dap, uint32_t csw)
+static int dap_setup_accessport_csw(struct adiv5_dap *dap, uint32_t csw, const struct target_addr *pAddr)
 {
-	csw = csw | CSW_DBGSWENABLE | CSW_MASTER_DEBUG | CSW_HPROT |
-		dap->apcsw[dap->ap_current];
+	struct adiv5_dap_port *port;
+	int r;
+
+	r = target_addr_to_dap_port(pAddr);
+	if( r < 0 ){
+		LOG_ERROR("dap-ap[ERROR] id =%d", r );
+		return ERROR_FAIL;
+	}
+
+	port = &(dap->port[r]);
+
+	/* clear away all sbzp bits */
+	csw &= ~(port->csw_reg_sbzp_mask);
+	/* clear away configurable bits */
+	csw &= ~(port->csw_route_cfg_bits);
+
+	/* does user want to specify? */
+	if( pAddr->route_attributes & 1 ){
+		/* note bit 0 is always masked out
+		 * because this is one of the size bits */
+		csw |= (pAddr->route_attributes & port->csw_route_cfg_bits);
+	} else {
+		csw |= (port->csw_reg_default   & port->csw_route_cfg_bits);
+	}
+
+	/* insert the reserved bits */
+	csw |= (port->csw_reg_orig & port->csw_reg_sbzp_mask);
+	
 
-	if (csw != dap->ap_csw_value) {
+	/* Assume success */
+	r = ERROR_OK;
+	
+	if( (!(port->cached_csw_valid)) || (csw != port->cached_csw_reg) ){
+		
 		/* LOG_DEBUG("DAP: Set CSW %x",csw); */
-		int retval = dap_queue_ap_write(dap, AP_REG_CSW, csw);
-		if (retval != ERROR_OK)
-			return retval;
-		dap->ap_csw_value = csw;
+		r = dap_queue_ap_write(dap, AP_MEM_REG_CSW, csw);
+		if( r == ERROR_OK ){
+			port->cached_csw_valid = true;
+			port->cached_csw_reg = csw;
+		}
 	}
-	return ERROR_OK;
+	return r;
 }
 
-static int dap_setup_accessport_tar(struct adiv5_dap *dap, uint32_t tar)
+static int dap_setup_accessport_tar(struct adiv5_dap *dap, uint64_t address )
 {
-	if (tar != dap->ap_tar_value || dap->ap_csw_value & CSW_ADDRINC_MASK) {
-		/* LOG_DEBUG("DAP: Set TAR %x",tar); */
-		int retval = dap_queue_ap_write(dap, AP_REG_TAR, tar);
-		if (retval != ERROR_OK)
-			return retval;
-		dap->ap_tar_value = tar;
+	int r;
+	struct adiv5_dap_port *port;
+	
+	port = &(dap->port[ dap->cached_ap_port ]);
+
+	/* this is easier to read then a multi-step IF statement */
+	if ( !(port->cached_tar_valid) ){
+		goto doit;
 	}
-	return ERROR_OK;
+
+	if( address != port->cached_tar_reg ){
+		goto doit;
+	}
+
+	if( !(port->cached_csw_reg & CSW_ADDRINC_MASK) ){
+		/* last trasnsaction was not incrementing! */
+		/* so the tar could not have changed */
+		return ERROR_OK;
+	}
+ doit:
+	r = ERROR_OK;
+
+	/* Some SOCs have mixed port sizes */
+	/* And we should not write to non-existant registers */
+	if( port->addr_64bit ){
+		uint64_t a2;
+		a2 = address >> 32;
+		r = dap_queue_ap_write(dap, AP_MEM_REG_TAR_hi, a2 );
+	}
+
+	if( r == ERROR_OK ){
+		/* write LOW */
+		r = dap_queue_ap_write(dap, AP_MEM_REG_TAR_lo, address );
+	}
+	
+	if( r == ERROR_OK ){
+		port->cached_tar_reg   = address;
+		port->cached_tar_valid = true;
+	}
+	return r;
 }
 
 /**
@@ -164,18 +277,397 @@ static int dap_setup_accessport_tar(struct adiv5_dap *dap, uint32_t tar)
  *
  * @return ERROR_OK if the transaction was properly queued, else a fault code.
  */
-int dap_setup_accessport(struct adiv5_dap *dap, uint32_t csw, uint32_t tar)
+static int dap_setup_accessport(struct adiv5_dap *dap, uint32_t csw, const struct target_addr *pAddr)
 {
 	int retval;
-	retval = dap_setup_accessport_csw(dap, csw);
+
+	retval = target_addr_to_dap_port( pAddr );
+	if( retval < 0 ){
+		return ERROR_FAIL;
+	}
+	dap_ap_select(dap, retval );
+	
+	retval = dap_setup_accessport_csw(dap, csw, pAddr);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = dap_setup_accessport_tar(dap, tar);
+	retval = dap_setup_accessport_tar(dap, pAddr->addr);
 	if (retval != ERROR_OK)
 		return retval;
 	return ERROR_OK;
 }
 
+static int coresight_io_chunk_rd(struct coresight_bulk *bulk )
+{
+	int r;
+	uint32_t x;
+	uint32_t csw;
+	uint32_t *rd_buf;
+	uint64_t addr;
+	
+	r = ERROR_FAIL;
+	rd_buf = NULL;
+	
+	if( bulk->addrinc ){
+		csw = CSW_ADDRINC_SINGLE;
+	} else {
+		csw = CSW_ADDRINC_OFF;
+	}
+	switch(bulk->size){
+	case 1:
+		csw |= CSW_8BIT;
+		break;
+	case 2:
+		csw |= CSW_16BIT;
+		break;
+	case 4:
+		csw |= CSW_32BIT;
+		break;
+	case 8:
+		csw |= CSW_64BIT;
+		break;
+	}
+
+	/* if size <= 4, then 1 per entry */
+	/* if size == 8, then 2 per entry */
+	/* simpler, just multiply by 2    */
+	
+	rd_buf = calloc( sizeof(uint32_t),  2 * bulk->wip_count );
+	if( !rd_buf ){
+		LOG_ERROR("dap-rd, no memory?!?");
+		r =  ERROR_FAIL;
+		goto fail;
+	}
+
+	r = dap_setup_accessport( bulk->dap, csw, &(bulk->addr) );
+	if( r != ERROR_OK ){
+		goto fail;
+	}
+
+	for( x = 0 ; x < bulk->wip_count ; x++ ){
+		/* FIXME: (optimze)
+		 *  Add packed transfers
+		 */
+
+		r = ERROR_OK;
+		if( bulk->size == 8 ){
+			r = dap_queue_ap_read( bulk->dap, AP_MEM_REG_DRW, rd_buf + (x*2) + 0 );
+			if( r != ERROR_OK ){
+				goto fail;
+			}
+			r = dap_queue_ap_read( bulk->dap, AP_MEM_REG_DRW, rd_buf + (x*2) + 1 );
+		} else {
+			r = dap_queue_ap_read( bulk->dap, AP_MEM_REG_DRW, rd_buf + x );
+		}
+		if( r != ERROR_OK ){
+			goto fail;
+		}
+	}
+
+	r = dap_run(bulk->dap);
+	if( r != ERROR_OK ){
+		goto fail;
+	}
+	
+	/* now unpack and put the transfer away */
+	for( x = 0 ; x < bulk->wip_count ; x++ ){
+		int endian;
+		uint32_t b;
+		uint32_t u32;
+		addr = bulk->addr.addr;
+
+		endian = bulk->port->big_endian;
+		for( b = 0 ; b < bulk->size ; b++ ){
+			if( bulk->size == 8 ){
+				u32 = rd_buf[(x*2)+endian];
+			} else {
+				u32 = rd_buf[x];
+			}
+			
+			if( bulk->dap->ti_be_32_quirks) {
+				u32 = u32 >> (8 * (3 - ((addr+b) & 3)));
+			} else {
+				u32 = u32 >> (8 * (((addr+b) & 3)));
+			}
+			((uint8_t *)(bulk->buffer))[b] = ((uint8_t)u32);
+			/* switch endian for 64bit transfers */
+			if( b == 3 ){
+				endian ^= 1;
+			}
+		}
+		bulk->addr.addr += bulk->size;
+		bulk->buffer    += bulk->size;
+		bulk->count     -= 1;
+	}
+	r = ERROR_OK;
+ fail:
+	if( rd_buf ){
+		free( (void *)(rd_buf) );
+	}
+	return r;
+}
+
+
+static int coresight_io_chunk_wr(struct coresight_bulk *bulk )
+{
+	int r;
+	int rewrite_tar;
+	int this_size;
+	int this_count;
+	uint32_t x;
+	uint32_t csw;
+	uint64_t outvalue;
+	uint8_t *buff;
+	uint32_t addr;
+	uint64_t ti_addr_xor;
+	uint64_t ti_addr_xor2;
+	
+	/* Transfer one chunk (bulk->wip_count)
+	 * the TAR will not wrap
+	 */
+	ti_addr_xor  = 0;
+	ti_addr_xor2 = 0;
+	if( bulk->addrinc ){
+		csw = CSW_ADDRINC_SINGLE;
+	} else {
+		csw = CSW_ADDRINC_OFF;
+	}
+
+	switch( bulk->size ){
+	case 1:
+		csw |= CSW_8BIT;
+		ti_addr_xor  = 3;
+		ti_addr_xor2 = 0;
+		break;
+	case 2:
+		csw |= CSW_16BIT;
+		ti_addr_xor  = 2;
+		ti_addr_xor2 = 1;
+		break;
+	case 4:
+		csw |= CSW_32BIT;
+		ti_addr_xor  = 0;
+		ti_addr_xor2 = 3;
+		break;
+	case 8:
+		csw |= CSW_64BIT;
+		ti_addr_xor  = 0;
+		ti_addr_xor2 = 0;
+		break;
+	}
+	/* wackyness is only applicable to TI write only */
+	if( (!(bulk->dap->ti_be_32_quirks)) ||
+		(!(bulk->addrinc)) ){
+		ti_addr_xor  = 0;
+		ti_addr_xor2 = 0;
+	}
+
+	rewrite_tar = true;
+
+	for( x = 0 ; x < bulk->wip_count ; x++ ){
+
+		outvalue   = 0;
+		this_count = 1;
+
+		if( rewrite_tar ){
+			/* we have to rewrite this all the time */
+			rewrite_tar = bulk->dap->ti_be_32_quirks;
+			struct target_addr tmp;
+			tmp = bulk->addr;
+			tmp.addr ^= ti_addr_xor;
+	
+			r = dap_setup_accessport( bulk->dap, csw, &tmp );
+			if( r != ERROR_OK ){
+				goto fail;
+			}
+		}	
+
+		/* FIXME: (Optmization)
+		 *  Determine if we can us packed transfers.
+		 *  Note: Not all dap ports support packed.
+		 *  Also this may be inconsistent on the port.
+		 *  example: port[x] does support it
+		 *  however: port[y] does not support it.
+		 */
+		this_size  = bulk->size;
+		/* INSERT THAT OPTIMIZATION HERE
+		 */
+
+		/* How many source bytes each transfer will consume, and their location in the DRW,
+		 * depends on the type of transfer and alignment. See ARM document IHI0031C. */
+		buff     = bulk->buffer;
+		addr     = bulk->addr.addr;
+		outvalue = 0;
+
+		/* If you are concerned about the TI xors..
+		 * Note that if they do not apply, the values
+		 * are zeroed out, which makes the xor a nop.
+		 *
+		 * This just simplifies the reading and lessens
+		 * the indent level
+		 */
+		switch (this_size) {
+		case 8:
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			break;
+		case 4:
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			break;
+		case 2:
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			break;
+		case 1:
+			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
+			break;
+		}
+		bulk->buffer    = buff;
+		bulk->addr.addr = addr;
+
+		r = ERROR_OK;
+		if( this_size == 8 ){
+			/* ARM IHI 0031B, page: 8-140
+			 * title: Word order for access size larger than word
+			 *
+			 * port is BE, data is BE
+			 * port is LE, data is LE 
+			 */
+			uint64_t ov1, ov2;
+
+			if( bulk->port->big_endian ){
+				ov1 = outvalue >> 32;
+				ov2 = outvalue >> 0;
+			} else {
+				ov1 = outvalue >> 0;
+				ov2 = outvalue >> 32;
+			}
+			
+			r = dap_queue_ap_write( bulk->dap, AP_MEM_REG_DRW, ov1 );
+			if( r == ERROR_OK ){
+				r = dap_queue_ap_write( bulk->dap, AP_MEM_REG_DRW, ov2 );
+			}
+		} else {
+			r = dap_queue_ap_write( bulk->dap, AP_MEM_REG_DRW, outvalue );
+		}
+		if( r != ERROR_OK ){
+			break;
+		}
+		bulk->addr.addr += this_size;
+		bulk->buffer    += this_size;
+		bulk->count     -= this_count;
+	}
+	
+	/* flush at the end of each chunk */
+	if( r == ERROR_OK ){
+		r = dap_run( bulk->dap );
+	}
+ fail:
+	return r;
+}
+
+
+int coresight_io_bulk( struct coresight_bulk *bulk )
+{
+	int r;
+	uint64_t w;
+
+	if( bulk->count == 0 ){
+		return ERROR_OK;
+	}
+
+	/* if 64bit is requested, make sure it is supported */
+	if( bulk->size == 8 ){
+		if( !(bulk->port->data_64bit) ){
+			LOG_ERROR("dap-ap[%d] not 64bit port", bulk->port->port_num );
+			return ERROR_TARGET_UNALIGNED_ACCESS;
+		}
+		if( !(bulk->is_aligned) ){
+			LOG_ERROR("dap-ap[%d] 64bit xfers require 64bit alignment", bulk->port->port_num );
+			return ERROR_TARGET_UNALIGNED_ACCESS;
+		}
+	}
+	
+	if( !(bulk->is_aligned) ){
+		if( !(bulk->port->unaligned_access_ok) ){
+			LOG_ERROR("dap-ap[%d] not aligned", bulk->port->port_num );
+			return ERROR_TARGET_UNALIGNED_ACCESS;
+		}
+	}
+	
+	if( bulk->port->word_only_transfers ){
+		if( bulk->size != 4 ){
+			LOG_ERROR("dap-ap[%d] restricted port word size only", bulk->port->port_num );
+			return ERROR_TARGET_UNALIGNED_ACCESS;
+		}
+	}
+
+	r = ERROR_OK;
+	/* Loop - handling transfer chunks */
+	while( bulk->count ){
+
+		/* Size of this transfer chunk */
+		bulk->wip_count = bulk->count;
+		
+
+		/* During this transfer, will the TAR wrap? */
+		/* If YES - then cut the transfer short */
+		if( bulk->addrinc ){
+			/* it only wraps if tar is incrementing */
+			
+			/* Determine address when TAR wraps. */
+			w = bulk->addr.addr;
+
+			/* Round up to next block */
+			w += (bulk->port->tar_wrap-1);
+			w &= (~(bulk->port->tar_wrap-1));
+
+			/* get num-bytes to wrap */
+			w = w - bulk->addr.addr;
+
+			/* bytes to count of items */
+			w = w / bulk->size;
+
+			if( w == 0 ){
+				/* this happens when the transfer
+				 * is not aligned, and crosses
+				 * the wrap boundary, 
+				 *
+				 * This occurs exactly on the
+				 * single transfer that crosses
+				 * the wrap boundary 
+				 */
+				w = 1;
+			}
+
+			/* If needed, clip the count */
+			if( w < bulk->wip_count ){
+				bulk->wip_count = w;
+			}
+		}
+
+		/* transfer a chunk */
+		if( bulk->rw == 'w' ){
+			r = coresight_io_chunk_wr( bulk );
+		} else {
+			r = coresight_io_chunk_rd( bulk );
+		}
+		if( r != ERROR_OK ){
+			break;
+		}
+	}
+	return r;
+}
+
+
 /**
  * Asynchronous (queued) read of a word from memory or a system register.
  *
@@ -187,46 +679,81 @@ int dap_setup_accessport(struct adiv5_dap *dap, uint32_t csw, uint32_t tar)
  *
  * @return ERROR_OK for success.  Otherwise a fault code.
  */
-int mem_ap_read_u32(struct adiv5_dap *dap, uint32_t address,
+int mem_ap_read_u32(struct adiv5_dap *dap, const struct target_addr *pAddr,
 		uint32_t *value)
 {
 	int retval;
+	int r;
 
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when reading several consecutive addresses.
 	 */
-	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF,
-			address & 0xFFFFFFF0);
+	if( dap_dbg_highlevel ){
+		struct dap_access_log *p;
+		p = dap_dbg_log_entry(dap);
+		if( p ){
+			p->access_type = MEM_AP_RD32;
+			p->address     = pAddr->addr;
+			p->pointer     = value;
+		}
+	}
+	  
+	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF,	pAddr);
 	if (retval != ERROR_OK)
 		return retval;
 
-	return dap_queue_ap_read(dap, AP_REG_BD0 | (address & 0xC), value);
+	r = dap_queue_ap_read(dap, AP_MEM_REG_BD0 | (pAddr->addr & 0xC), value);
+	
+	return r;
 }
 
-/**
- * Synchronous read of a word from memory or a system register.
- * As a side effect, this flushes any queued transactions.
- *
- * @param dap The DAP connected to the MEM-AP performing the read.
- * @param address Address of the 32-bit word to read; it must be
- *	readable by the currently selected MEM-AP.
- * @param value points to where the result will be stored.
- *
- * @return ERROR_OK for success; *value holds the result.
- * Otherwise a fault code.
- */
-int mem_ap_read_atomic_u32(struct adiv5_dap *dap, uint32_t address,
-		uint32_t *value)
+int mem_ap_read_u64(struct adiv5_dap *dap, const struct target_addr *pAddr,
+		uint64_t *value)
 {
+	uint32_t l,h;
 	int retval;
+	int r;
 
-	retval = mem_ap_read_u32(dap, address, value);
+	/* Use banked addressing (REG_BDx) to avoid some link traffic
+	 * (updating TAR) when reading several consecutive addresses.
+	 */
+	if( dap_dbg_highlevel ){
+		struct dap_access_log *p;
+		p = dap_dbg_log_entry(dap);
+		if( p ){
+			p->access_type = MEM_AP_RD64;
+			p->address     = pAddr->addr;
+			p->pointer     = value;
+		}
+	}
+	  
+	retval = dap_setup_accessport(dap, CSW_64BIT | CSW_ADDRINC_OFF, pAddr );
 	if (retval != ERROR_OK)
 		return retval;
 
-	return dap_run(dap);
+	uint64_t a;
+	a = pAddr->addr;
+	
+	r = dap_queue_ap_read(dap, AP_MEM_REG_BD0 | (a & 0xC), &l);
+	if( r != ERROR_OK ){
+		return r;
+	}
+	a += 4;
+	r = dap_queue_ap_read(dap, AP_MEM_REG_BD0 | (a & 0xC), &h);
+	if( r != ERROR_OK ){
+		return r;
+	}
+
+	r = dap_run(dap);
+	
+	*value = h;
+	*value = *value << 32;
+	*value = *value + l;
+	
+	return r;
 }
 
+
 /**
  * Asynchronous (queued) write of a word to memory or a system register.
  *
@@ -238,395 +765,539 @@ int mem_ap_read_atomic_u32(struct adiv5_dap *dap, uint32_t address,
  *
  * @return ERROR_OK for success.  Otherwise a fault code.
  */
-int mem_ap_write_u32(struct adiv5_dap *dap, uint32_t address,
-		uint32_t value)
+int mem_ap_write_u32(struct adiv5_dap *dap, const struct target_addr *pAddr, uint32_t value)
 {
 	int retval;
 
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when writing several consecutive addresses.
 	 */
-	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF,
-			address & 0xFFFFFFF0);
+	if( dap_dbg_highlevel ){
+		struct dap_access_log *p;
+		p = dap_dbg_log_entry(dap);
+		if( p ){
+			p->access_type = MEM_AP_WR32;
+			p->address     = pAddr->addr;
+			p->dataval     = value;
+		}
+	}
+	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF, pAddr );
 	if (retval != ERROR_OK)
 		return retval;
 
-	return dap_queue_ap_write(dap, AP_REG_BD0 | (address & 0xC),
+	return dap_queue_ap_write(dap, AP_MEM_REG_BD0 | (pAddr->addr & 0xC),
 			value);
 }
 
 /**
- * Synchronous write of a word to memory or a system register.
- * As a side effect, this flushes any queued transactions.
+ * Asynchronous (queued) write of a word to memory or a system register.
  *
  * @param dap The DAP connected to the MEM-AP.
  * @param address Address to be written; it must be writable by
  *	the currently selected MEM-AP.
- * @param value Word that will be written.
+ * @param value Word that will be written to the address when transaction
+ *	queue is flushed (assuming no errors).
  *
- * @return ERROR_OK for success; the data was written.  Otherwise a fault code.
+ * @return ERROR_OK for success.  Otherwise a fault code.
  */
-int mem_ap_write_atomic_u32(struct adiv5_dap *dap, uint32_t address,
-		uint32_t value)
+int mem_ap_write_u64(struct adiv5_dap *dap, const struct target_addr *pAddr, uint64_t value)
 {
-	int retval = mem_ap_write_u32(dap, address, value);
+	int retval;
 
+	if( !dap->port[ dap->cached_ap_port ].data_64bit ){
+		LOG_ERROR("target port does not support 64bit data transfers");
+		return ERROR_TARGET_UNALIGNED_ACCESS;
+	}
+
+	/* Use banked addressing (REG_BDx) to avoid some link traffic
+	 * (updating TAR) when writing several consecutive addresses.
+	 */
+	if( dap_dbg_highlevel ){
+		struct dap_access_log *p;
+		p = dap_dbg_log_entry(dap);
+		if( p ){
+			p->access_type = MEM_AP_WR64;
+			p->address     = pAddr->addr;
+			p->dataval     = value;
+		}
+	}
+	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF, pAddr );
 	if (retval != ERROR_OK)
 		return retval;
 
-	return dap_run(dap);
+	uint64_t a;
+	a = pAddr->addr;
+	dap_queue_ap_write(dap, AP_MEM_REG_BD0 | (a & 0xC), value);
+	/* FIX ME handle endianess */
+	value = value >> 32;
+	a += 4;
+	return dap_queue_ap_write(dap, AP_MEM_REG_BD0 | (a & 0xC), value);
 }
 
-/**
- * Synchronous write of a block of memory, using a specific access size.
- *
- * @param dap The DAP connected to the MEM-AP.
- * @param buffer The data buffer to write. No particular alignment is assumed.
- * @param size Which access size to use, in bytes. 1, 2 or 4.
- * @param count The number of writes to do (in size units, not bytes).
- * @param address Address to be written; it must be writable by the currently selected MEM-AP.
- * @param addrinc Whether the target address should be increased for each write or not. This
- *  should normally be true, except when writing to e.g. a FIFO.
- * @return ERROR_OK on success, otherwise an error code.
- */
-int mem_ap_write(struct adiv5_dap *dap, const uint8_t *buffer, uint32_t size, uint32_t count,
-		uint32_t address, bool addrinc)
+static int dap_mem_ap_read_tar( struct adiv5_dap *dap, uint64_t *tar )
 {
-	size_t nbytes = size * count;
-	const uint32_t csw_addrincr = addrinc ? CSW_ADDRINC_SINGLE : CSW_ADDRINC_OFF;
-	uint32_t csw_size;
-	uint32_t addr_xor;
-	int retval;
-
-	/* TI BE-32 Quirks mode:
-	 * Writes on big-endian TMS570 behave very strangely. Observed behavior:
-	 *   size   write address   bytes written in order
-	 *   4      TAR ^ 0         (val >> 24), (val >> 16), (val >> 8), (val)
-	 *   2      TAR ^ 2         (val >> 8), (val)
-	 *   1      TAR ^ 3         (val)
-	 * For example, if you attempt to write a single byte to address 0, the processor
-	 * will actually write a byte to address 3.
-	 *
-	 * To make writes of size < 4 work as expected, we xor a value with the address before
-	 * setting the TAP, and we set the TAP after every transfer rather then relying on
-	 * address increment. */
-
-	if (size == 4) {
-		csw_size = CSW_32BIT;
-		addr_xor = 0;
-	} else if (size == 2) {
-		csw_size = CSW_16BIT;
-		addr_xor = dap->ti_be_32_quirks ? 2 : 0;
-	} else if (size == 1) {
-		csw_size = CSW_8BIT;
-		addr_xor = dap->ti_be_32_quirks ? 3 : 0;
-	} else {
-		return ERROR_TARGET_UNALIGNED_ACCESS;
+	uint32_t l,h;
+	uint64_t tmp;
+	int r;
+
+	h = 0;
+	l = 0;
+	
+	if( dap->port[ dap->cached_ap_port ].addr_64bit ){
+		r = dap_queue_ap_read(dap, AP_MEM_REG_TAR_hi, &h);
+		if( r != ERROR_OK ){
+			return r;
+		}
+	}
+	
+	r = dap_queue_ap_read(dap, AP_MEM_REG_TAR_lo, &l);
+	if( r != ERROR_OK ){
+		return r;
+	}
+	r = dap_run(dap);
+	if( r != ERROR_OK ){
+		return r;
 	}
+	tmp = h;
+	tmp = tmp << 32;
+	tmp = tmp | l;
+	if( tar ){
+		*tar = tmp;
+	}
+	return ERROR_OK;
+}
 
-	if (dap->unaligned_access_bad && (address % size != 0))
-		return ERROR_TARGET_UNALIGNED_ACCESS;
 
-	retval = dap_setup_accessport_tar(dap, address ^ addr_xor);
-	if (retval != ERROR_OK)
-		return retval;
+/*--------------------------------------------------------------------------*/
 
-	while (nbytes > 0) {
-		uint32_t this_size = size;
 
-		/* Select packed transfer if possible */
-		if (addrinc && dap->packed_transfers && nbytes >= 4
-				&& max_tar_block_size(dap->tar_autoincr_block, address) >= 4) {
-			this_size = 4;
-			retval = dap_setup_accessport_csw(dap, csw_size | CSW_ADDRINC_PACKED);
-		} else {
-			retval = dap_setup_accessport_csw(dap, csw_size | csw_addrincr);
-		}
+#define DAP_POWER_DOMAIN_TIMEOUT (10)
 
-		if (retval != ERROR_OK)
-			break;
+/* FIXME don't import ... just initialize as
+ * part of DAP transport setup
+*/
+extern const struct dap_ops jtag_dp_ops;
 
-		/* How many source bytes each transfer will consume, and their location in the DRW,
-		 * depends on the type of transfer and alignment. See ARM document IHI0031C. */
-		uint32_t outvalue = 0;
-		if (dap->ti_be_32_quirks) {
-			switch (this_size) {
-			case 4:
-				outvalue |= (uint32_t)*buffer++ << 8 * (3 ^ (address++ & 3) ^ addr_xor);
-				outvalue |= (uint32_t)*buffer++ << 8 * (3 ^ (address++ & 3) ^ addr_xor);
-				outvalue |= (uint32_t)*buffer++ << 8 * (3 ^ (address++ & 3) ^ addr_xor);
-				outvalue |= (uint32_t)*buffer++ << 8 * (3 ^ (address++ & 3) ^ addr_xor);
-				break;
-			case 2:
-				outvalue |= (uint32_t)*buffer++ << 8 * (1 ^ (address++ & 3) ^ addr_xor);
-				outvalue |= (uint32_t)*buffer++ << 8 * (1 ^ (address++ & 3) ^ addr_xor);
-				break;
-			case 1:
-				outvalue |= (uint32_t)*buffer++ << 8 * (0 ^ (address++ & 3) ^ addr_xor);
-				break;
-			}
-		} else {
-			switch (this_size) {
-			case 4:
-				outvalue |= (uint32_t)*buffer++ << 8 * (address++ & 3);
-				outvalue |= (uint32_t)*buffer++ << 8 * (address++ & 3);
-			case 2:
-				outvalue |= (uint32_t)*buffer++ << 8 * (address++ & 3);
-			case 1:
-				outvalue |= (uint32_t)*buffer++ << 8 * (address++ & 3);
-			}
-		}
+/*--------------------------------------------------------------------------*/
 
-		nbytes -= this_size;
+int target_cs_debugport_init( struct target *target )
+{
+	return dap_debugport_init( target_cs_to_dap(target) );
+}
 
-		retval = dap_queue_ap_write(dap, AP_REG_DRW, outvalue);
-		if (retval != ERROR_OK)
-			break;
 
-		/* Rewrite TAR if it wrapped or we're xoring addresses */
-		if (addrinc && (addr_xor || (address % dap->tar_autoincr_block < size && nbytes > 0))) {
-			retval = dap_setup_accessport_tar(dap, address ^ addr_xor);
-			if (retval != ERROR_OK)
-				break;
-		}
+static const char *dap_idr_to_port_type_name( uint32_t idr_reg )
+{
+	const char *cp;
+	
+	switch( idr_reg & AP_TYPE_MASK ){
+	default:  cp = "unknown"; break;
+	case AP_TYPE_AHB_AP  : cp = "ahb-ap"; break;
+	case AP_TYPE_AHB2_AP : cp = "ahb2-ap"; break;
+	case AP_TYPE_APB_AP  : cp = "apb-ap"; break;
+	case AP_TYPE_APB2_AP : cp = "apb2-ap"; break;
+	case AP_TYPE_AXI_AP  : cp = "axi-ap"; break;
+	case AP_TYPE_JTAG_AP : cp = "jtag-ap"; break;
 	}
+	return cp;
+}
 
-	/* REVISIT: Might want to have a queued version of this function that does not run. */
-	if (retval == ERROR_OK)
-		retval = dap_run(dap);
-
-	if (retval != ERROR_OK) {
-		uint32_t tar;
-		if (dap_queue_ap_read(dap, AP_REG_TAR, &tar) == ERROR_OK
-				&& dap_run(dap) == ERROR_OK)
-			LOG_ERROR("Failed to write memory at 0x%08"PRIx32, tar);
-		else
-			LOG_ERROR("Failed to write memory and, additionally, failed to find out where");
+static int dap_idr_0x14770004( struct adiv5_dap *dap, struct adiv5_dap_port *port )
+{
+	int r;
+	uint32_t reg;
+	
+	/* PER: ARM DDI 0480F, page: 3-182 */
+	LOG_DEBUG( "dap-port[%d] axi with ace", port->port_num );
+
+	r = dap_ap_read( dap, AP_MEM_REG_CSW, &reg );
+	if( r != ERROR_OK ){
+		return r;
+	}
+	/* this dap has a CFG register! wow! */
+	LOG_DEBUG("dap-port[%d] cfg: 0x%08" PRIx32, port->port_num, reg );
+	if( port->cfg_reg_forced ){
+		reg = port->cfg_reg;
+		LOG_DEBUG("dap-port[%d] cfg: 0x%08" PRIx32 " *FORCED*",
+				  port->port_num, reg );
+	} 
+	port->cfg_reg  = reg;
+
+
+	/* read and capture the SBZP csw registers */
+	r = dap_ap_read(dap, AP_MEM_REG_CSW, &reg );
+	if( r != ERROR_OK ){
+		return r;
 	}
+	port->csw_reg_orig = reg;
+	
+	port->csw_reg_default =
+		 /* Table a4-6, protection encoding, IHI-0022E */
+		(1 << 28) | /* [2]=0(data), [1]=0(secure access), [0]=1, privileged */
+		(0 << 24) | /* 0 means"device memory" do what I say! no caching */
+		(3 << 13) | /* all masters included */
+		(0 << 12) | /* FIXME: What do we do with cache coherency? */
+		(0 <<  8) | /* assume NORMAL not barrier */
+		0; /* all other bits are don't care or N/A */
+								  
+	/* these bits the user can specify/override */
+	port->csw_route_cfg_bits =
+		(0x00 << 31) | /* DBGEN does not exist */
+		(0x07 << 28) | /* HPROT bits */
+		(0x0f << 24) | /* CACHE bits */
+		(0x00 << 23) | /* SPIDEN status bit is read only */
+		(0x00 << 15) | /* Reserved, SBZP */
+		(0x03 << 13) | /* Domain */
+		(0x01 << 12) | /* enable ACE transactions */
+		(0x0f <<  8) | /* barrier mode 0 or 8 */
+		(0x00 <<  7) | /* transaction in process {aka: busy} is read only */
+		(0x00 <<  6) | /* debug enabled bit (readonly) */
+		(0x00 <<  4) | /* increment bits */
+		(0x00 <<  0);  /* size bits */
+
+	/* these are the "perserve/reserved" bits */
+	/* figure: 3-201, page 3-182 of DDI-0480-F soc r3p1 trm */
+	port->csw_reg_sbzp_mask = 0x807f8000;
+	
+	/* per ARM DDI 0480F, table: Table 3-227 states always little endian */
+	port->big_endian = false;
+	
+	/* AXI ports vary, use cfg register */
+	port->addr_64bit = !!(port->cfg_reg & 0x02);
+	port->data_64bit = !!(port->cfg_reg & 0x04);
+	
+	/* this is a full featured port */
+	port->word_only_transfers = false;
+	/* axi requires alignment */
+	port->unaligned_access_ok = false;
+	
+	/* table: 3-220, field: addrinc */
+	port->packed_transfers = true;
 
-	return retval;
+	return ERROR_OK;
 }
 
-/**
- * Synchronous read of a block of memory, using a specific access size.
- *
- * @param dap The DAP connected to the MEM-AP.
- * @param buffer The data buffer to receive the data. No particular alignment is assumed.
- * @param size Which access size to use, in bytes. 1, 2 or 4.
- * @param count The number of reads to do (in size units, not bytes).
- * @param address Address to be read; it must be readable by the currently selected MEM-AP.
- * @param addrinc Whether the target address should be increased after each read or not. This
- *  should normally be true, except when reading from e.g. a FIFO.
- * @return ERROR_OK on success, otherwise an error code.
- */
-int mem_ap_read(struct adiv5_dap *dap, uint8_t *buffer, uint32_t size, uint32_t count,
-		uint32_t adr, bool addrinc)
+static int dap_idr_0x14770002( struct adiv5_dap *dap, struct adiv5_dap_port *port )
 {
-	size_t nbytes = size * count;
-	const uint32_t csw_addrincr = addrinc ? CSW_ADDRINC_SINGLE : CSW_ADDRINC_OFF;
-	uint32_t csw_size;
-	uint32_t address = adr;
-	int retval;
-
-	/* TI BE-32 Quirks mode:
-	 * Reads on big-endian TMS570 behave strangely differently than writes.
-	 * They read from the physical address requested, but with DRW byte-reversed.
-	 * For example, a byte read from address 0 will place the result in the high bytes of DRW.
-	 * Also, packed 8-bit and 16-bit transfers seem to sometimes return garbage in some bytes,
-	 * so avoid them. */
-
-	if (size == 4)
-		csw_size = CSW_32BIT;
-	else if (size == 2)
-		csw_size = CSW_16BIT;
-	else if (size == 1)
-		csw_size = CSW_8BIT;
-	else
-		return ERROR_TARGET_UNALIGNED_ACCESS;
+	int r;
+	uint32_t reg;
+	
+	/* Cortex DAP LITE, PER ARM DDI 0316D, table: 2-13 */
+	/* and Section: 2.7.4 */
+	LOG_DEBUG( "dap-port[%d] dap-lite", port->port_num );
+
+	/* the CFG register doesnot exist on the DAP LITE */
+	port->cfg_reg = 0;
+
+	/* read and capture the SBZP csw registers */
+	r = dap_ap_read(dap, AP_MEM_REG_CSW, &reg );
+	if( r != ERROR_OK ){
+		return r;
+	}
+	/* Table 2-14, page 2-35 ddi-316D dap lite trm */
+	/* the DBGSW ENABLE bit must forced on */
+	reg |= 0x80000000;
+	r = dap_ap_write(dap, AP_MEM_REG_CSW, reg );
+	port->csw_reg_orig = reg;
+
+	/* from figure 2-13, ddi-0316d, page 2-34 */
+	port->csw_reg_sbzp_mask = 0x7ffff000;
+		
+	/* there are no configurable bits */
+	port->csw_reg_default = 0;
+
+	/* nothing can be configured on this dap port */
+	port->csw_route_cfg_bits = 0;
+	
+	/* dap-lite does not support big endian */
+	port->big_endian = false;
+	
+	/* dap light does not support big data */
+	port->addr_64bit = false;
+	port->data_64bit = false;
+	
+	/* dap-lite only does word transfers */
+	port->word_only_transfers = true;
+	
+	/* dap-lite does not support unaligned access */
+	port->unaligned_access_ok = false;
+	
+	/* and no packed transfers */
+	port->packed_transfers = false;
 
-	if (dap->unaligned_access_bad && (adr % size != 0))
-		return ERROR_TARGET_UNALIGNED_ACCESS;
+	return ERROR_OK;
+}
 
-	/* Allocate buffer to hold the sequence of DRW reads that will be made. This is a significant
-	 * over-allocation if packed transfers are going to be used, but determining the real need at
-	 * this point would be messy. */
-	uint32_t *read_buf = malloc(count * sizeof(uint32_t));
-	uint32_t *read_ptr = read_buf;
-	if (read_buf == NULL) {
-		LOG_ERROR("Failed to allocate read buffer");
-		return ERROR_FAIL;
+static int dap_idr_0x447700001( struct adiv5_dap *dap, struct adiv5_dap_port *port )
+{
+	int r;
+	uint32_t reg;
+	
+	/* Cortex M1 SEE: ARM DDI0413D, Page: 9-10, Figure: 9-4 */ 
+	LOG_DEBUG("dap-port[%d] cortex-m1 port", port->port_num );
+
+	/* the CFG register does not exist in the M1 dap */
+	port->cfg_reg = 0;
+
+	r = dap_ap_read(dap, AP_MEM_REG_CSW, &reg );
+	if( r != ERROR_OK ){
+		return r;
 	}
+	
+	port->csw_reg_orig = reg;
+
+	port->csw_reg_default =
+		/* From table 9-3, ddi-413D, cortex m1, r1p0 */
+		(3 << 24); /* Reset value is non-cachablenon bufferable data access privileged */
+	
+	port->csw_route_cfg_bits =
+		(15 << 24 ) | /* HPROT is configurable */
+		( 0 << 23 ) | /* SPIDEN = ro bit not configurable */
+		( 0 << 12 ) | /* reserved field */
+		( 0 <<  8 ) | /* MODE is not configurable */
+		( 0 <<  7 ) | /* TrInProg BUSY BIT is Read Only */
+		( 0 <<  6 ) | /* DbgInEn Read Only Bit */
+		( 0 <<  4 ) | /* addr inc */
+		( 0 <<  0 );  /* size */
+
+	/* the perserved bits are */
+	/* ddi 0431D, figure 9-3, page 9-7 */
+	port->csw_reg_sbzp_mask = (0xf07ff000);
+	
+	/* Page 1-2, bullet 1, 7th dash
+	 *
+	 * If your processor has debug, debug 
+	 * resources and debugger accesses 
+	 * are always little-endian.
+	 */
+	port->big_endian = false;
+	
+	port->addr_64bit = false;
+	port->data_64bit = false;
+	
+	/* M1 only does word transfers */
+	port->word_only_transfers = true;
+	
+	/* the M1 does not support unaligned anything */
+	port->unaligned_access_ok = false;
+	
+	/* table: 9-3, page 9-6 packed transfers supported */
+	port->packed_transfers = true;
+	
+	return ERROR_OK;
+}
 
-	retval = dap_setup_accessport_tar(dap, address);
-	if (retval != ERROR_OK) {
-		free(read_buf);
-		return retval;
+
+static int dap_idr_0x44770002( struct adiv5_dap *dap, struct adiv5_dap_port *port )
+{
+	int r;
+	uint32_t csw_reg;
+	
+	/* PER ARM DDI 0480F, Table 3-207 APB-AP */
+	/* Also section: 4.9 */
+	LOG_DEBUG("dap-port[%d]: soc-400 APB port", port->port_num );
+
+	/* the CFG register does not exist */
+	port->cfg_reg = 0;
+	r = dap_ap_read(dap, AP_MEM_REG_CSW, &csw_reg );
+	if( r != ERROR_OK ){
+		return r;
 	}
+	/* we *MUST* enable the debug port */
+	csw_reg |= 0x80000000;
+	r = dap_ap_write(dap, AP_MEM_REG_CSW, csw_reg );
+	if( r != ERROR_OK ){
+		return r;
+	}
+	port->csw_reg_orig = csw_reg;
+	/* figure 3-210, page 3-189, DDI-0480F */
+	port->csw_reg_sbzp_mask = 0x7ffff000;
+
+	/* there is nothing to use for the 'default' */
+	port->csw_reg_default = 0;
+	
+	/* Table 3-229 APB Control/Status Word */
+	/* there are *NO* user configurable bits */
+	port->csw_route_cfg_bits = 0;
+
+	/* Section 4.9.3 Implimentation Features
+	 * The APB-AP does not support the following MEM-AP features:
+	 * Big-endian. All accesses must be to a little-endian memory 
+	 * Sub-word transfers. Only word transfers are supported.		
+	 */
+	port->big_endian = false;
+	
+	/* APB is a debug bus, it is light weight */
+	port->addr_64bit = false;
+	port->data_64bit = false;
+	
+	/* this is a limited port */
+	port->word_only_transfers = true;
+	/* requires alignment */
+	port->unaligned_access_ok = false;
+	
+	/* table: 3-220, field: addrinc */
+	port->packed_transfers = false;
 
-	/* Queue up all reads. Each read will store the entire DRW word in the read buffer. How many
-	 * useful bytes it contains, and their location in the word, depends on the type of transfer
-	 * and alignment. */
-	while (nbytes > 0) {
-		uint32_t this_size = size;
+	return ERROR_OK;
+}
 
-		/* Select packed transfer if possible */
-		if (addrinc && dap->packed_transfers && nbytes >= 4
-				&& max_tar_block_size(dap->tar_autoincr_block, address) >= 4) {
-			this_size = 4;
-			retval = dap_setup_accessport_csw(dap, csw_size | CSW_ADDRINC_PACKED);
-		} else {
-			retval = dap_setup_accessport_csw(dap, csw_size | csw_addrincr);
-		}
-		if (retval != ERROR_OK)
-			break;
 
-		retval = dap_queue_ap_read(dap, AP_REG_DRW, read_ptr++);
-		if (retval != ERROR_OK)
-			break;
+static int dap_idr_0x24770011( struct adiv5_dap *dap, struct adiv5_dap_port *port )
+{
+	int r;
+	uint32_t csw_reg;
+	
+	/* cortex M3 - r2p0 ARM DDI 0337H */
+	LOG_DEBUG("dap-ap[%d]: cortex-m3-r2p0 port", port->port_num );
 
-		nbytes -= this_size;
-		address += this_size;
+	/* the CFG register does not exist */
+	port->cfg_reg = 0;
 
-		/* Rewrite TAR if it wrapped */
-		if (addrinc && address % dap->tar_autoincr_block < size && nbytes > 0) {
-			retval = dap_setup_accessport_tar(dap, address);
-			if (retval != ERROR_OK)
-				break;
-		}
-	}
+	/* 7.2.2 AHB-AP programmers model  */
 
-	if (retval == ERROR_OK)
-		retval = dap_run(dap);
+	r = dap_ap_read( dap, AP_MEM_REG_CSW, &csw_reg );
+	if( r != ERROR_OK ){
+		return r;
+	}
+	
+	port->csw_reg_orig = csw_reg;
+	/* Figure 7-2 */
+	port->csw_reg_sbzp_mask = 0xddfff000;
+	port->csw_reg_default   =
+		(1<<29) | /* debug */
+		(1<<25) | /* hprot = 1 */
+		0; /* no other bits need a default */
+
+	port->csw_route_cfg_bits = (1<<29) | (1 <<25);
+	
+	/* Section 7.2.1 ... */
+	/* AHB-AP transactions are little-endian. */
+	port->big_endian = false;
+	
+	/* Cortex M3 is not 64bit... */
+	port->addr_64bit = false;
+	port->data_64bit = false;
+	
+	/* this is not that limited */
+	port->word_only_transfers = false;
+	/* requires alignment */
+	port->unaligned_access_ok = true;
+	
+	/* Table 7-6 CSW bit assignments - shows it is supported */
+	port->packed_transfers = true;
 
-	/* Restore state */
-	address = adr;
-	nbytes = size * count;
-	read_ptr = read_buf;
+	return ERROR_OK;
+}
 
-	/* If something failed, read TAR to find out how much data was successfully read, so we can
-	 * at least give the caller what we have. */
-	if (retval != ERROR_OK) {
-		uint32_t tar;
-		if (dap_queue_ap_read(dap, AP_REG_TAR, &tar) == ERROR_OK
-				&& dap_run(dap) == ERROR_OK) {
-			LOG_ERROR("Failed to read memory at 0x%08"PRIx32, tar);
-			if (nbytes > tar - address)
-				nbytes = tar - address;
-		} else {
-			LOG_ERROR("Failed to read memory and, additionally, failed to find out where");
-			nbytes = 0;
-		}
+static int dap_idr_UNKNOWN( struct adiv5_dap *dap, struct adiv5_dap_port *port )
+{
+	int r;
+	uint32_t csw;
+		
+	LOG_ERROR("dap-ap[%d]: mem-ap IDR value 0x%08" PRIx32,
+			  port->port_num, port->idr_reg );
+
+	/* Lets make some assumptions */
+	/* assume no CFG reg */
+	port->cfg_reg = 0;
+
+	r = dap_ap_read( dap, AP_MEM_REG_CSW, &csw);
+	if( r != ERROR_OK ){
+		return r;
 	}
+	port->csw_reg_orig       = csw;
+	port->csw_reg_sbzp_mask  = 0xFFFFF000;
+	port->csw_reg_default    = csw & 0xFFFFF000;
+	/* assume all upper bits are configurable */
+	port->csw_route_cfg_bits = 0xfffff000;
+		
 
-	/* Replay loop to populate caller's buffer from the correct word and byte lane */
-	while (nbytes > 0) {
-		uint32_t this_size = size;
-
-		if (addrinc && dap->packed_transfers && nbytes >= 4
-				&& max_tar_block_size(dap->tar_autoincr_block, address) >= 4) {
-			this_size = 4;
-		}
+	/* assume little endian */
+	port->big_endian = false;
 
-		if (dap->ti_be_32_quirks) {
-			switch (this_size) {
-			case 4:
-				*buffer++ = *read_ptr >> 8 * (3 - (address++ & 3));
-				*buffer++ = *read_ptr >> 8 * (3 - (address++ & 3));
-			case 2:
-				*buffer++ = *read_ptr >> 8 * (3 - (address++ & 3));
-			case 1:
-				*buffer++ = *read_ptr >> 8 * (3 - (address++ & 3));
-			}
-		} else {
-			switch (this_size) {
-			case 4:
-				*buffer++ = *read_ptr >> 8 * (address++ & 3);
-				*buffer++ = *read_ptr >> 8 * (address++ & 3);
-			case 2:
-				*buffer++ = *read_ptr >> 8 * (address++ & 3);
-			case 1:
-				*buffer++ = *read_ptr >> 8 * (address++ & 3);
-			}
-		}
+	/* and 32bit */
+	port->addr_64bit = false;
+	port->data_64bit = false;
 
-		read_ptr++;
-		nbytes -= this_size;
-	}
+	port->word_only_transfers = true;
+	port->packed_transfers = false;
 
-	free(read_buf);
-	return retval;
+	return ERROR_OK;
 }
 
-/*--------------------------------------------------------------------*/
-/*          Wrapping function with selection of AP                    */
-/*--------------------------------------------------------------------*/
-int mem_ap_sel_read_u32(struct adiv5_dap *swjdp, uint8_t ap,
-		uint32_t address, uint32_t *value)
+static int dap_ap_class_none( struct adiv5_dap *dap, struct adiv5_dap_port *port )
 {
-	dap_ap_select(swjdp, ap);
-	return mem_ap_read_u32(swjdp, address, value);
+	LOG_DEBUG("dap-ap[%d] ignored", port->port_num );
+	return ERROR_OK;
 }
 
-int mem_ap_sel_write_u32(struct adiv5_dap *swjdp, uint8_t ap,
-		uint32_t address, uint32_t value)
-{
-	dap_ap_select(swjdp, ap);
-	return mem_ap_write_u32(swjdp, address, value);
-}
 
-int mem_ap_sel_read_atomic_u32(struct adiv5_dap *swjdp, uint8_t ap,
-		uint32_t address, uint32_t *value)
+static int dap_ap_class_mem( struct adiv5_dap *dap, struct adiv5_dap_port *port )
 {
-	dap_ap_select(swjdp, ap);
-	return mem_ap_read_atomic_u32(swjdp, address, value);
-}
+	int r;
+	uint32_t rombase_reg;
+	
+	dap_ap_select( dap, port->port_num );
+		
+	r = dap_ap_read(dap, AP_MEM_REG_BASE, &rombase_reg );
+	if( r != ERROR_OK ){
+		return r;
+	}
 
-int mem_ap_sel_write_atomic_u32(struct adiv5_dap *swjdp, uint8_t ap,
-		uint32_t address, uint32_t value)
-{
-	dap_ap_select(swjdp, ap);
-	return mem_ap_write_atomic_u32(swjdp, address, value);
-}
+	LOG_DEBUG("dap-port[%d] rom: 0x%08" PRIx32, port->port_num, rombase_reg );
+	port->rom_base = rombase_reg;
 
-int mem_ap_sel_read_buf(struct adiv5_dap *swjdp, uint8_t ap,
-		uint8_t *buffer, uint32_t size, uint32_t count, uint32_t address)
-{
-	dap_ap_select(swjdp, ap);
-	return mem_ap_read(swjdp, buffer, size, count, address, true);
-}
+	/* set some common defaults */
+	/* these are the most restrictive */
+	port->memaccess_tck        = 8;
+	port->packed_transfers     = false;
+	port->tar_wrap             = 1024;
+	port->word_only_transfers  = true;
+	port->big_endian           = false;
+	port->addr_64bit           = false;
+	port->data_64bit           = false;
+	port->unaligned_access_ok  = false;
 
-int mem_ap_sel_write_buf(struct adiv5_dap *swjdp, uint8_t ap,
-		const uint8_t *buffer, uint32_t size, uint32_t count, uint32_t address)
-{
-	dap_ap_select(swjdp, ap);
-	return mem_ap_write(swjdp, buffer, size, count, address, true);
-}
 
-int mem_ap_sel_read_buf_noincr(struct adiv5_dap *swjdp, uint8_t ap,
-		uint8_t *buffer, uint32_t size, uint32_t count, uint32_t address)
-{
-	dap_ap_select(swjdp, ap);
-	return mem_ap_read(swjdp, buffer, size, count, address, false);
-}
+	/* handle each different type of port */
 
-int mem_ap_sel_write_buf_noincr(struct adiv5_dap *swjdp, uint8_t ap,
-		const uint8_t *buffer, uint32_t size, uint32_t count, uint32_t address)
-{
-	dap_ap_select(swjdp, ap);
-	return mem_ap_write(swjdp, buffer, size, count, address, false);
+	switch( port->idr_reg ){
+	default:
+		r = dap_idr_UNKNOWN( dap, port );
+		break;
+	case 0x14770004:
+		r = dap_idr_0x14770004( dap, port );
+		break;
+	case 0x14770002:
+		r = dap_idr_0x14770002( dap, port );
+		break;
+	case 0x44770001:
+		r = dap_idr_0x447700001( dap, port );
+		break;
+	case 0x44770002:
+		r = dap_idr_0x44770002( dap, port );
+		break;
+	case 0x24770011:
+		r = dap_idr_0x24770011( dap, port );
+		break;
+	}
+	
+	if (dap->ti_be_32_quirks){
+		/* it lies */
+		/* Packed transfers on TI BE-32 processors do not work correctly in
+		 * many cases. */
+		port->packed_transfers = false;
+		
+		/* and 64bit support is uknown to me
+		 * default to safe 32bit view
+		 */
+		port->addr_64bit       = false;
+		port->addr_64bit       = false;
+	}
+	return r;
 }
 
-/*--------------------------------------------------------------------------*/
-
-
-#define DAP_POWER_DOMAIN_TIMEOUT (10)
-
-/* FIXME don't import ... just initialize as
- * part of DAP transport setup
-*/
-extern const struct dap_ops jtag_dp_ops;
-
-/*--------------------------------------------------------------------------*/
 
 /**
  * Initialize a DAP.  This sets up the power domains, prepares the DP
@@ -640,116 +1311,126 @@ extern const struct dap_ops jtag_dp_ops;
  * in layering.  (JTAG is useful without any debug target; but not SWD.)
  * And this may not even use an AHB-AP ... e.g. DAP-Lite uses an APB-AP.
  */
-int ahbap_debugport_init(struct adiv5_dap *dap)
+int dap_debugport_init(struct adiv5_dap *dap)
 {
-	int retval;
-
+	int r;
+	int x;
+	struct adiv5_dap_port *port;
+	
 	LOG_DEBUG(" ");
 
+	dap->port_types_done = false;	
+	/* invalidate what we know about the dap */
+	dap->cached_ap_port       = -1;
+	dap->cached_dp_bank_value = -1;
+	
+	
 	/* Default MEM-AP setup.
-	 *
-	 * REVISIT AP #0 may be an inappropriate default for this.
-	 * Should we probe, or take a hint from the caller?
 	 * Presumably we can ignore the possibility of multiple APs.
 	 */
-	/*SQU: Should not hard coded it. Let's hard coded in cortex-m and cortex-a for now
-	dap->ap_current = !0;
-	dap_ap_select(dap, 0);*/
 	dap->last_read = NULL;
 
-	/* DP initialization */
 
-	dap->dp_bank_value = 0;
-
-	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
-	if (retval != ERROR_OK)
-		return retval;
+	r = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
+	if (r != ERROR_OK)
+		return r;
 
-	retval = dap_queue_dp_write(dap, DP_CTRL_STAT, SSTICKYERR);
-	if (retval != ERROR_OK)
-		return retval;
+	r = dap_queue_dp_write(dap, DP_CTRL_STAT, SSTICKYERR);
+	if (r != ERROR_OK)
+		return r;
 
-	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
-	if (retval != ERROR_OK)
-		return retval;
+	r = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
+	if (r != ERROR_OK)
+		return r;
 
 	dap->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
-	retval = dap_queue_dp_write(dap, DP_CTRL_STAT, dap->dp_ctrl_stat);
-	if (retval != ERROR_OK)
-		return retval;
+	r = dap_queue_dp_write(dap, DP_CTRL_STAT, dap->dp_ctrl_stat);
+	if (r != ERROR_OK)
+		return r;
 
 	/* Check that we have debug power domains activated */
 	LOG_DEBUG("DAP: wait CDBGPWRUPACK");
-	retval = dap_dp_poll_register(dap, DP_CTRL_STAT,
+	r = dap_dp_poll_register(dap, DP_CTRL_STAT,
 				      CDBGPWRUPACK, CDBGPWRUPACK,
 				      DAP_POWER_DOMAIN_TIMEOUT);
-	if (retval != ERROR_OK)
-		return retval;
+	if (r != ERROR_OK)
+		return r;
 
 	/*LOG_DEBUG("DAP: wait CSYSPWRUPACK");
-	retval = dap_dp_poll_register(dap, DP_CTRL_STAT,
+	r = dap_dp_poll_register(dap, DP_CTRL_STAT,
 				      CSYSPWRUPACK, CSYSPWRUPACK,
 				      DAP_POWER_DOMAIN_TIMEOUT);
-	if (retval != ERROR_OK)
-		//return retval; SQU: for QCOM chip, ignore this as without bootloader, this bit might be not set
+	if (r != ERROR_OK)
+		//return r; SQU: for QCOM chip, ignore this as without bootloader, this bit might be not set
         LOG_USER("DAP: Timeout for waiting CSYSPWRUPACK");*/
 
-	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
-	if (retval != ERROR_OK)
-		return retval;
+	r = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
+	if (r != ERROR_OK)
+		return r;
 	/* With debug power on we can activate OVERRUN checking */
 	dap->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ | CORUNDETECT;
-	retval = dap_queue_dp_write(dap, DP_CTRL_STAT, dap->dp_ctrl_stat);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* check that we support packed transfers */
-	uint32_t csw, cfg;
-
-	retval = dap_setup_accessport(dap, CSW_8BIT | CSW_ADDRINC_PACKED, 0);
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = dap_queue_ap_read(dap, AP_REG_CSW, &csw);
-	if (retval != ERROR_OK)
-		return retval;
-
-	//retval = dap_queue_ap_read(dap, AP_REG_CFG, &cfg); SQU: for Krait this will cause problem
-    cfg=0xF;
-	if (retval != ERROR_OK)
-		return retval;
-
-	retval = dap_run(dap);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if (csw & CSW_ADDRINC_PACKED)
-		dap->packed_transfers = true;
-	else
-		dap->packed_transfers = false;
-
-	/* Packed transfers on TI BE-32 processors do not work correctly in
-	 * many cases. */
-	if (dap->ti_be_32_quirks)
-		dap->packed_transfers = false;
-
-	LOG_DEBUG("MEM_AP Packed Transfers: %s",
-			dap->packed_transfers ? "enabled" : "disabled");
+	r = dap_queue_dp_write(dap, DP_CTRL_STAT, dap->dp_ctrl_stat);
+	if (r != ERROR_OK)
+		return r;
+	r = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
+	if (r != ERROR_OK)
+		return r;
+
+	/*
+	 * Need to find the AHB port, with a DAP ROM
+	 * We assume that all ports act like that port 
+	 */
 
-	/* The ARM ADI spec leaves implementation-defined whether unaligned
-	 * memory accesses work, only work partially, or cause a sticky error.
-	 * On TI BE-32 processors, reads seem to return garbage in some bytes
-	 * and unaligned writes seem to cause a sticky error.
-	 * TODO: it would be nice to have a way to detect whether unaligned
-	 * operations are supported on other processors. */
-	dap->unaligned_access_bad = dap->ti_be_32_quirks;
+	
+	/* invalidate ap cache */
+	for( x = 0 ; x < 256 ; x++ ){
+		dap->port[ x ].port_num = x;
+	}
+	
+	for( x = 0 ; x < 256 ; x++ ){
+		uint32_t i_reg;
+		port = &(dap->port[ x ]);
+		
+		dap_ap_select( dap, port->port_num );
+		dap_queue_ap_read( dap, AP_REG_IDR , &i_reg );
+		r = dap_run( dap );
+		if( r != ERROR_OK ){
+			continue;
+		}
 
-	LOG_DEBUG("MEM_AP CFG: large data %d, long address %d, big-endian %d",
-			!!(cfg & 0x04), !!(cfg & 0x02), !!(cfg & 0x01));
+		const char *port_type_name;
+		port_type_name = dap_idr_to_port_type_name( i_reg );
+		
+		if( (i_reg != 0) || (port->idr_reg_forced) ){
+			LOG_DEBUG("dap-port[%d] idr: 0x%08" PRIx32 " (%s)",
+					  port->port_num, i_reg, port_type_name );
+		}
+		/* if this was "forced" - then used the forced value */
+		if( port->idr_reg_forced ){
+			i_reg = port->idr_reg;
+			port_type_name = dap_idr_to_port_type_name( i_reg );
+			
+			LOG_DEBUG("dap-port[%d] idr: 0x%08" PRIx32 " *FORCED* (%s)",
+					  port->port_num, i_reg, port_type_name );
+		}
+		
+		port->idr_reg  = i_reg;
+		if( i_reg == 0 ){
+			continue;
+		}
 
+		switch( i_reg & AP_CLASS_MASK ){
+		default:
+			/* we don't care about this */
+			break;
+		case AP_CLASS_MEM:
+			dap_ap_class_mem( dap, port );
+			break;
+		case AP_CLASS_NONE:
+			dap_ap_class_none( dap, port );
+			break;
+		}
+	}
 	return ERROR_OK;
 }
 
@@ -770,25 +1451,27 @@ static bool is_dap_cid_ok(uint32_t cid3, uint32_t cid2, uint32_t cid1, uint32_t
 			&& ((cid1 & 0x0f) == 0) && cid0 == 0x0d;
 }
 
+
 /*
  * This function checks the ID for each access port to find the requested Access Port type
  */
-int dap_find_ap(struct adiv5_dap *dap, enum ap_type type_to_find, uint8_t *ap_num_out)
+int target_cs_find_ap(struct target *target, enum ap_type type_to_find, uint8_t *ap_num_out)
 {
 	int ap;
+	uint32_t id_val;
+	struct adiv5_dap *dap;
+
+	dap = target_cs_to_dap(target);
+	
+	/* Determine all port types */
+	if( ! (dap->port_types_done) ){
+		dap_debugport_init( dap );
+	}
+	
+		
+	for (ap = 0; ap < 256; ap++) {
 
-	/* Maximum AP number is 255 since the SELECT register is 8 bits */
-	for (ap = 0; ap <= 255; ap++) {
-
-		/* read the IDR register of the Access Port */
-		uint32_t id_val = 0;
-		dap_ap_select(dap, ap);
-
-		int retval = dap_queue_ap_read(dap, AP_REG_IDR, &id_val);
-		if (retval != ERROR_OK)
-			return retval;
-
-		retval = dap_run(dap);
+		id_val = dap->port[ap].idr_reg;
 
 		/* IDR bits:
 		 * 31-28 : Revision
@@ -802,43 +1485,53 @@ int dap_find_ap(struct adiv5_dap *dap, enum ap_type type_to_find, uint8_t *ap_nu
 		/* Reading register for a non-existant AP should not cause an error,
 		 * but just to be sure, try to continue searching if an error does happen.
 		 */
-		if ((retval == ERROR_OK) &&                  /* Register read success */
-			((id_val & 0x0FFF0000) == 0x04770000) && /* Jedec codes match */
-			((id_val & 0xFF) == type_to_find)) {     /* type matches. SQU: updated based on ADI V5+*/
-
-			LOG_DEBUG("Found %s at AP index: %d (IDR=0x%08" PRIX32 ")",
-						(type_to_find == AP_TYPE_AHB_AP)  ? "AHB-AP"  :
-						(type_to_find == AP_TYPE_APB_AP)  ? "APB-AP"  :
-						(type_to_find == AP_TYPE_JTAG_AP) ? "JTAG-AP" :
-						(type_to_find == AP_TYPE_AXI_AP)  ? "AXI-AP"  : "Unknown",
-						ap, id_val);
-
-			*ap_num_out = ap;
-			return ERROR_OK;
+		if ((id_val & 0x0FFF0000) == 0x04770000){
+			/* not ARM */
+			continue;
 		}
+		if ( ((int)((id_val & 0xFF))) != ((int)(type_to_find))){
+			continue;
+		}
+		
+
+		LOG_DEBUG("dap-port[%d] type: %s, idr=0x%08" PRIx32,
+				  ap, dap_idr_to_port_type_name( id_val ), id_val );
+		
+		*ap_num_out = ap;
+		return ERROR_OK;
 	}
 
-	LOG_DEBUG("No %s found",
-				(type_to_find == AP_TYPE_AHB_AP)  ? "AHB-AP"  :
-				(type_to_find == AP_TYPE_APB_AP)  ? "APB-AP"  :
-				(type_to_find == AP_TYPE_JTAG_AP) ? "JTAG-AP" : "Unknown");
+	LOG_DEBUG("dap: no port type: %s found", dap_idr_to_port_type_name(type_to_find));
 	return ERROR_FAIL;
 }
 
-int dap_get_debugbase(struct adiv5_dap *dap, int ap,
+int target_cs_get_debugbase2( struct target *target, const struct target_addr *p, uint32_t *dbgbase, uint32_t *apid )
+{
+	int ap;
+
+	ap = target_addr_to_dap_port( p );
+	if( ap < 0 ){
+		LOG_ERROR("dap-port[ERROR] invalid: %d", ap );
+		return ERROR_FAIL;
+	}
+
+	return target_cs_get_debugbase( target, ap, dbgbase, apid );
+}
+		
+
+int target_cs_get_debugbase( struct target *target, int ap,
 			uint32_t *dbgbase, uint32_t *apid)
 {
-	uint32_t ap_old;
+	struct adiv5_dap *dap = target_cs_to_dap( target );
 	int retval;
 
 	/* AP address is in bits 31:24 of DP_SELECT */
 	if (ap >= 256)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
-	ap_old = dap->ap_current;
-	dap_ap_select(dap, ap);
+	dap_ap_select(dap, ap );
 
-	retval = dap_queue_ap_read(dap, AP_REG_BASE, dbgbase);
+	retval = dap_queue_ap_read(dap, AP_MEM_REG_BASE, dbgbase);
 	if (retval != ERROR_OK)
 		return retval;
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, apid);
@@ -848,44 +1541,58 @@ int dap_get_debugbase(struct adiv5_dap *dap, int ap,
 	if (retval != ERROR_OK)
 		return retval;
 
-	dap_ap_select(dap, ap_old);
 
 	return ERROR_OK;
 }
 
-int dap_lookup_cs_component(struct adiv5_dap *dap, int ap,
-			uint32_t dbgbase, uint8_t type, uint32_t *addr, int32_t *idx)
+struct dap_rom_io {
+	struct adiv5_dap *dap;
+	struct target_addr base_addr;
+};
+
+static int dap_rom_read( struct dap_rom_io *p, uint32_t ofset, uint32_t *val )
+{
+	struct target_addr a;
+	int r;
+
+	a = p->base_addr;
+	a.addr += ofset;
+
+	r =  mem_ap_read_atomic_u32( p->dap, &a, val );
+	return r;
+}
+
+int target_cs_lookup_component(struct target *target,
+			       const struct target_addr *pAddr,
+			       uint32_t dbgbase, uint8_t type, uint32_t *addr, int32_t *idx)
 {
-	uint32_t ap_old;
+	struct dap_rom_io io;
 	uint32_t romentry, entry_offset = 0, component_base, devtype;
 	int retval;
 
-	if (ap >= 256)
-		return ERROR_COMMAND_SYNTAX_ERROR;
-
+	io.dap = target_cs_to_dap(target);
+	io.base_addr = *pAddr;
+	
 	*addr = 0;
-	ap_old = dap->ap_current;
-	dap_ap_select(dap, ap);
 
 	do {
-		retval = mem_ap_read_atomic_u32(dap, (dbgbase&0xFFFFF000) |
-						entry_offset, &romentry);
+		retval = dap_rom_read(&io, (dbgbase&0xFFFFF000) | entry_offset, &romentry);
 		if (retval != ERROR_OK)
 			return retval;
 
-		component_base = (dbgbase & 0xFFFFF000)
-			+ (romentry & 0xFFFFF000);
+		component_base = (dbgbase & 0xFFFFF000) + (romentry & 0xFFFFF000);
 
 		if (romentry & 0x1) {
 			uint32_t c_cid1;
-			retval = mem_ap_read_atomic_u32(dap, component_base | 0xff4, &c_cid1);
+			retval = dap_rom_read(&io, component_base | 0xff4, &c_cid1);
 			if (retval != ERROR_OK) {
 				LOG_ERROR("Can't read component with base address 0x%" PRIx32
 					  ", the corresponding core might be turned off", component_base);
 				return retval;
 			}
 			if (((c_cid1 >> 4) & 0x0f) == 1) {
-				retval = dap_lookup_cs_component(dap, ap, component_base,
+				/* Nested ROM TABLE */
+				retval = target_cs_lookup_component(target, pAddr, component_base,
 							type, addr, idx);
 				if (retval == ERROR_OK)
 					break;
@@ -893,24 +1600,25 @@ int dap_lookup_cs_component(struct adiv5_dap *dap, int ap,
 					return retval;
 			}
 
-			retval = mem_ap_read_atomic_u32(dap,
+			retval = dap_rom_read( &io, 
 					(component_base & 0xfffff000) | 0xfcc,
 					&devtype);
 			if (retval != ERROR_OK)
 				return retval;
 			if ((devtype & 0xff) == type) {
 				if (!*idx) {
+					/* FOUND! This one! */
 					*addr = component_base;
 					break;
-				} else
+				} else {
+					/* not found yet */
 					(*idx)--;
+				}
 			}
 		}
 		entry_offset += 4;
 	} while (romentry > 0);
 
-	dap_ap_select(dap, ap_old);
-
 	if (!*addr)
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 
@@ -918,13 +1626,18 @@ int dap_lookup_cs_component(struct adiv5_dap *dap, int ap,
 }
 
 static int dap_rom_display(struct command_context *cmd_ctx,
-				struct adiv5_dap *dap, int ap, uint32_t dbgbase, int depth)
+				struct adiv5_dap *_dap, int ap, uint32_t dbgbase, int depth)
 {
+	struct dap_rom_io io;	
 	int retval;
 	uint32_t cid0, cid1, cid2, cid3, memtype, romentry;
 	uint16_t entry_offset;
 	char tabs[7] = "";
 
+	io.dap = _dap;
+	TARGET_ADDR_INIT( &io.base_addr, 0 );
+	io.base_addr.route = ap + TA_ROUTE_arm_dap0;
+	
 	if (depth > 16) {
 		command_print(cmd_ctx, "\tTables too deep");
 		return ERROR_FAIL;
@@ -940,22 +1653,22 @@ static int dap_rom_display(struct command_context *cmd_ctx,
 		command_print(cmd_ctx, "\t%sROM table in legacy format", tabs);
 
 	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
-	retval = mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFF0, &cid0);
+	retval = dap_rom_read(&io, (dbgbase&0xFFFFF000) | 0xFF0, &cid0);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFF4, &cid1);
+	retval = dap_rom_read(&io, (dbgbase&0xFFFFF000) | 0xFF4, &cid1);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFF8, &cid2);
+	retval = dap_rom_read(&io, (dbgbase&0xFFFFF000) | 0xFF8, &cid2);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFFC, &cid3);
+	retval = dap_rom_read(&io, (dbgbase&0xFFFFF000) | 0xFFC, &cid3);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = mem_ap_read_u32(dap, (dbgbase&0xFFFFF000) | 0xFCC, &memtype);
+	retval = dap_rom_read(&io, (dbgbase&0xFFFFF000) | 0xFCC, &memtype);
 	if (retval != ERROR_OK)
 		return retval;
-	retval = dap_run(dap);
+	retval = dap_run(io.dap);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -974,7 +1687,7 @@ static int dap_rom_display(struct command_context *cmd_ctx,
 
 	/* Now we read ROM table entries from dbgbase&0xFFFFF000) | 0x000 until we get 0x00000000 */
 	for (entry_offset = 0; ; entry_offset += 4) {
-		retval = mem_ap_read_atomic_u32(dap, (dbgbase&0xFFFFF000) | entry_offset, &romentry);
+		retval = dap_rom_read( &io, (dbgbase&0xFFFFF000) | entry_offset, &romentry);
 		if (retval != ERROR_OK)
 			return retval;
 		command_print(cmd_ctx, "\t%sROMTABLE[0x%x] = 0x%" PRIx32 "",
@@ -989,43 +1702,43 @@ static int dap_rom_display(struct command_context *cmd_ctx,
 			component_base = (dbgbase & 0xFFFFF000) + (romentry & 0xFFFFF000);
 
 			/* IDs are in last 4K section */
-			retval = mem_ap_read_atomic_u32(dap, component_base + 0xFE0, &c_pid0);
+			retval = dap_rom_read( &io, component_base + 0xFE0, &c_pid0);
 			if (retval != ERROR_OK) {
 				command_print(cmd_ctx, "\t%s\tCan't read component with base address 0x%" PRIx32
 					      ", the corresponding core might be turned off", tabs, component_base);
 				continue;
 			}
 			c_pid0 &= 0xff;
-			retval = mem_ap_read_atomic_u32(dap, component_base + 0xFE4, &c_pid1);
+			retval = dap_rom_read( &io, component_base + 0xFE4, &c_pid1);
 			if (retval != ERROR_OK)
 				return retval;
 			c_pid1 &= 0xff;
-			retval = mem_ap_read_atomic_u32(dap, component_base + 0xFE8, &c_pid2);
+			retval = dap_rom_read(&io, component_base + 0xFE8, &c_pid2);
 			if (retval != ERROR_OK)
 				return retval;
 			c_pid2 &= 0xff;
-			retval = mem_ap_read_atomic_u32(dap, component_base + 0xFEC, &c_pid3);
+			retval = dap_rom_read(&io, component_base + 0xFEC, &c_pid3);
 			if (retval != ERROR_OK)
 				return retval;
 			c_pid3 &= 0xff;
-			retval = mem_ap_read_atomic_u32(dap, component_base + 0xFD0, &c_pid4);
+			retval = dap_rom_read(&io, component_base + 0xFD0, &c_pid4);
 			if (retval != ERROR_OK)
 				return retval;
 			c_pid4 &= 0xff;
 
-			retval = mem_ap_read_atomic_u32(dap, component_base + 0xFF0, &c_cid0);
+			retval = dap_rom_read(&io, component_base + 0xFF0, &c_cid0);
 			if (retval != ERROR_OK)
 				return retval;
 			c_cid0 &= 0xff;
-			retval = mem_ap_read_atomic_u32(dap, component_base + 0xFF4, &c_cid1);
+			retval = dap_rom_read(&io, component_base + 0xFF4, &c_cid1);
 			if (retval != ERROR_OK)
 				return retval;
 			c_cid1 &= 0xff;
-			retval = mem_ap_read_atomic_u32(dap, component_base + 0xFF8, &c_cid2);
+			retval = dap_rom_read(&io, component_base + 0xFF8, &c_cid2);
 			if (retval != ERROR_OK)
 				return retval;
 			c_cid2 &= 0xff;
-			retval = mem_ap_read_atomic_u32(dap, component_base + 0xFFC, &c_cid3);
+			retval = dap_rom_read(&io, component_base + 0xFFC, &c_cid3);
 			if (retval != ERROR_OK)
 				return retval;
 			c_cid3 &= 0xff;
@@ -1045,7 +1758,7 @@ static int dap_rom_display(struct command_context *cmd_ctx,
 				unsigned minor;
 				const char *major = "Reserved", *subtype = "Reserved";
 
-				retval = mem_ap_read_atomic_u32(dap,
+				retval = dap_rom_read(&io,
 						(component_base & 0xfffff000) | 0xfcc,
 						&devtype);
 				if (retval != ERROR_OK)
@@ -1338,7 +2051,7 @@ static int dap_rom_display(struct command_context *cmd_ctx,
 
 			/* ROM Table? */
 			if (((c_cid1 >> 4) & 0x0f) == 1) {
-				retval = dap_rom_display(cmd_ctx, dap, ap, component_base, depth + 1);
+				retval = dap_rom_display(cmd_ctx, io.dap, ap, component_base, depth + 1);
 				if (retval != ERROR_OK)
 					return retval;
 			}
@@ -1353,21 +2066,23 @@ static int dap_rom_display(struct command_context *cmd_ctx,
 	return ERROR_OK;
 }
 
-static int dap_info_command(struct command_context *cmd_ctx,
-		struct adiv5_dap *dap, int ap)
+static int dap_info_command(struct command_context *cmd_ctx, struct adiv5_dap *dap, int ap )
 {
 	int retval;
 	uint32_t dbgbase, apid;
 	int romtable_present = 0;
 	uint8_t mem_ap;
-	uint32_t ap_old;
+	struct dap_rom_io io;
+	struct target *target = get_current_target(cmd_ctx);
 
-	retval = dap_get_debugbase(dap, ap, &dbgbase, &apid);
+	io.dap = dap;
+	TARGET_ADDR_INIT( &io.base_addr, 0 );
+	io.base_addr.route = TA_ROUTE_arm_dap0 + ap;
+	retval = target_cs_get_debugbase(target, ap, &dbgbase, &apid);
 	if (retval != ERROR_OK)
 		return retval;
 
-	ap_old = dap->ap_current;
-	dap_ap_select(dap, ap);
+	dap_ap_select(dap, ap );
 
 	/* Now we read ROM table ID registers, ref. ARM IHI 0029B sec  */
 	mem_ap = ((apid&0x10000) && ((apid&0x0F) != 0));
@@ -1401,63 +2116,99 @@ static int dap_info_command(struct command_context *cmd_ctx,
 		dap_rom_display(cmd_ctx, dap, ap, dbgbase, 0);
 	} else
 		command_print(cmd_ctx, "\tNo ROM table present");
-	dap_ap_select(dap, ap_old);
 
 	return ERROR_OK;
 }
 
+COMMAND_HANDLER(handle_dap_log_command)
+{
+	int v;
+	int r;
+	switch(CMD_ARGC){
+	default:
+		r = ERROR_COMMAND_SYNTAX_ERROR;
+		break;
+	case 0:
+		command_print(CMD_CTX, "low: %d, high: %d\n", dap_dbg_lowlevel, dap_dbg_highlevel );
+		r = ERROR_OK;
+		break;
+	case 2:
+		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], v );
+		if( 0 == strcmp( CMD_ARGV[0], "low" )){
+			dap_dbg_lowlevel = v;
+			r = ERROR_OK;
+			break;
+		}
+		if( 0 == strcmp( CMD_ARGV[0], "high" )){
+			dap_dbg_highlevel = v;
+			r = ERROR_OK;
+			break;
+		}
+		r = ERROR_COMMAND_SYNTAX_ERROR;
+		break;
+	}
+	return r;
+}
+
 COMMAND_HANDLER(handle_dap_info_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
-	uint32_t apsel;
+	struct adiv5_dap *dap = target_cs_to_dap(target);
 
 	switch (CMD_ARGC) {
 	case 0:
-		apsel = dap->apsel;
+		/* no change to setting */
 		break;
 	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
+		{
+			uint32_t x;
+			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], x);
+			if( x > 255 ){
+				/* invalid */
+				return ERROR_COMMAND_SYNTAX_ERROR;
+			}
+			dap->ap_cmd_sel = x;
+		}
 		break;
 	default:
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	return dap_info_command(CMD_CTX, dap, apsel);
+	return dap_info_command(CMD_CTX, dap, dap->ap_cmd_sel );
 }
 
 COMMAND_HANDLER(dap_baseaddr_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
+	struct adiv5_dap *dap = target_cs_to_dap(target);
 
-	uint32_t apsel, baseaddr;
+	uint32_t ap_cmd_sel, baseaddr;
 	int retval;
 
+	ap_cmd_sel = 0;
 	switch (CMD_ARGC) {
 	case 0:
-		apsel = dap->apsel;
+		ap_cmd_sel = dap->ap_cmd_sel;
 		break;
 	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], ap_cmd_sel);
 		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel >= 256)
+		if (ap_cmd_sel >= 256)
 			return ERROR_COMMAND_SYNTAX_ERROR;
+		dap->ap_cmd_sel = ap_cmd_sel;
 		break;
 	default:
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	dap_ap_select(dap, apsel);
+	dap_ap_select(dap, ap_cmd_sel );
 
 	/* NOTE:  assumes we're talking to a MEM-AP, which
 	 * has a base address.  There are other kinds of AP,
 	 * though they're not common for now.  This should
 	 * use the ID register to verify it's a MEM-AP.
 	 */
-	retval = dap_queue_ap_read(dap, AP_REG_BASE, &baseaddr);
+	retval = dap_queue_ap_read(dap, AP_MEM_REG_BASE, &baseaddr);
 	if (retval != ERROR_OK)
 		return retval;
 	retval = dap_run(dap);
@@ -1472,25 +2223,32 @@ COMMAND_HANDLER(dap_baseaddr_command)
 COMMAND_HANDLER(dap_memaccess_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
+	struct adiv5_dap *dap = target_cs_to_dap(target);
+	uint32_t tck;
 
-	uint32_t memaccess_tck;
 
-	switch (CMD_ARGC) {
-	case 0:
-		memaccess_tck = dap->memaccess_tck;
-		break;
-	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], memaccess_tck);
-		break;
-	default:
+	if( CMD_ARGC > 1 ){
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
-	dap->memaccess_tck = memaccess_tck;
 
-	command_print(CMD_CTX, "memory bus access delay set to %" PRIi32 " tck",
-			dap->memaccess_tck);
+	if( CMD_ARGC == 0 ){
+		tck = dap->port[ dap->ap_cmd_sel ].memaccess_tck;
+	} else {
+		COMMAND_PARSE_NUMBER( u32, CMD_ARGV[1], tck);
+	}
+	
+	/* Be reasonable 
+	 * stupidly assuming 1mhz clock
+	 * this is 50milisecond
+	 */
+	if( tck > 50000 ){
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+
+	dap->port[ dap->ap_cmd_sel ].memaccess_tck = tck;
+
+	command_print(CMD_CTX, "dap-ap[%d] access delay: %d",
+				  dap->ap_cmd_sel, (int)(tck) );
 
 	return ERROR_OK;
 }
@@ -1498,28 +2256,27 @@ COMMAND_HANDLER(dap_memaccess_command)
 COMMAND_HANDLER(dap_apsel_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
+	struct adiv5_dap *dap = target_cs_to_dap(target);
 
-	uint32_t apsel, apid;
+	uint32_t ap_cmd_sel, apid;
 	int retval;
 
 	switch (CMD_ARGC) {
 	case 0:
-		apsel = 0;
+		ap_cmd_sel = 0;
 		break;
 	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], ap_cmd_sel);
 		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel >= 256)
+		if (ap_cmd_sel >= 256)
 			return ERROR_COMMAND_SYNTAX_ERROR;
 		break;
 	default:
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	dap->apsel = apsel;
-	dap_ap_select(dap, apsel);
+	dap->ap_cmd_sel = ap_cmd_sel;
+	dap_ap_select(dap, ap_cmd_sel );
 
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
 	if (retval != ERROR_OK)
@@ -1529,7 +2286,7 @@ COMMAND_HANDLER(dap_apsel_command)
 		return retval;
 
 	command_print(CMD_CTX, "ap %" PRIi32 " selected, identification register 0x%8.8" PRIx32,
-			apsel, apid);
+			ap_cmd_sel, apid);
 
 	return retval;
 }
@@ -1537,30 +2294,37 @@ COMMAND_HANDLER(dap_apsel_command)
 COMMAND_HANDLER(dap_apcsw_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
-
-	uint32_t apcsw = dap->apcsw[dap->apsel], sprot = 0;
+	struct adiv5_dap *dap = target_cs_to_dap( target );
+	struct adiv5_dap_port *port;
+	uint32_t user_default;
 
+	port = &(dap->port[dap->ap_cmd_sel]);
+	user_default = port->csw_reg_default;
+	
 	switch (CMD_ARGC) {
 	case 0:
-		command_print(CMD_CTX, "apsel %" PRIi32 " selected, csw 0x%8.8" PRIx32,
-			(dap->apsel), apcsw);
 		break;
 	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], sprot);
-		/* AP address is in bits 31:24 of DP_SELECT */
-		if (sprot > 1)
+		/* this is an compatible change
+		 * the old code was *hard*coded* to
+		 * exactly one type of dap port
+		 * there are many types...
+		 * the bits vary depending on the
+		 * specific port type and chip type
+		 */
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], user_default);
+		/* sanity check */
+		if( user_default & (~(port->csw_route_cfg_bits))){
+			command_print( CMD_CTX, "dap-ap[%d] does not support this configuration", port->port_num );
 			return ERROR_COMMAND_SYNTAX_ERROR;
-		if (sprot)
-			apcsw |= CSW_SPROT;
-		else
-			apcsw &= ~CSW_SPROT;
+		}
+		port->csw_reg_default = user_default;
 		break;
 	default:
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
-	dap->apcsw[dap->apsel] = apcsw;
+	command_print(CMD_CTX, "dap-ap[%d]: csw 0x%8.8" PRIx32,
+				  port->port_num, user_default);
 
 	return 0;
 }
@@ -1570,27 +2334,26 @@ COMMAND_HANDLER(dap_apcsw_command)
 COMMAND_HANDLER(dap_apid_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
+	struct adiv5_dap *dap = target_cs_to_dap(target);
 
-	uint32_t apsel, apid;
+	uint32_t ap_cmd_sel, apid;
 	int retval;
 
 	switch (CMD_ARGC) {
 	case 0:
-		apsel = dap->apsel;
+		ap_cmd_sel = dap->ap_cmd_sel;
 		break;
 	case 1:
-		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], apsel);
+		COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], ap_cmd_sel);
 		/* AP address is in bits 31:24 of DP_SELECT */
-		if (apsel >= 256)
+		if (ap_cmd_sel >= 256)
 			return ERROR_COMMAND_SYNTAX_ERROR;
 		break;
 	default:
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	dap_ap_select(dap, apsel);
+	dap_ap_select(dap, ap_cmd_sel );
 
 	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
 	if (retval != ERROR_OK)
@@ -1607,8 +2370,7 @@ COMMAND_HANDLER(dap_apid_command)
 COMMAND_HANDLER(dap_ti_be_32_quirks_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm->dap;
+	struct adiv5_dap *dap = target_cs_to_dap(target);
 
 	uint32_t enable = dap->ti_be_32_quirks;
 
@@ -1630,6 +2392,334 @@ COMMAND_HANDLER(dap_ti_be_32_quirks_command)
 	return 0;
 }
 
+
+
+void adiv5_dap_init_common( struct adiv5_dap *dap )
+{
+	dap_dbg_init(dap );
+}
+
+struct dap_rdwr {
+	Jim_GetOptInfo goi;
+	int      is_wr;
+	struct target_addr addr;
+	int      width;
+	int      count;
+	int      max_n;
+	union  {
+#define RDWR_N_u8  64	   
+#define RDWR_N_u16 (RDWR_N_u8/2)
+#define RDWR_N_u32 (RDWR_N_u16/2)
+#define RDWR_N_u64 (RDWR_N_u32/2)
+		uint8_t  u8[RDWR_N_u8];
+		uint16_t u16[RDWR_N_u16];
+		uint32_t u32[RDWR_N_u32];
+		uint32_t u64[RDWR_N_u64];
+	} data;
+};
+
+static int jim_dap_mem_rdwr_opts( struct dap_rdwr *p )
+{
+	int e;
+	jim_wide w;
+	int x;
+	char *cp;
+	/*
+	 * port address attribute width ... 
+	 */
+
+	e = Jim_GetOpt_String( &(p->goi), &cp, NULL );
+	if( e != JIM_OK ){
+		return e;
+	}
+
+	/* Get dap port number */
+	e = Jim_GetOpt_ArmDapPort( &(p->goi), &x );
+	if( e != JIM_OK ){
+		return e;
+	}
+	
+	TARGET_ADDR_INIT( &p->addr, 0 );
+	p->addr.route = x + TA_ROUTE_arm_dap0;
+
+	/* Get Route attributes */
+	e = Jim_GetOpt_Wide( &(p->goi),&w );
+	if( e != JIM_OK ){
+		return e;
+	}
+	p->addr.route_attributes = w;
+
+	/* Get bit width */
+	e = Jim_GetOpt_Wide( &(p->goi),&w );
+	if( e != JIM_OK ){
+		return e;
+	}
+
+	/* VALIDATE the width, and change from "bits"
+	 * which is what OpenOCD uses at the command line
+	 * to bytes which is what the DAP api uses.
+	 */
+	e = JIM_OK;
+	switch( w ){
+	default:
+		Jim_SetResultString( p->goi.interp, "?size must be 8,16,32,64,128",-1);
+		e = JIM_ERR;
+		break;
+	case 8:
+		w = 1;
+		p->max_n = RDWR_N_u8;
+		break;
+	case 16:
+		w = 2;
+		p->max_n = RDWR_N_u16;
+		break;
+	case 32:
+		w = 4;
+		p->max_n = RDWR_N_u32;
+		break;
+	case 64:
+		w = 8;
+		p->max_n = RDWR_N_u64;
+		break;
+		/* FUTURE: 128 */
+	}
+	p->width = w;
+
+	/* Get bit address */
+	e = Jim_GetOpt_Wide( &(p->goi),&w );
+	if( e != JIM_OK ){
+		return e;
+	}
+	
+	p->addr.addr = w;
+	
+	if( (p->is_wr) || (e != JIM_OK) ){
+		return e;
+	}
+	
+	/* read has a count */
+	e = Jim_GetOpt_Wide( &(p->goi),&w );
+	if( e != JIM_OK ){
+		return e;
+	}
+	p->count = w;
+	if( p->count > 256 ){
+		/* Be reasonable! */
+		return JIM_ERR;
+	}
+	
+	return JIM_OK;
+}
+		
+	
+
+static int jim_dap_mem_write( Jim_Interp *_interp, int _argc, Jim_Obj * const *_argv )
+{
+	struct dap_rdwr rdwr;
+	int e;
+	jim_wide w;
+	int x;
+	struct command_context *context;
+	struct target *target;
+
+	memset( &rdwr, 0, sizeof(rdwr) );
+	rdwr.is_wr = 1;
+	/* Get rid of the rd/wr word */
+	/* hence -1/+1 */
+	Jim_GetOpt_Setup( &rdwr.goi, _interp, _argc-1, _argv+1 );
+	
+	context = current_command_context(rdwr.goi.interp);	
+	target = get_current_target(context);
+
+	/*
+	 * port:address attribute width 
+	 */
+	
+	e = jim_dap_mem_rdwr_opts( &rdwr );
+	if( e != JIM_OK ){
+		return e;
+	}
+
+	x = 0;
+	e = ERROR_OK;
+
+	/* for each arg */
+	while( rdwr.goi.argc ){
+
+		/* get a chunk */
+		e = ERROR_OK;
+		for( x = 0 ; (rdwr.goi.argc) && (x < rdwr.max_n) ; x++ ){
+			e = Jim_GetOpt_Wide( &rdwr.goi, &w );
+			if( e != JIM_OK ){
+				return e;
+			}
+			switch( rdwr.width ){
+			case 1:
+				rdwr.data.u8[x] = ((uint8_t)w);
+				break;
+			case 2:
+				rdwr.data.u16[x] = ((uint16_t)w);
+				break;
+			case 4:
+				rdwr.data.u32[x] = ((uint32_t)w);
+				break;
+			case 8:
+				rdwr.data.u64[x] = ((uint64_t)w);
+				break;
+			}
+		}
+
+		/* do we have any to write? */
+		if( x ){
+			e = target_cs_wr_bulk( target, &rdwr.addr, rdwr.width, x, (void *)(&rdwr.data));
+			if( e != ERROR_OK ){
+				goto wr_bad;
+			}
+		}
+		/* reset x in case we are done */
+		x = 0;
+	}
+	/* any left over at the end? */
+	if( x ){
+		e = target_cs_wr_bulk( target, &rdwr.addr, rdwr.width, x, (void *)(&rdwr.data));
+	}
+	if( e != ERROR_OK ){
+	wr_bad:
+		Jim_SetResultString( rdwr.goi.interp, "cannot write...\n", -1);
+		return JIM_ERR;
+	} else {
+		return JIM_OK;
+	}
+}
+
+static int jim_dap_mem_read( Jim_Interp *_interp, int _argc, Jim_Obj * const *_argv )
+{
+	struct dap_rdwr rdwr;
+	int e;
+	jim_wide w;
+	int x;
+	struct command_context *context;
+	struct target *target;
+	Jim_Obj *list;
+
+	memset( &rdwr, 0, sizeof(rdwr) );
+	/* Get rid of the rd/wr word */
+	/* hence -1/+1 */
+	Jim_GetOpt_Setup( &rdwr.goi, _interp, _argc-1, _argv+1 );
+	
+	context = current_command_context(rdwr.goi.interp);	
+	target = get_current_target(context);
+
+	list = Jim_NewListObj( rdwr.goi.interp, NULL, 0 );
+	
+	/*
+	 * port:address attribute width count
+	 */
+	
+	e = jim_dap_mem_rdwr_opts( &rdwr );
+	if( e != JIM_OK ){
+		return e;
+	}
+
+	while( rdwr.count ){
+		/* Go read */
+		int n;
+		n = rdwr.count;
+		if( n > rdwr.max_n ){
+			n = rdwr.max_n;
+		}
+		e = target_cs_rd_bulk( target, &rdwr.addr, rdwr.width, n, (void *)(&rdwr.data) );
+		if( e != ERROR_OK ){
+			Jim_FreeObj( rdwr.goi.interp, list );
+			
+			Jim_SetResultFormatted( rdwr.goi.interp, "?Cannot read @ %s", target_addr2str1( target, &rdwr.addr ) );
+			return JIM_ERR;
+		}
+
+		/* Print */
+		for( x = 0 ; x < n ; x++ ){
+			
+			switch( rdwr.width ){
+			case 1:
+				w = rdwr.data.u8[x];
+				break;
+			case 2:
+				w = rdwr.data.u16[x];
+				break;
+			case 4:
+				w = rdwr.data.u32[x];
+				break;
+			case 8:
+				w = rdwr.data.u64[x];
+				break;
+				/* FUTURE: 128 */
+			}
+			Jim_ListAppendElement( rdwr.goi.interp, list, Jim_NewIntObj( rdwr.goi.interp, w ) );
+			rdwr.count -= n;
+		}
+	}
+	Jim_SetResult( rdwr.goi.interp, list );
+	return JIM_OK;
+}
+
+static const Jim_Nvp port_regnames[] = {
+	{ .name = "cfg", 0 },
+	{ .name = "idr", 1 },
+	{ .name = NULL, 0 }
+};
+
+
+static int jim_dap_force_cfg( Jim_Interp *_interp, int _argc, Jim_Obj * const *_argv )
+{
+	Jim_GetOptInfo goi;
+	Jim_Nvp *nvp;
+	int e;
+	jim_wide w;
+	int pn;
+	uint32_t value;
+	struct command_context *context;
+	struct target *target;
+	struct adiv5_dap *dap;
+	
+	Jim_GetOpt_Setup( &goi, _interp, _argc-1, _argv+1 );
+
+	context = current_command_context(goi.interp);	
+	target = get_current_target(context);
+	dap = target_cs_to_dap(target);
+
+	/* get port */
+	e = Jim_GetOpt_ArmDapPort( &goi, &pn );
+	if( e != JIM_OK ){
+		return e;
+	}
+	
+	/* get regname */
+	e = Jim_GetOpt_Nvp( &goi, port_regnames, &nvp );
+	if( e != JIM_OK ){
+		return e;
+	}
+
+	/* value */
+	e = Jim_GetOpt_Wide( &goi, &w );
+	if( e != JIM_OK ){
+		return e;
+	}
+	value = w;
+
+	switch( nvp->value ){
+	case 0:
+		dap->port[pn].cfg_reg_forced = 1;
+		dap->port[pn].cfg_reg = value;
+		break;
+	case 1:
+		dap->port[pn].idr_reg_forced = 1;
+		dap->port[pn].idr_reg = value;
+		break;
+	}
+	return JIM_OK;
+}
+
+
 static const struct command_registration dap_commands[] = {
 	{
 		.name = "info",
@@ -1640,6 +2730,28 @@ static const struct command_registration dap_commands[] = {
 		.usage = "[ap_num]",
 	},
 	{
+		.name = "force_port_cfg",
+		.jim_handler = jim_dap_force_cfg,
+		.mode = COMMAND_EXEC,
+		.help = "PORTNUM REG VALUE - used to force the value of the CFG or IDR register",
+		.usage = "PORTNUM cfg|idr VALUE",
+	},
+	{
+		.name = "log",
+		.handler = handle_dap_log_command,
+		.mode = COMMAND_EXEC,
+		.help = "enable/disable dap logging",
+		.usage = "[[low|high] VALUE]",
+	},
+	{
+		.name = "baseaddr",
+		.handler = dap_baseaddr_command,
+		.mode = COMMAND_EXEC,
+		.help = "return debug base address from MEM-AP "
+			"(default currently selected AP)",
+		.usage = "[ap_num]",
+	},
+	{
 		.name = "apsel",
 		.handler = dap_apsel_command,
 		.mode = COMMAND_EXEC,
@@ -1664,12 +2776,11 @@ static const struct command_registration dap_commands[] = {
 		.usage = "[ap_num]",
 	},
 	{
-		.name = "baseaddr",
-		.handler = dap_baseaddr_command,
-		.mode = COMMAND_EXEC,
-		.help = "return debug base address from MEM-AP "
-			"(default currently selected AP)",
-		.usage = "[ap_num]",
+		.name = "ti_be_32_quirks",
+		.handler = dap_ti_be_32_quirks_command,
+		.mode = COMMAND_CONFIG,
+		.help = "set/get quirks mode for TI TMS450/TMS570 processors",
+		.usage = "[enable]",
 	},
 	{
 		.name = "memaccess",
@@ -1679,20 +2790,38 @@ static const struct command_registration dap_commands[] = {
 			"bus access [0-255]",
 		.usage = "[cycles]",
 	},
+#if 0
+	/* FIXME: THis should exist */
 	{
-		.name = "ti_be_32_quirks",
-		.handler = dap_ti_be_32_quirks_command,
-		.mode = COMMAND_CONFIG,
-		.help = "set/get quirks mode for TI TMS450/TMS570 processors",
-		.usage = "[enable]",
+		.name = "hexdump",
+		.jim_handler = jim_dap_mem_hexdump,
+		.mode = COMMAND_EXEC,
+		.help = "read/dump memory via dap port",
+		.usage = "arm.dapX attribute width address count"
+	},
+#endif
+	{
+		.name = "read",
+		.jim_handler = jim_dap_mem_read,
+		.mode = COMMAND_EXEC,
+		.help = "return list of values read from dap port",
+		.usage = "arm.dapX attribute width address count"
+	},
+	{
+		.name = "write",
+		.jim_handler = jim_dap_mem_write,
+		.mode = COMMAND_EXEC,
+		.help = "write memory via dap port",
+		.usage = "arm.dapX attribute width address data0 [data1 ...]"
 	},
+	
 	COMMAND_REGISTRATION_DONE
 };
 
 const struct command_registration dap_command_handlers[] = {
 	{
 		.name = "dap",
-		.mode = COMMAND_EXEC,
+		.mode = COMMAND_CONFIG,
 		.help = "DAP command group",
 		.usage = "",
 		.chain = dap_commands,
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 160478a..8618107 100755
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -24,6 +24,8 @@
 #ifndef ARM_ADI_V5_H
 #define ARM_ADI_V5_H
 
+#define DAP_REG_CACHE 0
+
 /**
  * @file
  * This defines formats and data structures used to talk to ADIv5 entities.
@@ -31,7 +33,12 @@
  * resources accessed through a MEM-AP.
  */
 
+
+struct coresight_settings;
+
+#include "target_addr.h"
 #include "arm_jtag.h"
+#include "arm_adi_v5_debug.h"
 
 /* FIXME remove these JTAG-specific decls when mem_ap_read_buf_u32()
  * is no longer JTAG-specific
@@ -91,15 +98,16 @@
 
 /* MEM-AP register addresses */
 /* TODO: rename as MEM_AP_REG_* */
-#define AP_REG_CSW		0x00
-#define AP_REG_TAR		0x04
-#define AP_REG_DRW		0x0C
-#define AP_REG_BD0		0x10
-#define AP_REG_BD1		0x14
-#define AP_REG_BD2		0x18
-#define AP_REG_BD3		0x1C
-#define AP_REG_CFG		0xF4		/* big endian? */
-#define AP_REG_BASE		0xF8
+#define AP_MEM_REG_CSW		0x00
+#define AP_MEM_REG_TAR_lo	0x04 /* bits [31:00] */
+#define AP_MEM_REG_TAR_hi   0x08 /* bits [63:32] */
+#define AP_MEM_REG_DRW		0x0C
+#define AP_MEM_REG_BD0		0x10
+#define AP_MEM_REG_BD1		0x14
+#define AP_MEM_REG_BD2		0x18
+#define AP_MEM_REG_BD3		0x1C
+#define AP_MEM_REG_CFG		0xF4	/* Not implimented in all DAPs */
+#define AP_MEM_REG_BASE		0xF8
 
 /* Generic AP register address */
 #define AP_REG_IDR		0xFC
@@ -108,18 +116,19 @@
 #define CSW_8BIT		0
 #define CSW_16BIT		1
 #define CSW_32BIT		2
+#define CSW_64BIT       3
+#define CSW_128BIT      4
+#define CSW_256BIT      5
+/* values 6 .. 15 = reserved */
+	
 #define CSW_ADDRINC_MASK    (3UL << 4)
-#define CSW_ADDRINC_OFF     0UL
+#define CSW_ADDRINC_OFF     (0UL << 4)
 #define CSW_ADDRINC_SINGLE  (1UL << 4)
 #define CSW_ADDRINC_PACKED  (2UL << 4)
 #define CSW_DEVICE_EN       (1UL << 6)
 #define CSW_TRIN_PROG       (1UL << 7)
 #define CSW_SPIDEN          (1UL << 23)
-/* 30:24 - implementation-defined! */
-#define CSW_HPROT           (1UL << 25) /* ? */
-#define CSW_MASTER_DEBUG    (1UL << 29) /* ? */
-#define CSW_SPROT           (1UL << 30)
-#define CSW_DBGSWENABLE     (1UL << 31)
+
 
 /**
  * This represents an ARM Debug Interface (v5) Debug Access Port (DAP).
@@ -139,49 +148,127 @@
  */
 struct adiv5_dap {
 	const struct dap_ops *ops;
+	int ops_dirty;
+	int ops_last_result;
+	/* there may be more then one dap, each dap has a name */
+	const char *name;
 
+	struct dap_debug_info dbg;
 	/* Control config */
 	uint32_t dp_ctrl_stat;
 
-	uint32_t apcsw[256];
-	uint32_t apsel;
 
+	/* this is the ap port the user has selected */
+	uint32_t ap_cmd_sel;
+	
+	bool     port_types_done;
+	struct adiv5_dap_port {
+		int      port_num;
+
+		/* Identification register */
+		bool     idr_reg_forced;
+		uint32_t idr_reg;
+
+		/* Configuration register */
+		bool     cfg_reg_forced;
+		uint32_t cfg_reg;
+
+		/* where is the DAP_ROM */
+		uint32_t rom_base;
+
+		/**
+		 * Cache for (MEM-AP) AP_REG_TAR register value This is written to
+		 * configure the address being read or written
+		 * "-1" indicates no cached value.
+		 */
+		uint64_t cached_tar_reg;
+		bool     cached_tar_valid;
+
+
+		/**
+		 * Cache for (MEM-AP) AP_REG_CSW register value.  This is written to
+		 * configure an access mode, such as autoincrementing AP_REG_TAR during
+		 * word access.  "-1" indicates no cached value.
+		 */
+		uint32_t cached_csw_reg;
+		bool     cached_csw_valid;
+		
+		/* Each type of MEM_AP has different properties
+		 * we must "preserve" certian bits when accessing 
+		 * ARM refers to this as: SBZP, or SB0P
+		 * aka: sbz = should be ZERO, sbo = should be ONE
+		 *
+		 * The "p" means: They might be something else
+		 * but you must preserve the value, don't change
+		 */
+
+		/* reg_default:  What to use if user did not specify */
+		uint32_t csw_reg_default;
+
+		/* these bits are the ones the user *CAN* configure */
+		uint32_t csw_route_cfg_bits;
+
+		/* this is what we read at startup */
+		uint32_t csw_reg_orig;
+		uint32_t csw_reg_sbzp_mask;
+
+		bool     addr_64bit;
+		bool     data_64bit;
+
+		/* port is big endian */
+		bool     big_endian;
+
+		/* only supports word transfers */
+		bool     word_only_transfers;
+		
+		/* port does  support unaligned access */
+		bool     unaligned_access_ok;
+
+		/* true if packed transfers are supported by the MEM-AP */
+		bool packed_transfers;
+
+
+		/* Transfer Address Register WRAP size
+		 * NOTE: This is really 1K some chips
+		 * support more, but there should be a 
+		 * dap config command to change tar size
+		 * 
+		 * Meaning: it should not be hard coded!
+		 */
+		uint64_t tar_wrap;
+
+		/**
+		 * Configures how many extra tck clocks are added after starting a
+		 * MEM-AP access before we try to read its status (and/or result).
+		 *
+		 * This can vary depending upon the port!
+		 */
+		uint32_t	memaccess_tck;
+		
+	} port[ 256 ];
+	
 	/**
 	 * Cache for DP_SELECT bits identifying the current AP.  A DAP may
 	 * connect to multiple APs, such as one MEM-AP for general access,
 	 * another reserved for accessing debug modules, and a JTAG-DP.
 	 * "-1" indicates no cached value.
 	 */
-	uint32_t ap_current;
-
+	int cached_ap_port;
 	/**
 	 * Cache for DP_SELECT bits identifying the current four-word AP
 	 * register bank.  This caches AP register addresss bits 7:4; JTAG
 	 * and SWD access primitves pass address bits 3:2; bits 1:0 are zero.
 	 * "-1" indicates no cached value.
 	 */
-	uint32_t ap_bank_value;
+	uint32_t cached_ap_bank_value;
 
 	/**
 	 * Cache for DP_SELECT bits identifying the current four-word DP
 	 * register bank.  This caches DP register addresss bits 7:4; JTAG
 	 * and SWD access primitves pass address bits 3:2; bits 1:0 are zero.
 	 */
-	uint32_t dp_bank_value;
-
-	/**
-	 * Cache for (MEM-AP) AP_REG_CSW register value.  This is written to
-	 * configure an access mode, such as autoincrementing AP_REG_TAR during
-	 * word access.  "-1" indicates no cached value.
-	 */
-	uint32_t ap_csw_value;
+	uint32_t cached_dp_bank_value;
 
-	/**
-	 * Cache for (MEM-AP) AP_REG_TAR register value This is written to
-	 * configure the address being read or written
-	 * "-1" indicates no cached value.
-	 */
-	uint32_t ap_tar_value;
 
 	/* information about current pending SWjDP-AHBAP transaction */
 	uint8_t  ack;
@@ -192,23 +279,11 @@ struct adiv5_dap {
 	 */
 	uint32_t *last_read;
 
-	/**
-	 * Configures how many extra tck clocks are added after starting a
-	 * MEM-AP access before we try to read its status (and/or result).
-	 */
-	uint32_t	memaccess_tck;
 
 	/* Size of TAR autoincrement block, ARM ADI Specification requires at least 10 bits */
 	/* FIXME: This is not a feature of the DAP, it's specific to the MEM-AP used. */
 	uint32_t tar_autoincr_block;
 
-	/* true if packed transfers are supported by the MEM-AP */
-	/* FIXME: This is not a feature of the DAP, it's specific to the MEM-AP used. */
-	bool packed_transfers;
-
-	/* true if unaligned memory access is not supported by the MEM-AP */
-	/* FIXME: This is not a feature of the DAP, it's specific to the MEM-AP used. */
-	bool unaligned_access_bad;
 
 	/* The TI TMS470 and TMS570 series processors use a BE-32 memory ordering
 	 * despite lack of support in the ARMv7 architecture. Memory access through
@@ -252,16 +327,76 @@ struct dap_ops {
 	int (*run)(struct adiv5_dap *dap);
 };
 
+struct coresight_bulk {
+	int							rw;
+	struct target				*target; /* might be null */
+	struct coresight_settings	*cs;
+	struct adiv5_dap			*dap;
+	struct adiv5_dap_port		*port;
+	struct target_addr			addr;
+	void 						*buffer;
+	bool            	        is_aligned;
+	uint32_t					size;
+	uint32_t					count;
+	bool						addrinc;
+
+	/* used in the 'work in process' loop */
+	uint32_t                    wip_count;
+};
+
+
+int coresight_io_bulk( struct coresight_bulk *pBulk );
+
+
+extern int dap_dbg_lowlevel;
+extern int dap_dbg_highlevel;
+void dap_dbg_add_names( struct adiv5_dap *dap,
+			/* what port number is this on */
+			int portnum,
+			/* ie:  apps0, gpu0, etc */
+			const char *blockname,
+			/* base address of this coresight block */
+			uint64_t baseaddress,
+			const struct dap_coresight_name *names );
+			
+			
+
 /*
- * Access Port types
+ * Access Port types, the AP_REG_IDR
  */
 enum ap_type {
-	AP_TYPE_AHB_AP  = 0x01,  /* AHB Memory-AP */
-	AP_TYPE_APB_AP  = 0x02,  /* APB Memory-AP */
-	AP_TYPE_JTAG_AP = 0x10,  /* JTAG-AP - JTAG master for controlling other JTAG devices */
-	AP_TYPE_AXI_AP  = 0x04,  /* AXI3/AXI4 Memory-AP */
+	/* ARM document: ARM IHI 0031B, Page 7-127, Table 7-2 */
+
+	/* revision bits[31:28] */
+	AP_revsion_MASK = (0x0f<<28),
+
+	/* JEP106 bits[27:17]*/
+	AP_JEP106_MASK  = (0x7FF << 17),
+	AP_JEP106_ARM   = 0x04770000,
+	
+	/* *CLASS* bits[16:13] */
+	AP_CLASS_NONE   = (0   <<13),
+	AP_CLASS_MEM    = (0x08<<13),
+	AP_CLASS_MASK   = (0x0f<<13),
+
+	/* reserved, SBZ bits[12:8] */
+	AP_sbz_field1   = (0x1f<<8),
+	
+	/* combine Varient & type into one thing 
+	 * *VARIENT* bits[7:4]
+	 * *TYPE*    bits[3:0]
+	 */
+	AP_TYPE_AHB_AP   = (0x01<<0),   /* AHB Memory-AP (varient 0) */
+	AP_TYPE_AHB2_AP  = (0x11<<0),   /* AHB Memory-AP (varient 1) */
+	AP_TYPE_APB_AP   = (0x02<<0),   /* APB Memory-AP (varient 0) */
+	AP_TYPE_APB2_AP  = (0x12<<0),   /* APB Memory-AP (varient 1) */
+	AP_TYPE_JTAG_AP  = (0x10<<0),   /* JTAG-AP - JTAG master for controlling other JTAG devices */
+	AP_TYPE_AXI_AP   = (0x04<<0),   /* AXI3/AXI4 Memory-AP */
+	AP_TYPE_MASK     = (0xff<<0)
+	
 };
 
+
 /**
  * Queue a DP register read.
  * Note that not all DP registers are readable; also, that JTAG and SWD
@@ -278,6 +413,15 @@ static inline int dap_queue_dp_read(struct adiv5_dap *dap,
 		unsigned reg, uint32_t *data)
 {
 	assert(dap->ops != NULL);
+	if( dap_dbg_lowlevel ){
+		struct dap_access_log *p;
+		p = dap_dbg_log_entry(dap);
+		if( p ){
+			p->access_type = DAP_DP_RD;
+			p->reg = reg;
+			p->pointer = data;
+		}
+	}
 	return dap->ops->queue_dp_read(dap, reg, data);
 }
 
@@ -296,6 +440,15 @@ static inline int dap_queue_dp_write(struct adiv5_dap *dap,
 		unsigned reg, uint32_t data)
 {
 	assert(dap->ops != NULL);
+	if( dap_dbg_lowlevel ){
+		struct dap_access_log *p;
+		p = dap_dbg_log_entry(dap);
+		if( p ){
+			p->access_type = DAP_DP_WR;
+			p->reg = reg;
+			p->dataval = data;
+		}
+	}
 	return dap->ops->queue_dp_write(dap, reg, data);
 }
 
@@ -313,6 +466,15 @@ static inline int dap_queue_ap_read(struct adiv5_dap *dap,
 		unsigned reg, uint32_t *data)
 {
 	assert(dap->ops != NULL);
+	if( dap_dbg_lowlevel ){
+		struct dap_access_log *p;
+		p = dap_dbg_log_entry(dap);
+		if( p ){
+			p->access_type = DAP_DP_RD;
+			p->reg = reg;
+			p->pointer = data;
+		}
+	}
 	return dap->ops->queue_ap_read(dap, reg, data);
 }
 
@@ -329,6 +491,15 @@ static inline int dap_queue_ap_write(struct adiv5_dap *dap,
 		unsigned reg, uint32_t data)
 {
 	assert(dap->ops != NULL);
+	if( dap_dbg_lowlevel ){
+		struct dap_access_log *p;
+		p = dap_dbg_log_entry(dap);
+		if( p ){
+			p->access_type = DAP_DP_RD;
+			p->reg = reg;
+			p->dataval = data;
+		}
+	}
 	return dap->ops->queue_ap_write(dap, reg, data);
 }
 
@@ -346,6 +517,15 @@ static inline int dap_queue_ap_write(struct adiv5_dap *dap,
 static inline int dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
 {
 	assert(dap->ops != NULL);
+	if( dap_dbg_lowlevel ){
+		struct dap_access_log *p;
+		p = dap_dbg_log_entry(dap);
+		if( p ){
+			p->access_type = DAP_AP_ABORT;
+			p->reg = 0;
+			p->pointer = ack;
+		}
+	}
 	return dap->ops->queue_ap_abort(dap, ack);
 }
 
@@ -361,8 +541,11 @@ static inline int dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
  */
 static inline int dap_run(struct adiv5_dap *dap)
 {
+	int r;
 	assert(dap->ops != NULL);
-	return dap->ops->run(dap);
+	r = dap->ops->run(dap);
+	dap_dbg_log_dump( dap );
+	return r;
 }
 
 static inline int dap_dp_read_atomic(struct adiv5_dap *dap, unsigned reg,
@@ -406,77 +589,50 @@ static inline int dap_dp_poll_register(struct adiv5_dap *dap, unsigned reg,
 	}
 }
 
-/** Accessor for currently selected DAP-AP number (0..255) */
-static inline uint8_t dap_ap_get_select(struct adiv5_dap *swjdp)
-{
-	return (uint8_t)(swjdp->ap_current);
-}
 
-/* AP selection applies to future AP transactions */
-void dap_ap_select(struct adiv5_dap *dap, uint8_t ap);
+struct target_addr;
 
+/* required [for now] byt he kinetis.c] flash code */
+
+void dap_ap_select(struct adiv5_dap *dap, int ap );
+
+/* clear all port cache info we know of */
+void dap_invalidate_port_cache( struct adiv5_dap *dap );
 /* Queued AP transactions */
-int dap_setup_accessport(struct adiv5_dap *swjdp,
-		uint32_t csw, uint32_t tar);
 
 /* Queued MEM-AP memory mapped single word transfers */
-int mem_ap_read_u32(struct adiv5_dap *swjdp, uint32_t address, uint32_t *value);
-int mem_ap_write_u32(struct adiv5_dap *swjdp, uint32_t address, uint32_t value);
+int mem_ap_read_u32(struct adiv5_dap *swjdp, const struct target_addr *pAddr, uint32_t *value);
+int mem_ap_write_u32(struct adiv5_dap *swjdp, const struct target_addr *pAddr, uint32_t value);
+
+int mem_ap_read_u64(struct adiv5_dap *swjdp, const struct target_addr *pAddr, uint64_t *value);
+int mem_ap_write_u64(struct adiv5_dap *swjdp, const struct target_addr *pAddr, uint64_t value);
 
 /* Synchronous MEM-AP memory mapped single word transfers */
-int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp,
-		uint32_t address, uint32_t *value);
-int mem_ap_write_atomic_u32(struct adiv5_dap *swjdp,
-		uint32_t address, uint32_t value);
-
-/* Queued MEM-AP memory mapped single word transfers with selection of ap */
-int mem_ap_sel_read_u32(struct adiv5_dap *swjdp, uint8_t ap,
-		uint32_t address, uint32_t *value);
-int mem_ap_sel_write_u32(struct adiv5_dap *swjdp, uint8_t ap,
-		uint32_t address, uint32_t value);
-
-/* Synchronous MEM-AP memory mapped single word transfers with selection of ap */
-int mem_ap_sel_read_atomic_u32(struct adiv5_dap *swjdp, uint8_t ap,
-		uint32_t address, uint32_t *value);
-int mem_ap_sel_write_atomic_u32(struct adiv5_dap *swjdp, uint8_t ap,
-		uint32_t address, uint32_t value);
-
-/* Synchronous MEM-AP memory mapped bus block transfers */
-int mem_ap_read(struct adiv5_dap *dap, uint8_t *buffer, uint32_t size,
-		uint32_t count, uint32_t address, bool addrinc);
-int mem_ap_write(struct adiv5_dap *dap, const uint8_t *buffer, uint32_t size,
-		uint32_t count, uint32_t address, bool addrinc);
-
-/* Synchronous MEM-AP memory mapped bus block transfers with selection of ap */
-int mem_ap_sel_read_buf(struct adiv5_dap *swjdp, uint8_t ap,
-		uint8_t *buffer, uint32_t size, uint32_t count, uint32_t address);
-int mem_ap_sel_write_buf(struct adiv5_dap *swjdp, uint8_t ap,
-		const uint8_t *buffer, uint32_t size, uint32_t count, uint32_t address);
-
-/* Synchronous, non-incrementing buffer functions for accessing fifos, with
- * selection of ap */
-int mem_ap_sel_read_buf_noincr(struct adiv5_dap *swjdp, uint8_t ap,
-		uint8_t *buffer, uint32_t size, uint32_t count, uint32_t address);
-int mem_ap_sel_write_buf_noincr(struct adiv5_dap *swjdp, uint8_t ap,
-		const uint8_t *buffer, uint32_t size, uint32_t count, uint32_t address);
+int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp, const struct target_addr *pAddr, uint32_t *value);
+int mem_ap_write_atomic_u32(struct adiv5_dap *swjdp, const struct target_addr *pAddr, uint32_t value);
+
+struct target;
 
 /* Initialisation of the debug system, power domains and registers */
-int ahbap_debugport_init(struct adiv5_dap *swjdp);
+int target_cs_debugport_init( struct target *target );
+int dap_debugport_init( struct adiv5_dap *dap );
 
 /* Probe the AP for ROM Table location */
-int dap_get_debugbase(struct adiv5_dap *dap, int ap,
+int target_cs_get_debugbase( struct target *target, int ap,
+			uint32_t *dbgbase, uint32_t *apid);
+
+int target_cs_get_debugbase2( struct target *target, const struct target_addr *addr,
 			uint32_t *dbgbase, uint32_t *apid);
 
 /* Probe Access Ports to find a particular type */
-int dap_find_ap(struct adiv5_dap *dap,
+int target_cs_find_ap( struct target *target,
 			enum ap_type type_to_find,
 			uint8_t *ap_num_out);
 
 /* Lookup CoreSight component */
-int dap_lookup_cs_component(struct adiv5_dap *dap, int ap,
+int target_cs_lookup_component(struct target *target, const struct target_addr *pAddr,
 			uint32_t dbgbase, uint8_t type, uint32_t *addr, int32_t *idx);
 
-struct target;
 
 /* Put debug link into SWD mode */
 int dap_to_swd(struct target *target);
@@ -489,7 +645,244 @@ extern struct adiv5_dap *global_dap;
 struct swd_driver;
 struct adiv5_dap *adiv5_jtag_dap_new(struct jtag_tap *tap);
 struct adiv5_dap *adiv5_swd_dap_new(const struct swd_driver *swd);
+void adiv5_dap_init_common( struct adiv5_dap *dap );
 
 extern const struct command_registration dap_command_handlers[];
 
+
+struct coresight_address {
+	/* is forced by user (verses discovered) */
+	bool   is_forced;
+	/* what to use, or what was discovered */
+	struct target_addr addr;
+};
+
+/** The CORESIGT settings for a target.
+ * this represents the memory interfaces on the dap.
+ * 
+ * For *SMALL* chips - there are 2 dap ports.
+ *  Port (X) connects directly to the system memory bus.
+ *  Port (Y) connects to the "coresight registers" that control the CPU
+ *
+ * There may be multiple ports, for example Qualcom chips have 4 ports.
+ *   Port (0) - is used for debug (APB)
+ *   Port (1) - is system memory (AXI)
+ *   Port (2) - is a jtag interface (JTAG)
+ *   Port (3) - is a cortex M3 debug bus.
+ */
+
+struct coresight_settings {
+	/** The DAP that this CPU core uses.
+	 * There may be more then one dap in the system.
+	 * Think: Dual Cortex_M cores.
+	 */
+	struct adiv5_dap         *HIDE_dap;
+
+
+	/** DEBUG interface for this CPU.
+	 *
+	 * For Cortex-M parts, the "dbg.addr.addr" is always 0.
+	 * Example: the base address is 0.
+	 *          The CPUID register is defined as 0xE000ED00
+	 *          Think if this as a quasi-physical address.
+	 * 
+	 *
+	 * MULTICORE is different!
+	 * 
+	 * Part 1:
+	 * ------
+	 * The 'dbg.addr.addr' is the base address for the core.
+	 * 
+	 * Example: the core0 base address is 0x02300000
+	 * Example: the core1 base address is 0x02400000
+	 * Example:  ....
+	 *   The dbg.addr.addr = <the above number>"
+	 *
+	 * Part 2:
+	 * ------
+	 * Within that 4k block, at offset 0xD00 is the CPU ID register.
+	 *
+	 * Because this is really "not-a-bus" but a 'bus+base'
+	 * we don't call this the "dbgbus"
+	 */
+	struct coresight_address dbgbus;
+
+	/** Memory interface for this core
+	 * 
+	 * Generally you can think of this as "cpu physical memory space"
+	 *
+	 * This port should have the same interface as the CPU
+	 * and should effectively be a physical memory map
+	 *
+	 */
+	struct coresight_address membus;
+
+
+	/** SOC System Bus Access port 
+	 * 
+	 * In some cases, the CPU may have it's own view of memory
+	 * but there exists another DAP port that is the chip physical memory.
+	 *
+	 * Example: SOC with 2x CortexM3 + Several Armv8
+	 *
+	 * The Armv8 the MemAP equals the SYSBUS
+	 *
+	 * However, the two cortex cores have their own memory view.
+	 * Example:  CPUID @ 0xe000ed00 - exists in two views.
+	 * The first Cortex-M3(A) has one view
+	 * Another view for CoretexM3(B)
+	 *
+	 * And the ArmV8's cannot see or access the M3 bus.
+	 *
+	 * For simple cortex-M3s
+	 *      sysbus=membus=dbgbus
+	 *
+	 * For complex chips... (phone chips)
+	 *      It can be very different.
+	 */
+	struct coresight_address sysbus;
+
+	/* ARMV8 chips always have an CTI module.
+	 * Other cores might not have a CTI module.
+	 * the 'address' is the offset into the DBG bus.
+	 * in the same way that the CPUID register is done
+	 */
+	struct coresight_address cti;
+	/* TODO:
+	 *    Add support for ETM, ETB, and FUNNELs
+	 * 
+	 * Key thing, there may be "layers" of funnels.
+	 * ie: Cluster0 has 4 cpus, and a funnel.
+	 * ie: Clusters[0:3] feed into a funnel called APPS funnel
+	 * ie: Other CPUS feed into funnels (cortex & dsps)
+	 * 
+	 * Finally, there is a common funnel in front of the ETB
+	 */
+};
+
+static inline struct adiv5_dap *coresight_to_dap( const struct coresight_settings *cs )
+{
+	if( cs == NULL ){
+		return NULL;
+	} else {
+		return cs->HIDE_dap;
+	}
+}
+
+int coresight_resolve_route( const struct coresight_settings *cs,
+							 const struct target_addr *pAddr,
+							 struct target_addr *p_NewAddr);
+
+int target_addr_resolve_route( struct target *target,
+							   const struct target_addr *pAddr,
+							   struct target_addr *p_NewAddr );
+	
+
+struct adiv5_dap *target_cs_to_dap( struct target *target );
+
+int target_cs_rd32( struct target *target, const struct target_addr *addr, uint32_t *value );
+int target_cs_rd64( struct target *target, const struct target_addr *addr, uint64_t *value );
+int target_cs_wr32( struct target *target, const struct target_addr *addr, uint32_t value );
+int target_cs_wr64( struct target *target, const struct target_addr *addr, uint64_t value );
+
+int target_cs_addr_queued_rd32( struct target *target, const struct target_addr *addr, uint32_t *value );
+int target_cs_addr_queued_rd64( struct target *target, const struct target_addr *addr, uint64_t *value );
+int target_cs_addr_queued_wr32( struct target *target, const struct target_addr *addr, uint32_t value );
+int target_cs_addr_queued_wr64( struct target *target, const struct target_addr *addr, uint64_t value );
+
+int target_cs_dbg_rd32( struct target *target, uint64_t ofset, uint32_t *value );
+int target_cs_dbg_rd64( struct target *target, uint64_t ofset, uint64_t *value );
+int target_cs_dbg_wr32( struct target *target, uint64_t ofset, uint32_t value );
+int target_cs_dbg_wr64( struct target *target, uint64_t ofset, uint64_t value );
+
+
+int target_cs_dbg_queued_rd32( struct target *target, uint64_t ofset, uint32_t *value );
+int target_cs_dbg_queued_rd64( struct target *target, uint64_t ofset, uint64_t *value );
+int target_cs_dbg_queued_wr32( struct target *target, uint64_t ofset, uint32_t value );
+int target_cs_dbg_queued_wr64( struct target *target, uint64_t ofset, uint64_t value );
+
+/* And some [armv8] always have a CTI interface */
+int target_cs_cti_rd32( struct target *target, uint64_t ofset, uint32_t *value );
+int target_cs_cti_rd64( struct target *target, uint64_t ofset, uint64_t *value );
+int target_cs_cti_wr32( struct target *target, uint64_t ofset, uint32_t value );
+int target_cs_cti_wr64( struct target *target, uint64_t ofset, uint64_t value );
+
+/* And some [armv8] always have a MEM interface */
+int target_cs_mem_rd32( struct target *target, uint64_t ofset, uint32_t *value );
+int target_cs_mem_rd64( struct target *target, uint64_t ofset, uint64_t *value );
+int target_cs_mem_wr32( struct target *target, uint64_t ofset, uint32_t value );
+int target_cs_mem_wr64( struct target *target, uint64_t ofset, uint64_t value );
+
+
+int target_cs_rd_bulk( struct target *target,
+		       const struct target_addr *addr,
+		       size_t item_size,
+		       size_t item_count,
+		       void   *buffer );
+
+int target_cs_wr_bulk( struct target *target,
+		       const struct target_addr *addr,
+		       size_t item_size,
+		       size_t item_count,
+		       const void   *buffer );
+
+int target_cs_rd_bulk_noinc( struct target *target,
+			     const struct target_addr *addr,
+			     size_t item_size,
+			     size_t item_count,
+			     void   *buffer );
+
+int target_cs_wr_bulk_noinc( struct target *target,
+			     const struct target_addr *addr,
+			     size_t item_size,
+			     size_t item_count,
+			     const void   *buffer );
+
+
+int target_cs_mem_rd_bulk( struct target *target,
+			   uint64_t ofset,
+			   size_t item_size,
+			   size_t item_count,
+			   void   *buffer );
+int target_cs_mem_wr_bulk( struct target *target,
+			   uint64_t ofset,
+			   size_t item_size,
+			   size_t item_count,
+			   const void   *buffer );
+
+int target_cs_dbg_rd_bulk( struct target *target,
+			   uint64_t ofset,
+			   size_t item_size,
+			   size_t item_count,
+			   void   *buffer );
+int target_cs_dbg_wr_bulk( struct target *target,
+			   uint64_t ofset,
+			   size_t item_size,
+			   size_t item_count,
+			   const void   *buffer );
+
+int target_cs_dbg_rd_bulk_noinc( struct target *target,
+			   uint64_t ofset,
+			   size_t item_size,
+			   size_t item_count,
+			   void   *buffer );
+
+int target_cs_dbg_wr_bulk_noinc( struct target *target,
+			   uint64_t ofset,
+			   size_t item_size,
+			   size_t item_count,
+			   const void   *buffer );
+
+void target_cs_connect_dap( struct target *target, struct adiv5_dap *dap);
+
+
+int target_cs_dap_run(struct target *target);
+
+			   
+int target_cs_discover_ap( struct target *target,
+						   enum ap_type findme,
+						   struct coresight_address *port );
+
+
+
 #endif
diff --git a/src/target/arm_adi_v5_debug.c b/src/target/arm_adi_v5_debug.c
new file mode 100644
index 0000000..be790ab
--- /dev/null
+++ b/src/target/arm_adi_v5_debug.c
@@ -0,0 +1,403 @@
+ #ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "jtag/interface.h"
+#include "arm.h"
+#include "arm_adi_v5.h"
+#include <helper/time_support.h>
+
+int dap_dbg_lowlevel = 0;
+int dap_dbg_highlevel = 0;
+
+static int dap_log_overflow_once;
+
+#define dap_has_coresight_names(DAP)				\
+	(dap_find_namelist((DAP), (DAP)->cached_ap_port) != NULL)
+
+/* find the name list for this port */
+static const struct dap_coresight_namelist *
+dap_find_namelist( struct adiv5_dap *dap, uint32_t portnum )
+{
+	const struct dap_coresight_namelist *nl;
+
+	nl = dap->dbg.namelist;
+	/* MOST chips have a *SINGLE* dap debug port 
+	 * SOME chips (qualcomm) have two, or three...
+	 * there is no need to make this fancy and fast 
+	 */
+	while( nl ){
+		/* find the port number */
+		if( nl->portnum == portnum ){
+			return nl;
+		}
+		nl = nl->next_port;
+	}
+	return nl;
+}
+
+
+static const struct dap_coresight_block *
+dap_find_reg_block( const struct dap_coresight_namelist *nl, uint64_t a )
+{
+	uint64_t x,y;
+	const struct dap_coresight_block *b;
+
+	if( nl == NULL ){
+		return NULL;
+	}
+	
+	b = nl->blocks;
+
+	while( b ){
+		x = a & ((~b->address_mask));
+		y = b->base_address & (~(b->address_mask));
+
+		if( x == y ){
+			break;
+		}
+
+		b = b->next_block;
+	}
+	return b;
+}
+
+static const struct dap_coresight_name *
+dap_reg_name( const struct dap_coresight_block *blk, uint64_t a )
+{
+	const struct dap_coresight_name *n;
+
+	a = a & (blk->address_mask);
+	n = blk->names;
+
+	while( (n->rd_name) || (n->wr_name) ){
+		if( n->address == a ){
+			return n;
+		}
+		n++;
+	}
+	return NULL;
+}
+
+
+
+static const char *
+dap_coresight_regname( struct adiv5_dap *dap, uint32_t portnum, int is_wr, uint64_t addr )
+{
+	const struct dap_coresight_namelist *nl;
+	const struct dap_coresight_block *blk;
+	const struct dap_coresight_name *n;
+	const char *cp1;
+	const char *cp2;
+	
+	cp1 = "(unknown)";
+	cp2 = "(unknown)";
+	nl = dap_find_namelist( dap,portnum );
+	if( !nl ){
+		goto done;
+	}
+
+	cp1 = dap->name;
+	blk = dap_find_reg_block( nl, addr );
+	if( !blk ){
+		goto done;
+	}
+	cp1 = blk->name;
+
+	n = dap_reg_name( blk, addr );
+	if( n ){
+		if( is_wr ){
+			cp2 = n->wr_name;
+			if( !cp2 ){
+				cp2 = n->rd_name;
+			}
+		} else {
+			cp2 = n->rd_name;
+			if(!cp2){
+				cp2 = n->wr_name;
+			}
+		}
+	}
+ done:
+	snprintf( dap->dbg.coresight_namebuf, sizeof(dap->dbg.coresight_namebuf), "%s.%s", cp1, cp2 );
+	return dap->dbg.coresight_namebuf;
+}
+
+
+/* init the debug context on his dap */
+void dap_dbg_init(struct adiv5_dap *dap )
+{
+	if( dap->name == NULL ){
+		dap->name = strdup("dap");
+	}
+	memset( &(dap->dbg), 0, sizeof(dap->dbg) );
+	
+	dap->dbg.n_log_entries = 0;
+	dap->dbg.n_log_avail   = 20;
+	dap->dbg.log = calloc( dap->dbg.n_log_avail, sizeof( dap->dbg.log[0] ) );
+	if(dap->dbg.log==NULL){
+		dap->dbg.n_log_avail = 0;
+		LOG_ERROR("no memory for dap log?");
+	}
+}
+
+struct dap_access_log * dap_dbg_log_entry(struct adiv5_dap *dap )
+{
+	struct dap_access_log *p;
+	if( dap->dbg.n_log_entries >= dap->dbg.n_log_avail ){
+		if( (dap->dbg.n_log_avail) && (dap_log_overflow_once == 0) ){
+			dap_log_overflow_once = 1;
+			LOG_ERROR("DAP LOG overflow\n");
+		}
+		return NULL;
+	}
+	dap->dbg.n_log_entries += 1;
+	p = &(dap->dbg.log[ dap->dbg.n_log_entries ]);
+	return p;
+}
+
+static const char *dap_ap_regname( unsigned reg, bool is_write )
+{
+	(void)(is_write);
+	const char *cp;
+	switch( reg ){
+	default:
+		cp = "ap-unknown";
+		break;
+	case AP_MEM_REG_CSW:
+		cp = "ap-csw";
+		break;
+	case AP_MEM_REG_TAR_lo:
+		cp = "ap-tar-lo";
+		break;
+	case AP_MEM_REG_TAR_hi:
+		cp = "ap-tar-hi";
+		break;
+	case AP_MEM_REG_DRW:
+		cp = "ap-drw";
+		break;
+	case AP_MEM_REG_BD0:
+		cp = "ap-bd0";
+		break;
+	case AP_MEM_REG_BD1:
+		cp = "ap-bd1";
+		break;
+	case AP_MEM_REG_BD2:
+		cp = "ap-bd2";
+		break;
+	case AP_MEM_REG_BD3:
+		cp = "ap-bd3";
+		break;
+	case AP_MEM_REG_CFG:
+		cp = "ap-cfg";
+		break;
+	case AP_MEM_REG_BASE:
+		cp = "ap-base";
+		break;
+	}
+	return cp;
+}
+
+static const char *dap_dp_regname( unsigned reg, bool is_write, bool is_swd )
+{
+#if DP_IDCODE != DP_ABORT
+#error fix me
+#endif
+#if DP_RESEND != DP_SELECT
+#error fix me
+#endif
+	const char *cp;
+	(void)(is_write);
+	switch( reg ){
+	default:
+		cp = "uknown";
+		break;
+	case DP_IDCODE:
+		if( is_write ){
+			cp = "dp-abort";
+		} else {
+			cp = "dp-idcode";
+		}
+		break;
+	case DP_CTRL_STAT:
+		cp = "dp-ctrl-stat";
+		break;
+	case DP_RESEND:
+		if( is_swd ){
+			cp = "dp-resend";
+		} else {
+			cp = "dp-select";
+		}
+		break;
+	case DP_RDBUFF:
+		cp = "dp-rdbuf";
+		break;
+	case DP_WCR:
+		cp = "dp-wcr";
+		break;
+	}
+	return cp;
+}
+
+
+void dap_dbg_highlevel_xx( struct adiv5_dap *dap, uint32_t address, bool is_wr, char *value )
+{
+	const char *cp;
+
+	if( !dap_dbg_highlevel ){
+		return;
+	}
+	
+	if( !dap_has_coresight_names( dap ) ){
+		return;
+	}
+	
+	cp = dap_coresight_regname( dap, dap->cached_ap_port, is_wr, address );
+	LOG_OUTPUT("dap-%s: 0x%08" PRIx32 " (%8s) %s\n",
+		   (is_wr ? "wr" : "rd"),
+		   address,
+		   cp,
+		   value );
+}
+
+
+
+void dap_dbg_highlevel_wr32( struct adiv5_dap *dap, uint32_t address, uint32_t value)
+{
+	char buf[20];
+
+	if( !dap_dbg_highlevel ){
+		return;
+	}
+	snprintf( buf, sizeof(buf),"0x%08" PRIx32 , value );
+
+	dap_dbg_highlevel_xx( dap, 1, address, buf );
+}
+
+
+void dap_dbg_highlevel_rd32( struct adiv5_dap *dap, uint32_t address, uint32_t *value)
+{
+	char *cp;
+	char buf[20];
+	if( !dap_dbg_highlevel ){
+		return;
+	}
+	if( value ){
+		snprintf( buf,sizeof(buf), "0x%08" PRIx32, *value );
+		cp = buf;
+	} else {
+		cp = "dummy";
+	}
+
+	dap_dbg_highlevel_xx(dap, 0, address,cp);
+}
+
+#define PRINTBUFSIZE 30
+static void print_num( char *buf, int width, uint64_t val )
+{
+	snprintf( buf, PRINTBUFSIZE,  "0x%0*" PRIx64,  width, val );
+}
+
+
+void dap_dbg_log_dump( struct adiv5_dap *dap )
+{
+	unsigned x;
+	const char *regname;
+	const char *val;
+	struct dap_access_log *p;
+	int is_wr;
+	char buf[PRINTBUFSIZE];
+
+	if( dap_dbg_lowlevel <= 0 ){
+		return;
+	}
+
+	for( x = 0 ; x < dap->dbg.n_log_entries ; x++ ){
+		p = &(dap->dbg.log[x]);
+		
+		is_wr = 0;
+		val = buf;
+		switch( p->access_type ){
+		case DAP_AP_ABORT:
+			/* data is uint8 */
+			p->dataval = * ((uint8_t *)(p->pointer));
+			LOG_OUTPUT( "dap: abort result: 0x%02" PRIx64 "\n", p->dataval );
+			break;
+		case DAP_DP_WR:
+			is_wr++;
+			/* fall through */
+		case DAP_DP_RD:
+			regname = dap_dp_regname( p->reg, is_wr, dap->ops->is_swd );
+			if( !is_wr ){
+				if( p->pointer ){
+					p->dataval = *((uint32_t *)(p->pointer));
+				} else {
+					val = "dummy-rd";
+				}
+			}
+			print_num( buf, 8, p->dataval );
+			LOG_OUTPUT( "dap-%s: %-8s: %s\n", is_wr ? "wr" : "rd", regname, val );
+			break;
+		case DAP_AP_WR:
+			is_wr++;
+			/* fallthrough */
+		case DAP_AP_RD:
+			regname = dap_ap_regname( p->reg, is_wr );
+			if( !is_wr ){
+				if( p->pointer ){
+					p->dataval = *((uint32_t *)(p->pointer));
+				} else {
+					val = "dummy-rd";
+				}
+			}
+			print_num( buf, 8, p->dataval );
+			LOG_OUTPUT( "dap-%s: %-8s: %s\n", is_wr ? "wr" : "rd", regname, val );
+			break;
+		case MEM_AP_WR32:
+		case MEM_AP_WR64:
+			is_wr++;
+			/* fallthrough */
+		case MEM_AP_RD32:
+		case MEM_AP_RD64:
+			/* REG = dap port number */
+			/* ADR = register address */
+			regname = dap_coresight_regname( dap, p->reg, is_wr, p->address );
+			if( !is_wr ){
+				if( p->pointer ){
+					if( p->access_type == MEM_AP_RD64 ){
+						p->dataval = *((uint64_t *)(p->pointer));
+					} else {
+						p->dataval = *((uint32_t *)(p->pointer));
+					}
+				} else {
+					val = "dummy-rd";
+				}
+			}
+			if( (p->access_type == MEM_AP_RD64) || (p->access_type == MEM_AP_WR64) ){
+				print_num( buf, 16, p->dataval );
+			} else {
+				/* 32bit */
+				print_num( buf,  8, p->dataval );
+			}
+			LOG_OUTPUT( "dap-%s: %20s: %s\n", is_wr ? "wr" : "rd", regname, val );
+			break;
+		case MEM_AP_WRBULK:
+			is_wr++;
+			/* fallthrough */
+		case MEM_AP_RDBULK:
+			/* this has no names */
+			regname = dap_coresight_regname( dap, p->reg, is_wr, p->address );
+			LOG_OUTPUT("dap-bulk-%s: @ 0x%08" PRIx64 " inc:%d len: 0x%08" PRIx64 "\n",
+				   is_wr ? "wr" : "rd",
+				   p->address,
+				   p->reg ? 1 : 0,
+				   p->dataval );
+			break;
+		}
+	}
+	/* clear log array */
+	dap->dbg.n_log_entries = 0;
+	memset( (void *)(dap->dbg.log),
+		0,
+		sizeof(dap->dbg.log[0]) * dap->dbg.n_log_avail );
+}
diff --git a/src/target/arm_adi_v5_debug.h b/src/target/arm_adi_v5_debug.h
new file mode 100644
index 0000000..071ff9c
--- /dev/null
+++ b/src/target/arm_adi_v5_debug.h
@@ -0,0 +1,69 @@
+/* Copyright qualcomm */
+
+struct adiv5_dap;
+
+struct dap_access_log {
+	int access_type;
+#define DAP_DP_RD     ( ('d' << 24) | ('p'<<16) | ('r'<<8) | ('d'<<0))
+#define DAP_DP_WR     ( ('d' << 24) | ('p'<<16) | ('w'<<8) | ('r'<<0))
+#define DAP_AP_RD     ( ('a' << 24) | ('p'<<16) | ('r'<<8) | ('d'<<0))
+#define DAP_AP_WR     ( ('a' << 24) | ('p'<<16) | ('w'<<8) | ('r'<<0))
+#define DAP_AP_ABORT  ( ('a' << 24) | ('a'<<16) | ('b'<<8) | ('t'<<0))
+#define MEM_AP_RD32   ( ('m' << 24) | ('r'<<16) | ('d'<<8) | (32 <<0))
+#define MEM_AP_WR32   ( ('m' << 24) | ('w'<<16) | ('r'<<8) | (32 <<0))
+#define MEM_AP_RD64   ( ('m' << 24) | ('r'<<16) | ('d'<<8) | (64 <<0))
+#define MEM_AP_WR64   ( ('m' << 24) | ('w'<<16) | ('r'<<8) | (64 <<0))
+#define MEM_AP_RDBULK ( ('m' << 24) | ('r'<<16) | ('b'<<8) | ('l'<<0))
+#define MEM_AP_WRBULK ( ('m' << 24) | ('w'<<16) | ('b'<<8) | ('l'<<0))
+	
+	unsigned reg;
+	uint64_t dataval;
+	uint64_t address;
+	void     *pointer;
+};
+
+
+struct dap_coresight_name {
+	/* register name */
+	/* terminated with both rd & wr name = 0 */
+	const char *rd_name;
+	const char *wr_name;
+	uint64_t    address;
+};
+
+#define DAP_CORESIGHT_NAME_TERMINATE()   { .address = 0, .wr_name = NULL, .rd_name = NULL }
+
+struct dap_coresight_block {
+	/* Example:  The CPU vrs ETM vrs STM */
+	/* base of this block */
+	const char *name;
+	uint64_t base_address;
+	/* typically mask = 0xFFF (size=4k)*/
+	uint64_t address_mask;
+	const struct dap_coresight_name *names;
+	const struct dap_coresight_block *next_block;
+} ;
+
+struct dap_coresight_namelist {
+	/* Example the DEBUG AP vrs the MEM AP */
+	uint32_t portnum;
+	/* list of blocks on this port */
+	const struct dap_coresight_block  *blocks;
+	/* next port */
+	const struct dap_coresight_namelist *next_port;
+};
+
+struct dap_debug_info {
+	struct dap_access_log *log;
+	size_t n_log_avail;
+	size_t n_log_entries;
+	char   coresight_namebuf[30];
+	
+	/* list of names on this dap port */
+	const struct dap_coresight_namelist *namelist;
+} ;
+
+struct dap_access_log * dap_dbg_log_entry(struct adiv5_dap *dap );
+
+void dap_dbg_log_dump( struct adiv5_dap *dap );
+void dap_dbg_init(struct adiv5_dap *dap );
diff --git a/src/target/arm_adi_v5_mem_ap.c b/src/target/arm_adi_v5_mem_ap.c
new file mode 100644
index 0000000..6f1ec08
--- /dev/null
+++ b/src/target/arm_adi_v5_mem_ap.c
@@ -0,0 +1,85 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "jtag/interface.h"
+#include "arm.h"
+#include "arm_adi_v5.h"
+#include <helper/time_support.h>
+
+/*--------------------------------------------------------------------*/
+/*          Wrapping function with selection of AP                    */
+/*--------------------------------------------------------------------*/
+
+
+
+
+/**
+ * Synchronous read of a word from memory or a system register.
+ * As a side effect, this flushes any queued transactions.
+ *
+ * @param dap The DAP connected to the MEM-AP performing the read.
+ * @param pAddr PAddr of the 32-bit word to read; it must be
+ *	readable by the currently selected MEM-AP.
+ * @param value points to where the result will be stored.
+ *
+ * @return ERROR_OK for success; *value holds the result.
+ * Otherwise a fault code.
+ */
+
+int mem_ap_read_atomic_u32(struct adiv5_dap *dap, const struct target_addr *pAddr,
+		uint32_t *value)
+{
+	int retval;
+
+	retval = mem_ap_read_u32(dap, pAddr, value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dap_run(dap);
+}
+
+int mem_ap_read_atomic_u64(struct adiv5_dap *dap, const struct target_addr *pAddr,
+		uint64_t *value)
+{
+	int retval;
+
+	retval = mem_ap_read_u64(dap, pAddr, value );
+	if (retval == ERROR_OK){
+		retval = dap_run(dap);
+	}
+	return retval;
+}
+
+
+/**
+ * Synchronous write of a word to memory or a system register.
+ * As a side effect, this flushes any queued transactions.
+ *
+ * @param dap The DAP connected to the MEM-AP.
+ * @param pAddr address to be written; 
+ * @param value Word that will be written.
+ *
+ * @return ERROR_OK for success; the data was written.  Otherwise a fault code.
+ */
+int mem_ap_write_atomic_u32(struct adiv5_dap *dap, const struct target_addr *pAddr,
+		uint32_t value)
+{
+	int retval = mem_ap_write_u32(dap, pAddr, value);
+
+	if (retval == ERROR_OK)
+		retval = dap_run(dap);
+	return retval;
+}
+
+int mem_ap_write_atomic_u64(struct adiv5_dap *dap, const struct target_addr *pAddr,
+		uint64_t value)
+{
+	int retval = mem_ap_write_u64(dap, pAddr, value);
+	if (retval == ERROR_OK)
+		retval = dap_run(dap);
+
+	return retval;
+}
+
+
diff --git a/src/target/arm_dpm.c b/src/target/arm_dpm.c
index 1c0025b..cda900a 100755
--- a/src/target/arm_dpm.c
+++ b/src/target/arm_dpm.c
@@ -55,7 +55,7 @@ static int dpm_mrc(struct target *target, int cpnum,
 	uint32_t *value)
 {
 	struct arm *arm = target_to_arm(target);
-	struct arm_dpm *dpm = arm->dpm;
+	struct arm_dpm *dpm = arm_to_arm_dpm(arm);
 	int retval;
 
 	retval = dpm->prepare(dpm);
@@ -80,7 +80,7 @@ static int dpm_mcr(struct target *target, int cpnum,
 	uint32_t value)
 {
 	struct arm *arm = target_to_arm(target);
-	struct arm_dpm *dpm = arm->dpm;
+	struct arm_dpm *dpm = arm_to_arm_dpm(arm);
 	int retval;
 
 	retval = dpm->prepare(dpm);
@@ -336,7 +336,7 @@ static int dpm_maybe_update_bpwp(struct arm_dpm *dpm, bool bpwp,
 	if (retval != ERROR_OK)
 		LOG_ERROR("%s: can't %s HW %spoint %d",
 			disable ? "disable" : "enable",
-			target_name(dpm->arm->target),
+			target_name(arm_dpm_to_target(dpm)),
 			(xp->number < 16) ? "break" : "watch",
 			xp->number & 0xf);
 done:
@@ -371,7 +371,7 @@ int arm_dpm_write_dirty_registers(struct arm_dpm *dpm, bool bpwp)
 	 * we should be able to assume we handle them; but until then,
 	 * cope with the hand-crafted breakpoint code.
 	 */
-	if (arm->target->type->add_breakpoint == dpm_add_breakpoint) {
+	if (arm_to_target(arm)->type->add_breakpoint == dpm_add_breakpoint) {
 		for (unsigned i = 0; i < dpm->nbp; i++) {
 			struct dpm_bp *dbp = dpm->dbp + i;
 			struct breakpoint *bp = dbp->bp;
@@ -581,7 +581,7 @@ fail:
 }
 
 static int arm_dpm_write_core_reg(struct target *target, struct reg *r,
-	int regnum, enum arm_mode mode, uint32_t value)
+	int regnum, enum arm_mode mode, uint64_t value)
 {
 	struct arm_dpm *dpm = target_to_arm(target)->dpm;
 	int retval;
@@ -624,7 +624,7 @@ fail:
 static int arm_dpm_full_context(struct target *target)
 {
 	struct arm *arm = target_to_arm(target);
-	struct arm_dpm *dpm = arm->dpm;
+	struct arm_dpm *dpm = arm_to_arm_dpm(arm);
 	struct reg_cache *cache = arm->core_cache;
 	int retval;
 	bool did_read;
@@ -705,8 +705,10 @@ done:
 static int dpm_bpwp_setup(struct arm_dpm *dpm, struct dpm_bpwp *xp,
 	uint32_t addr, uint32_t length)
 {
+	struct target *target;
 	uint32_t control;
 
+	target = arm_dpm_to_target( dpm );
 	control = (1 << 0)	/* enable */
 		| (3 << 1);	/* both user and privileged access */
 
@@ -752,8 +754,8 @@ static int dpm_bpwp_setup(struct arm_dpm *dpm, struct dpm_bpwp *xp,
 	xp->control = control;
 	xp->dirty = true;
 
-	LOG_DEBUG("BPWP: addr %8.8" PRIx32 ", control %" PRIx32 ", number %d",
-		xp->address, control, xp->number);
+	LOG_DEBUG("BPWP: addr %s, control %" PRIx32 ", number %d",
+		  target_addr64str1( target, xp->address), control, xp->number);
 
 	/* hardware is updated in write_dirty_registers() */
 	return ERROR_OK;
@@ -762,7 +764,7 @@ static int dpm_bpwp_setup(struct arm_dpm *dpm, struct dpm_bpwp *xp,
 static int dpm_add_breakpoint(struct target *target, struct breakpoint *bp)
 {
 	struct arm *arm = target_to_arm(target);
-	struct arm_dpm *dpm = arm->dpm;
+	struct arm_dpm *dpm = arm_to_arm_dpm(arm);
 	int retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 
 	if (bp->length < 2)
@@ -790,7 +792,7 @@ static int dpm_add_breakpoint(struct target *target, struct breakpoint *bp)
 static int dpm_remove_breakpoint(struct target *target, struct breakpoint *bp)
 {
 	struct arm *arm = target_to_arm(target);
-	struct arm_dpm *dpm = arm->dpm;
+	struct arm_dpm *dpm = arm_to_arm_dpm(arm);
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
 
 	for (unsigned i = 0; i < dpm->nbp; i++) {
@@ -846,7 +848,7 @@ static int dpm_watchpoint_setup(struct arm_dpm *dpm, unsigned index_t,
 static int dpm_add_watchpoint(struct target *target, struct watchpoint *wp)
 {
 	struct arm *arm = target_to_arm(target);
-	struct arm_dpm *dpm = arm->dpm;
+	struct arm_dpm *dpm = arm_to_arm_dpm(arm);
 	int retval = ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 
 	if (dpm->bpwp_enable) {
@@ -864,7 +866,7 @@ static int dpm_add_watchpoint(struct target *target, struct watchpoint *wp)
 static int dpm_remove_watchpoint(struct target *target, struct watchpoint *wp)
 {
 	struct arm *arm = target_to_arm(target);
-	struct arm_dpm *dpm = arm->dpm;
+	struct arm_dpm *dpm = arm_to_arm_dpm(arm);
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
 
 	for (unsigned i = 0; i < dpm->nwp; i++) {
@@ -906,7 +908,7 @@ void arm_dpm_report_wfar(struct arm_dpm *dpm, uint32_t addr)
 
 void arm_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
 {
-	struct target *target = dpm->arm->target;
+	struct target *target = arm_dpm_to_target(dpm);
 
 	dpm->dscr = dscr;
 
@@ -948,8 +950,8 @@ void arm_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
  */
 int arm_dpm_setup(struct arm_dpm *dpm)
 {
-	struct arm *arm = dpm->arm;
-	struct target *target = arm->target;
+	struct arm *arm = arm_dpm_to_arm(dpm);
+	struct target *target = arm_to_target(arm);
 	struct reg_cache *cache;
 
 	arm->dpm = dpm;
@@ -1023,7 +1025,7 @@ int arm_dpm_initialize(struct arm_dpm *dpm)
 		}
 	} else
 		LOG_WARNING("%s: can't disable breakpoints and watchpoints",
-			target_name(dpm->arm->target));
+			    target_name( arm_dpm_to_target(dpm) ));
 
 	return ERROR_OK;
 }
diff --git a/src/target/arm_dpm.h b/src/target/arm_dpm.h
index 73ed1bc..04380ec 100755
--- a/src/target/arm_dpm.h
+++ b/src/target/arm_dpm.h
@@ -33,7 +33,7 @@
 
 struct dpm_bpwp {
 	unsigned number;
-	uint32_t address;
+	uint64_t address;
 	uint32_t control;
 	/* true if hardware state needs flushing */
 	bool dirty;
@@ -101,7 +101,7 @@ struct arm_dpm {
 	 * breakpoints; indices 16..31 are for watchpoints.
 	 */
 	int (*bpwp_enable)(struct arm_dpm *, unsigned index_value,
-			uint32_t addr, uint32_t control);
+			uint64_t addr, uint32_t control);
 
 	/**
 	 * Disables one breakpoint or watchpoint by clearing its
@@ -121,7 +121,7 @@ struct arm_dpm {
 	struct dpm_wp *dwp;
 
 	/** Address of the instruction which triggered a watchpoint. */
-	uint32_t wp_pc;
+	uint64_t wp_pc;
 
 	/** Recent value of DSCR. */
 	uint32_t dscr;
@@ -129,6 +129,18 @@ struct arm_dpm {
 	/* FIXME -- read/write DCSR methods and symbols */
 };
 
+/** Convert an ARM Cortex Debug Programmers Model to an ARM pointer */
+static inline struct arm *arm_dpm_to_arm( struct arm_dpm *dpm )
+{
+	return dpm->arm;
+}
+
+static inline struct target *arm_dpm_to_target( struct arm_dpm *dpm )
+{
+	return arm_to_target( arm_dpm_to_arm( dpm ) );
+}
+
+
 int arm_dpm_setup(struct arm_dpm *dpm);
 int arm_dpm_initialize(struct arm_dpm *dpm);
 
@@ -200,4 +212,5 @@ void arm_dpm_report_wfar(struct arm_dpm *, uint32_t wfar);
 
 void arm_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dcsr);
 
+
 #endif /* __ARM_DPM_H */
diff --git a/src/target/arm_semihosting.c b/src/target/arm_semihosting.c
index 2237693..da2d7d7 100755
--- a/src/target/arm_semihosting.c
+++ b/src/target/arm_semihosting.c
@@ -471,10 +471,7 @@ static int do_semihosting(struct target *target)
 int arm_semihosting_v8(struct target *target, int *retval)
 {
 	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a);
-	struct armv8 *armv8 = &armv8_common->armv8;
-	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
-	struct arm *arm = &armv7a->arm;
+	struct arm *arm = cortex_a_to_arm(cortex_a);
 	uint32_t pc, lr, spsr, cpsr;
 	struct reg *r;
 	int result;
@@ -511,6 +508,7 @@ int arm_semihosting_v8(struct target *target, int *retval)
 	if (spsr & 0x20)
 		arm->core_state = ARM_STATE_THUMB;
 
+	result = -1;
 	/* return value in R0 */
 	buf_set_u32(arm->core_cache->reg_list[0].value, 0, 32, result);
 	arm->core_cache->reg_list[0].dirty = 1;
diff --git a/src/target/armv4_5.c b/src/target/armv4_5.c
index c905357..50a9957 100755
--- a/src/target/armv4_5.c
+++ b/src/target/armv4_5.c
@@ -655,7 +655,7 @@ int arm_arch_state(struct target *target)
 {
 	struct arm *arm = target_to_arm(target);
 
-	if (arm->common_magic != ARM_COMMON_MAGIC) {
+	if ( !is_arm(arm) ){
 		LOG_ERROR("BUG: called for a non-ARM target");
 		return ERROR_FAIL;
 	}
@@ -1622,9 +1622,9 @@ static int arm_default_mcr(struct target *target, int cpnum,
 int arm_init_arch_info(struct target *target, struct arm *arm)
 {
 	target->arch_info = arm;
-	arm->target = target;
+	arm->HIDE_target = target;
 
-	arm->common_magic = ARM_COMMON_MAGIC;
+	arm->common_arm_magic = ARM_COMMON_MAGIC;
 
 	/* core_type may be overridden by subtype logic */
 	if (arm->core_type != ARM_MODE_THREAD) {
diff --git a/src/target/armv7a.c b/src/target/armv7a.c
index e009f8d..c8703cf 100755
--- a/src/target/armv7a.c
+++ b/src/target/armv7a.c
@@ -44,7 +44,7 @@ static void armv7a_show_fault_registers(struct target *target)
 {
 	uint32_t dfsr, ifsr, dfar, ifar;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm_dpm *dpm = armv7a->arm.dpm;
+	struct arm_dpm *dpm = armv7a_to_arm_dpm(armv7a);
 	int retval;
 
 	retval = dpm->prepare(dpm);
@@ -91,7 +91,7 @@ done:
 static int armv7a_read_ttbcr(struct target *target)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm_dpm *dpm = armv7a->arm.dpm;
+	struct arm_dpm *dpm = armv7a_to_arm_dpm(armv7a);
 	uint32_t ttbcr;
 	int retval = dpm->prepare(dpm);
 	if (retval != ERROR_OK)
@@ -130,7 +130,7 @@ int armv7a_mmu_translate_va(struct target *target,  uint32_t va, uint32_t *val)
 	uint32_t second_lvl_descriptor = 0x0;
 	int retval;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm_dpm *dpm = armv7a->arm.dpm;
+	struct arm_dpm *dpm = armv7a_to_arm_dpm(armv7a);
 	uint32_t ttb = 0;	/*  default ttb0 */
 	if (armv7a->armv7a_mmu.ttbr1_used == -1)
 		armv7a_read_ttbcr(target);
@@ -228,7 +228,7 @@ int armv7a_mmu_translate_va_pa(struct target *target, uint32_t va,
 {
 	int retval = ERROR_FAIL;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm_dpm *dpm = armv7a->arm.dpm;
+	struct arm_dpm *dpm = armv7a_to_arm_dpm(armv7a);
 	uint32_t virt = va & ~0xfff;
 	uint32_t NOS, NS, INNER, OUTER;
 	*val = 0xdeadbeef;
@@ -333,7 +333,7 @@ static int armv7a_handle_inner_cache_info_command(struct command_context *cmd_ct
 static int _armv7a_flush_all_data(struct target *target)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm_dpm *dpm = armv7a->arm.dpm;
+	struct arm_dpm *dpm = armv7a_to_arm_dpm(armv7a);
 	struct armv7a_cachesize *d_u_size =
 		&(armv7a->armv7a_mmu.armv7a_cache.d_u_size);
 	int32_t c_way, c_index = d_u_size->index;
@@ -533,7 +533,7 @@ static int armv7a_read_mpidr(struct target *target)
 {
 	int retval = ERROR_FAIL;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm_dpm *dpm = armv7a->arm.dpm;
+	struct arm_dpm *dpm = armv7a_to_arm_dpm(armv7a);
 	uint32_t mpidr;
 	retval = dpm->prepare(dpm);
 	if (retval != ERROR_OK)
@@ -578,8 +578,9 @@ int armv7a_identify_cache(struct target *target)
 {
 	/*  read cache descriptor */
 	int retval = ERROR_FAIL;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm_dpm *dpm = armv7a->arm.dpm;
+	struct armv7a_common	*armv7a = target_to_armv7a(target);
+	struct arm_dpm		*dpm    = armv7a_to_arm_dpm(armv7a);
+	struct arm		*arm	= armv7a_to_arm( armv7a );
 	uint32_t cache_selected, clidr;
 	uint32_t cache_i_reg, cache_d_reg;
 	struct armv7a_cache_common *cache = &(armv7a->armv7a_mmu.armv7a_cache);
@@ -611,7 +612,7 @@ int armv7a_identify_cache(struct target *target)
 	if (retval != ERROR_OK)
 		goto done;
 
-	retval = armv7a->arm.mrc(target, 15,
+	retval =arm->mrc(target, 15,
 			2, 0,	/* op1, op2 */
 			0, 0,	/* CRn, CRm */
 			&cache_selected);
@@ -728,13 +729,13 @@ done:
 
 int armv7a_init_arch_info(struct target *target, struct armv7a_common *armv7a)
 {
-	struct arm *arm = &armv7a->arm;
-	arm->arch_info = armv7a;
-	target->arch_info = &armv7a->arm;
+	struct arm *arm   = &armv7a->HIDE_arm;
+	arm->arch_info    = armv7a;
+	target->arch_info = arm;
 	/*  target is useful in all function arm v4 5 compatible */
-	armv7a->arm.target = target;
-	armv7a->arm.common_magic = ARM_COMMON_MAGIC;
-	armv7a->common_magic = ARMV7_COMMON_MAGIC;
+	arm->HIDE_target = target;
+	arm->common_arm_magic = ARM_COMMON_MAGIC;
+	armv7a->common_armv7a_magic = ARMV7_COMMON_MAGIC;
 	armv7a->armv7a_mmu.armv7a_cache.l2_cache = NULL;
 	armv7a->armv7a_mmu.armv7a_cache.ctype = -1;
 	armv7a->armv7a_mmu.armv7a_cache.flush_all_data_cache = NULL;
@@ -749,9 +750,10 @@ int armv7a_arch_state(struct target *target)
 	};
 
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *arm = &armv7a->arm;
+	struct arm *arm = armv7a_to_arm(armv7a);
+	struct arm_dpm *arm_dpm = armv7a_to_arm_dpm(armv7a);
 
-	if (armv7a->common_magic != ARMV7_COMMON_MAGIC) {
+	if ( !is_armv7a( armv7a) ){
 		LOG_ERROR("BUG: called for a non-ARMv7A target");
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
@@ -773,7 +775,7 @@ int armv7a_arch_state(struct target *target)
 		armv7a_show_fault_registers(target);
 	if (target->debug_reason == DBG_REASON_WATCHPOINT)
 		LOG_USER("Watchpoint triggered at PC %#08x",
-			(unsigned) armv7a->dpm.wp_pc);
+			(unsigned) arm_dpm->wp_pc);
 
 	return ERROR_OK;
 }
diff --git a/src/target/armv7a.h b/src/target/armv7a.h
index 5cd7a64..241e5a0 100755
--- a/src/target/armv7a.h
+++ b/src/target/armv7a.h
@@ -80,25 +80,25 @@ struct armv7a_mmu_common {
 	int32_t ttbr1_used; /*  -1 not initialized, 0 no ttbr1 1 ttbr1 used and  */
 	uint32_t ttbr0_mask;/*  masked to be used  */
 	uint32_t os_border;
-
+	
 	int (*read_physical_memory)(struct target *target, uint32_t address, uint32_t size,
-			uint32_t count, uint8_t *buffer);
+								uint32_t count, uint8_t *buffer);
 	struct armv7a_cache_common armv7a_cache;
 	uint32_t mmu_enabled;
 };
 
 struct armv7a_common {
-	struct arm arm;
-	int common_magic;
+	
+	struct arm HIDE_arm;
+	int common_armv7a_magic;
 	struct reg_cache *core_cache;
 
+	uint32_t cpuid_reg;
+	
+  
 	/* Core Debug Unit */
-	struct arm_dpm dpm;
-	uint32_t debug_base;
-	uint32_t cti_base;
-	uint8_t debug_ap;
-	uint8_t memory_ap;
-	bool memory_ap_available;
+	struct arm_dpm HIDE_dpm;
+
 	/* mdir */
 	uint8_t multi_processor_system;
 	uint8_t cluster_id;
@@ -114,10 +114,43 @@ struct armv7a_common {
 	void (*pre_restore_context)(struct target *target);
 };
 
+static inline bool is_armv7a( struct armv7a_common *p )
+{
+	return (ARMV7_COMMON_MAGIC == p->common_armv7a_magic);
+}
+
 static inline struct armv7a_common *
 target_to_armv7a(struct target *target)
 {
-	return container_of(target->arch_info, struct armv7a_common, arm);
+	struct armv7a_common *r;
+	r = container_of(target->arch_info, struct armv7a_common, HIDE_arm);
+	assert( is_armv7a( r ) );
+	return r;
+}
+
+static inline struct arm_dpm *armv7a_to_arm_dpm( struct armv7a_common *armv7a_common )
+{
+	return &(armv7a_common->HIDE_dpm);
+}
+
+static inline struct arm *
+armv7a_to_arm( struct armv7a_common *armv7a_common )
+{
+	return &(armv7a_common->HIDE_arm);
+}
+
+static struct target *armv7a_to_target( struct armv7a_common *armv7a )
+{
+	return arm_to_target( armv7a_to_arm(armv7a) );
+}
+
+static inline bool armv7a_mem_ap_avail( struct armv7a_common *armv7a )
+{
+	struct coresight_settings *p;
+
+	p = target_to_coresight( armv7a_to_target( armv7a ) );
+
+	return (p->membus.addr.route != TA_ROUTE_DEFAULT);
 }
 
 /* register offsets from armv7a.debug_base */
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index 99af3a8..9d92916 100755
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -213,7 +213,7 @@ static int armv7m_read_core_reg(struct target *target, struct reg *r,
 }
 
 static int armv7m_write_core_reg(struct target *target, struct reg *r,
-	int num, enum arm_mode mode, uint32_t value)
+	int num, enum arm_mode mode, uint64_t value)
 {
 	int retval;
 	struct arm_reg *armv7m_core_reg;
@@ -231,7 +231,7 @@ static int armv7m_write_core_reg(struct target *target, struct reg *r,
 		return ERROR_JTAG_DEVICE_ERROR;
 	}
 
-	LOG_DEBUG("write core reg %i value 0x%" PRIx32 "", num, value);
+	LOG_DEBUG("write core reg %i value 0x%s", num, target_addr64str1( target, value ));
 	armv7m->arm.core_cache->reg_list[num].valid = 1;
 	armv7m->arm.core_cache->reg_list[num].dirty = 0;
 
@@ -302,7 +302,7 @@ int armv7m_start_algorithm(struct target *target,
 	/* NOTE: armv7m_run_algorithm requires that each algorithm uses a software breakpoint
 	 * at the exit point */
 
-	if (armv7m_algorithm_info->common_magic != ARMV7M_COMMON_MAGIC) {
+	if ( is_armv7m_algorithm( armv7m_algorithm_info) ){
 		LOG_ERROR("current target isn't an ARMV7M target");
 		return ERROR_TARGET_INVALID;
 	}
@@ -390,7 +390,7 @@ int armv7m_wait_algorithm(struct target *target,
 	/* NOTE: armv7m_run_algorithm requires that each algorithm uses a software breakpoint
 	 * at the exit point */
 
-	if (armv7m_algorithm_info->common_magic != ARMV7M_COMMON_MAGIC) {
+	if (is_armv7m_algorithm(armv7m_algorithm_info)) {
 		LOG_ERROR("current target isn't an ARMV7M target");
 		return ERROR_TARGET_INVALID;
 	}
@@ -576,7 +576,7 @@ int armv7m_init_arch_info(struct target *target, struct armv7m_common *armv7m)
 {
 	struct arm *arm = &armv7m->arm;
 
-	armv7m->common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m->common_armv7m_magic = ARMV7M_COMMON_MAGIC;
 	armv7m->fp_feature = FP_NONE;
 
 	arm->core_type = ARM_MODE_THREAD;
@@ -643,7 +643,7 @@ int armv7m_checksum_memory(struct target *target,
 	if (retval != ERROR_OK)
 		goto cleanup;
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_COMMON_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);
@@ -703,7 +703,7 @@ int armv7m_blank_check_memory(struct target *target,
 	if (retval != ERROR_OK)
 		return retval;
 
-	armv7m_info.common_magic = ARMV7M_COMMON_MAGIC;
+	armv7m_info.common_armv7m_algo_magic = ARMV7M_ALGO_MAGIC;
 	armv7m_info.core_mode = ARM_MODE_THREAD;
 
 	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index ca409df..13bf25f 100755
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -142,7 +142,7 @@ enum {
 struct armv7m_common {
 	struct arm	arm;
 
-	int common_magic;
+	int common_armv7m_magic;
 	int exception_number;
 
 	int fp_feature;
@@ -161,25 +161,43 @@ struct armv7m_common {
 	void (*pre_restore_context)(struct target *target);
 };
 
-static inline struct armv7m_common *
-target_to_armv7m(struct target *target)
+static inline struct arm *armv7m_to_arm( struct armv7m_common *armv7m )
 {
-	return container_of(target->arch_info, struct armv7m_common, arm);
+	return &(armv7m->arm);
 }
 
-static inline bool is_armv7m(struct armv7m_common *armv7m)
+
+static inline bool is_armv7m( struct armv7m_common *a )
+{
+	return (ARMV7M_COMMON_MAGIC == a->common_armv7m_magic);
+}
+
+
+static inline struct armv7m_common *
+target_to_armv7m(struct target *target)
 {
-	return armv7m->common_magic == ARMV7M_COMMON_MAGIC;
+	struct armv7m_common *r;
+	r = container_of(target->arch_info, struct armv7m_common, arm);
+	assert( is_armv7m(r) );
+	return r;
 }
 
+
+#define ARMV7M_ALGO_MAGIC ( ('A'<<24) | ('7'<<16) | ('M'<<8) | ('A'<<0))
+
 struct armv7m_algorithm {
-	int common_magic;
+	int common_armv7m_algo_magic;
 
 	enum arm_mode core_mode;
 
 	uint32_t context[ARMV7M_LAST_REG]; /* ARMV7M_NUM_REGS */
 };
 
+static inline bool is_armv7m_algorithm( struct armv7m_algorithm *p )
+{
+	return (ARMV7M_ALGO_MAGIC == p->common_armv7m_algo_magic);
+}
+
 struct reg_cache *armv7m_build_reg_cache(struct target *target);
 enum armv7m_mode armv7m_number_to_mode(int number);
 int armv7m_mode_to_number(enum armv7m_mode mode);
diff --git a/src/target/armv8.c b/src/target/armv8.c
index cc74e2b..f3abec3 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -16,8 +16,32 @@
 
 #include "arm_opcodes.h"
 
+const struct dap_coresight_name armv8_cpu_regs[] = {
+#define CORESIGHT_RW_REG( N, V, D ) { .address = V, .rd_name = #N, .wr_name = #N }
+#define CORESIGHT_RO_REG( N, V, D ) { .address = V, .rd_name = #N, .wr_name = NULL }
+#define CORESIGHT_WO_REG( N, V, D ) { .address = V, .wr_name = #N, .rd_name = NULL }
+#include "armv8_cpudbg_regs.h"
+#undef CORESIGHT_RW_REG
+#undef CORESIGHT_RO_REG
+#undef CORESIGHT_WO_REG
+  /* terminate */
+  DAP_CORESIGHT_NAME_TERMINATE()
+};
+
+const struct dap_coresight_name armv8_cti_regs[] = {
+#define CORESIGHT_RW_REG( N, V, D ) { .address = V, .rd_name = #N, .wr_name = #N }
+#define CORESIGHT_RO_REG( N, V, D ) { .address = V, .rd_name = #N, .wr_name = NULL }
+#define CORESIGHT_WO_REG( N, V, D ) { .address = V, .wr_name = #N, .rd_name = NULL }
+#include "armv8_ctidbg_regs.h"
+#undef CORESIGHT_RW_REG
+#undef CORESIGHT_RO_REG
+#undef CORESIGHT_WO_REG
+  /* terminate */
+  DAP_CORESIGHT_NAME_TERMINATE()
+};
+
+
 
-#define keep_old_code 0
 #define WITH_FPU 1
 
 static const struct {
@@ -359,6 +383,7 @@ static const struct reg_arch_type armv8_reg_type = {
 
 struct reg_cache *armv8_build_reg_cache(struct target *target, struct armv8 *armv8)
 {
+	struct arm   *arm   = armv8_to_arm(armv8);
 	int num_regs = ARRAY_SIZE(armv8_core_regs);
 	struct reg_cache *cache = malloc(sizeof(struct reg_cache));
 	struct reg *reg_list = calloc(num_regs, sizeof(struct reg));
@@ -381,7 +406,7 @@ struct reg_cache *armv8_build_reg_cache(struct target *target, struct armv8 *arm
 		reg_arch_info[i].num = armv8_core_regs[i].cookie;
 		reg_arch_info[i].mode = armv8_core_regs[i].mode;
 		reg_arch_info[i].target = target;
-		reg_arch_info[i].arm = armv8->arm;
+		reg_arch_info[i].arm = arm;
 
 		reg_list[i].name = (char *) armv8_core_regs[i].name;
 		reg_list[i].number = armv8_core_regs[i].gdb_index;
@@ -456,14 +481,12 @@ struct reg_cache *armv8_build_reg_cache(struct target *target, struct armv8 *arm
 
 int armv8_arch_state(struct target *target)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-    struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a53);
-    struct armv8 *armv8 = &armv8_common->armv8;
-	struct arm *arm = armv8->arm;
+	struct armv8 *armv8 = target_to_armv8( target );
+	struct arm   *arm   = armv8_to_arm( armv8 );
 	uint32_t cpsr;
 
 	if(!target->is_64b) return arm_arch_state(target);
-	if (arm->common_magic != ARM_COMMON_MAGIC) {
+	if ( !is_arm(arm)) {
 		LOG_ERROR("BUG: called for a non-ARM target");
 		return ERROR_FAIL;
 	}
@@ -479,446 +502,11 @@ int armv8_arch_state(struct target *target)
 	return ERROR_OK;
 }
 
-#if use_old_code
-#define ARMV4_5_CORE_REG_MODENUM(cache, mode, num) \
-	(cache->reg_list[armv4_5_core_reg_map[mode][num]])
-
-COMMAND_HANDLER(handle_armv4_5_reg_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-	struct reg *regs;
-
-	if (!is_arm(arm)) {
-		command_print(CMD_CTX, "current target isn't an ARM");
-		return ERROR_FAIL;
-	}
-
-	if (target->state != TARGET_HALTED) {
-		command_print(CMD_CTX, "error: target must be halted for register accesses");
-		return ERROR_FAIL;
-	}
-
-	if (arm->core_type != ARM_MODE_ANY) {
-		command_print(CMD_CTX,
-			"Microcontroller Profile not supported - use standard reg cmd");
-		return ERROR_OK;
-	}
-
-	if (!is_arm_mode(arm->core_mode)) {
-		LOG_ERROR("not a valid arm core mode - communication failure?");
-		return ERROR_FAIL;
-	}
-
-	if (!arm->full_context) {
-		command_print(CMD_CTX, "error: target doesn't support %s",
-			CMD_NAME);
-		return ERROR_FAIL;
-	}
-
-	regs = arm->core_cache->reg_list;
-
-	for (unsigned mode = 0; mode < ARRAY_SIZE(arm_mode_data); mode++) {
-		const char *name;
-		char *sep = "\n";
-		char *shadow = "";
-
-		/* label this bank of registers (or shadows) */
-		switch (arm_mode_data[mode].psr) {
-			case ARM_MODE_SYS:
-				continue;
-			case ARM_MODE_USR:
-				name = "System and User";
-				sep = "";
-				break;
-			case ARM_MODE_MON:
-				if (arm->core_type != ARM_MODE_MON)
-					continue;
-			/* FALLTHROUGH */
-			default:
-				name = arm_mode_data[mode].name;
-				shadow = "shadow ";
-				break;
-		}
-		command_print(CMD_CTX, "%s%s mode %sregisters",
-			sep, name, shadow);
-
-		/* display N rows of up to 4 registers each */
-		for (unsigned i = 0; i < arm_mode_data[mode].n_indices; ) {
-			char output[80];
-			int output_len = 0;
-
-			for (unsigned j = 0; j < 4; j++, i++) {
-				uint32_t value;
-				struct reg *reg = regs;
-
-				if (i >= arm_mode_data[mode].n_indices)
-					break;
-
-				reg += arm_mode_data[mode].indices[i];
-
-				/* REVISIT be smarter about faults... */
-				if (!reg->valid)
-					arm->full_context(target);
-
-				value = buf_get_u32(reg->value, 0, 32);
-				output_len += snprintf(output + output_len,
-						sizeof(output) - output_len,
-						"%8s: %8.8" PRIx32 " ",
-						reg->name, value);
-			}
-			command_print(CMD_CTX, "%s", output);
-		}
-	}
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_armv4_5_core_state_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-	struct arm *arm = target_to_arm(target);
-
-	if (!is_arm(arm)) {
-		command_print(CMD_CTX, "current target isn't an ARM");
-		return ERROR_FAIL;
-	}
-
-	if (arm->core_type == ARM_MODE_THREAD) {
-		/* armv7m not supported */
-		command_print(CMD_CTX, "Unsupported Command");
-		return ERROR_OK;
-	}
-
-	if (CMD_ARGC > 0) {
-		if (strcmp(CMD_ARGV[0], "arm") == 0)
-			arm->core_state = ARM_STATE_ARM;
-		if (strcmp(CMD_ARGV[0], "thumb") == 0)
-			arm->core_state = ARM_STATE_THUMB;
-	}
-
-	command_print(CMD_CTX, "core state: %s", arm_state_strings[arm->core_state]);
-
-	return ERROR_OK;
-}
-
-COMMAND_HANDLER(handle_arm_disassemble_command)
-{
-	int retval = ERROR_OK;
-	struct target *target = get_current_target(CMD_CTX);
-
-	if (target == NULL) {
-		LOG_ERROR("No target selected");
-		return ERROR_FAIL;
-	}
-
-	struct arm *arm = target_to_arm(target);
-	uint32_t address;
-	int count = 1;
-	int thumb = 0;
-
-	if (!is_arm(arm)) {
-		command_print(CMD_CTX, "current target isn't an ARM");
-		return ERROR_FAIL;
-	}
-
-	if (arm->core_type == ARM_MODE_THREAD) {
-		/* armv7m is always thumb mode */
-		thumb = 1;
-	}
-
-	switch (CMD_ARGC) {
-		case 3:
-			if (strcmp(CMD_ARGV[2], "thumb") != 0)
-				goto usage;
-			thumb = 1;
-		/* FALL THROUGH */
-		case 2:
-			COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], count);
-		/* FALL THROUGH */
-		case 1:
-			COMMAND_PARSE_NUMBER(u32, CMD_ARGV[0], address);
-			if (address & 0x01) {
-				if (!thumb) {
-					command_print(CMD_CTX, "Disassemble as Thumb");
-					thumb = 1;
-				}
-				address &= ~1;
-			}
-			break;
-		default:
-usage:
-			count = 0;
-			retval = ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	while (count-- > 0) {
-		struct arm_instruction cur_instruction;
-
-		if (thumb) {
-			/* Always use Thumb2 disassembly for best handling
-			 * of 32-bit BL/BLX, and to work with newer cores
-			 * (some ARMv6, all ARMv7) that use Thumb2.
-			 */
-			retval = thumb2_opcode(target, address,
-					&cur_instruction);
-			if (retval != ERROR_OK)
-				break;
-		} else {
-			uint32_t opcode;
-
-			retval = target_read_u32(target, address, &opcode);
-			if (retval != ERROR_OK)
-				break;
-			retval = arm_evaluate_opcode(opcode, address,
-					&cur_instruction) != ERROR_OK;
-			if (retval != ERROR_OK)
-				break;
-		}
-		command_print(CMD_CTX, "%s", cur_instruction.text);
-		address += cur_instruction.instruction_size;
-	}
-
-	return retval;
-}
-
-static int jim_mcrmrc(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
-{
-	struct command_context *context;
-	struct target *target;
-	struct arm *arm;
-	int retval;
-
-	context = current_command_context(interp);
-	assert(context != NULL);
-
-	target = get_current_target(context);
-	if (target == NULL) {
-		LOG_ERROR("%s: no current target", __func__);
-		return JIM_ERR;
-	}
-	if (!target_was_examined(target)) {
-		LOG_ERROR("%s: not yet examined", target_name(target));
-		return JIM_ERR;
-	}
-	arm = target_to_arm(target);
-	if (!is_arm(arm)) {
-		LOG_ERROR("%s: not an ARM", target_name(target));
-		return JIM_ERR;
-	}
-
-	if ((argc < 6) || (argc > 7)) {
-		/* FIXME use the command name to verify # params... */
-		LOG_ERROR("%s: wrong number of arguments", __func__);
-		return JIM_ERR;
-	}
-
-	int cpnum;
-	uint32_t op1;
-	uint32_t op2;
-	uint32_t CRn;
-	uint32_t CRm;
-	uint32_t value;
-	long l;
-
-	/* NOTE:  parameter sequence matches ARM instruction set usage:
-	 *	MCR	pNUM, op1, rX, CRn, CRm, op2	; write CP from rX
-	 *	MRC	pNUM, op1, rX, CRn, CRm, op2	; read CP into rX
-	 * The "rX" is necessarily omitted; it uses Tcl mechanisms.
-	 */
-	retval = Jim_GetLong(interp, argv[1], &l);
-	if (retval != JIM_OK)
-		return retval;
-	if (l & ~0xf) {
-		LOG_ERROR("%s: %s %d out of range", __func__,
-			"coprocessor", (int) l);
-		return JIM_ERR;
-	}
-	cpnum = l;
-
-	retval = Jim_GetLong(interp, argv[2], &l);
-	if (retval != JIM_OK)
-		return retval;
-	if (l & ~0x7) {
-		LOG_ERROR("%s: %s %d out of range", __func__,
-			"op1", (int) l);
-		return JIM_ERR;
-	}
-	op1 = l;
-
-	retval = Jim_GetLong(interp, argv[3], &l);
-	if (retval != JIM_OK)
-		return retval;
-	if (l & ~0xf) {
-		LOG_ERROR("%s: %s %d out of range", __func__,
-			"CRn", (int) l);
-		return JIM_ERR;
-	}
-	CRn = l;
-
-	retval = Jim_GetLong(interp, argv[4], &l);
-	if (retval != JIM_OK)
-		return retval;
-	if (l & ~0xf) {
-		LOG_ERROR("%s: %s %d out of range", __func__,
-			"CRm", (int) l);
-		return JIM_ERR;
-	}
-	CRm = l;
-
-	retval = Jim_GetLong(interp, argv[5], &l);
-	if (retval != JIM_OK)
-		return retval;
-	if (l & ~0x7) {
-		LOG_ERROR("%s: %s %d out of range", __func__,
-			"op2", (int) l);
-		return JIM_ERR;
-	}
-	op2 = l;
-
-	value = 0;
-
-	/* FIXME don't assume "mrc" vs "mcr" from the number of params;
-	 * that could easily be a typo!  Check both...
-	 *
-	 * FIXME change the call syntax here ... simplest to just pass
-	 * the MRC() or MCR() instruction to be executed.  That will also
-	 * let us support the "mrc2" and "mcr2" opcodes (toggling one bit)
-	 * if that's ever needed.
-	 */
-	if (argc == 7) {
-		retval = Jim_GetLong(interp, argv[6], &l);
-		if (retval != JIM_OK)
-			return retval;
-		value = l;
-
-		/* NOTE: parameters reordered! */
-		/* ARMV4_5_MCR(cpnum, op1, 0, CRn, CRm, op2) */
-		retval = arm->mcr(target, cpnum, op1, op2, CRn, CRm, value);
-		if (retval != ERROR_OK)
-			return JIM_ERR;
-	} else {
-		/* NOTE: parameters reordered! */
-		/* ARMV4_5_MRC(cpnum, op1, 0, CRn, CRm, op2) */
-		retval = arm->mrc(target, cpnum, op1, op2, CRn, CRm, &value);
-		if (retval != ERROR_OK)
-			return JIM_ERR;
-
-		Jim_SetResult(interp, Jim_NewIntObj(interp, value));
-	}
-
-	return JIM_OK;
-}
-
-COMMAND_HANDLER(handle_arm_semihosting_command)
-{
-	struct target *target = get_current_target(CMD_CTX);
-
-	if (target == NULL) {
-		LOG_ERROR("No target selected");
-		return ERROR_FAIL;
-	}
-
-	struct arm *arm = target_to_arm(target);
-
-	if (!is_arm(arm)) {
-		command_print(CMD_CTX, "current target isn't an ARM");
-		return ERROR_FAIL;
-	}
-
-	if (!arm->setup_semihosting) {
-		command_print(CMD_CTX, "semihosting not supported for current target");
-		return ERROR_FAIL;
-	}
-
-	if (CMD_ARGC > 0) {
-		int semihosting;
-
-		COMMAND_PARSE_ENABLE(CMD_ARGV[0], semihosting);
-
-		if (!target_was_examined(target)) {
-			LOG_ERROR("Target not examined yet");
-			return ERROR_FAIL;
-		}
-
-		if (arm->setup_semihosting(target, semihosting) != ERROR_OK) {
-			LOG_ERROR("Failed to Configure semihosting");
-			return ERROR_FAIL;
-		}
-
-		/* FIXME never let that "catch" be dropped! */
-		arm->is_semihosting = semihosting;
-	}
-
-	command_print(CMD_CTX, "semihosting is %s",
-		arm->is_semihosting
-		? "enabled" : "disabled");
-
-	return ERROR_OK;
-}
-
-static const struct command_registration arm_exec_command_handlers[] = {
-	{
-		.name = "reg",
-		.handler = handle_armv4_5_reg_command,
-		.mode = COMMAND_EXEC,
-		.help = "display ARM core registers",
-		.usage = "",
-	},
-	{
-		.name = "core_state",
-		.handler = handle_armv4_5_core_state_command,
-		.mode = COMMAND_EXEC,
-		.usage = "['arm'|'thumb']",
-		.help = "display/change ARM core state",
-	},
-	{
-		.name = "disassemble",
-		.handler = handle_arm_disassemble_command,
-		.mode = COMMAND_EXEC,
-		.usage = "address [count ['thumb']]",
-		.help = "disassemble instructions ",
-	},
-	{
-		.name = "mcr",
-		.mode = COMMAND_EXEC,
-		.jim_handler = &jim_mcrmrc,
-		.help = "write coprocessor register",
-		.usage = "cpnum op1 CRn CRm op2 value",
-	},
-	{
-		.name = "mrc",
-		.jim_handler = &jim_mcrmrc,
-		.help = "read coprocessor register",
-		.usage = "cpnum op1 CRn CRm op2",
-	},
-	{
-		"semihosting",
-		.handler = handle_arm_semihosting_command,
-		.mode = COMMAND_EXEC,
-		.usage = "['enable'|'disable']",
-		.help = "activate support for semihosting operations",
-	},
-
-	COMMAND_REGISTRATION_DONE
-};
-const struct command_registration arm_command_handlers[] = {
-	{
-		.name = "arm",
-		.mode = COMMAND_ANY,
-		.help = "ARM command group",
-		.usage = "",
-		.chain = arm_exec_command_handlers,
-	},
-	COMMAND_REGISTRATION_DONE
-};
-#endif
 
 static int jim_modeswitch(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 {
 	struct command_context *context;
 	struct target *target;
-	struct arm *arm;
 	int retval;
 
 	context = current_command_context(interp);
@@ -933,15 +521,8 @@ static int jim_modeswitch(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 		LOG_ERROR("%s: not yet examined", target_name(target));
 		return JIM_ERR;
 	}
-	arm = target_to_arm(target);
-	if (!is_arm(arm)) {
-		LOG_ERROR("%s: not an ARM", target_name(target));
-		return JIM_ERR;
-	}
 
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a53);
-	struct armv8 *armv8 = &armv8_common->armv8;
+	struct armv8 *armv8 = target_to_armv8( target );
 
 	uint32_t value;
 	long l;
@@ -966,7 +547,6 @@ static int jim_drps(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 {
 	struct command_context *context;
 	struct target *target;
-	struct arm *arm;
 	int retval;
 
 	context = current_command_context(interp);
@@ -981,15 +561,8 @@ static int jim_drps(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 		LOG_ERROR("%s: not yet examined", target_name(target));
 		return JIM_ERR;
 	}
-	arm = target_to_arm(target);
-	if (!is_arm(arm)) {
-		LOG_ERROR("%s: not an ARM", target_name(target));
-		return JIM_ERR;
-	}
-
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a53);
-	struct armv8 *armv8 = &armv8_common->armv8;
+	
+	struct armv8 *armv8 = target_to_armv8( target );
 
 	retval = armv8->drps(target);
 
@@ -1003,7 +576,6 @@ static int jim_msrmrs(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 {
 	struct command_context *context;
 	struct target *target;
-	struct arm *arm;
 	int retval;
 
 	context = current_command_context(interp);
@@ -1018,11 +590,6 @@ static int jim_msrmrs(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 		LOG_ERROR("%s: not yet examined", target_name(target));
 		return JIM_ERR;
 	}
-	arm = target_to_arm(target);
-	if (!is_arm(arm)) {
-		LOG_ERROR("%s: not an ARM", target_name(target));
-		return JIM_ERR;
-	}
 
 //	if ((argc < 6) || (argc > 7)) {
 //		/* FIXME use the command name to verify # params... */
@@ -1030,9 +597,8 @@ static int jim_msrmrs(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 //		return JIM_ERR;
 //	}
 
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a53);
-	struct armv8 *armv8 = &armv8_common->armv8;
+	
+	struct armv8 *armv8 = target_to_armv8(target);
 
 
 	uint32_t op0;
@@ -1147,10 +713,6 @@ static int jim_msrmrs(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
 
 static int armv8_setup_semihosting(struct target *target, const struct target_addr *pValue)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
-	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
-	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
 	int retval = ERROR_OK;
 
 	// set semihosting skip enable
@@ -1242,13 +804,12 @@ int armv8_get_gdb_reg_list(struct target *target,
 		struct reg **reg_list[], int *reg_list_size,
 		enum target_register_class reg_class)
 {
-	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a);
-	struct armv8 *armv8 = &armv8_common->armv8;
+	struct armv8 *armv8 = target_to_armv8( target );
+	struct arm *arm = armv8_to_arm(armv8);
 	int i;
 
 	if(!target->is_64b) return arm_get_gdb_reg_list(target, reg_list, reg_list_size, reg_class);
-	if (!is_aarch64_mode(armv8->arm->core_mode)) {
+	if (!is_aarch64_mode(arm->core_mode)) {
 		LOG_ERROR("not a valid arm core mode - communication failure?");
 		return ERROR_FAIL;
 	}
@@ -1269,490 +830,6 @@ int armv8_get_gdb_reg_list(struct target *target,
 	}
 }
 
-#if use_old_code
-/* wait for execution to complete and check exit point */
-static int armv4_5_run_algorithm_completion(struct target *target,
-	uint32_t exit_point,
-	int timeout_ms,
-	void *arch_info)
-{
-	int retval;
-	struct arm *arm = target_to_arm(target);
-
-	retval = target_wait_state(target, TARGET_HALTED, timeout_ms);
-	if (retval != ERROR_OK)
-		return retval;
-	if (target->state != TARGET_HALTED) {
-		retval = target_halt(target);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = target_wait_state(target, TARGET_HALTED, 500);
-		if (retval != ERROR_OK)
-			return retval;
-		return ERROR_TARGET_TIMEOUT;
-	}
-
-	/* fast exit: ARMv5+ code can use BKPT */
-	if (exit_point && buf_get_u32(arm->pc->value, 0, 32) != exit_point) {
-		LOG_WARNING(
-			"target reentered debug state, but not at the desired exit point: 0x%4.4" PRIx32 "",
-			buf_get_u32(arm->pc->value, 0, 32));
-		return ERROR_TARGET_TIMEOUT;
-	}
-
-	return ERROR_OK;
-}
-
-int armv4_5_run_algorithm_inner(struct target *target,
-	int num_mem_params, struct mem_param *mem_params,
-	int num_reg_params, struct reg_param *reg_params,
-	uint32_t entry_point, uint32_t exit_point,
-	int timeout_ms, void *arch_info,
-	int (*run_it)(struct target *target, uint32_t exit_point,
-	int timeout_ms, void *arch_info))
-{
-	struct arm *arm = target_to_arm(target);
-	struct arm_algorithm *arm_algorithm_info = arch_info;
-	enum arm_state core_state = arm->core_state;
-	uint32_t context[17];
-	uint32_t cpsr;
-	int exit_breakpoint_size = 0;
-	int i;
-	int retval = ERROR_OK;
-
-	LOG_DEBUG("Running algorithm");
-
-	if (arm_algorithm_info->common_magic != ARM_COMMON_MAGIC) {
-		LOG_ERROR("current target isn't an ARMV4/5 target");
-		return ERROR_TARGET_INVALID;
-	}
-
-	if (target->state != TARGET_HALTED) {
-		LOG_WARNING("target not halted");
-		return ERROR_TARGET_NOT_HALTED;
-	}
-
-	if (!is_arm_mode(arm->core_mode)) {
-		LOG_ERROR("not a valid arm core mode - communication failure?");
-		return ERROR_FAIL;
-	}
-
-	/* armv5 and later can terminate with BKPT instruction; less overhead */
-	if (!exit_point && arm->is_armv4) {
-		LOG_ERROR("ARMv4 target needs HW breakpoint location");
-		return ERROR_FAIL;
-	}
-
-	/* save r0..pc, cpsr-or-spsr, and then cpsr-for-sure;
-	 * they'll be restored later.
-	 */
-	for (i = 0; i <= 16; i++) {
-		struct reg *r;
-
-		r = &ARMV4_5_CORE_REG_MODE(arm->core_cache,
-				arm_algorithm_info->core_mode, i);
-		if (!r->valid)
-			arm->read_core_reg(target, r, i,
-				arm_algorithm_info->core_mode);
-		context[i] = buf_get_u32(r->value, 0, 32);
-	}
-	cpsr = buf_get_u32(arm->cpsr->value, 0, 32);
-
-	for (i = 0; i < num_mem_params; i++) {
-		retval = target_write_buffer(target, mem_params[i].address, mem_params[i].size,
-				mem_params[i].value);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	for (i = 0; i < num_reg_params; i++) {
-		struct reg *reg = register_get_by_name(arm->core_cache, reg_params[i].reg_name, 0);
-		if (!reg) {
-			LOG_ERROR("BUG: register '%s' not found", reg_params[i].reg_name);
-			return ERROR_COMMAND_SYNTAX_ERROR;
-		}
-
-		if (reg->size != reg_params[i].size) {
-			LOG_ERROR("BUG: register '%s' size doesn't match reg_params[i].size",
-				reg_params[i].reg_name);
-			return ERROR_COMMAND_SYNTAX_ERROR;
-		}
-
-		retval = armv4_5_set_core_reg(reg, reg_params[i].value);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	arm->core_state = arm_algorithm_info->core_state;
-	if (arm->core_state == ARM_STATE_ARM)
-		exit_breakpoint_size = 4;
-	else if (arm->core_state == ARM_STATE_THUMB)
-		exit_breakpoint_size = 2;
-	else {
-		LOG_ERROR("BUG: can't execute algorithms when not in ARM or Thumb state");
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
-
-	if (arm_algorithm_info->core_mode != ARM_MODE_ANY) {
-		LOG_DEBUG("setting core_mode: 0x%2.2x",
-			arm_algorithm_info->core_mode);
-		buf_set_u32(arm->cpsr->value, 0, 5,
-			arm_algorithm_info->core_mode);
-		arm->cpsr->dirty = 1;
-		arm->cpsr->valid = 1;
-	}
-
-	/* terminate using a hardware or (ARMv5+) software breakpoint */
-	if (exit_point) {
-		retval = breakpoint_add(target, exit_point,
-				exit_breakpoint_size, BKPT_HARD);
-		if (retval != ERROR_OK) {
-			LOG_ERROR("can't add HW breakpoint to terminate algorithm");
-			return ERROR_TARGET_FAILURE;
-		}
-	}
-
-	retval = target_resume(target, 0, entry_point, 1, 1);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = run_it(target, exit_point, timeout_ms, arch_info);
-
-	if (exit_point)
-		breakpoint_remove(target, exit_point);
-
-	if (retval != ERROR_OK)
-		return retval;
-
-	for (i = 0; i < num_mem_params; i++) {
-		if (mem_params[i].direction != PARAM_OUT) {
-			int retvaltemp = target_read_buffer(target, mem_params[i].address,
-					mem_params[i].size,
-					mem_params[i].value);
-			if (retvaltemp != ERROR_OK)
-				retval = retvaltemp;
-		}
-	}
-
-	for (i = 0; i < num_reg_params; i++) {
-		if (reg_params[i].direction != PARAM_OUT) {
-
-			struct reg *reg = register_get_by_name(arm->core_cache,
-					reg_params[i].reg_name,
-					0);
-			if (!reg) {
-				LOG_ERROR("BUG: register '%s' not found", reg_params[i].reg_name);
-				retval = ERROR_COMMAND_SYNTAX_ERROR;
-				continue;
-			}
-
-			if (reg->size != reg_params[i].size) {
-				LOG_ERROR(
-					"BUG: register '%s' size doesn't match reg_params[i].size",
-					reg_params[i].reg_name);
-				retval = ERROR_COMMAND_SYNTAX_ERROR;
-				continue;
-			}
-
-			buf_set_u32(reg_params[i].value, 0, 32, buf_get_u32(reg->value, 0, 32));
-		}
-	}
-
-	/* restore everything we saved before (17 or 18 registers) */
-	for (i = 0; i <= 16; i++) {
-		uint32_t regvalue;
-		regvalue = buf_get_u32(ARMV4_5_CORE_REG_MODE(arm->core_cache,
-				arm_algorithm_info->core_mode, i).value, 0, 32);
-		if (regvalue != context[i]) {
-			LOG_DEBUG("restoring register %s with value 0x%8.8" PRIx32 "",
-				ARMV4_5_CORE_REG_MODE(arm->core_cache,
-				arm_algorithm_info->core_mode, i).name, context[i]);
-			buf_set_u32(ARMV4_5_CORE_REG_MODE(arm->core_cache,
-				arm_algorithm_info->core_mode, i).value, 0, 32, context[i]);
-			ARMV4_5_CORE_REG_MODE(arm->core_cache, arm_algorithm_info->core_mode,
-				i).valid = 1;
-			ARMV4_5_CORE_REG_MODE(arm->core_cache, arm_algorithm_info->core_mode,
-				i).dirty = 1;
-		}
-	}
-
-	arm_set_cpsr(arm, cpsr);
-	arm->cpsr->dirty = 1;
-
-	arm->core_state = core_state;
-
-	return retval;
-}
-
-int armv4_5_run_algorithm(struct target *target,
-	int num_mem_params,
-	struct mem_param *mem_params,
-	int num_reg_params,
-	struct reg_param *reg_params,
-	uint32_t entry_point,
-	uint32_t exit_point,
-	int timeout_ms,
-	void *arch_info)
-{
-	return armv4_5_run_algorithm_inner(target,
-			num_mem_params,
-			mem_params,
-			num_reg_params,
-			reg_params,
-			entry_point,
-			exit_point,
-			timeout_ms,
-			arch_info,
-			armv4_5_run_algorithm_completion);
-}
-
-/**
- * Runs ARM code in the target to calculate a CRC32 checksum.
- *
- */
-int arm_checksum_memory(struct target *target,
-	uint32_t address, uint32_t count, uint32_t *checksum)
-{
-	struct working_area *crc_algorithm;
-	struct arm_algorithm arm_algo;
-	struct arm *arm = target_to_arm(target);
-	struct reg_param reg_params[2];
-	int retval;
-	uint32_t i;
-	uint32_t exit_var = 0;
-
-	/* see contrib/loaders/checksum/armv4_5_crc.s for src */
-
-	static const uint32_t arm_crc_code[] = {
-		0xE1A02000,		/* mov		r2, r0 */
-		0xE3E00000,		/* mov		r0, #0xffffffff */
-		0xE1A03001,		/* mov		r3, r1 */
-		0xE3A04000,		/* mov		r4, #0 */
-		0xEA00000B,		/* b		ncomp */
-		/* nbyte: */
-		0xE7D21004,		/* ldrb	r1, [r2, r4] */
-		0xE59F7030,		/* ldr		r7, CRC32XOR */
-		0xE0200C01,		/* eor		r0, r0, r1, asl 24 */
-		0xE3A05000,		/* mov		r5, #0 */
-		/* loop: */
-		0xE3500000,		/* cmp		r0, #0 */
-		0xE1A06080,		/* mov		r6, r0, asl #1 */
-		0xE2855001,		/* add		r5, r5, #1 */
-		0xE1A00006,		/* mov		r0, r6 */
-		0xB0260007,		/* eorlt	r0, r6, r7 */
-		0xE3550008,		/* cmp		r5, #8 */
-		0x1AFFFFF8,		/* bne		loop */
-		0xE2844001,		/* add		r4, r4, #1 */
-		/* ncomp: */
-		0xE1540003,		/* cmp		r4, r3 */
-		0x1AFFFFF1,		/* bne		nbyte */
-		/* end: */
-		0xe1200070,		/* bkpt		#0 */
-		/* CRC32XOR: */
-		0x04C11DB7		/* .word 0x04C11DB7 */
-	};
-
-	retval = target_alloc_working_area(target,
-			sizeof(arm_crc_code), &crc_algorithm);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* convert code into a buffer in target endianness */
-	for (i = 0; i < ARRAY_SIZE(arm_crc_code); i++) {
-		retval = target_write_u32(target,
-				crc_algorithm->address + i * sizeof(uint32_t),
-				arm_crc_code[i]);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	arm_algo.common_magic = ARM_COMMON_MAGIC;
-	arm_algo.core_mode = ARM_MODE_SVC;
-	arm_algo.core_state = ARM_STATE_ARM;
-
-	init_reg_param(&reg_params[0], "r0", 32, PARAM_IN_OUT);
-	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
-
-	buf_set_u32(reg_params[0].value, 0, 32, address);
-	buf_set_u32(reg_params[1].value, 0, 32, count);
-
-	/* 20 second timeout/megabyte */
-	int timeout = 20000 * (1 + (count / (1024 * 1024)));
-
-	/* armv4 must exit using a hardware breakpoint */
-	if (arm->is_armv4)
-		exit_var = crc_algorithm->address + sizeof(arm_crc_code) - 8;
-
-	retval = target_run_algorithm(target, 0, NULL, 2, reg_params,
-			crc_algorithm->address,
-			exit_var,
-			timeout, &arm_algo);
-	if (retval != ERROR_OK) {
-		LOG_ERROR("error executing ARM crc algorithm");
-		destroy_reg_param(&reg_params[0]);
-		destroy_reg_param(&reg_params[1]);
-		target_free_working_area(target, crc_algorithm);
-		return retval;
-	}
-
-	*checksum = buf_get_u32(reg_params[0].value, 0, 32);
-
-	destroy_reg_param(&reg_params[0]);
-	destroy_reg_param(&reg_params[1]);
-
-	target_free_working_area(target, crc_algorithm);
-
-	return ERROR_OK;
-}
-
-/**
- * Runs ARM code in the target to check whether a memory block holds
- * all ones.  NOR flash which has been erased, and thus may be written,
- * holds all ones.
- *
- */
-int arm_blank_check_memory(struct target *target,
-	uint32_t address, uint32_t count, uint32_t *blank)
-{
-	struct working_area *check_algorithm;
-	struct reg_param reg_params[3];
-	struct arm_algorithm arm_algo;
-	struct arm *arm = target_to_arm(target);
-	int retval;
-	uint32_t i;
-	uint32_t exit_var = 0;
-
-	/* see contrib/loaders/erase_check/armv4_5_erase_check.s for src */
-
-	static const uint32_t check_code[] = {
-		/* loop: */
-		0xe4d03001,		/* ldrb r3, [r0], #1 */
-		0xe0022003,		/* and r2, r2, r3    */
-		0xe2511001,		/* subs r1, r1, #1   */
-		0x1afffffb,		/* bne loop          */
-		/* end: */
-		0xe1200070,		/* bkpt #0 */
-	};
-
-	/* make sure we have a working area */
-	retval = target_alloc_working_area(target,
-			sizeof(check_code), &check_algorithm);
-	if (retval != ERROR_OK)
-		return retval;
-
-	/* convert code into a buffer in target endianness */
-	for (i = 0; i < ARRAY_SIZE(check_code); i++) {
-		retval = target_write_u32(target,
-				check_algorithm->address
-				+ i * sizeof(uint32_t),
-				check_code[i]);
-		if (retval != ERROR_OK)
-			return retval;
-	}
-
-	arm_algo.common_magic = ARM_COMMON_MAGIC;
-	arm_algo.core_mode = ARM_MODE_SVC;
-	arm_algo.core_state = ARM_STATE_ARM;
-
-	init_reg_param(&reg_params[0], "r0", 32, PARAM_OUT);
-	buf_set_u32(reg_params[0].value, 0, 32, address);
-
-	init_reg_param(&reg_params[1], "r1", 32, PARAM_OUT);
-	buf_set_u32(reg_params[1].value, 0, 32, count);
-
-	init_reg_param(&reg_params[2], "r2", 32, PARAM_IN_OUT);
-	buf_set_u32(reg_params[2].value, 0, 32, 0xff);
-
-	/* armv4 must exit using a hardware breakpoint */
-	if (arm->is_armv4)
-		exit_var = check_algorithm->address + sizeof(check_code) - 4;
-
-	retval = target_run_algorithm(target, 0, NULL, 3, reg_params,
-			check_algorithm->address,
-			exit_var,
-			10000, &arm_algo);
-	if (retval != ERROR_OK) {
-		destroy_reg_param(&reg_params[0]);
-		destroy_reg_param(&reg_params[1]);
-		destroy_reg_param(&reg_params[2]);
-		target_free_working_area(target, check_algorithm);
-		return retval;
-	}
-
-	*blank = buf_get_u32(reg_params[2].value, 0, 32);
-
-	destroy_reg_param(&reg_params[0]);
-	destroy_reg_param(&reg_params[1]);
-	destroy_reg_param(&reg_params[2]);
-
-	target_free_working_area(target, check_algorithm);
-
-	return ERROR_OK;
-}
-
-static int arm_full_context(struct target *target)
-{
-	struct arm *arm = target_to_arm(target);
-	unsigned num_regs = arm->core_cache->num_regs;
-	struct reg *reg = arm->core_cache->reg_list;
-	int retval = ERROR_OK;
-
-	for (; num_regs && retval == ERROR_OK; num_regs--, reg++) {
-		if (reg->valid)
-			continue;
-		retval = armv4_5_get_core_reg(reg);
-	}
-	return retval;
-}
-
-static int arm_default_mrc(struct target *target, int cpnum,
-	uint32_t op1, uint32_t op2,
-	uint32_t CRn, uint32_t CRm,
-	uint32_t *value)
-{
-	LOG_ERROR("%s doesn't implement MRC", target_type_name(target));
-	return ERROR_FAIL;
-}
-
-static int arm_default_mcr(struct target *target, int cpnum,
-	uint32_t op1, uint32_t op2,
-	uint32_t CRn, uint32_t CRm,
-	uint32_t value)
-{
-	LOG_ERROR("%s doesn't implement MCR", target_type_name(target));
-	return ERROR_FAIL;
-}
-
-int arm_init_arch_info(struct target *target, struct arm *arm)
-{
-	target->arch_info = arm;
-	arm->target = target;
-
-	arm->common_magic = ARM_COMMON_MAGIC;
-
-	/* core_type may be overridden by subtype logic */
-	if (arm->core_type != ARM_MODE_THREAD) {
-		arm->core_type = ARM_MODE_ANY;
-		arm_set_cpsr(arm, ARM_MODE_USR);
-	}
-
-	/* default full_context() has no core-specific optimizations */
-	if (!arm->full_context && arm->read_core_reg)
-		arm->full_context = arm_full_context;
-
-	if (!arm->mrc)
-		arm->mrc = arm_default_mrc;
-	if (!arm->mcr)
-		arm->mcr = arm_default_mcr;
-
-	if (!arm->mrs)
-		arm->mrs = arm_default_mrc;
-	if (!arm->msr)
-		arm->msr = arm_default_mcr;
-
-
-	return ERROR_OK;
-}
-#endif
 
 /*
  * Coprocessor support
@@ -1763,10 +840,9 @@ static int armv8_mrs(struct target *target,
 	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
 	uint32_t *value)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
-	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
-	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
+	struct armv8 *armv8 = target_to_armv8( target );
+	struct armv8_dpm *armv8_dpm = armv8_to_armv8_dpm(armv8);
+	struct arm_dpm   *dpm       = armv8_to_arm_dpm(armv8);
 	int retval;
 	uint32_t v32;
 
@@ -1785,10 +861,9 @@ static int armv8_msr(struct target *target,
 	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
 	uint32_t value)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
-	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
-	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
+	struct armv8     *armv8     = target_to_armv8( target );
+	struct armv8_dpm *armv8_dpm = armv8_to_armv8_dpm( armv8 );
+	struct arm_dpm   *dpm       = armv8_to_arm_dpm( armv8 );
 	int retval;
 
 	retval = dpm->prepare(dpm);
@@ -1807,10 +882,9 @@ static int armv8_drps(struct target *target,
 	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
 	uint32_t value)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
-	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
-	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
+	struct armv8     *armv8     = target_to_armv8( target );
+	struct armv8_dpm *armv8_dpm = armv8_to_armv8_dpm( armv8 );
+	struct arm_dpm   *dpm       = armv8_to_arm_dpm( armv8 );
 	int retval;
 
 	retval = dpm->prepare(dpm);
@@ -1829,10 +903,6 @@ static int armv8_drps(struct target *target,
 
 static int armv8_modeswitch(struct target *target, uint64_t value)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
-	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
-	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
 	int retval = ERROR_OK;
 
 	// set modeswitch and asic rom base
@@ -1845,9 +915,7 @@ static int armv8_modeswitch(struct target *target, uint64_t value)
 
 int armv8_init_arch_info(struct target *target)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a53);
-	struct armv8 *armv8 = &armv8_common->armv8;
+	struct armv8 *armv8 = target_to_armv8( target );
 
 	if (!armv8->mrs)
 		armv8->mrs = armv8_mrs;
@@ -1860,3 +928,5 @@ int armv8_init_arch_info(struct target *target)
 
 	return ERROR_OK;
 }
+
+
diff --git a/src/target/armv8.h b/src/target/armv8.h
index 19f6899..419d044 100755
--- a/src/target/armv8.h
+++ b/src/target/armv8.h
@@ -12,6 +12,7 @@
 #include "arm_dpm.h"
 #include "armv8_dpm.h"
 
+#if 0
 #define EDESR		0x020
 #define EDECR		0x024
 #define EDWAR_L		0x030
@@ -51,9 +52,39 @@
 #define CTIDEVID1			0xFC4
 #define CTIDEVID2			0xFC0*/
 
+#endif
+
 #define CTIDBGCHAN_HALT		1
 #define CTIDBGCHAN_RESTART	2
 
+extern const struct dap_coresight_name armv8_cpu_regs[];
+extern const struct dap_coresight_name armv8_cti_regs[];
+
+enum armv8_cpu_regs {
+#define CORESIGHT_RW_REG( N, V, D )  N = (V)
+#define CORESIGHT_WO_REG( N, V, D )  N = (V)
+#define CORESIGHT_RO_REG( N, V, D )  N = (V)
+#include "armv8_cpudbg_regs.h"
+#undef CORESIGHT_RW_REG
+#undef CORESIGHT_RO_REG
+#undef CORESIGHT_WO_REG
+
+  armv8cpu_force32bit = 0x7fffffff
+};
+
+enum armv8_cti_regs {
+#define CORESIGHT_RW_REG( N, V, D )  N = (V)
+#define CORESIGHT_WO_REG( N, V, D )  N = (V)
+#define CORESIGHT_RO_REG( N, V, D )  N = (V)
+#include "armv8_ctidbg_regs.h"
+#undef CORESIGHT_RW_REG
+#undef CORESIGHT_RO_REG
+#undef CORESIGHT_WO_REG
+  armv8cti_force32bit = 0x7fffffff
+};
+
+
+
 //co-exist with arm_mode, aarch64_mode is for AArch64 state
 enum aarch64_mode {
 	AARCH64_MODE_EL0t = 0,
@@ -68,12 +99,16 @@ enum aarch64_mode {
 
 struct armv8	//struct for armv8 core
 {
-	struct arm* arm; //pointer to legacy arm struct
 	struct armv8_dpm armv8_dpm;
 	struct reg_cache *core_cache;
 	struct reg *pc;
 	struct reg *cpsr;
 
+	/* as read from the CORESIGHT BLOCK */
+	uint32_t midr_el1_reg;
+	uint32_t edpfr_reg;
+	uint32_t eddfr_reg;
+  
 	/** Read coprocessor register.  */
 	int (*mrs)(struct target *target,
 	        uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
@@ -89,23 +124,113 @@ struct armv8	//struct for armv8 core
 
 	/** Write coprocessor register.  */
 	int (*modeswitch)(struct target *target, uint32_t value);
+
+#define ARMV8_MAGIC  ( ('A' << 24) | ('r' << 16) | ('V' << 8) | ('8' << 0))
+	uint32_t armv8_magic;
 };
 
 struct armv8_common {
-	struct cortex_a_common cortex_a_common;
-	struct armv8 armv8;
+	struct cortex_a_common HIDE_cortex_a_common;
+	struct armv8 HIDE_armv8;
 };
 
-static inline struct armv8_common* cortex_a_to_armv8(struct cortex_a_common *cortex_a)
+static inline bool is_armv8( const struct armv8 *p )
+{
+	return ( ARMV8_MAGIC == p->armv8_magic );
+}
+
+	
+							 
+static inline struct cortex_a_common *armv8_to_cortex_a( struct armv8 *armv8 )
+{
+	struct armv8_common *r;
+	struct cortex_a_common *c;
+
+	r = container_of( armv8, struct armv8_common, HIDE_armv8 );
+	c = &(r->HIDE_cortex_a_common);
+	assert( is_cortex_a(c) );
+	return c;
+}
+
+
+static inline struct armv7a_common *armv8_to_armv7a( struct armv8 *armv8 )
+{
+	return cortex_a_to_armv7a( armv8_to_cortex_a( armv8 ) );
+}
+
+			      
+
+static inline struct armv8* cortex_a_to_armv8(struct cortex_a_common *cortex_a)
 {
-	return container_of(cortex_a, struct armv8_common, cortex_a_common);
+	struct armv8_common *r;
+	r = container_of(cortex_a, struct armv8_common, HIDE_cortex_a_common);
+	
+	assert( is_armv8( &(r->HIDE_armv8)  ));
+	return &(r->HIDE_armv8);
 }
 
+
+static inline struct armv8 *target_to_armv8( struct target *target )
+{
+	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
+
+	return cortex_a_to_armv8( cortex_a );
+}
+
+static inline struct arm *armv8_to_arm( struct armv8 *armv8 )
+{
+	return cortex_a_to_arm(armv8_to_cortex_a(armv8));
+}
+
+
+static inline struct armv8_dpm *armv8_to_armv8_dpm( struct armv8 *armv8 )
+{
+	return &(armv8->armv8_dpm);
+}
+
+static inline struct arm_dpm *armv8_to_arm_dpm( struct armv8 *armv8 )
+{
+	return armv7a_to_arm_dpm( armv8_to_armv7a(armv8) );
+}
+
+static inline struct armv8_dpm *target_to_armv8_dpm( struct target *target )
+{
+	return armv8_to_armv8_dpm( target_to_armv8(target) );
+}
+
+static inline struct target *armv8_to_target( struct armv8 *armv8 )
+{
+	struct arm *arm = armv8_to_arm(armv8);
+	return arm_to_target( arm );
+}
+
+
+
+static inline struct armv8 *armv8_dpm_to_armv8( struct armv8_dpm *armv8_dpm )
+{
+	struct armv8 *armv8;
+
+	armv8 = container_of( armv8_dpm, struct armv8, armv8_dpm );
+	return armv8;
+}
+
+static inline struct target *armv8_dpm_to_target( struct armv8_dpm *armv8_dpm )
+{
+	return armv8_to_target( armv8_dpm_to_armv8( armv8_dpm ) );
+}
+  
+
 int armv8_arch_state(struct target *target);
 
 extern const struct command_registration arm_v8_command_handlers[];
 
 int armv8_init_arch_info(struct target *target);
 
+struct cortex_a_brp;
+int armv8_wr_bpwp_regs( struct armv8 *armv8, struct cortex_a_brp *p );
+
+struct reg_cache *armv8_build_reg_cache(struct target *target, struct armv8 *armv8);
+
+
 
 #endif /* ARMV8_H */
diff --git a/src/target/armv8_cpudbg_regs.h b/src/target/armv8_cpudbg_regs.h
new file mode 100644
index 0000000..47ad643
--- /dev/null
+++ b/src/target/armv8_cpudbg_regs.h
@@ -0,0 +1,118 @@
+
+/* then this file does nothing */
+
+  CORESIGHT_RW_REG( EDESR		, 0x020, "External Debug Event Status Reg" ),
+  CORESIGHT_RW_REG( EDECR		, 0x024, "External Debug Execution Control Reg" ),
+  CORESIGHT_RW_REG( EDWAR		, 0x030, "External Debug Watchpoint Address Reg"	),
+		   
+  CORESIGHT_RW_REG( DBGDTRRX_EL0	, 0x080 , "Debug Communications Channel RX"		),
+  CORESIGHT_RW_REG( EDITR		, 0x084, "External Debug Instruction Transfer Reg"	),
+  CORESIGHT_RW_REG( EDSCR		, 0x088, "External Debug Status and Control Reg"	),
+  CORESIGHT_RW_REG( DBGDTRTX_EL0	, 0x08C, "The Debug Communications Channel TX"		),
+  CORESIGHT_RW_REG( EDRCR		, 0x090, "External Debug Reserve Control Reg"		),
+  CORESIGHT_RW_REG( EDACR		, 0x094, "External Debug Auxiliary Control Reg"		),
+  CORESIGHT_RW_REG( EDECCR		, 0x098, "External Debug Exception Catch Control Reg"	),
+  CORESIGHT_RW_REG( EDPCSRlo		, 0x0A0, "External Debug Program Counter Sample Regs"	),
+  CORESIGHT_RW_REG( EDCIDSR		, 0x0A4, "External Debug Context ID Sample Reg"		),
+  CORESIGHT_RW_REG( EDVIDSR		, 0x0A8, "External Debug Virtual Context Sample Reg"	),
+  CORESIGHT_RW_REG( EDPCSRhi		, 0x0AC, "External Debug Program Counter Sample Regs"	),
+  CORESIGHT_RW_REG( OSLAR_EL1		, 0x300, "OS Lock Access Reg"				),
+  CORESIGHT_RW_REG( EDPRCR		, 0x310, "External Debug Power/Reset Control Reg"	),
+  CORESIGHT_RW_REG( EDPRSR		, 0x314, "External Debug Processor Status Reg"		),
+  CORESIGHT_RW_REG( DBGBVR0_EL1		, 0x400, "Breakpoint Value Regs"			),
+#if !defined( DBGBVRn_EL1 )
+#define DBGBVRn_EL1(n)  (DBGBVR0_EL1 + ((n)*16))
+#endif
+  CORESIGHT_RW_REG( DBGBVR1_EL1		, 0x410, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR2_EL1		, 0x420, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR3_EL1		, 0x430, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR4_EL1		, 0x440, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR5_EL1		, 0x450, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR6_EL1		, 0x460, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR7_EL1		, 0x470, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR8_EL1		, 0x480, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR9_EL1		, 0x490, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR10_EL1		, 0x4a0, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR11_EL1		, 0x4b0, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR12_EL1		, 0x4c0, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR13_EL1		, 0x4d0, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR14_EL1		, 0x4e0, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR15_EL1		, 0x4f0, "Breakpoint Value Regs"			),
+  
+  CORESIGHT_RW_REG( DBGBCR0_EL1		, 0x408, "Breakpoint Control Regs"			),
+#if !defined( DBGCBRn_EL1 )
+#define DBGBCRn_EL1(n)  (DBGBCR0_EL1 + ((n)*16))
+#endif
+  CORESIGHT_RW_REG( DBGBCR1_EL1		, 0x418, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR2_EL1		, 0x428, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR3_EL1		, 0x438, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR4_EL1		, 0x448, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR5_EL1		, 0x458, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR6_EL1		, 0x468, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR7_EL1		, 0x478, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR8_EL1		, 0x488, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR9_EL1		, 0x498, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR10_EL1		, 0x4a8, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR11_EL1		, 0x4b8, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR12_EL1		, 0x4c8, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR13_EL1		, 0x4d8, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR14_EL1		, 0x4e8, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR15_EL1		, 0x4f8, "Breakpoint Control Regs"			),
+
+
+
+  CORESIGHT_RW_REG( DBGWVR0_EL1		, 0x800, "Watchpoint Value Regs"			),
+#if !defined(DBGWVRn_EL1)
+#define DBGWVRn_EL1(n) (DBGWVR0_EL1 + ((n)*16))
+#endif
+  CORESIGHT_RW_REG( DBGWVR1_EL1		, 0x810, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR2_EL1		, 0x820, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR3_EL1		, 0x830, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR4_EL1		, 0x840, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR5_EL1		, 0x850, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR6_EL1		, 0x860, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR7_EL1		, 0x870, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR8_EL1		, 0x880, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR9_EL1		, 0x890, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR10_EL1		, 0x8a0, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR11_EL1		, 0x8b0, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR12_EL1		, 0x8c0, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR13_EL1		, 0x8d0, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR14_EL1		, 0x8e0, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR15_EL1		, 0x8f0, "Watchpoint Value Regs"			),
+
+  CORESIGHT_RW_REG( DBGWCR0_EL1		, 0x804, "Watchpoint Control Regs"			),
+#if !defined(DBGWCRn_EL1)
+#define DBGWCRn_EL1(n) (DBGWCR0_EL1 + ((n)*16))
+#endif
+  CORESIGHT_RW_REG( DBGWCR1_EL1		, 0x814, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR2_EL1		, 0x824, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR3_EL1		, 0x834, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR4_EL1		, 0x844, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR5_EL1		, 0x854, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR6_EL1		, 0x864, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR7_EL1		, 0x874, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR8_EL1		, 0x884, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR9_EL1		, 0x894, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR10_EL1		, 0x8a4, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR11_EL1		, 0x8b4, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR12_EL1		, 0x8c4, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR13_EL1		, 0x8d4, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR14_EL1		, 0x8e4, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR15_EL1		, 0x8f4, "Watchpoint Control Regs"			),
+
+  CORESIGHT_RW_REG( IMP_DEF_An		, 0xc00, "IMPLEMENTATION DEFINED"			),
+  CORESIGHT_RW_REG( MIDR_EL1		, 0xD00, "Main ID Reg"					),
+  CORESIGHT_RW_REG( EDPFR			, 0xD20, "External Debug Processor Feature Reg"		),
+  CORESIGHT_RW_REG( EDDFR			, 0xD28, "External Debug Feature Reg"			),
+/* Reserved 0xD30 UNKNOWN */
+/* Reserved 0xD38 UNKNOWN */
+  CORESIGHT_RW_REG( IMP_DEF_Bn		, 0xe80, "IMPLEMENTATION DEFINED"			),
+/*   xxxx				, 0xF00-F8C Management regs Management regs and CoreSight compliance */
+  CORESIGHT_RW_REG( DBGCLAIMSET_EL1	, 0xFA0, "Claim Tag Set Reg"				),
+  CORESIGHT_RW_REG( DBGCLAIMCLR_EL1	, 0xFA4, "Claim Tag Clr Reg"				),
+  CORESIGHT_RW_REG( EDDEVAFFn		, 0xFA8, "Device Affinity regs"				),
+/* 0xFB0-FB4 Management regs Management regs and CoreSight compliance  */
+  CORESIGHT_RW_REG( DBGAUTHSTATUS_EL1	, 0xFB8, "Authentication Status reg"			),
+  CORESIGHT_RW_REG( EDDEVIDn		, 0xFC0, "Device ID regs"				),
+/* 0xFD0-FFC Management regs Management regs and CoreSight compliance */
diff --git a/src/target/armv8_ctidbg_regs.h b/src/target/armv8_ctidbg_regs.h
new file mode 100644
index 0000000..23a7742
--- /dev/null
+++ b/src/target/armv8_ctidbg_regs.h
@@ -0,0 +1,42 @@
+
+CORESIGHT_RW_REG( CTICONTROL		, 0x000, "Control reg" ),
+  CORESIGHT_RW_REG( CTIINTACK		, 0x010, "Output Trigger Acknowledge reg" ),
+  CORESIGHT_RW_REG( CTIAPPSET		, 0x014, "Application Trigger Set reg" ),
+  CORESIGHT_RW_REG( CTIAPPCLEAR		, 0x018, "Application Trigger Clear reg" ),
+  CORESIGHT_RW_REG( CTIAPPPULSE		, 0x01C, "Application Pulse reg" ),
+  CORESIGHT_RW_REG( CTIINEN0		, 0x020, "Input Trigger to Output Channel Enable regs" ),
+#if !defined(CTIINENn)
+#define CTIINENn(n)  (CTIINEN0 + (4*(n)))
+#endif
+  CORESIGHT_RW_REG( CTIINEN1		, 0x024, "Input Trigger to Output Channel Enable regs" ),
+  CORESIGHT_RW_REG( CTIINEN2		, 0x028, "Input Trigger to Output Channel Enable regs" ),
+  CORESIGHT_RW_REG( CTIINEN3		, 0x02c, "Input Trigger to Output Channel Enable regs" ),
+  CORESIGHT_RW_REG( CTIINEN4		, 0x030, "Input Trigger to Output Channel Enable regs" ),
+  CORESIGHT_RW_REG( CTIINEN5		, 0x034, "Input Trigger to Output Channel Enable regs" ),
+  CORESIGHT_RW_REG( CTIINEN6		, 0x038, "Input Trigger to Output Channel Enable regs" ),
+  CORESIGHT_RW_REG( CTIINEN7		, 0x03c, "Input Trigger to Output Channel Enable regs" ),
+
+  CORESIGHT_RW_REG( CTIOUTEN0		, 0x0A0, "Input Channel to Output Trigger Enable regs" ),
+#if !defined(CTIOUTENn)
+#define CTIOUTENn(n)  (CTIOUTEN0 + (4*(n)))
+#endif
+  CORESIGHT_RW_REG( CTIOUTEN1		, 0x0A4, "Input Channel to Output Trigger Enable regs" ),
+  CORESIGHT_RW_REG( CTIOUTEN2		, 0x0A8, "Input Channel to Output Trigger Enable regs" ),
+  CORESIGHT_RW_REG( CTIOUTEN3		, 0x0Ac, "Input Channel to Output Trigger Enable regs" ),
+  CORESIGHT_RW_REG( CTIOUTEN4		, 0x0B0, "Input Channel to Output Trigger Enable regs" ),
+  CORESIGHT_RW_REG( CTIOUTEN5		, 0x0B4, "Input Channel to Output Trigger Enable regs" ),
+  CORESIGHT_RW_REG( CTIOUTEN6		, 0x0B8, "Input Channel to Output Trigger Enable regs" ),
+  CORESIGHT_RW_REG( CTIOUTEN7		, 0x0BC, "Input Channel to Output Trigger Enable regs" ),
+  
+  CORESIGHT_RW_REG( CTITRIGINSTATUS	, 0x130, "Trigger In Status reg" ),
+  CORESIGHT_RW_REG( CTITRIGOUTSTATUS	, 0x134, "Trigger Out Status reg" ),
+  CORESIGHT_RW_REG( CTICHINSTATUS		, 0x138, "Channel In Status reg" ),
+  CORESIGHT_RW_REG( CTICHOUTSTATUS	, 0x13C, "Channel Out Status reg" ),
+  CORESIGHT_RW_REG( CTIGATE		, 0x140, "Channel Gate Enable reg" ),
+  CORESIGHT_RW_REG( ASICCTL		, 0x144, "External Control reg" ),
+/* 0xE80-EFC IMPLEMENTATION DEFINED */
+/* 0xF00-FBC Management regs Management regs and CoreSight compliance */
+  CORESIGHT_RW_REG( CTIDEVID2		, 0xFC0, "CTI Device Id Reg2" ),
+  CORESIGHT_RW_REG( CTIDEVID1		, 0xFC4, "CTI Device Id Reg2" ),
+  CORESIGHT_RW_REG( CTIDEVID0		, 0xFC8, "CTI Device Id Reg2" ),
+/* 0xFD0-FFC Management regs Management regs and CoreSight compliance */
diff --git a/src/target/armv8_dpm.c b/src/target/armv8_dpm.c
index 3040aa0..a73cd2c 100755
--- a/src/target/armv8_dpm.c
+++ b/src/target/armv8_dpm.c
@@ -38,10 +38,11 @@
 /* just read the register -- rely on the core mode being right */
 static int aarch64_dpm_read_reg(struct armv8_dpm *armv8_dpm, struct reg *r, unsigned regnum)
 {
+	struct armv8 *armv8 = armv8_dpm_to_armv8( armv8_dpm );
 	uint64_t v64;
 	uint32_t v32;
 	int retval;
-	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
+	struct arm_dpm *dpm = armv8_to_arm_dpm(armv8);
 
 	switch (regnum) {
 		case 0 ... 30:
@@ -96,7 +97,8 @@ static int aarch64_dpm_read_reg(struct armv8_dpm *armv8_dpm, struct reg *r, unsi
 /* just write the register -- rely on the core mode being right */
 static int aarch64_dpm_write_reg(struct armv8_dpm *armv8_dpm, struct reg *r, unsigned regnum)
 {
-	struct arm_dpm *dpm=armv8_dpm->arm_dpm;
+	struct armv8 *armv8 = armv8_dpm_to_armv8(armv8_dpm);
+	struct arm_dpm *dpm = armv8_to_arm_dpm(armv8);
 	int retval;
 	uint64_t value;
 	if(regnum<33) value = buf_get_u64(r->value, 0, 64);
@@ -146,19 +148,21 @@ static int aarch64_dpm_write_reg(struct armv8_dpm *armv8_dpm, struct reg *r, uns
  */
 int armv8_dpm_read_current_registers(struct armv8_dpm *armv8_dpm)
 {
-	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
-	struct arm *arm = dpm->arm;
+	struct armv8 *armv8 = armv8_dpm_to_armv8(armv8_dpm);
+ 	struct target *target = armv8_dpm_to_target(armv8_dpm);
+	struct arm_dpm *dpm = armv8_to_arm_dpm(armv8);
 	uint32_t cpsr;
 	int retval;
 	struct reg *r;
-	if(!arm->target->is_64b) return arm_dpm_read_current_registers(dpm);
+
+	if(!target->is_64b) return arm_dpm_read_current_registers(dpm);
 
 	retval = dpm->prepare(dpm);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* read R0 first (it's used for scratch), then CPSR */
-	r = armv8_dpm->armv8->core_cache->reg_list + 0;
+	r = armv8->core_cache->reg_list + 0;
 	if (!r->valid) {
 		retval = aarch64_dpm_read_reg(armv8_dpm, r, 0);
 		if (retval != ERROR_OK)
@@ -174,10 +178,10 @@ int armv8_dpm_read_current_registers(struct armv8_dpm *armv8_dpm)
 	 * cache is set up.  We can't defend against many errors, in
 	 * particular against CPSRs that aren't valid *here* ...
 	 */
-	if (armv8_dpm->armv8->cpsr) {
-		buf_set_u32(armv8_dpm->armv8->cpsr->value, 0, 32, cpsr);
-		armv8_dpm->armv8->cpsr->valid = 1;
-		armv8_dpm->armv8->cpsr->dirty = 0;
+	if (armv8->cpsr) {
+		buf_set_u32(armv8->cpsr->value, 0, 32, cpsr);
+		armv8->cpsr->valid = 1;
+		armv8->cpsr->dirty = 0;
 	}
 
 	/*arm->core_mode = cpsr & 0x1f;
@@ -186,7 +190,7 @@ int armv8_dpm_read_current_registers(struct armv8_dpm *armv8_dpm)
 
 	/* REVISIT we can probably avoid reading R1..R14, saving time... */
 	for (unsigned i = 1; i < 33; i++) {
-		r = armv8_dpm->armv8->core_cache->reg_list + i;
+		r = armv8->core_cache->reg_list + i;
 		if (r->valid)
 			continue;
 
@@ -240,7 +244,7 @@ static int dpm_maybe_update_bpwp(struct arm_dpm *dpm, bool bpwp,
 	if (retval != ERROR_OK)
 		LOG_ERROR("%s: can't %s HW %spoint %d",
 			disable ? "disable" : "enable",
-			target_name(dpm->arm->target),
+			target_name(arm_dpm_to_target(dpm)),
 			(xp->number < 16) ? "break" : "watch",
 			xp->number & 0xf);
 done:
@@ -259,13 +263,15 @@ static int dpm_add_breakpoint(struct target *target, struct breakpoint *bp);
  */
 int armv8_dpm_write_dirty_registers(struct armv8_dpm *armv8_dpm, bool bpwp)
 {
-	struct arm_dpm *dpm=armv8_dpm->arm_dpm;
-	struct arm *arm = dpm->arm;
-	struct reg_cache *cache = armv8_dpm->armv8->core_cache;
+	struct armv8		*armv8	= armv8_dpm_to_armv8(armv8_dpm);
+	struct arm_dpm		*dpm	= armv8_to_arm_dpm(armv8);
+	struct arm		*arm	= armv8_to_arm(armv8);
+	struct target *target = arm_to_target(arm);
+	struct reg_cache	*cache	= armv8->core_cache;
 	int retval;
 	bool did_write;
 
-	if(!arm->target->is_64b) return arm_dpm_write_dirty_registers(dpm, bpwp);
+	if(!target->is_64b) return arm_dpm_write_dirty_registers(dpm, bpwp);
 	retval = dpm->prepare(dpm);
 	if (retval != ERROR_OK)
 		goto done;
@@ -277,7 +283,7 @@ int armv8_dpm_write_dirty_registers(struct armv8_dpm *armv8_dpm, bool bpwp)
 	 * we should be able to assume we handle them; but until then,
 	 * cope with the hand-crafted breakpoint code.
 	 */
-	if (arm->target->type->add_breakpoint == dpm_add_breakpoint) {
+	if (target->type->add_breakpoint == dpm_add_breakpoint) {
 		for (unsigned i = 0; i < dpm->nbp; i++) {
 			struct dpm_bp *dbp = dpm->dbp + i;
 			struct breakpoint *bp = dbp->bp;
@@ -320,7 +326,7 @@ int armv8_dpm_write_dirty_registers(struct armv8_dpm *armv8_dpm, bool bpwp)
 			/* also skip PC, CPSR, and non-dirty */
 			if (i == 32)
 				continue;
-			if (armv8_dpm->armv8->cpsr == cache->reg_list + i)
+			if (armv8->cpsr == cache->reg_list + i)
 				continue;
 			if (!cache->reg_list[i].dirty)
 				continue;
@@ -343,7 +349,7 @@ int armv8_dpm_write_dirty_registers(struct armv8_dpm *armv8_dpm, bool bpwp)
 	 */
 	arm->cpsr->dirty = false;
 
-	retval = aarch64_dpm_write_reg(armv8_dpm, armv8_dpm->armv8->pc, 32);
+	retval = aarch64_dpm_write_reg(armv8_dpm, armv8->pc, 32);
 	if (retval != ERROR_OK)
 		goto done;
 	arm->pc->dirty = false;
@@ -368,10 +374,9 @@ done:
 static int armv8_dpm_read_core_reg(struct target *target, struct reg *r,
 	int regnum, enum arm_mode mode)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
-	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
-	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
+	struct armv8		*armv8		= target_to_armv8(target);
+	struct armv8_dpm	*armv8_dpm	= armv8_to_armv8_dpm(armv8);
+	struct arm_dpm		*dpm		= armv8_to_arm_dpm( armv8 );
 	int retval;
 	if (regnum < 0 || regnum > 32)
 		return ERROR_COMMAND_SYNTAX_ERROR;
@@ -393,10 +398,9 @@ fail:
 static int armv8_dpm_write_core_reg(struct target *target, struct reg *r,
 	int regnum, enum arm_mode mode, uint64_t value)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
-	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
-	struct arm_dpm *dpm = armv8_dpm->arm_dpm;
+	struct armv8 *armv8		= target_to_armv8(target);
+	struct armv8_dpm *armv8_dpm	= armv8_to_armv8_dpm(armv8);
+	struct arm_dpm *dpm		= armv8_to_arm_dpm(armv8);
 	int retval;
 
 	if (regnum < 0 || regnum > 33)
@@ -409,19 +413,18 @@ static int armv8_dpm_write_core_reg(struct target *target, struct reg *r,
 	retval = aarch64_dpm_write_reg(armv8_dpm, r, regnum);
 	/* always clean up, regardless of error */
 
-fail:
 	/* (void) */ dpm->finish(dpm);
 	return retval;
 }
 
 static int armv8_dpm_full_context(struct target *target)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
-	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
-	struct arm *arm = target_to_arm(target);
-	struct arm_dpm *dpm = arm->dpm;
-	struct reg_cache *cache = arm->core_cache;
+	struct armv8     *armv8     = target_to_armv8(target);
+	struct armv8_dpm *armv8_dpm = armv8_to_armv8_dpm( armv8 );
+	struct arm_dpm   *dpm       = armv8_to_arm_dpm( armv8 );
+	struct arm       *arm       = armv8_to_arm(armv8);
+	struct reg_cache *cache     = arm->core_cache;
+
 	int retval;
 	bool did_read;
 
@@ -474,7 +477,7 @@ static int dpm_bpwp_setup(struct arm_dpm *dpm, struct dpm_bpwp *xp,
 	uint64_t addr, uint32_t length)
 {
 	uint32_t control;
-
+	struct target *target = arm_dpm_to_target(dpm);
 	control = (1 << 0)	/* enable */
 		| (3 << 1);	/* both user and privileged access */
 
@@ -521,7 +524,7 @@ static int dpm_bpwp_setup(struct arm_dpm *dpm, struct dpm_bpwp *xp,
 	xp->dirty = true;
 
 	LOG_DEBUG("BPWP: addr %s, control %" PRIx32 ", number %d",
-		  target_addr64str1(dpm->arm->target,xp->address), control, xp->number);
+		  target_addr64str1( target,xp->address), control, xp->number);
 
 	/* hardware is updated in write_dirty_registers() */
 	return ERROR_OK;
@@ -673,7 +676,7 @@ void armv8_dpm_report_wfar(struct arm_dpm *dpm, uint64_t addr)
  */
 void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
 {
-	struct target *target = dpm->arm->target;
+	struct target *target = arm_dpm_to_target(dpm);
 
 	dpm->dscr = dscr;
 
@@ -719,9 +722,9 @@ void armv8_dpm_report_dscr(struct arm_dpm *dpm, uint32_t dscr)
  */
 int armv8_dpm_setup(struct armv8_dpm * armv8_dpm)
 {
-	struct arm_dpm *dpm=armv8_dpm->arm_dpm;
-	struct arm *arm = dpm->arm;
-	struct target *target = arm->target;
+	struct armv8   *armv8 = armv8_dpm_to_armv8(armv8_dpm);
+	struct arm_dpm *dpm   = armv8_to_arm_dpm(armv8);
+	struct target *target = armv8_to_target(armv8);
 	struct reg_cache *cache;
 
 	arm_dpm_setup(dpm);
@@ -731,7 +734,8 @@ int armv8_dpm_setup(struct armv8_dpm * armv8_dpm)
 	armv8_dpm->read_core_reg = armv8_dpm_read_core_reg;
 	armv8_dpm->write_core_reg = armv8_dpm_write_core_reg;
 
-	cache = armv8_build_reg_cache(target, armv8_dpm->armv8);
+	cache = armv8_build_reg_cache(target, armv8 );
+		
 	if (!cache)
 		return ERROR_FAIL;
 
@@ -778,9 +782,9 @@ int armv8_dpm_setup(struct armv8_dpm * armv8_dpm)
  */
 int armv8_dpm_initialize(struct armv8_dpm * armv8_dpm)
 {
-	struct arm_dpm* dpm=armv8_dpm->arm_dpm;
-	struct arm *arm = dpm->arm;
-	struct target *target = arm->target;
+	struct armv8	*armv8	= armv8_dpm_to_armv8(armv8_dpm);
+	struct arm_dpm	* dpm	= armv8_to_arm_dpm(armv8);
+	struct target	*target = armv8_to_target(armv8);
 
 	if(!target->is_64b) return arm_dpm_initialize(dpm);
 	/* Disable all breakpoints and watchpoints at startup. */
@@ -797,7 +801,7 @@ int armv8_dpm_initialize(struct armv8_dpm * armv8_dpm)
 		}
 	} else
 		LOG_WARNING("%s: can't disable breakpoints and watchpoints",
-			target_name(dpm->arm->target));
+			    target_name(target));
 
 	return ERROR_OK;
 }
diff --git a/src/target/armv8_dpm.h b/src/target/armv8_dpm.h
index ab1330d..c604a5c 100755
--- a/src/target/armv8_dpm.h
+++ b/src/target/armv8_dpm.h
@@ -41,8 +41,6 @@ struct aarch64_dpm_wp {
  */
 //some method could re-use arm_dpm code, such as prepare and finsh
 struct armv8_dpm {
-	struct arm_dpm* arm_dpm; //pointer to legacy dpm
-	struct armv8* armv8; //pointer to armv8 core struct
 
 	/** Invoke before a series of instruction operations */
 	//int (*prepare)(struct armv8_dpm *);
@@ -115,6 +113,12 @@ struct armv8_dpm {
 	int (*write_core_reg)(struct target *target, struct reg *r,	int regnum, enum arm_mode mode, uint64_t value);
 };
 
+
+
+
+
+						     
+
 int armv8_get_gdb_reg_list(struct target *target,
 		struct reg **reg_list[], int *reg_list_size,
 		enum target_register_class reg_class);
diff --git a/src/target/coresight_io.c b/src/target/coresight_io.c
new file mode 100644
index 0000000..2173647
--- /dev/null
+++ b/src/target/coresight_io.c
@@ -0,0 +1,662 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "jtag/interface.h"
+#include "arm.h"
+#include "arm_adi_v5.h"
+#include "target.h"
+#include <helper/time_support.h>
+
+
+
+bool target_cs_isbus_avail( struct target *target, enum ta_route bus )
+{
+	bool b;
+	const struct target_addr *a;
+	const struct coresight_settings *cs;
+
+	b = false;
+	cs = target_to_coresight(target);
+
+	if( cs ){
+
+		a = NULL;
+		switch( bus ){
+		default:
+			break;
+		case TA_ROUTE_sysbus:
+			a = &(cs->sysbus.addr);
+			break;
+		case TA_ROUTE_membus:
+			a = &(cs->membus.addr);
+			break;
+		case TA_ROUTE_dbgbus:
+			a = &(cs->dbgbus.addr);
+			break;
+		}
+		if( a ){
+			if( (a->route >= TA_ROUTE_arm_dap0) &&
+				(a->route <= TA_ROUTE_arm_dap255) ){
+				b = true;
+			}
+		}
+	}
+	return b;
+}
+
+
+
+int target_addr_resolve_route( struct target *target,
+							   const struct target_addr *pAddr,
+							 struct target_addr *p_NewAddr )
+{
+	const struct coresight_settings *cs;
+	cs = target_to_coresight(target);
+
+	return coresight_resolve_route( cs, pAddr, p_NewAddr );
+}
+
+int coresight_resolve_route( const struct coresight_settings *cs,
+							 const struct target_addr *pAddr,
+							 struct target_addr *p_NewAddr  )
+{
+	int r;
+	const struct target_addr *resolved;
+
+	resolved = NULL;
+	/* Hmm not a coresight route! */
+	if( pAddr->route == TA_ROUTE_DEFAULT ){
+		r = -1;
+		goto done;
+	}
+
+	/* explicit dap port number */
+	r = target_addr_to_dap_port( pAddr );
+	if( r >= 0 ){
+		resolved = pAddr;
+		goto done;
+	}
+
+	r = -1;
+
+	resolved = NULL;
+	/* specific port per this CPU? */
+	switch( pAddr->route ){
+	default:
+		break;
+	case TA_ROUTE_PHYSICAL:
+	case TA_ROUTE_membus:
+		resolved =  &(cs->membus.addr);
+		break;
+	case TA_ROUTE_sysbus:
+		resolved =  &(cs->sysbus.addr);
+		break;
+	case TA_ROUTE_dbgbus:
+		resolved =  &(cs->dbgbus.addr);
+		break;
+	}
+
+	/* did we find it? */
+	if( resolved ){
+		/* go resolve that one .. */
+		r = target_addr_to_dap_port( resolved );
+		if( r < 0 ){
+			/* fail.. */
+			resolved = NULL;
+		}
+	}
+
+ done:
+	if( resolved ){
+		if( p_NewAddr) {
+			/* copy the route and attributes */
+			*p_NewAddr = *resolved;
+			/* keep the address */
+			p_NewAddr->addr = pAddr->addr;
+		}
+	}
+   
+	return r;
+}
+		
+
+struct coresight_settings *target_to_coresight( struct target *t )
+{
+	if( t->HIDE_coresight == NULL ){
+		t->HIDE_coresight = calloc(1, sizeof(*(t->HIDE_coresight)));
+	}
+	/* fix me: Deal with no memory */
+	/* there are many errors like this ...*/
+	return t->HIDE_coresight;
+}
+
+void target_cs_connect_dap( struct target *target, struct adiv5_dap *dap)
+{
+	struct coresight_settings *cs;
+	/* DO NOT USE ANYTHING OTEHR THEN 1K here
+	 *
+	 * Per ARM -  There is no standard way to determine 
+	 * the proper size - it is implimentation defined.
+	 *
+	 * The target init script can override this
+	 * Even if the target does support 4K pages
+	 *
+	 * Incrementally we are talking about very simple TAR register writes
+	 * during the overall bulk write process.
+	 * 
+	 */
+	dap->tar_autoincr_block = (1 << 10);
+
+	cs = target_to_coresight( target );
+	
+	cs->HIDE_dap = dap;
+}
+
+int target_cs_dap_run(struct target *target)
+{
+	struct adiv5_dap *dap = target_cs_to_dap(target);
+	return dap_run( dap );
+}
+
+
+struct adiv5_dap *target_cs_to_dap( struct target *target )
+{
+	return coresight_to_dap( target_to_coresight(target) );
+}
+
+
+int target_cs_discover_ap( struct target *target, enum ap_type findme, struct coresight_address *port )
+{
+	int retval;
+	if( port->is_forced ){
+		/* User specified this, we *DO*NOT* discover this */
+		return ERROR_OK;
+	}
+
+	uint8_t x;
+
+	retval = target_cs_find_ap( target, findme, &x );
+	if( retval == ERROR_OK ){
+		TARGET_ADDR_INIT( &(port->addr), 0 );
+		/* update the route */
+		port->addr.route = TA_ROUTE_arm_dap0 + x;
+	}
+	return retval;
+}
+
+
+
+int target_cs_queued_rd32( struct target *target,
+						   const struct target_addr *p,
+						   uint32_t *value )
+{
+	return mem_ap_read_u32( target_cs_to_dap(target),
+				    p,
+				    value );
+}
+
+
+
+int target_cs_queued_wr32( struct target *target, const struct target_addr *p, uint32_t value )
+{
+	return mem_ap_write_u32( target_cs_to_dap(target), p, value );
+}
+
+int target_cs_queued_rd64( struct target *target, const struct target_addr *p, uint64_t *value )
+{
+	return mem_ap_read_u64( target_cs_to_dap(target), p, value );
+}
+
+
+
+int target_cs_queued_wr64( struct target *target, const struct target_addr *p, uint64_t value )
+{
+	return mem_ap_write_u64( target_cs_to_dap(target), p, value );
+}
+
+static struct target_addr *target_cs_dbg_addr( struct target *target )
+{
+	return &(target_to_coresight(target)->dbgbus.addr);
+}
+
+
+static struct target_addr *target_cs_cti_addr( struct target *target )
+{
+	return &(target_to_coresight(target)->cti.addr);
+}
+
+
+static struct target_addr *target_cs_mem_addr( struct target *target )
+{
+	return &(target_to_coresight(target)->membus.addr);
+}
+
+int target_cs_dbg_queued_rd32( struct target *target, uint64_t addr, uint32_t *value )
+{
+	struct target_addr a = *target_cs_dbg_addr(target);
+	a.addr += addr;
+  
+	return mem_ap_read_u32( target_cs_to_dap(target), &a, value );
+}
+
+
+static int coresight_bulk_setup( struct coresight_bulk *bulk,
+								  struct target *target,  const struct target_addr *pAddr,
+								  size_t size, size_t count, const void *buffer )
+{
+	int r;
+	memset( (void *)(bulk), 0, sizeof(*bulk) );
+
+	bulk->target	= target;
+	bulk->cs		= target_to_coresight( bulk->target );
+	bulk->dap		= coresight_to_dap( bulk->cs );
+	bulk->addr		= *pAddr;
+	r = target_addr_to_dap_port( pAddr );
+	if( r < 0 ){
+		LOG_ERROR("dap-port[ERROR]: invalid: %d", r );
+		return ERROR_FAIL;
+	}
+	bulk->port		= &(bulk->dap->port[ r ]);
+	bulk->size		= size;
+	bulk->count		= count;
+	bulk->buffer	= (void *)(buffer);
+
+	/* ASSUME ... */
+	bulk->is_aligned	= true;
+
+	/* target aligned? */
+	if( bulk->addr.addr & (size-1) ){
+		bulk->is_aligned = false;
+	}
+
+	/* host aligned */
+	if( ((uintptr_t)(bulk->buffer)) & (size-1) ){
+		bulk->is_aligned = false;
+	}
+	return ERROR_OK;
+}
+
+int target_cs_rd_bulk_noinc( struct target *target,  const struct target_addr *addr,
+							 size_t size, size_t count, void *buffer )
+
+{
+	int r;
+	struct coresight_bulk bulk;
+
+	r = coresight_bulk_setup( &bulk, target, addr, size, count, buffer );
+	if( r != ERROR_OK ){
+		return r;
+	}
+
+	bulk.addrinc = false;
+	bulk.rw      = 'r';
+	
+	return coresight_io_bulk( &bulk );
+}
+
+int target_cs_rd_bulk( struct target *target,  const struct target_addr *addr,
+							 size_t size, size_t count, void *buffer )
+
+{
+	int r;
+	struct coresight_bulk bulk;
+
+	r = coresight_bulk_setup( &bulk, target, addr, size, count, buffer );
+	if( r != ERROR_OK ){
+		return r;
+	}
+	
+
+	bulk.addrinc = true;
+	bulk.rw      = 'r';
+	
+	return coresight_io_bulk( &bulk );
+}
+
+int target_cs_wr_bulk_noinc( struct target *target,  const struct target_addr *addr,
+							 size_t size, size_t count, const void *buffer )
+
+{
+	int r;
+	struct coresight_bulk bulk;
+
+	r = coresight_bulk_setup( &bulk, target, addr, size, count, buffer );
+	if( r != ERROR_OK ){
+		return r;
+	}
+	
+
+	bulk.addrinc = false;
+	bulk.rw      = 'w';
+	
+	return coresight_io_bulk( &bulk );
+}
+
+int target_cs_wr_bulk( struct target *target,  const struct target_addr *addr,
+							 size_t size, size_t count, const void *buffer )
+
+{
+	int r;
+	struct coresight_bulk bulk;
+
+	r = coresight_bulk_setup( &bulk, target, addr, size, count, buffer );
+	if( r != ERROR_OK ){
+		return r;
+	}
+
+	bulk.addrinc = true;
+	bulk.rw      = 'w';
+	
+	return coresight_io_bulk( &bulk );
+}
+
+
+
+int target_cs_wr64( struct target *target, const struct target_addr *p, uint64_t value )
+{
+	int r;
+	r = target_cs_queued_wr64( target, p, value );
+	if(r == ERROR_OK ){
+		r = target_cs_dap_run( target );
+	}
+	return r;
+}
+
+
+
+
+int target_cs_wr32( struct target *target, const struct target_addr *p, uint32_t value )
+{
+	int r;
+	r = target_cs_queued_wr32( target, p, value );
+	if(r == ERROR_OK ){
+		r = target_cs_dap_run(target);
+	}
+	return r;
+}
+
+int target_cs_rd32( struct target *target, const struct target_addr *p, uint32_t *value )
+{
+	int r;
+	r = target_cs_queued_rd32( target, p, value );
+	if( r == ERROR_OK ){
+		r = target_cs_dap_run(target);
+	}
+	return r;
+}
+
+int target_cs_dbg_rd32( struct target *target, uint64_t addr, uint32_t *value )
+{
+	struct target_addr a = *target_cs_dbg_addr(target);
+	a.addr += addr;
+
+	return target_cs_rd32( target, &a, value );
+}
+
+int target_cs_dbg_wr32( struct target *target,uint64_t addr, uint32_t value )
+{
+	struct target_addr a = *target_cs_dbg_addr(target);
+	a.addr += addr;
+
+	return target_cs_wr32( target, &a, value );
+}
+
+
+int target_cs_dbg_queued_wr32( struct target *target, uint64_t addr, uint32_t value )
+{
+	struct target_addr a = *target_cs_dbg_addr(target);
+	a.addr += addr;
+
+	return target_cs_queued_wr32( target, &a, value );
+}
+
+
+int target_cs_rd64( struct target *target, const struct target_addr *p, uint64_t *value )
+{
+	int r;
+	r = target_cs_queued_rd64( target, p, value );
+	if( r == ERROR_OK ){
+		r = target_cs_dap_run(target);
+	}
+	return r;
+}
+
+/* does this targets DEBUG port support 64bit data transfers? */
+static struct adiv5_dap_port *target_cs_dbgport( struct target *target )
+{
+	int x;
+	struct target_addr *a = target_cs_dbg_addr(target);
+	struct adiv5_dap *dap = target_cs_to_dap( target );
+
+	x = a->route - TA_ROUTE_arm_dap0;
+	if( (x < 0) || (x > 255) ){
+		/* could log an error but that will be
+		 * handled elsewhere, so we say no
+		 */
+		return NULL;
+	}
+	return &( dap->port[x] );
+}
+	
+
+int target_cs_dbg_rd64( struct target *target,uint64_t addr, uint64_t *value )
+{
+	uint64_t a64,b64;
+	uint32_t a32,b32;
+	int r;
+	struct target_addr a = *target_cs_dbg_addr(target);
+	struct adiv5_dap_port *port;	
+	a.addr += addr;
+
+	/* get the debug port */
+	port = target_cs_dbgport( target );
+	if( port == NULL ){
+		LOG_ERROR("TARGET: %s no dbg port!", target_name(target));
+		return ERROR_FAIL;
+	}
+
+	/* if it supports 64bit - just use it */
+	if( port->data_64bit ){
+		return target_cs_rd64( target, &a, value );
+	}
+
+	/* otherwise fake it */
+	/* always read in increasing order */
+	r = target_cs_rd32( target, &a, &a32 );
+	if( r == ERROR_OK ){
+		a.addr += 4;
+		r = target_cs_rd32( target, &a, &b32 );
+	}
+	/* reassemble the value */
+	a64 = a32;
+	b64 = b32;
+	if( port->big_endian ){
+		a64 = a64 << 32;
+	} else {
+		b64 = b64 << 32;
+	}
+	a64 = a64 | b64;
+	if( value ){
+		*value = a64;
+	}
+	return r;
+}
+
+
+int target_cs_dbg_wr64( struct target *target,uint64_t addr, uint64_t value )
+{
+	uint64_t a64,b64;
+	int r;
+	struct target_addr a = *target_cs_dbg_addr(target);
+	struct adiv5_dap_port *port;
+	a.addr += addr;
+
+	/* get the debug port */
+	port = target_cs_dbgport( target );
+	if( port == NULL ){
+		LOG_ERROR("TARGET: %s no dbg port!", target_name(target));
+		return ERROR_FAIL;
+	}
+
+	/* if it supports 64bit - just use */
+	if( port->data_64bit ){
+		return target_cs_wr64( target, &a, value );
+	}
+	
+	a64 = value;
+	b64 = value;
+	if( port->big_endian ){
+		a64 = a64 >> 32;
+	} else {
+		b64 = b64 >> 32;
+	}
+	
+	/* always read in increasing order */
+	r = target_cs_wr32( target, &a, a64 );
+	a.addr += 4;
+	if( r == ERROR_OK ){
+		r = target_cs_wr32( target, &a, b64 );
+	}
+	
+	return r;
+}
+
+
+int target_cs_cti_rd32( struct target *target, uint64_t addr, uint32_t *value )
+{
+	struct target_addr a = *target_cs_cti_addr(target);
+	a.addr += addr;
+
+	return target_cs_rd32( target, &a, value );
+}
+
+
+int target_cs_cti_wr32( struct target *target,uint64_t addr, uint32_t value )
+{
+	struct target_addr a = *target_cs_cti_addr(target);
+	a.addr += addr;
+
+	return target_cs_wr32( target, &a, value );
+}
+
+
+int target_cs_cti_rd64( struct target *target,uint64_t addr, uint64_t *value )
+{
+	struct target_addr a = *target_cs_cti_addr(target);
+	a.addr += addr;
+
+	return target_cs_rd64( target, &a, value );
+}
+
+
+int target_cs_cti_wr64( struct target *target,uint64_t addr, uint64_t value )
+{
+	struct target_addr a = *target_cs_cti_addr(target);
+	a.addr += addr;
+
+	return target_cs_wr64( target, &a, value );
+}
+
+int target_cs_mem_rd32( struct target *target, uint64_t addr, uint32_t *value )
+{
+	struct target_addr a = *target_cs_mem_addr(target);
+	a.addr += addr;
+
+	return target_cs_rd32( target, &a, value );
+}
+
+
+int target_cs_mem_wr32( struct target *target,uint64_t addr, uint32_t value )
+{
+	struct target_addr a = *target_cs_mem_addr(target);
+	a.addr += addr;
+
+	return target_cs_wr32( target, &a, value );
+}
+
+
+int target_cs_mem_rd64( struct target *target,uint64_t addr, uint64_t *value )
+{
+	struct target_addr a = *target_cs_mem_addr(target);
+	a.addr += addr;
+
+	return target_cs_rd64( target, &a, value );
+}
+
+
+int target_cs_mem_wr64( struct target *target,uint64_t addr, uint64_t value )
+{
+	struct target_addr a = *target_cs_mem_addr(target);
+	a.addr += addr;
+
+	return target_cs_wr64( target, &a, value );
+}
+
+
+int target_cs_dbg_wr_bulk_noinc( struct target *target,  uint64_t addr, 
+								 size_t size, size_t count, const void *buffer )
+{
+	struct target_addr a;
+
+	a = *target_cs_dbg_addr(target);
+	a.addr += addr;
+
+	return target_cs_wr_bulk_noinc( target, &a, size, count, buffer );
+}
+
+int target_cs_dbg_rd_bulk_noinc( struct target *target,  uint64_t addr, 
+								 size_t size, size_t count, void *buffer )
+{
+	struct target_addr a;
+
+	a = *target_cs_dbg_addr(target);
+	a.addr += addr;
+
+	return target_cs_rd_bulk_noinc( target, &a, size, count, buffer );
+}
+
+int target_cs_dbg_wr_bulk( struct target *target,  uint64_t addr, 
+						   size_t size, size_t count, const void *buffer )
+{
+	struct target_addr a;
+
+	a = *target_cs_dbg_addr(target);
+	a.addr += addr;
+
+	return target_cs_wr_bulk( target, &a, size, count, buffer );
+}
+
+int target_cs_dbg_rd_bulk( struct target *target,  uint64_t addr, 
+						   size_t size, size_t count, void *buffer )
+{
+	struct target_addr a;
+
+	a = *target_cs_dbg_addr(target);
+	a.addr += addr;
+
+	return target_cs_rd_bulk( target, &a, size, count, buffer );
+}
+
+int target_cs_mem_wr_bulk( struct target *target,  uint64_t addr, 
+						   size_t size, size_t count, const void *buffer )
+{
+	struct target_addr a;
+
+	a = *target_cs_mem_addr(target);
+	a.addr += addr;
+
+	return target_cs_wr_bulk( target, &a, size, count, buffer );
+}
+
+int target_cs_mem_rd_bulk( struct target *target,  uint64_t addr, 
+						   size_t size, size_t count, void *buffer )
+{
+	struct target_addr a;
+
+	a = *target_cs_mem_addr(target);
+	a.addr += addr;
+
+	return target_cs_rd_bulk( target, &a, size, count, buffer );
+}
+
diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index 4273b21..5f5fd3f 100755
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -76,17 +76,19 @@ static int cortex_a_read_apb_ab_memory(struct target *target,
 	uint32_t address, uint32_t size, uint32_t count, uint8_t *buffer);
 
 
+
+
 /*  restore cp15_control_reg at resume */
 static int cortex_a_restore_cp15_control_reg(struct target *target)
 {
 	int retval = ERROR_OK;
 	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct arm *arm = cortex_a_to_arm( cortex_a );
 
 	if (cortex_a->cp15_control_reg != cortex_a->cp15_control_reg_curr) {
 		cortex_a->cp15_control_reg_curr = cortex_a->cp15_control_reg;
 		/* LOG_INFO("cp15_control_reg: %8.8" PRIx32, cortex_a->cp15_control_reg); */
-		retval = armv7a->arm.mcr(target, 15,
+		retval = arm->mcr(target, 15,
 				0, 0,	/* op1, op2 */
 				1, 0,	/* CRn, CRm */
 				cortex_a->cp15_control_reg);
@@ -98,17 +100,20 @@ static int cortex_a_restore_cp15_control_reg(struct target *target)
  *  remove apb predictible data abort */
 static int cortex_a_check_address(struct target *target, uint32_t address)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
+	struct cortex_a_common	*cortex_a	= target_to_cortex_a(target);
+	struct armv7a_common	*armv7a		= cortex_a_to_armv7a(cortex_a);
+	struct arm		*arm		= cortex_a_to_arm( cortex_a );
+	struct arm_dpm		*arm_dpm	= cortex_a_to_arm_dpm(cortex_a);
 	uint32_t os_border = armv7a->armv7a_mmu.os_border;
+	
 	if ((address < os_border) &&
-		(armv7a->arm.core_mode == ARM_MODE_SVC)) {
+		(arm->core_mode == ARM_MODE_SVC)) {
 		LOG_ERROR("%" PRIx32 " access in userspace and target in supervisor", address);
 		return ERROR_FAIL;
 	}
 	if ((address >= os_border) &&
 		(cortex_a->curr_mode != ARM_MODE_SVC)) {
-		dpm_modeswitch(&armv7a->dpm, ARM_MODE_SVC);
+		dpm_modeswitch(arm_dpm, ARM_MODE_SVC);
 		cortex_a->curr_mode = ARM_MODE_SVC;
 		LOG_INFO("%" PRIx32 " access in kernel space and target not in supervisor",
 			address);
@@ -116,7 +121,7 @@ static int cortex_a_check_address(struct target *target, uint32_t address)
 	}
 	if ((address < os_border) &&
 		(cortex_a->curr_mode == ARM_MODE_SVC)) {
-		dpm_modeswitch(&armv7a->dpm, ARM_MODE_ANY);
+		dpm_modeswitch(arm_dpm, ARM_MODE_ANY);
 		cortex_a->curr_mode = ARM_MODE_ANY;
 	}
 	return ERROR_OK;
@@ -126,8 +131,10 @@ static int cortex_a_check_address(struct target *target, uint32_t address)
  *  - read or write memory in phys or virt address */
 static int cortex_a_mmu_modify(struct target *target, int enable)
 {
-	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct cortex_a_common	*cortex_a = target_to_cortex_a(target);
+	struct armv7a_common	*armv7a = cortex_a_to_armv7a(cortex_a);
+	struct arm		*arm = cortex_a_to_arm( cortex_a );
+
 	int retval = ERROR_OK;
 	if (enable) {
 		/*  if mmu enabled at target stop and mmu not enable */
@@ -137,7 +144,7 @@ static int cortex_a_mmu_modify(struct target *target, int enable)
 		}
 		if (!(cortex_a->cp15_control_reg_curr & 0x1U)) {
 			cortex_a->cp15_control_reg_curr |= 0x1U;
-			retval = armv7a->arm.mcr(target, 15,
+			retval = arm->mcr(target, 15,
 					0, 0,	/* op1, op2 */
 					1, 0,	/* CRn, CRm */
 					cortex_a->cp15_control_reg_curr);
@@ -152,7 +159,7 @@ static int cortex_a_mmu_modify(struct target *target, int enable)
 		}
 		if ((cortex_a->cp15_control_reg_curr & 0x1U)) {
 			cortex_a->cp15_control_reg_curr &= ~0x1U;
-			retval = armv7a->arm.mcr(target, 15,
+			retval = arm->mcr(target, 15,
 					0, 0,	/* op1, op2 */
 					1, 0,	/* CRn, CRm */
 					cortex_a->cp15_control_reg_curr);
@@ -166,31 +173,25 @@ static int cortex_a_mmu_modify(struct target *target, int enable)
  */
 static int cortex_a_init_debug_access(struct target *target)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	int retval;
 	uint32_t dummy;
 
 	LOG_DEBUG(" ");
 
-    /* Strong Qu: Write 0 to DBGOSLAR(OS Lock Access Register, FC33_0300) */
-    LOG_USER("Clear DBGOSLAR.");
-    retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_OSLAR, 0);
-    if (retval != ERROR_OK)
-    {
-        LOG_USER("Failed to clear DBGOSLAR.");
-        return retval;
-    }
+	/* Strong Qu: Write 0 to DBGOSLAR(OS Lock Access Register, FC33_0300) */
+	LOG_USER("Clear DBGOSLAR.");
+	retval = target_cs_dbg_wr32( target, CPUDBG_OSLAR, 0);
+	if (retval != ERROR_OK){
+		LOG_USER("Failed to clear DBGOSLAR.");
+		return retval;
+	}
 
 	/* Unlocking the debug registers for modification
 	 * The debugport might be uninitialised so try twice */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+	retval = target_cs_dbg_wr32( target, CPUDBG_LOCKACCESS, 0xC5ACCE55);
 	if (retval != ERROR_OK) {
 		/* try again */
-		retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+		retval = target_cs_dbg_wr32( target, CPUDBG_LOCKACCESS, 0xC5ACCE55);
 		if (retval == ERROR_OK)
 			LOG_USER(
 				"Locking debug access failed on first, but succeeded on second try.");
@@ -199,8 +200,7 @@ static int cortex_a_init_debug_access(struct target *target)
 		return retval;
 	/* Clear Sticky Power Down status Bit in PRSR to enable access to
 	   the registers in the Core Power Domain */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_PRSR, &dummy);
+	retval = target_cs_dbg_rd32( target, CPUDBG_PRSR, &dummy);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -222,8 +222,6 @@ static int cortex_a_exec_opcode(struct target *target,
 {
 	uint32_t dscr;
 	int retval;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
 
 	dscr = dscr_p ? *dscr_p : 0;
 
@@ -232,8 +230,7 @@ static int cortex_a_exec_opcode(struct target *target,
 	/* Wait for InstrCompl bit to be set */
 	long long then = timeval_ms();
 	while ((dscr & DSCR_INSTR_COMP) == 0) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK) {
 			LOG_ERROR("Could not read DSCR register, opcode = 0x%08" PRIx32, opcode);
 			return retval;
@@ -244,15 +241,13 @@ static int cortex_a_exec_opcode(struct target *target,
 		}
 	}
 
-	retval = mem_ap_sel_write_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_ITR, opcode);
+	retval = target_cs_dbg_queued_wr32( target, CPUDBG_ITR, opcode);
 	if (retval != ERROR_OK)
 		return retval;
 
 	then = timeval_ms();
 	do {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK) {
 			LOG_ERROR("Could not read DSCR register");
 			return retval;
@@ -277,8 +272,6 @@ static int cortex_a_read_regs_through_mem(struct target *target, uint32_t addres
 	uint32_t *regfile)
 {
 	int retval = ERROR_OK;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
 
 	retval = cortex_a_dap_read_coreregister_u32(target, regfile, 0);
 	if (retval != ERROR_OK)
@@ -290,8 +283,11 @@ static int cortex_a_read_regs_through_mem(struct target *target, uint32_t addres
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = mem_ap_sel_read_buf(swjdp, armv7a->memory_ap,
-			(uint8_t *)(&regfile[1]), 4, 15, address);
+	retval = target_cs_mem_rd_bulk( target,
+					address,
+					4,
+					15,
+					(void *)(&regfile[1]) );
 
 	return retval;
 }
@@ -302,8 +298,6 @@ static int cortex_a_dap_read_coreregister_u32(struct target *target,
 	int retval = ERROR_OK;
 	uint8_t reg = regnum&0xFF;
 	uint32_t dscr = 0;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
 
 	if (reg > 17)
 		return retval;
@@ -342,8 +336,7 @@ static int cortex_a_dap_read_coreregister_u32(struct target *target,
 	/* Wait for DTRRXfull then read DTRRTX */
 	long long then = timeval_ms();
 	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			return retval;
 		if (timeval_ms() > then + 1000) {
@@ -352,8 +345,7 @@ static int cortex_a_dap_read_coreregister_u32(struct target *target,
 		}
 	}
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DTRTX, value);
+	retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, value);
 	LOG_DEBUG("read DCC 0x%08" PRIx32, *value);
 
 	return retval;
@@ -365,14 +357,11 @@ static int cortex_a_dap_write_coreregister_u32(struct target *target,
 	int retval = ERROR_OK;
 	uint8_t Rd = regnum&0xFF;
 	uint32_t dscr;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
 
 	LOG_DEBUG("register %i, value 0x%08" PRIx32, regnum, value);
 
 	/* Check that DCCRX is not full */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		return retval;
 	if (dscr & DSCR_DTR_RX_FULL) {
@@ -389,8 +378,7 @@ static int cortex_a_dap_write_coreregister_u32(struct target *target,
 
 	/* Write DTRRX ... sets DSCR.DTRRXfull but exec_opcode() won't care */
 	LOG_DEBUG("write DCC 0x%08" PRIx32, value);
-	retval = mem_ap_sel_write_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DTRRX, value);
+	retval = target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, value);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -438,20 +426,6 @@ static int cortex_a_dap_write_coreregister_u32(struct target *target,
 	return retval;
 }
 
-/* Write to memory mapped registers directly with no cache or mmu handling */
-static int cortex_a_dap_write_memap_register_u32(struct target *target,
-	uint32_t address,
-	uint32_t value)
-{
-	int retval;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, address, value);
-
-	return retval;
-}
-
 /*
  * Cortex-A implementation of Debug Programmer's Model
  *
@@ -463,34 +437,27 @@ static int cortex_a_dap_write_memap_register_u32(struct target *target,
  * be the places to enable/disable that mode.
  */
 
-static inline struct cortex_a_common *dpm_to_a(struct arm_dpm *dpm)
-{
-	return container_of(dpm, struct cortex_a_common, armv7a_common.dpm);
-}
-
-static int cortex_a_write_dcc(struct cortex_a_common *a, uint32_t data)
+static int cortex_a_write_dcc(struct cortex_a_common *cortex_a, uint32_t data)
 {
 	LOG_DEBUG("write DCC 0x%08" PRIx32, data);
-	return mem_ap_sel_write_u32(a->armv7a_common.arm.dap,
-		a->armv7a_common.debug_ap, a->armv7a_common.debug_base + CPUDBG_DTRRX, data);
+	return target_cs_dbg_queued_wr32( cortex_a_to_target(cortex_a), CPUDBG_DTRRX, data);
 }
 
-static int cortex_a_read_dcc(struct cortex_a_common *a, uint32_t *data,
+static int cortex_a_read_dcc(struct cortex_a_common *cortex_a, uint32_t *data,
 	uint32_t *dscr_p)
 {
-	struct adiv5_dap *swjdp = a->armv7a_common.arm.dap;
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
+	struct target *target = cortex_a_to_target( cortex_a );
+
 	if (dscr_p)
 		dscr = *dscr_p;
 
 	/* Wait for DTRRXfull */
 	long long then = timeval_ms();
 	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, a->armv7a_common.debug_ap,
-				a->armv7a_common.debug_base + CPUDBG_DSCR,
-				&dscr);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR,&dscr);
 		if (retval != ERROR_OK)
 			return retval;
 		if (timeval_ms() > then + 1000) {
@@ -499,8 +466,7 @@ static int cortex_a_read_dcc(struct cortex_a_common *a, uint32_t *data,
 		}
 	}
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, a->armv7a_common.debug_ap,
-			a->armv7a_common.debug_base + CPUDBG_DTRTX, data);
+	retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, data);
 	if (retval != ERROR_OK)
 		return retval;
 	/* LOG_DEBUG("read DCC 0x%08" PRIx32, *data); */
@@ -513,17 +479,14 @@ static int cortex_a_read_dcc(struct cortex_a_common *a, uint32_t *data,
 
 static int cortex_a_dpm_prepare(struct arm_dpm *dpm)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
-	struct adiv5_dap *swjdp = a->armv7a_common.arm.dap;
+	struct target		*target		= arm_dpm_to_target(dpm);
 	uint32_t dscr;
 	int retval;
 
 	/* set up invariant:  INSTR_COMP is set after ever DPM operation */
 	long long then = timeval_ms();
 	for (;; ) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, a->armv7a_common.debug_ap,
-				a->armv7a_common.debug_base + CPUDBG_DSCR,
-				&dscr);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR,	&dscr);
 		if (retval != ERROR_OK)
 			return retval;
 		if ((dscr & DSCR_INSTR_COMP) != 0)
@@ -539,7 +502,7 @@ static int cortex_a_dpm_prepare(struct arm_dpm *dpm)
 		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
 		/* Clear DCCRX */
 		retval = cortex_a_exec_opcode(
-				a->armv7a_common.arm.target,
+					      target,
 				ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 				&dscr);
 		if (retval != ERROR_OK)
@@ -558,16 +521,17 @@ static int cortex_a_dpm_finish(struct arm_dpm *dpm)
 static int cortex_a_instr_write_data_dcc(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t data)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
+	struct target *target = arm_dpm_to_target(dpm);
+	struct cortex_a_common *cortex_a = arm_dpm_to_cortex_a(dpm);
 	int retval;
 	uint32_t dscr = DSCR_INSTR_COMP;
 
-	retval = cortex_a_write_dcc(a, data);
+	retval = cortex_a_write_dcc(cortex_a, data);
 	if (retval != ERROR_OK)
 		return retval;
 
 	return cortex_a_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			opcode,
 			&dscr);
 }
@@ -575,17 +539,18 @@ static int cortex_a_instr_write_data_dcc(struct arm_dpm *dpm,
 static int cortex_a_instr_write_data_r0(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t data)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
+	struct target *target            = arm_dpm_to_target(dpm);
+	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
-	retval = cortex_a_write_dcc(a, data);
+	retval = cortex_a_write_dcc(cortex_a, data);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* DCCRX to R0, "MCR p14, 0, R0, c0, c5, 0", 0xEE000E15 */
 	retval = cortex_a_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 			&dscr);
 	if (retval != ERROR_OK)
@@ -593,7 +558,7 @@ static int cortex_a_instr_write_data_r0(struct arm_dpm *dpm,
 
 	/* then the opcode, taking data from R0 */
 	retval = cortex_a_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			opcode,
 			&dscr);
 
@@ -602,7 +567,7 @@ static int cortex_a_instr_write_data_r0(struct arm_dpm *dpm,
 
 static int cortex_a_instr_cpsr_sync(struct arm_dpm *dpm)
 {
-	struct target *target = dpm->arm->target;
+	struct target *target = arm_dpm_to_target(dpm);
 	uint32_t dscr = DSCR_INSTR_COMP;
 
 	/* "Prefetch flush" after modifying execution status in CPSR */
@@ -614,32 +579,34 @@ static int cortex_a_instr_cpsr_sync(struct arm_dpm *dpm)
 static int cortex_a_instr_read_data_dcc(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t *data)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
+	struct target *target = arm_dpm_to_target(dpm);
+	struct cortex_a_common *cortex_a = arm_dpm_to_cortex_a(dpm);
 	int retval;
 	uint32_t dscr = DSCR_INSTR_COMP;
 
 	/* the opcode, writing data to DCC */
 	retval = cortex_a_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			opcode,
 			&dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
-	return cortex_a_read_dcc(a, data, &dscr);
+	return cortex_a_read_dcc(cortex_a, data, &dscr);
 }
 
 
 static int cortex_a_instr_read_data_r0(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t *data)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
+	struct target		*target		= arm_dpm_to_target(dpm);
+	struct cortex_a_common	*cortex_a	= target_to_cortex_a(target);
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
 	/* the opcode, writing data to R0 */
 	retval = cortex_a_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			opcode,
 			&dscr);
 	if (retval != ERROR_OK)
@@ -647,102 +614,16 @@ static int cortex_a_instr_read_data_r0(struct arm_dpm *dpm,
 
 	/* write R0 to DCC */
 	retval = cortex_a_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
 			&dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
-	return cortex_a_read_dcc(a, data, &dscr);
-}
-
-static int cortex_a_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
-	uint32_t addr, uint32_t control)
-{
-	struct cortex_a_common *a = dpm_to_a(dpm);
-	uint32_t vr = a->armv7a_common.debug_base;
-	uint32_t cr = a->armv7a_common.debug_base;
-	int retval;
-
-	switch (index_t) {
-		case 0 ... 15:	/* breakpoints */
-			vr += CPUDBG_BVR_BASE;
-			cr += CPUDBG_BCR_BASE;
-			break;
-		case 16 ... 31:	/* watchpoints */
-			vr += CPUDBG_WVR_BASE;
-			cr += CPUDBG_WCR_BASE;
-			index_t -= 16;
-			break;
-		default:
-			return ERROR_FAIL;
-	}
-	vr += 4 * index_t;
-	cr += 4 * index_t;
-
-	LOG_DEBUG("A: bpwp enable, vr %08x cr %08x",
-		(unsigned) vr, (unsigned) cr);
-
-	retval = cortex_a_dap_write_memap_register_u32(dpm->arm->target,
-			vr, addr);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = cortex_a_dap_write_memap_register_u32(dpm->arm->target,
-			cr, control);
-	return retval;
-}
-
-static int cortex_a_bpwp_disable(struct arm_dpm *dpm, unsigned index_t)
-{
-	struct cortex_a_common *a = dpm_to_a(dpm);
-	uint32_t cr;
-
-	switch (index_t) {
-		case 0 ... 15:
-			cr = a->armv7a_common.debug_base + CPUDBG_BCR_BASE;
-			break;
-		case 16 ... 31:
-			cr = a->armv7a_common.debug_base + CPUDBG_WCR_BASE;
-			index_t -= 16;
-			break;
-		default:
-			return ERROR_FAIL;
-	}
-	cr += 4 * index_t;
-
-	LOG_DEBUG("A: bpwp disable, cr %08x", (unsigned) cr);
-
-	/* clear control register */
-	return cortex_a_dap_write_memap_register_u32(dpm->arm->target, cr, 0);
+	return cortex_a_read_dcc(cortex_a, data, &dscr);
 }
 
-static int cortex_a_dpm_setup(struct cortex_a_common *a, uint32_t didr)
-{
-	struct arm_dpm *dpm = &a->armv7a_common.dpm;
-	int retval;
-
-	dpm->arm = &a->armv7a_common.arm;
-	dpm->didr = didr;
-
-	dpm->prepare = cortex_a_dpm_prepare;
-	dpm->finish = cortex_a_dpm_finish;
-
-	dpm->instr_write_data_dcc = cortex_a_instr_write_data_dcc;
-	dpm->instr_write_data_r0 = cortex_a_instr_write_data_r0;
-	dpm->instr_cpsr_sync = cortex_a_instr_cpsr_sync;
-
-	dpm->instr_read_data_dcc = cortex_a_instr_read_data_dcc;
-	dpm->instr_read_data_r0 = cortex_a_instr_read_data_r0;
 
-	dpm->bpwp_enable = cortex_a_bpwp_enable;
-	dpm->bpwp_disable = cortex_a_bpwp_disable;
-
-	retval = arm_dpm_setup(dpm);
-	if (retval == ERROR_OK)
-		retval = arm_dpm_initialize(dpm);
-
-	return retval;
-}
 static struct target *get_cortex_a(struct target *target, int32_t coreid)
 {
 	struct target_list *head;
@@ -793,11 +674,9 @@ static int cortex_a_poll(struct target *target)
 {
 	int retval = ERROR_OK;
 	uint32_t dscr;
-	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	struct cortex_a_common	*cortex_a	= target_to_cortex_a(target);
 	enum target_state prev_target_state = target->state;
-    dap_ap_select(swjdp, 1);  //swjdp->apsel=1;
+	
 	/*  toggle to another core is done by gdb as follow */
 	/*  maint packet J core_id */
 	/*  continue */
@@ -810,8 +689,7 @@ static int cortex_a_poll(struct target *target)
 		target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 		return retval;
 	}
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		return retval;
 	cortex_a->cpudbg_dscr = dscr;
@@ -865,35 +743,29 @@ static int cortex_a_halt(struct target *target)
 {
 	int retval = ERROR_OK;
 	uint32_t dscr;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
 
 	/*
 	 * Tell the core to be halted by writing DRCR with 0x1
 	 * and then wait for the core to be halted.
 	 */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DRCR, DRCR_HALT);
+	retval = target_cs_dbg_wr32( target, CPUDBG_DRCR, DRCR_HALT);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/*
 	 * enter halting debug mode
 	 */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, dscr | DSCR_HALT_DBG_MODE);
+	retval = target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr | DSCR_HALT_DBG_MODE);
 	if (retval != ERROR_OK)
 		return retval;
 
 	long long then = timeval_ms();
 	for (;; ) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			return retval;
 		if ((dscr & DSCR_CORE_HALTED) != 0)
@@ -912,8 +784,9 @@ static int cortex_a_halt(struct target *target)
 static int cortex_a_internal_restore(struct target *target, int current,
 	uint32_t *address, int handle_breakpoints, int debug_execution)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *arm = &armv7a->arm;
+	struct cortex_a_common	*cortex_a	= target_to_cortex_a(target);
+	struct arm		*arm		= cortex_a_to_arm(cortex_a);
+	struct arm_dpm          *arm_dpm        = cortex_a_to_arm_dpm(cortex_a);
 	int retval;
 	uint32_t resume_pc;
 
@@ -971,7 +844,7 @@ static int cortex_a_internal_restore(struct target *target, int current,
 	arm->pc->dirty = 1;
 	arm->pc->valid = 1;
 	/* restore dpm_mode at system halt */
-	dpm_modeswitch(&armv7a->dpm, ARM_MODE_ANY);
+	dpm_modeswitch(arm_dpm, ARM_MODE_ANY);
 	/* called it now before restoring context because it uses cpu
 	 * register r0 for restoring cp15 control register */
 	retval = cortex_a_restore_cp15_control_reg(target);
@@ -1005,9 +878,8 @@ static int cortex_a_internal_restore(struct target *target, int current,
 
 static int cortex_a_internal_restart(struct target *target)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *arm = &armv7a->arm;
-	struct adiv5_dap *swjdp = arm->dap;
+	struct cortex_a_common	*cortex_a	= target_to_cortex_a(target);
+	struct arm		*arm		= cortex_a_to_arm(cortex_a);
 	int retval;
 	uint32_t dscr;
 	/*
@@ -1018,29 +890,25 @@ static int cortex_a_internal_restart(struct target *target)
 	 * disable IRQs by default, with optional override...
 	 */
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
 	if ((dscr & DSCR_INSTR_COMP) == 0)
 		LOG_ERROR("DSCR InstrCompl must be set before leaving debug!");
 
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, dscr & ~DSCR_ITR_EN);
+	retval = target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr & ~DSCR_ITR_EN);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DRCR, DRCR_RESTART |
+	retval = target_cs_dbg_wr32( target, CPUDBG_DRCR, DRCR_RESTART |
 			DRCR_CLEAR_EXCEPTIONS);
 	if (retval != ERROR_OK)
 		return retval;
 
 	long long then = timeval_ms();
 	for (;; ) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			return retval;
 		if ((dscr & DSCR_CORE_RESTARTED) != 0)
@@ -1122,17 +990,16 @@ static int cortex_a_debug_entry(struct target *target)
 	uint32_t regfile[16], cpsr, dscr;
 	int retval = ERROR_OK;
 	struct working_area *regfile_working_area = NULL;
-	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *arm = &armv7a->arm;
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	struct cortex_a_common	*cortex_a	= target_to_cortex_a(target);
+	struct armv7a_common	*armv7a		= cortex_a_to_armv7a(cortex_a);
+	struct arm		*arm		= cortex_a_to_arm(cortex_a);
+	struct arm_dpm          *arm_dpm        = cortex_a_to_arm_dpm(cortex_a);
 	struct reg *reg;
 
 	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a->cpudbg_dscr);
 
 	/* REVISIT surely we should not re-read DSCR !! */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1143,24 +1010,21 @@ static int cortex_a_debug_entry(struct target *target)
 
 	/* Enable the ITR execution once we are in debug mode */
 	dscr |= DSCR_ITR_EN;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, dscr);
+	retval = target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* Examine debug reason */
-	arm_dpm_report_dscr(&armv7a->dpm, cortex_a->cpudbg_dscr);
+	arm_dpm_report_dscr( arm_dpm , cortex_a->cpudbg_dscr);
 
 	/* save address of instruction that triggered the watchpoint? */
 	if (target->debug_reason == DBG_REASON_WATCHPOINT) {
 		uint32_t wfar;
 
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_WFAR,
-				&wfar);
+		retval = target_cs_dbg_rd32( target, CPUDBG_WFAR,	&wfar);
 		if (retval != ERROR_OK)
 			return retval;
-		arm_dpm_report_wfar(&armv7a->dpm, wfar);
+		arm_dpm_report_wfar(arm_dpm, wfar);
 	}
 
 	/* REVISIT fast_reg_read is never set ... */
@@ -1171,7 +1035,7 @@ static int cortex_a_debug_entry(struct target *target)
 
 	/* First load register acessible through core debug port*/
 	if (!regfile_working_area)
-		retval = arm_dpm_read_current_registers(&armv7a->dpm);
+		retval = arm_dpm_read_current_registers(arm_dpm);
 	else {
 		retval = cortex_a_read_regs_through_mem(target,
 				regfile_working_area->address, regfile);
@@ -1240,11 +1104,12 @@ static int cortex_a_debug_entry(struct target *target)
 static int cortex_a_post_debug_entry(struct target *target)
 {
 	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
+	struct armv7a_common *armv7a = cortex_a_to_armv7a(cortex_a);
+	struct arm *arm = cortex_a_to_arm( cortex_a );
 	int retval;
 
 	/* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
-	retval = armv7a->arm.mrc(target, 15,
+	retval = arm->mrc(target, 15,
 			0, 0,	/* op1, op2 */
 			1, 0,	/* CRn, CRm */
 			&cortex_a->cp15_control_reg);
@@ -1266,7 +1131,7 @@ static int cortex_a_post_debug_entry(struct target *target)
 		(cortex_a->cp15_control_reg & 0x4U) ? 1 : 0;
 	armv7a->armv7a_mmu.armv7a_cache.i_cache_enabled =
 		(cortex_a->cp15_control_reg & 0x1000U) ? 1 : 0;
-	cortex_a->curr_mode = armv7a->arm.core_mode;
+	cortex_a->curr_mode = arm->core_mode;
 
 	return ERROR_OK;
 }
@@ -1274,8 +1139,8 @@ static int cortex_a_post_debug_entry(struct target *target)
 static int cortex_a_step(struct target *target, int current, uint32_t address,
 	int handle_breakpoints)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *arm = &armv7a->arm;
+	struct cortex_a_common	*cortex_a	= target_to_cortex_a(target);
+	struct arm		*arm		= cortex_a_to_arm(cortex_a);
 	struct breakpoint *breakpoint = NULL;
 	struct breakpoint stepbreakpoint;
 	struct reg *r;
@@ -1346,20 +1211,80 @@ static int cortex_a_step(struct target *target, int current, uint32_t address,
 
 static int cortex_a_restore_context(struct target *target, bool bpwp)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
+	struct armv7a_common   *armv7a   = cortex_a_to_armv7a(cortex_a);
+	struct arm_dpm         *arm_dpm  = cortex_a_to_arm_dpm(cortex_a);
 
 	LOG_DEBUG(" ");
 
 	if (armv7a->pre_restore_context)
 		armv7a->pre_restore_context(target);
 
-	return arm_dpm_write_dirty_registers(&armv7a->dpm, bpwp);
+	return arm_dpm_write_dirty_registers(arm_dpm, bpwp);
 }
 
 /*
  * Cortex-A Breakpoint and watchpoint functions
  */
 
+static int cortex_a_wr_bpwp_reg( struct target *target, struct cortex_a_brp *b )
+{
+	int retval;
+
+	if( b->control == 0 ){
+		/* we are disabling, write CR first */
+		retval = target_cs_dbg_wr32( target,
+									 CPUDBG_BCR_BASE + (4 * b->BRPn),
+									 b->control);
+		if( retval != ERROR_OK ){
+			return retval;
+		}
+	}
+	
+	/* this core is 32bit not 64bit */
+	retval = target_cs_dbg_wr32( target, CPUDBG_BVR_BASE + (4 * b->BRPn),
+				b->value);
+	if( retval != ERROR_OK ){
+		return retval;
+	}
+
+	if( b->control != 0 ){
+		/* we are enabling  write CR last */
+		retval = target_cs_dbg_wr32( target,
+									 CPUDBG_BCR_BASE + (4 * b->BRPn),
+									 b->control);
+	}	
+	return retval;
+}
+
+static int cortex_a_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
+	uint64_t addr, uint32_t control)
+{
+	struct cortex_a_brp b;
+
+	memset( &b, 0, sizeof(b) );
+	b.control = control;
+	b.value   = addr;
+	b.BRPn    = index_t;
+
+	return cortex_a_wr_bpwp_reg( arm_dpm_to_target(dpm), &b );
+}
+
+static int cortex_a_bpwp_disable(struct arm_dpm *dpm, unsigned index_t)
+{
+	struct cortex_a_brp b;
+
+	memset( &b, 0, sizeof(b) );
+	b.control = 0;
+	b.value   = 0;
+	b.BRPn    = index_t;
+
+	return cortex_a_wr_bpwp_reg( arm_dpm_to_target(dpm), &b );
+}
+
+
+
+
 /* Setup hardware Breakpoint Register Pair */
 static int cortex_a_set_breakpoint(struct target *target,
 	struct breakpoint *breakpoint, uint8_t matchmode)
@@ -1369,7 +1294,6 @@ static int cortex_a_set_breakpoint(struct target *target,
 	uint32_t control;
 	uint8_t byte_addr_select = 0x0F;
 	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 	struct cortex_a_brp *brp_list = cortex_a->brp_list;
 
 	if (breakpoint->set) {
@@ -1393,19 +1317,13 @@ static int cortex_a_set_breakpoint(struct target *target,
 		brp_list[brp_i].used = 1;
 		brp_list[brp_i].value = (breakpoint->address & 0xFFFFFFFC);
 		brp_list[brp_i].control = control;
-		retval = cortex_a_dap_write_memap_register_u32(target, armv7a->debug_base
-				+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
-				brp_list[brp_i].value);
-		if (retval != ERROR_OK)
-			return retval;
-		retval = cortex_a_dap_write_memap_register_u32(target, armv7a->debug_base
-				+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
-				brp_list[brp_i].control);
+
+		retval = cortex_a_wr_bpwp_reg( target, brp_list + brp_i );
 		if (retval != ERROR_OK)
 			return retval;
-		LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
-			brp_list[brp_i].control,
-			brp_list[brp_i].value);
+		LOG_DEBUG("brp %i control 0x%0" PRIx32 " value %s", brp_i,
+			  brp_list[brp_i].control,
+			  target_addr64str1( target, brp_list[brp_i].value));
 	} else if (breakpoint->type == BKPT_SOFT) {
 		uint8_t code[4];
 		if (breakpoint->length == 2)
@@ -1437,7 +1355,6 @@ static int cortex_a_set_context_breakpoint(struct target *target,
 	uint32_t control;
 	uint8_t byte_addr_select = 0x0F;
 	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 	struct cortex_a_brp *brp_list = cortex_a->brp_list;
 
 	if (breakpoint->set) {
@@ -1449,6 +1366,13 @@ static int cortex_a_set_context_breakpoint(struct target *target,
 		(brp_list[brp_i].type != BRP_CONTEXT)) && (brp_i < cortex_a->brp_num))
 		brp_i++;
 
+	/*         Question what is this?
+	 *         We search for a context ...
+	 *         Then blindly assume the next
+	 *         entry is not in use.
+	 *
+	 * What happens if it is in use?
+	 */
 	if (brp_i >= cortex_a->brp_num) {
 		LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
 		return ERROR_FAIL;
@@ -1461,19 +1385,13 @@ static int cortex_a_set_context_breakpoint(struct target *target,
 	brp_list[brp_i].used = 1;
 	brp_list[brp_i].value = (breakpoint->asid);
 	brp_list[brp_i].control = control;
-	retval = cortex_a_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
-			brp_list[brp_i].value);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = cortex_a_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
-			brp_list[brp_i].control);
+
+	retval = cortex_a_wr_bpwp_reg( target, brp_list + brp_i );
 	if (retval != ERROR_OK)
 		return retval;
-	LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
-		brp_list[brp_i].control,
-		brp_list[brp_i].value);
+	LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%s", brp_i,
+			  brp_list[brp_i].control,
+			  target_addr64str1( target, brp_list[brp_i].value));
 	return ERROR_OK;
 
 }
@@ -1489,7 +1407,6 @@ static int cortex_a_set_hybrid_breakpoint(struct target *target, struct breakpoi
 	uint8_t CTX_machmode = 0x03;
 	uint8_t IVA_machmode = 0x01;
 	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 	struct cortex_a_brp *brp_list = cortex_a->brp_list;
 
 	if (breakpoint->set) {
@@ -1527,14 +1444,8 @@ static int cortex_a_set_hybrid_breakpoint(struct target *target, struct breakpoi
 	brp_list[brp_1].used = 1;
 	brp_list[brp_1].value = (breakpoint->asid);
 	brp_list[brp_1].control = control_CTX;
-	retval = cortex_a_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BVR_BASE + 4 * brp_list[brp_1].BRPn,
-			brp_list[brp_1].value);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = cortex_a_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BCR_BASE + 4 * brp_list[brp_1].BRPn,
-			brp_list[brp_1].control);
+
+	retval = cortex_a_wr_bpwp_reg( target, brp_list + brp_1 );
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1545,14 +1456,8 @@ static int cortex_a_set_hybrid_breakpoint(struct target *target, struct breakpoi
 	brp_list[brp_2].used = 1;
 	brp_list[brp_2].value = (breakpoint->address & 0xFFFFFFFC);
 	brp_list[brp_2].control = control_IVA;
-	retval = cortex_a_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BVR_BASE + 4 * brp_list[brp_2].BRPn,
-			brp_list[brp_2].value);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = cortex_a_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BCR_BASE + 4 * brp_list[brp_2].BRPn,
-			brp_list[brp_2].control);
+
+	retval = cortex_a_wr_bpwp_reg( target, brp_list + brp_2 );
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1563,7 +1468,6 @@ static int cortex_a_unset_breakpoint(struct target *target, struct breakpoint *b
 {
 	int retval;
 	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
 	struct cortex_a_brp *brp_list = cortex_a->brp_list;
 
 	if (!breakpoint->set) {
@@ -1579,38 +1483,24 @@ static int cortex_a_unset_breakpoint(struct target *target, struct breakpoint *b
 				LOG_DEBUG("Invalid BRP number in breakpoint");
 				return ERROR_OK;
 			}
-			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
-				brp_list[brp_i].control, brp_list[brp_i].value);
+			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%s", brp_i,
+				  brp_list[brp_i].control, target_addr64str1(target,brp_list[brp_i].value));
 			brp_list[brp_i].used = 0;
 			brp_list[brp_i].value = 0;
 			brp_list[brp_i].control = 0;
-			retval = cortex_a_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
-					brp_list[brp_i].control);
-			if (retval != ERROR_OK)
-				return retval;
-			retval = cortex_a_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
-					brp_list[brp_i].value);
+			retval = cortex_a_wr_bpwp_reg( target, brp_list + brp_i );
 			if (retval != ERROR_OK)
 				return retval;
 			if ((brp_j < 0) || (brp_j >= cortex_a->brp_num)) {
 				LOG_DEBUG("Invalid BRP number in breakpoint");
 				return ERROR_OK;
 			}
-			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_j,
-				brp_list[brp_j].control, brp_list[brp_j].value);
+			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%s", brp_j,
+				  brp_list[brp_j].control, target_addr64str1(target,brp_list[brp_j].value));
 			brp_list[brp_j].used = 0;
 			brp_list[brp_j].value = 0;
 			brp_list[brp_j].control = 0;
-			retval = cortex_a_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BCR_BASE + 4 * brp_list[brp_j].BRPn,
-					brp_list[brp_j].control);
-			if (retval != ERROR_OK)
-				return retval;
-			retval = cortex_a_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BVR_BASE + 4 * brp_list[brp_j].BRPn,
-					brp_list[brp_j].value);
+			retval = cortex_a_wr_bpwp_reg( target, brp_list + brp_j );
 			if (retval != ERROR_OK)
 				return retval;
 			breakpoint->linked_BRP = 0;
@@ -1623,19 +1513,12 @@ static int cortex_a_unset_breakpoint(struct target *target, struct breakpoint *b
 				LOG_DEBUG("Invalid BRP number in breakpoint");
 				return ERROR_OK;
 			}
-			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
-				brp_list[brp_i].control, brp_list[brp_i].value);
+			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%s" PRIx32, brp_i,
+				  brp_list[brp_i].control, target_addr64str1(target,brp_list[brp_i].value));
 			brp_list[brp_i].used = 0;
 			brp_list[brp_i].value = 0;
 			brp_list[brp_i].control = 0;
-			retval = cortex_a_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BCR_BASE + 4 * brp_list[brp_i].BRPn,
-					brp_list[brp_i].control);
-			if (retval != ERROR_OK)
-				return retval;
-			retval = cortex_a_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BVR_BASE + 4 * brp_list[brp_i].BRPn,
-					brp_list[brp_i].value);
+			retval = cortex_a_wr_bpwp_reg( target, brp_list + brp_i );
 			if (retval != ERROR_OK)
 				return retval;
 			breakpoint->set = 0;
@@ -1739,7 +1622,8 @@ static int cortex_a_remove_breakpoint(struct target *target, struct breakpoint *
 
 static int cortex_a_assert_reset(struct target *target)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct cortex_a_common	*cortex_a = target_to_cortex_a(target);
+	struct arm		*arm      = cortex_a_to_arm(cortex_a);
 
 	LOG_DEBUG(" ");
 
@@ -1759,7 +1643,7 @@ static int cortex_a_assert_reset(struct target *target)
 	}
 
 	/* registers are now invalid */
-	register_cache_invalidate(armv7a->arm.core_cache);
+	register_cache_invalidate(arm->core_cache);
 
 	target->state = TARGET_RESET;
 
@@ -1799,9 +1683,8 @@ static int cortex_a_write_apb_ab_memory(struct target *target,
 	/* write memory through APB-AP */
 
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *arm = &armv7a->arm;
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	struct cortex_a_common	*cortex_a	= target_to_cortex_a(target);
+	struct arm		*arm		= cortex_a_to_arm(cortex_a);
 	int total_bytes = count * size;
 	int total_u32;
 	int start_byte = address & 0x3;
@@ -1828,7 +1711,7 @@ static int cortex_a_write_apb_ab_memory(struct target *target,
 	reg->dirty = true;
 
 	/*  clear any abort  */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DRCR, 1<<2);
+	retval = target_cs_dbg_wr32( target, CPUDBG_DRCR, 1<<2);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1871,62 +1754,57 @@ static int cortex_a_write_apb_ab_memory(struct target *target,
 	/* We now have a 32 bit aligned buffer that can be written */
 
 	/* Read DSCR */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		goto error_free_buff_w;
 
 	/* Set DTR mode to Fast (2) */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_FAST_MODE;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, dscr);
+	retval = target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr);
 	if (retval != ERROR_OK)
 		goto error_free_buff_w;
 
 	/* Copy the destination address into R0 */
 	/*  - pend an instruction  MRC p14, 0, R0, c5, c0 */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_ITR, ARMV4_5_MRC(14, 0, 0, 0, 5, 0));
+	retval = target_cs_dbg_wr32( target, CPUDBG_ITR, ARMV4_5_MRC(14, 0, 0, 0, 5, 0));
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 	/* Write address into DTRRX, which triggers previous instruction */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DTRRX, address & (~0x3));
+	retval = target_cs_dbg_wr32( target, CPUDBG_DTRRX, address & (~0x3));
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
 	/* Write the data transfer instruction into the ITR
 	 * (STC p14, c5, [R0], 4)
 	 */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_ITR, ARMV4_5_STC(0, 1, 0, 1, 14, 5, 0, 4));
+	retval = target_cs_dbg_wr32( target, CPUDBG_ITR, ARMV4_5_STC(0, 1, 0, 1, 14, 5, 0, 4));
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
 	/* Do the write */
-	retval = mem_ap_sel_write_buf_noincr(swjdp, armv7a->debug_ap,
-					tmp_buff, 4, total_u32, armv7a->debug_base + CPUDBG_DTRRX);
+	retval = target_cs_dbg_wr_bulk_noinc( target,
+					      4,
+					      total_u32,
+					      CPUDBG_DTRRX,
+					      tmp_buff );
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
 
 	/* Switch DTR mode back to non-blocking (0) */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, dscr);
+	retval = target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr);
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
     /* Check for sticky abort flags in the DSCR */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		goto error_free_buff_w;
 	if (dscr & (DSCR_STICKY_ABORT_PRECISE | DSCR_STICKY_ABORT_IMPRECISE)) {
 		/* Abort occurred - clear it and exit */
 		LOG_ERROR("abort occurred - dscr = 0x%08" PRIx32, dscr);
-		mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-					armv7a->debug_base + CPUDBG_DRCR, 1<<2);
+		target_cs_dbg_wr32( target, CPUDBG_DRCR, 1<<2);
 		goto error_free_buff_w;
 	}
 
@@ -1936,11 +1814,9 @@ static int cortex_a_write_apb_ab_memory(struct target *target,
 
 error_unset_dtr_w:
 	/* Unset DTR mode */
-	mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, dscr);
+	target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr);
 error_free_buff_w:
 	LOG_ERROR("error");
 	free(tmp_buff);
@@ -1954,9 +1830,8 @@ static int cortex_a_read_apb_ab_memory(struct target *target,
 	/* read memory through APB-AP */
 
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-	struct arm *arm = &armv7a->arm;
+	struct cortex_a_common	*cortex_a	= target_to_cortex_a(target);
+	struct arm		*arm		= cortex_a_to_arm(cortex_a);
 	int total_bytes = count * size;
 	int total_u32;
 	int start_byte = address & 0x3;
@@ -1985,13 +1860,12 @@ static int cortex_a_read_apb_ab_memory(struct target *target,
 
 	/*  clear any abort  */
 	retval =
-		mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DRCR, 1<<2);
+		target_cs_dbg_wr32( target, CPUDBG_DRCR, 1<<2);
 	if (retval != ERROR_OK)
 		goto error_free_buff_r;
 
 	/* Read DSCR */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 
 	/* This algorithm comes from either :
 	 * Cortex-A TRM Example 12-24
@@ -2001,13 +1875,11 @@ static int cortex_a_read_apb_ab_memory(struct target *target,
 
 	/* Set DTR access mode to stall mode b01  */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_STALL_MODE;
-	retval +=  mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, dscr);
+	retval +=  target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr);
 
 	/* Write R0 with value 'address' using write procedure for stall mode */
 	/*   - Write the address for read access into DTRRX */
-	retval += mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DTRRX, address & ~0x3);
+	retval += target_cs_dbg_wr32( target, CPUDBG_DTRRX, address & ~0x3);
 	/*  - Copy value from DTRRX to R0 using instruction mrc p14, 0, r0, c5, c0 */
 	cortex_a_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dscr);
 
@@ -2020,8 +1892,12 @@ static int cortex_a_read_apb_ab_memory(struct target *target,
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_FAST_MODE;
 	target_buffer_set_u32(target, u8buf_ptr + 4, dscr);
 	/*  group the 2 access CPUDBG_ITR 0x84 and CPUDBG_DSCR 0x88 */
-	retval += mem_ap_sel_write_buf(swjdp, armv7a->debug_ap, u8buf_ptr, 4, 2,
-			armv7a->debug_base + CPUDBG_ITR);
+	retval += target_cs_dbg_wr_bulk( target,
+					4,
+					2,
+					CPUDBG_ITR,
+					u8buf_ptr );
+	
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_r;
 
@@ -2047,36 +1923,31 @@ static int cortex_a_read_apb_ab_memory(struct target *target,
 	 *
 	 * This data is read in aligned to 32 bit boundary.
 	 */
-	retval = mem_ap_sel_read_buf_noincr(swjdp, armv7a->debug_ap, u8buf_ptr, 4, total_u32,
-									armv7a->debug_base + CPUDBG_DTRTX);
+	retval = target_cs_dbg_rd_bulk_noinc( target, CPUDBG_DTRTX, 4, total_u32, u8buf_ptr );
 	if (retval != ERROR_OK)
 			goto error_unset_dtr_r;
 
 	/* set DTR access mode back to non blocking b00  */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	retval =  mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-					armv7a->debug_base + CPUDBG_DSCR, dscr);
+	retval =  target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr);
 	if (retval != ERROR_OK)
 		goto error_free_buff_r;
 
 	/* Wait for the final read instruction to finish */
 	do {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-					armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			goto error_free_buff_r;
 	} while ((dscr & DSCR_INSTR_COMP) == 0);
 
 	/* Check for sticky abort flags in the DSCR */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		goto error_free_buff_r;
 	if (dscr & (DSCR_STICKY_ABORT_PRECISE | DSCR_STICKY_ABORT_IMPRECISE)) {
 		/* Abort occurred - clear it and exit */
 		LOG_ERROR("abort occurred - dscr = 0x%08" PRIx32, dscr);
-		mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-					armv7a->debug_base + CPUDBG_DRCR, 1<<2);
+		target_cs_dbg_wr32( target, CPUDBG_DRCR, 1<<2);
 		goto error_free_buff_r;
 	}
 
@@ -2091,11 +1962,9 @@ static int cortex_a_read_apb_ab_memory(struct target *target,
 
 error_unset_dtr_r:
 	/* Unset DTR mode */
-	mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, dscr);
+	target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr);
 error_free_buff_r:
 	LOG_ERROR("error");
 	free(tmp_buff);
@@ -2114,19 +1983,27 @@ static int cortex_a_read_phys_memory(struct target *target,
 	uint32_t address, uint32_t size,
 	uint32_t count, uint8_t *buffer)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	struct target_addr a;
+	struct target_addr resolved;
+	struct cortex_a_common	*cortex_a	= target_to_cortex_a(target);
+	struct armv7a_common	*armv7a		= cortex_a_to_armv7a(cortex_a);
+
+	
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
-	uint8_t apsel = swjdp->apsel;
+
 	LOG_DEBUG("Reading memory at real address 0x%" PRIx32 "; size %" PRId32 "; count %" PRId32,
 		address, size, count);
 
 	if (count && buffer) {
-
-		if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
-
-			/* read memory through AHB-AP */
-			retval = mem_ap_sel_read_buf(swjdp, armv7a->memory_ap, buffer, size, count, address);
+		TARGET_ADDR_INIT( &a, address );
+		int dp;
+
+		a.route = TA_ROUTE_membus;
+		dp = target_addr_resolve_route(target,&a, &resolved);
+		/* does a memory bus exist? */
+		if (dp>=0){
+			/* YES then use it */
+			retval = target_cs_rd_bulk( target, &resolved,size, count, buffer );
 		} else {
 
 			/* read memory through APB-AP */
@@ -2148,9 +2025,9 @@ static int cortex_a_read_memory(struct target *target, uint32_t address,
 	int mmu_enabled = 0;
 	uint32_t virt, phys;
 	int retval;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-	uint8_t apsel = swjdp->apsel;
+	struct cortex_a_common	*cortex_a	= target_to_cortex_a(target);	
+	struct armv7a_common	*armv7a		= cortex_a_to_armv7a(cortex_a);
+
 
 	/* cortex_a handles unaligned memory access */
 	LOG_DEBUG("Reading memory at address 0x%" PRIx32 "; size %" PRId32 "; count %" PRId32, address,
@@ -2163,7 +2040,7 @@ static int cortex_a_read_memory(struct target *target, uint32_t address,
 			return retval;
 	}
 
-	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
+	if( target_cs_isbus_avail( target, TA_ROUTE_membus ) ){
 		if (mmu_enabled) {
 			virt = address;
 			retval = cortex_a_virt2phys(target, virt, &phys);
@@ -2195,19 +2072,18 @@ static int cortex_a_write_phys_memory(struct target *target,
 	uint32_t count, const uint8_t *buffer)
 {
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
-	uint8_t apsel = swjdp->apsel;
 
 	LOG_DEBUG("Writing memory to real address 0x%" PRIx32 "; size %" PRId32 "; count %" PRId32, address,
 		size, count);
 
 	if (count && buffer) {
 
-		if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
-
+		if ( target_cs_isbus_avail( target, TA_ROUTE_membus ) ) {
+			struct target_addr a;
+			TARGET_ADDR_PHYS( &a, address );
 			/* write memory through AHB-AP */
-			retval = mem_ap_sel_write_buf(swjdp, armv7a->memory_ap, buffer, size, count, address);
+			retval = target_cs_mem_wr_bulk( target, address, size, count, buffer);
 		} else {
 
 			/* write memory through APB-AP */
@@ -2223,7 +2099,7 @@ static int cortex_a_write_phys_memory(struct target *target,
 
 	/* REVISIT this op is generic ARMv7-A/R stuff */
 	if (retval == ERROR_OK && target->state == TARGET_HALTED) {
-		struct arm_dpm *dpm = armv7a->arm.dpm;
+		struct arm_dpm *dpm = armv7a_to_arm_dpm(armv7a);
 
 		retval = dpm->prepare(dpm);
 		if (retval != ERROR_OK)
@@ -2278,6 +2154,8 @@ static int cortex_a_write_phys_memory(struct target *target,
 	return retval;
 }
 
+
+
 static int cortex_a_write_memory(struct target *target, uint32_t address,
 	uint32_t size, uint32_t count, const uint8_t *buffer)
 {
@@ -2285,8 +2163,6 @@ static int cortex_a_write_memory(struct target *target, uint32_t address,
 	uint32_t virt, phys;
 	int retval;
 	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-	uint8_t apsel = swjdp->apsel;
 
 	/* cortex_a handles unaligned memory access */
 	LOG_DEBUG("Writing memory at address 0x%" PRIx32 "; size %" PRId32 "; count %" PRId32, address,
@@ -2299,7 +2175,7 @@ static int cortex_a_write_memory(struct target *target, uint32_t address,
 			return retval;
 	}
 
-	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
+	if ( target_cs_isbus_avail( target, TA_ROUTE_membus ) ){
 		LOG_DEBUG("Writing memory to address 0x%" PRIx32 "; size %" PRId32 "; count %" PRId32, address, size,
 			count);
 		if (mmu_enabled) {
@@ -2333,8 +2209,6 @@ static int cortex_a_write_memory(struct target *target, uint32_t address,
 static int cortex_a_handle_target_request(void *priv)
 {
 	struct target *target = priv;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	int retval;
 
 	if (!target_was_examined(target))
@@ -2345,17 +2219,14 @@ static int cortex_a_handle_target_request(void *priv)
 	if (target->state == TARGET_RUNNING) {
 		uint32_t request;
 		uint32_t dscr;
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 
 		/* check if we have data */
 		while ((dscr & DSCR_DTR_TX_FULL) && (retval == ERROR_OK)) {
-			retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-					armv7a->debug_base + CPUDBG_DTRTX, &request);
+			retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &request);
 			if (retval == ERROR_OK) {
 				target_request(target, request);
-				retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-						armv7a->debug_base + CPUDBG_DSCR, &dscr);
+				retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
 			}
 		}
 	}
@@ -2363,29 +2234,56 @@ static int cortex_a_handle_target_request(void *priv)
 	return ERROR_OK;
 }
 
+static int cortex_a_dpm_setup(struct cortex_a_common *cortex_a, uint32_t didr)
+{
+	struct arm_dpm *dpm = cortex_a_to_arm_dpm( cortex_a );
+	int retval;
+
+	dpm->arm = &cortex_a->HIDE_armv7a_common.HIDE_arm;
+	dpm->didr = didr;
+
+	dpm->prepare = cortex_a_dpm_prepare;
+	dpm->finish = cortex_a_dpm_finish;
+
+	dpm->instr_write_data_dcc = cortex_a_instr_write_data_dcc;
+	dpm->instr_write_data_r0 = cortex_a_instr_write_data_r0;
+	dpm->instr_cpsr_sync = cortex_a_instr_cpsr_sync;
+
+	dpm->instr_read_data_dcc = cortex_a_instr_read_data_dcc;
+	dpm->instr_read_data_r0 = cortex_a_instr_read_data_r0;
+
+	dpm->bpwp_enable = cortex_a_bpwp_enable;
+	dpm->bpwp_disable = cortex_a_bpwp_disable;
+
+	retval = arm_dpm_setup(dpm);
+	if (retval == ERROR_OK)
+		retval = arm_dpm_initialize(dpm);
+
+	return retval;
+}
+
+
 /*
  * Cortex-A target information and configuration
  */
 
 static int cortex_a_examine_first(struct target *target)
 {
-	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	struct coresight_settings *coresight;
+	struct cortex_a_common	*cortex_a	= target_to_cortex_a(target);
+	struct arm		*arm		= cortex_a_to_arm( cortex_a );
 	int i;
 	int retval = ERROR_OK;
 	uint32_t didr, ctypr, ttypr, cpuid;
 
-	/* We do one extra read to ensure DAP is configured,
-	 * we call ahbap_debugport_init(swjdp) instead
-	 */
-	dap_ap_select(swjdp, 1); //swjdp->apsel=1;
-	retval = ahbap_debugport_init(swjdp);
+	coresight = target_to_coresight(target);
+	retval = target_cs_debugport_init( target );
 	if (retval != ERROR_OK)
 		return retval;
 
-	/* Search for the APB-AB - it is needed for access to debug registers */
-	retval = dap_find_ap(swjdp, AP_TYPE_APB_AP, &armv7a->debug_ap);
+	
+	/* If needed, search for the APB-AB - it is needed for access to debug registers */
+	retval = target_cs_discover_ap( target, AP_TYPE_APB_AP, &(coresight->dbgbus) );
 	if (retval != ERROR_OK) {
 		LOG_ERROR("Could not find APB-AP for debug access");
 		return retval;
@@ -2394,72 +2292,67 @@ static int cortex_a_examine_first(struct target *target)
 	/* SQU: tricky here. For 8916 it has AXI_AP but not AHB_AP as port 0 for sys-mem.And port3 is AHB_AP but it is RPM/Cortex M3
 	 * So either hard coded the memory_ap as port 0 or search AXI_AP first, or check AP type variant. Will take option 3.
 	 */
-	retval = dap_find_ap(swjdp, AP_TYPE_AHB_AP, &armv7a->memory_ap);
+	retval = target_cs_discover_ap( target, AP_TYPE_AHB_AP, &(coresight->membus) );
 	if (retval != ERROR_OK) {
 		/* AHB-AP not found - use APB-AP */
 		LOG_DEBUG("Could not find AHB-AP - Will try AXI-AP for memory access");
 		/* Search for the AXI-AP */
-		retval = dap_find_ap(swjdp, AP_TYPE_AXI_AP, &armv7a->memory_ap);
+		retval = target_cs_discover_ap( target, AP_TYPE_AXI_AP, &coresight->membus );
 		if (retval != ERROR_OK) {
 			/* AXI-AP not found - use APB-AP */
 			LOG_DEBUG("Could not find AXI/AHB-AP - using APB-AP for memory access");
-			armv7a->memory_ap_available = false;
-		} else {
-			armv7a->memory_ap_available = true;
-		}
-	} else {
-		armv7a->memory_ap_available = true;
-	}
+			/* mark this as "not-found" by making route = DEFAULT */
+			TARGET_ADDR_INIT( &(coresight->membus.addr), 0 );
+		} 
+	} 
 
 
-	if (!target->dbgbase_set) {
+	if ( coresight->dbgbus.is_forced ){
+		/* User specified this, we do not search for this */
+	} else {
 		uint32_t dbgbase;
 		/* Get ROM Table base */
 		uint32_t apid;
 		int32_t coreidx = target->coreid;
+		uint32_t tmp;
 		LOG_DEBUG("%s's dbgbase is not set, trying to detect using the ROM table",
 			  target->cmd_name);
-		retval = dap_get_debugbase(swjdp, 1, &dbgbase, &apid);
+		retval = target_cs_get_debugbase(target, 1, &dbgbase, &apid);
 		if (retval != ERROR_OK)
 			return retval;
 		/* Lookup 0x15 -- Processor DAP */
-		retval = dap_lookup_cs_component(swjdp, 1, dbgbase, 0x15,
-				&armv7a->debug_base, &coreidx);
+		retval = target_cs_lookup_component(target, &(coresight->dbgbus.addr), dbgbase, 0x15,
+				&tmp, &coreidx);
 		if (retval != ERROR_OK)
 			return retval;
-		LOG_DEBUG("Detected core %" PRId32 " dbgbase: %08" PRIx32,
-			  coreidx, armv7a->debug_base);
-	} else
-		armv7a->debug_base = target->dbgbase;
+		coresight->dbgbus.addr.addr = tmp;
+		LOG_DEBUG("Detected core %" PRId32 " dbgbase: %s" PRIx64,
+				  coreidx, target_addr2str1( target, &coresight->dbgbus.addr));
+	}
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_CPUID, &cpuid);
+	retval = target_cs_dbg_rd32( target, CPUDBG_CPUID, &cpuid);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_CPUID, &cpuid);
+	retval = target_cs_dbg_rd32( target, CPUDBG_CPUID, &cpuid);
 	if (retval != ERROR_OK) {
 		LOG_DEBUG("Examine %s failed", "CPUID");
 		return retval;
 	}
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_CTYPR, &ctypr);
+	retval = target_cs_dbg_rd32( target, CPUDBG_CTYPR, &ctypr);
 	if (retval != ERROR_OK) {
 		LOG_DEBUG("Examine %s failed", "CTYPR");
 		return retval;
 	}
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_TTYPR, &ttypr);
+	retval = target_cs_dbg_rd32( target, CPUDBG_TTYPR, &ttypr);
 	if (retval != ERROR_OK) {
 		LOG_DEBUG("Examine %s failed", "TTYPR");
 		return retval;
 	}
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DIDR, &didr);
+	retval = target_cs_dbg_rd32( target, CPUDBG_DIDR, &didr);
 	if (retval != ERROR_OK) {
 		LOG_DEBUG("Examine %s failed", "DIDR");
 		return retval;
@@ -2470,7 +2363,7 @@ static int cortex_a_examine_first(struct target *target)
 	LOG_DEBUG("ttypr = 0x%08" PRIx32, ttypr);
 	LOG_DEBUG("didr = 0x%08" PRIx32, didr);
 
-	armv7a->arm.core_type = ARM_MODE_MON;
+	arm->core_type = ARM_MODE_MON;
 	retval = cortex_a_dpm_setup(cortex_a, didr);
 	if (retval != ERROR_OK)
 		return retval;
@@ -2527,10 +2420,10 @@ static int cortex_a_init_target(struct command_context *cmd_ctx,
 static int cortex_a_init_arch_info(struct target *target,
 	struct cortex_a_common *cortex_a)
 {
-	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
+	struct armv7a_common *armv7a = cortex_a_to_armv7a(cortex_a);
 
 	/* Setup struct cortex_a_common */
-	cortex_a->common_magic = CORTEX_A_COMMON_MAGIC;
+	cortex_a->common_cortex_a_magic = CORTEX_A_COMMON_MAGIC;
 
 	cortex_a->fast_reg_read = 0;
 
@@ -2553,28 +2446,19 @@ static int cortex_a_init_arch_info(struct target *target,
 	return ERROR_OK;
 }
 
-void cortex_a_connect_dap(struct target *target, struct adiv5_dap *dap)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-
-	dap->memaccess_tck = 8;
-	dap->tar_autoincr_block = (1 << 10);
-
-	armv7a->arm.dap = dap;
-}
 
 static int cortex_a_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct cortex_a_common *cortex_a = calloc(1, sizeof(struct cortex_a_common));
 
-	cortex_a->armv7a_common.is_armv7r = false;
+	cortex_a->HIDE_armv7a_common.is_armv7r = false;
 	cortex_a_init_arch_info(target, cortex_a);
 
 	/* If it's not set, assume transport select is not swd. Nothing sets up the JTAG DAP so we have to. */
 	if (!global_dap)
 		global_dap = adiv5_jtag_dap_new(target->tap);
 
-	cortex_a_connect_dap(target, global_dap);
+	target_cs_connect_dap(target, global_dap);
  
 	return ERROR_OK;
 }
@@ -2583,7 +2467,7 @@ static int cortex_r4_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct cortex_a_common *cortex_a = calloc(1, sizeof(struct cortex_a_common));
 
-	cortex_a->armv7a_common.is_armv7r = true;
+	cortex_a->HIDE_armv7a_common.is_armv7r = true;
 
 	return cortex_a_init_arch_info(target, cortex_a);
 }
@@ -2591,36 +2475,26 @@ static int cortex_r4_target_create(struct target *target, Jim_Interp *interp)
 
 static int cortex_a_mmu(struct target *target, int *enabled)
 {
+	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
+	struct armv7a_common   *armv7a   = cortex_a_to_armv7a(cortex_a);
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("%s: target not halted", __func__);
 		return ERROR_TARGET_INVALID;
 	}
 
-	*enabled = target_to_cortex_a(target)->armv7a_common.armv7a_mmu.mmu_enabled;
+	*enabled = armv7a->armv7a_mmu.mmu_enabled;
 	return ERROR_OK;
 }
 
-static int cortex_a_virt2phys(struct target *target,
-	uint32_t virt, uint32_t *phys)
+static int cortex_a_virt2phys(struct target *target, uint32_t virt, uint32_t *phys)
 {
 	int retval = ERROR_FAIL;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-	uint8_t apsel = swjdp->apsel;
-	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
-		uint32_t ret;
-		retval = armv7a_mmu_translate_va(target,
-				virt, &ret);
-		if (retval != ERROR_OK)
-			goto done;
-		*phys = ret;
-	} else {/*  use this method if armv7a->memory_ap not selected
-		 *  mmu must be enable in order to get a correct translation */
-		retval = cortex_a_mmu_modify(target, 1);
-		if (retval != ERROR_OK)
-			goto done;
-		retval = armv7a_mmu_translate_va_pa(target, virt,  phys, 1);
-	}
+
+	/* turn MMU on so we can get a translation */
+	retval = cortex_a_mmu_modify(target, 1);
+	if (retval != ERROR_OK)
+		goto done;
+	retval = armv7a_mmu_translate_va_pa(target, virt,  phys, 1);
 done:
 	return retval;
 }
diff --git a/src/target/cortex_a.h b/src/target/cortex_a.h
index fb113fe..ae21c47 100755
--- a/src/target/cortex_a.h
+++ b/src/target/cortex_a.h
@@ -48,13 +48,13 @@
 struct cortex_a_brp {
 	int used;
 	int type;
-	uint32_t value;
+	uint64_t value;
 	uint32_t control;
 	uint8_t BRPn;
 };
 
 struct cortex_a_common {
-	int common_magic;
+	int common_cortex_a_magic;
 
 	/* Context information */
 	uint32_t cpudbg_dscr;
@@ -75,14 +75,60 @@ struct cortex_a_common {
 	/* Use cortex_a_read_regs_through_mem for fast register reads */
 	int fast_reg_read;
 
-	struct armv7a_common armv7a_common;
+	struct armv7a_common HIDE_armv7a_common;
 
 };
 
+static inline bool is_cortex_a( struct cortex_a_common *p )
+{
+	return (p->common_cortex_a_magic == CORTEX_A_COMMON_MAGIC);
+}
+
+static inline struct armv7a_common *cortex_a_to_armv7a( struct cortex_a_common *cortex_a )
+{
+	return &(cortex_a->HIDE_armv7a_common);
+}
+
+static inline struct arm *cortex_a_to_arm( struct cortex_a_common *cortex_a )
+{
+	return armv7a_to_arm( cortex_a_to_armv7a(cortex_a) );
+}
+
+static inline struct target *
+cortex_a_to_target(struct cortex_a_common *cortex_a)
+{
+	return arm_to_target( cortex_a_to_arm(cortex_a) );
+}
+
 static inline struct cortex_a_common *
 target_to_cortex_a(struct target *target)
 {
-	return container_of(target->arch_info, struct cortex_a_common, armv7a_common.arm);
+	struct cortex_a_common *r;
+	r = container_of(target->arch_info, struct cortex_a_common, HIDE_armv7a_common.HIDE_arm);
+	assert( is_cortex_a(r) );
+	return r;
+}
+
+
+
+static inline struct coresight_settings *cortex_a_to_coresight( struct cortex_a_common *cortex_a )
+{
+	return target_to_coresight( cortex_a_to_target( cortex_a ) );
+}
+
+static inline struct arm_dpm *cortex_a_to_arm_dpm( struct cortex_a_common *cortex_a )
+{
+	return armv7a_to_arm_dpm( cortex_a_to_armv7a(cortex_a) );
+}
+
+
+static inline struct cortex_a_common *arm_dpm_to_cortex_a(struct arm_dpm *dpm)
+{
+	return container_of(dpm, struct cortex_a_common, HIDE_armv7a_common.HIDE_dpm);
 }
 
+
+
+
+
 #endif /* CORTEX_A_H */
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index e5aa8e0..8c09567 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -15,8 +15,10 @@
 #include "arm_opcodes.h"
 #include "armv8.h"
 #include "arm_semihosting.h"
+#include "arm_adi_v5.h"
 #include <helper/time_support.h>
 
+static int cortex_a53_halt(struct target *target);
 static int cortex_a53_poll(struct target *target);
 static int cortex_a53_debug_entry(struct target *target);
 static int cortex_a53_restore_context(struct target *target, bool bpwp);
@@ -28,18 +30,14 @@ static int cortex_a53_set_hybrid_breakpoint(struct target *target,
 	struct breakpoint *breakpoint);
 static int cortex_a53_unset_breakpoint(struct target *target,
 	struct breakpoint *breakpoint);
-#if 0
-static int cortex_a53_dap_read_coreregister_u32(struct target *target,
-	uint32_t *value, int regnum);
-static int cortex_a53_dap_write_coreregister_u32(struct target *target,
-	uint32_t value, int regnum);
-#endif
 static int cortex_a53_mmu(struct target *target, int *enabled);
 static int cortex_a53_virt2phys_64(struct target *target,
         const struct target_addr *in_pVirt, struct target_addr *out_pPhys );
 static int cortex_a53_read_apb_ab_memory(struct target *target,
 	const struct target_addr *pAddr, uint32_t size, uint32_t count, uint8_t *buffer);
 
+#define _bitof(X,V)       _bitsof( X,X,V )
+#define _bitsof( X,Y,V )  (((V) >> (Y)) & ((1<<((X)-(Y)+1))-1))
 
 /* check whether it is in AArch32 or AArch64 through dscr. Only valid at debug state
  * return: 1 for AArch64, 0 for AArch32, -1 for not in debug state
@@ -47,6 +45,7 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 static int isAArch64(uint32_t dscr)
 {
 	if(dscr & 1) {
+		/* examine EL bits [9:8] */
 		//is in debug state
 		//LOG_DEBUG("dscr is 0x%x", dscr);
 		if(dscr & (1<<(((dscr&0x300)>>8)+10))) return 1;
@@ -58,67 +57,260 @@ static int isAArch64(uint32_t dscr)
 	}
 }
 
+	
+
+static int armv8_cti_wr_RESTART( struct target *target )
+{
+	return target_cs_cti_wr32( target, CTIAPPPULSE, 1<<CTIDBGCHAN_RESTART);
+}
+
+static int armv8_cti_wr_HALT( struct target *target )
+{
+	return target_cs_cti_wr32( target, CTIAPPPULSE, 1<<CTIDBGCHAN_HALT);
+}
+
+static int armv8_cti_rd_STATUS( struct target *target, uint32_t *puthere )
+{
+	return target_cs_cti_rd32( target, CTITRIGOUTSTATUS, puthere );
+}
+
+static int armv8_dbg_rd_EDPRSR( struct target *target, uint32_t *puthere )
+{
+	int r;
+	uint32_t v;
+	/* FIXME: Make this *per*cpu* */
+	static uint32_t old_EDPRSR;
+	
+
+	r = target_cs_dbg_rd32( target, EDPRSR, &v );
+	if( r != ERROR_OK ){
+		LOG_DEBUG("rd: edprsr: error: %d", r );
+		old_EDPRSR = (uint32_t)(-1);
+	} else {
+		if( v != old_EDPRSR ){
+			old_EDPRSR = v;
+			LOG_DEBUG("rd: edprsr 0x%08" PRIx32 " sdr:%d spmad:%d epmad:%d",
+					  v,
+					  _bitof( 11, v ),  _bitof( 10, v ), _bitof(9,v));
+			LOG_DEBUG("sdad:%d edad:%d dlk:%d oslk:%d halted:%d sr:%d r:%d spd:%d pu:%d",
+					  _bitof(8,v),
+					  _bitof(7,v), _bitof(6,v), _bitof(5,v), _bitof(4,v),
+					  _bitof(3,v), _bitof(2,v), _bitof(1,v), _bitof(0,v) );
+		}
+	}
+	if( puthere ){
+		*puthere = v;
+	}
+	return r;
+	   
+}
+
+			  
+
+static int armv8_dbg_wr_EDSCR( struct target *target, uint32_t v )
+{
+	int r;
+	LOG_DEBUG("wr: edscr: 0x%08" PRIx32 , v );
+	r = target_cs_dbg_wr32( target, EDSCR, v );
+	return r;
+}
+
+#define armv8_edscr_get_HDE(V)  _bitof( 14, (V) )
+#define armv8_edscr_set_HDE(V)  ((V) |= (1 << 14))
+
+static int armv8_dbg_rd_EDSCR( struct target *target, uint32_t *puthere )
+{
+	int r;
+	uint32_t v;
+	/* fix me: make this per cpu */
+	static uint32_t old_EDSCR;
+	r = target_cs_dbg_rd32( target, EDSCR, &v );
+
+	if( r != ERROR_OK ){
+		LOG_DEBUG("rd edscr: error: %d", r );
+		old_EDSCR = (uint32_t)(-1);
+	} else {
+		if( old_EDSCR != v ){
+			old_EDSCR = v;
+			
+			LOG_DEBUG("rd: edscr: 0x%08" PRIx32 " res0:%d rxful:%d txful:%d ito:%d rxo:%d txo:%d pipe:%d ite:%d",
+					  v,
+					  _bitof( 31, v ),  _bitof( 30, v ),
+					  _bitof( 29, v ),  _bitof( 28, v ),
+					  _bitof( 27, v ),  _bitof( 26, v ),
+					  _bitof( 25, v ),  _bitof( 24, v ));
+			LOG_DEBUG("intdis:%d tda:%d ma:%d res0:%d ns%d res0:%d sdd:%d res0:%d",
+					  _bitsof( 23,22,v ), _bitof( 21, v ),
+					  _bitof( 20, v ),  _bitof( 19, v ),
+					  _bitof( 18, v ),  _bitof( 17, v ),
+					  _bitof( 16, v ),  _bitof( 15, v ));
+			LOG_DEBUG("hde:%d rw:%d el:%d a:%d err:%d status:%d", 
+					  armv8_edscr_get_HDE( v ), _bitsof( 13,10, v ),
+					  _bitsof( 9,8, v ), _bitof(7,v),
+					  _bitof(6,v), _bitsof(5,0,v));
+		}
+	}
+	if( puthere ){
+		*puthere = v;
+	}
+	return r;
+}
+
+
+static int armv8_dbg_wr_OSLAR_EL1( struct target *target, uint32_t v)
+{
+	return target_cs_dbg_wr32( target, OSLAR_EL1, v );
+}
+
+static int armv8_rd_OSLAR_EL1( struct target *target, uint32_t *v)
+{
+	int r;
+
+	r = target_cs_dbg_rd32( target, OSLAR_EL1, v );
+	if( r != ERROR_OK ){
+		LOG_DEBUG("rd: oslar-el1: error %d",r);
+	} else {
+		LOG_DEBUG("rd: oslar-el1: 0x%08" PRIx32 " oslk:%d",
+				  *v, _bitof(0,*v) );
+	}
+	return r;
+}
+
+static int armv8_rd_OSLSR_EL1( struct target *target, uint32_t *v)
+{
+	int r;
+#if 1
+	/* FIXME: add opcode here */
+	/* this requires an *OPCODE* to read */
+	/* SEE: D7-2114 - of ARM DDI-0487A-D */
+	r = ERROR_FAIL;
+#endif
+	if( r != ERROR_OK ){
+		LOG_ERROR("rd: oslsr-el1: error %d", r );
+	} else {
+		LOG_ERROR("rd: oslsr-el1: 0x%0" PRIx32
+				  "oslm1:%d ntt:%d oslk:%d oslm0:%d",
+				  *v,
+				  _bitof(3,*v),
+				  _bitof(2,*v),
+				  _bitof(1,*v),
+				  _bitof(0,*v));
+	}
+	return r;
+}
+
+static int armv8_dbg_ClearStickyErrors( struct target *target )
+{
+	/* REFERENCE:  arm DDI-0487A
+	 * page 5325 of 5538, page J8-5325
+	 * shared/debug/ClearStickyErrors/ClearStickyErrors 
+	 */
+
+	/* Clear sticky bit errors
+	 * ARM DDI-0487A rev E, page H9-5154
+	 */
+	return target_cs_dbg_wr32( target, EDRCR, 1 << 2 );
+}
+
 static void cortex_a53_dbg_dump(struct target *target)
 {	//Strong Qu: dump several key dbg reg for debug purpose:
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	int retval;
 	uint32_t dummy;
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + EDPRSR, &dummy);
-	LOG_USER("Read %d EDPRSR 0x%08" PRIx32, retval, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + EDECR, &dummy);
-	LOG_USER("Read %d EDECR 0x%08" PRIx32, retval, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + EDESR, &dummy);
-	LOG_USER("Read %d EDESR 0x%08" PRIx32, retval, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + EDSCR, &dummy);
-	LOG_USER("Read %d EDSCR 0x%08" PRIx32, retval, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + OSLAR_EL1, &dummy);
-	LOG_USER("Read %d OSLAR_EL1 0x%08" PRIx32, retval, dummy);
-
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + EDRCR, &dummy);
-	LOG_USER("Read %d EDRCR 0x%08" PRIx32, retval, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + EDACR, &dummy);
-	LOG_USER("Read %d EDACR 0x%08" PRIx32, retval, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + EDECCR, &dummy);
-	LOG_USER("Read %d EDECCR 0x%08" PRIx32, retval, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + EDPRCR, &dummy);
-	LOG_USER("Read %d EDPRCR 0x%08" PRIx32, retval, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + DBGAUTHSTATUS_EL1, &dummy);
-	LOG_USER("Read %d DBGAUTHSTATUS_EL1 0x%08" PRIx32, retval, dummy);
+	retval = armv8_dbg_rd_EDPRSR( target, &dummy);
+	retval = target_cs_dbg_rd32( target, EDECR, &dummy);
+	LOG_DEBUG("Read %d EDECR 0x%08" PRIx32, retval, dummy);
+	retval = target_cs_dbg_rd32( target, EDESR, &dummy);
+	LOG_DEBUG("Read %d EDESR 0x%08" PRIx32, retval, dummy);
+	retval = armv8_dbg_rd_EDSCR( target, &dummy );
+	retval = armv8_rd_OSLAR_EL1( target, &dummy);
+
+
+	retval = target_cs_dbg_rd32( target, EDRCR, &dummy);
+	LOG_DEBUG("Read %d EDRCR 0x%08" PRIx32, retval, dummy);
+	retval = target_cs_dbg_rd32( target, EDACR, &dummy);
+	LOG_DEBUG("Read %d EDACR 0x%08" PRIx32, retval, dummy);
+	retval = target_cs_dbg_rd32( target, EDECCR, &dummy);
+	LOG_DEBUG("Read %d EDECCR 0x%08" PRIx32, retval, dummy);
+	retval = target_cs_dbg_rd32( target, EDPRCR, &dummy);
+	LOG_DEBUG("Read %d EDPRCR 0x%08" PRIx32, retval, dummy);
+	retval = target_cs_dbg_rd32( target, DBGAUTHSTATUS_EL1, &dummy);
+	LOG_DEBUG("Read %d DBGAUTHSTATUS_EL1 0x%08" PRIx32, retval, dummy);
 }
 
+	
+
+
 static void cortex_a53_cti_dump(struct target *target)
 {	//Strong Qu: dump several key CTI reg for debug purpose:
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	int retval;
 	uint32_t dummy;
 
-	//retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, cti_base + CTIDEVID, &dummy);
-	//LOG_USER("Read %d CTIDEVID 0x%08" PRIx32, retval, dummy); //RO, for 8916 it is 0x1040800
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTICONTROL, &dummy);
-	LOG_USER("Read %d CTICONTROL 0x%08" PRIx32, retval, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIGATE, &dummy);
-	LOG_USER("Read %d CTIGATE 0x%08" PRIx32, retval, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINEN(0), &dummy);
-	LOG_USER("Read %d CTIINEN0 0x%08" PRIx32, retval, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIOUTEN(0), &dummy);
-	LOG_USER("Read %d CTIOUTEN0 0x%08" PRIx32, retval, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTITRIGOUTSTATUS, &dummy);
-	LOG_USER("Read %d CTITRIGOUTSTATUS 0x%08" PRIx32, retval, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIAPPPULSE, &dummy);
-	LOG_USER("Read %d CTIAPPPULSE 0x%08" PRIx32, retval, dummy);
+	//retval = target_cs_cti_rd32( target, CTIDEVID, &dummy);
+	//LOG_DEBUG("Read %d CTIDEVID 0x%08" PRIx32, retval, dummy); //RO, for 8916 it is 0x1040800
+	retval = target_cs_cti_rd32( target, CTICONTROL, &dummy);
+	LOG_DEBUG("Read %d CTICONTROL 0x%08" PRIx32, retval, dummy);
+	retval = target_cs_cti_rd32( target, CTIGATE, &dummy);
+	LOG_DEBUG("Read %d CTIGATE 0x%08" PRIx32, retval, dummy);
+	retval = target_cs_cti_rd32( target, CTIINENn(0), &dummy);
+	LOG_DEBUG("Read %d CTIINEN0 0x%08" PRIx32, retval, dummy);
+	retval = target_cs_cti_rd32( target, CTIOUTENn(0), &dummy);
+	LOG_DEBUG("Read %d CTIOUTEN0 0x%08" PRIx32, retval, dummy);
+
+	retval = target_cs_cti_rd32( target, CTIINENn(1), &dummy);
+	LOG_DEBUG("Read %d CTIINEN0 0x%08" PRIx32, retval, dummy);
+	retval = target_cs_cti_rd32( target, CTIOUTENn(1), &dummy);
+	LOG_DEBUG("Read %d CTIOUTEN0 0x%08" PRIx32, retval, dummy);
+	
+
+	retval = target_cs_cti_rd32( target, CTITRIGOUTSTATUS, &dummy);
+	LOG_DEBUG("Read %d CTITRIGOUTSTATUS 0x%08" PRIx32, retval, dummy);
+	retval = target_cs_cti_rd32( target, CTIAPPPULSE, &dummy);
+	LOG_DEBUG("Read %d CTIAPPPULSE 0x%08" PRIx32, retval, dummy);
+}
+
+
+int armv8_dbg_wr_bpwp_regs( struct armv8 *armv8, struct cortex_a_brp *p )
+{
+	struct target *target        = armv8_to_target(armv8);
+	uint32_t vr;
+	uint32_t cr;
+	int retval;
+
+	vr = 0;
+	cr = 0;
+	
+	switch (p->BRPn) {
+	case 0 ... 15:	/* breakpoints */
+		vr += DBGBVRn_EL1( p->BRPn-0 );
+		cr += DBGBCRn_EL1( p->BRPn-0 );
+		break;
+	case 16 ... 31:	/* watchpoints */
+		vr += DBGWVRn_EL1( p->BRPn-16 );
+		cr += DBGWCRn_EL1( p->BRPn-16 );
+		break;
+	default:
+		return ERROR_FAIL;
+	}
+
+	LOG_DEBUG("A8: bpwp enable, cr %08" PRIx32 " vr: 0x%s",
+			  p->control,
+			  target_addr64str1( target, p->value ) );
+
+	retval = ERROR_OK;
+	if( p->control == 0 ){
+		/* we are disabling write control first */
+		retval = target_cs_dbg_wr32( target, cr, p->control );
+	}
+
+	if( retval == ERROR_OK ){
+		retval = target_cs_dbg_wr64( target, vr, p->value  );
+		if( p->control ){
+			/* we are enabling write control last */
+			retval = target_cs_dbg_wr32( target, cr, p->control);
+		}
+	}
+	return retval;
 }
 
 
@@ -126,16 +318,17 @@ static void cortex_a53_cti_dump(struct target *target)
 static int cortex_a53_restore_cp15_control_reg(struct target *target)
 {
 	int retval = ERROR_OK;
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-
-	if (cortex_a53->cp15_control_reg != cortex_a53->cp15_control_reg_curr) {
-		cortex_a53->cp15_control_reg_curr = cortex_a53->cp15_control_reg;
-		/* LOG_INFO("cp15_control_reg: %8.8" PRIx32, cortex_a53->cp15_control_reg); */
-		retval = armv7a->arm.mcr(target, 15,
+	struct armv8           *armv8    = target_to_armv8( target);
+	struct cortex_a_common *cortex_a = armv8_to_cortex_a( armv8 );
+	struct arm             *arm      = armv8_to_arm(armv8);
+
+	if (cortex_a->cp15_control_reg != cortex_a->cp15_control_reg_curr) {
+		cortex_a->cp15_control_reg_curr = cortex_a->cp15_control_reg;
+		/* LOG_INFO("cp15_control_reg: %8.8" PRIx32, cortex_a->cp15_control_reg); */
+		retval = arm->mcr(target, 15,
 				0, 0,	/* op1, op2 */
 				1, 0,	/* CRn, CRm */
-				cortex_a53->cp15_control_reg);
+				cortex_a->cp15_control_reg);
 	}
 	return retval;
 }
@@ -144,26 +337,29 @@ static int cortex_a53_restore_cp15_control_reg(struct target *target)
  *  remove apb predictible data abort */
 static int cortex_a53_check_address(struct target *target, const struct target_addr *pAddr)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
+	struct armv8 *armv8              = target_to_armv8(target);
+	struct cortex_a_common *cortex_a = armv8_to_cortex_a( armv8 );
+	struct armv7a_common *armv7a     = armv8_to_armv7a( armv8 );
+	struct arm_dpm *arm_dpm          = armv8_to_arm_dpm( armv8 );
+	struct arm *arm                  = armv8_to_arm(armv8);          
 
 	uint32_t os_border = armv7a->armv7a_mmu.os_border;
 	if ((pAddr->addr < os_border) &&
-		(armv7a->arm.core_mode == ARM_MODE_SVC)) {
-		LOG_ERROR("%" PRIx64 " access in userspace and target in supervisor", pAddr->addr );
+		(arm->core_mode == ARM_MODE_SVC)) {
+		LOG_ERROR("access in userspace and target in supervisor: %s", target_addr2str1(target,pAddr) );
 		return ERROR_FAIL;
 	}
 	if ((pAddr->addr >= os_border) &&
 		(cortex_a->curr_mode != ARM_MODE_SVC)) {
-		dpm_modeswitch(&armv7a->dpm, ARM_MODE_SVC);
+		dpm_modeswitch(arm_dpm, ARM_MODE_SVC);
 		cortex_a->curr_mode = ARM_MODE_SVC;
-		LOG_INFO("%" PRIx64 " access in kernel space and target not in supervisor",
-			pAddr->addr );
+		LOG_INFO("access in kernel space and target not in supervisor: %s",
+				 target_addr2str1(target,pAddr) );
 		return ERROR_OK;
 	}
 	if ((pAddr->addr < os_border) &&
 		(cortex_a->curr_mode == ARM_MODE_SVC)) {
-		dpm_modeswitch(&armv7a->dpm, ARM_MODE_ANY);
+		dpm_modeswitch(arm_dpm, ARM_MODE_ANY);
 		cortex_a->curr_mode = ARM_MODE_ANY;
 	}
 	return ERROR_OK;
@@ -173,36 +369,39 @@ static int cortex_a53_check_address(struct target *target, const struct target_a
  *  - read or write memory in phys or virt address */
 static int cortex_a53_mmu_modify(struct target *target, int enable)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct armv8		*armv8          = target_to_armv8(target);
+	struct arm		*arm            = armv8_to_arm(armv8);
+	struct cortex_a_common	*cortex_a	= armv8_to_cortex_a( armv8 );
+	struct armv7a_common	*armv7a		= armv8_to_armv7a( armv8 );
+
 	int retval = ERROR_OK;
 	if (enable) {
 		/*  if mmu enabled at target stop and mmu not enable */
-		if (!(cortex_a53->cp15_control_reg & 0x1U)) {
+		if (!(cortex_a->cp15_control_reg & 0x1U)) {
 			LOG_ERROR("trying to enable mmu on target stopped with mmu disable");
 			return ERROR_FAIL;
 		}
-		if (!(cortex_a53->cp15_control_reg_curr & 0x1U)) {
-			cortex_a53->cp15_control_reg_curr |= 0x1U;
-			retval = armv7a->arm.mcr(target, 15,
+		if (!(cortex_a->cp15_control_reg_curr & 0x1U)) {
+			cortex_a->cp15_control_reg_curr |= 0x1U;
+			retval = arm->mcr(target, 15,
 					0, 0,	/* op1, op2 */
 					1, 0,	/* CRn, CRm */
-					cortex_a53->cp15_control_reg_curr);
+					cortex_a->cp15_control_reg_curr);
 		}
 	} else {
-		if (cortex_a53->cp15_control_reg_curr & 0x4U) {
+		if (cortex_a->cp15_control_reg_curr & 0x4U) {
 			/*  data cache is active */
-			cortex_a53->cp15_control_reg_curr &= ~0x4U;
+			cortex_a->cp15_control_reg_curr &= ~0x4U;
 			/* flush data cache armv7 function to be called */
 			if (armv7a->armv7a_mmu.armv7a_cache.flush_all_data_cache)
 				armv7a->armv7a_mmu.armv7a_cache.flush_all_data_cache(target);
 		}
-		if ((cortex_a53->cp15_control_reg_curr & 0x1U)) {
-			cortex_a53->cp15_control_reg_curr &= ~0x1U;
-			retval = armv7a->arm.mcr(target, 15,
+		if ((cortex_a->cp15_control_reg_curr & 0x1U)) {
+			cortex_a->cp15_control_reg_curr &= ~0x1U;
+			retval = arm->mcr(target, 15,
 					0, 0,	/* op1, op2 */
 					1, 0,	/* CRn, CRm */
-					cortex_a53->cp15_control_reg_curr);
+					cortex_a->cp15_control_reg_curr);
 		}
 	}
 	return retval;
@@ -213,8 +412,6 @@ static int cortex_a53_mmu_modify(struct target *target, int enable)
  */
 static int cortex_a53_init_debug_access(struct target *target)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	int retval;
 	uint32_t dummy;
 
@@ -230,45 +427,45 @@ static int cortex_a53_init_debug_access(struct target *target)
 	Later, just set CTIAPPPULSE[chan]=1 to trigger.
 	For restart, it is similar but using CTIINEN1 and CTIOUTEN1.
 	*/
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTICONTROL, 1);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIGATE, &dummy);
+	retval = target_cs_cti_wr32( target, CTICONTROL, 1);
+	retval = target_cs_cti_rd32( target, CTIGATE, &dummy);
 	dummy |= (1<<CTIDBGCHAN_HALT)|(1<<CTIDBGCHAN_RESTART);
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIGATE, dummy);
+	retval = target_cs_cti_wr32( target, CTIGATE, dummy);
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINEN(0), &dummy);
+	retval = target_cs_cti_rd32( target, CTIINENn(0), &dummy);
 	dummy |= 1<<CTIDBGCHAN_HALT;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINEN(0), dummy);
+	retval = target_cs_cti_wr32( target, CTIINENn(0), dummy);
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIOUTEN(0), &dummy);
+	retval = target_cs_cti_rd32( target, CTIOUTENn(0), &dummy);
 	dummy |= 1<<CTIDBGCHAN_HALT;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIOUTEN(0), dummy);
+	retval = target_cs_cti_wr32( target, CTIOUTENn(0), dummy);
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINEN(1), &dummy);
+	retval = target_cs_cti_rd32( target, CTIINENn(1), &dummy);
 	dummy |= 1<<CTIDBGCHAN_RESTART;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINEN(1), dummy);
+	retval = target_cs_cti_wr32( target, CTIINENn(1), dummy);
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIOUTEN(1), &dummy);
+	retval = target_cs_cti_rd32( target, CTIOUTENn(1), &dummy);
 	dummy |= 1<<CTIDBGCHAN_RESTART;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIOUTEN(1), dummy);
+	retval = target_cs_cti_wr32( target, CTIOUTENn(1), dummy);
 
+	/* read this to determine state */
+	armv8_dbg_rd_EDPRSR( target, &dummy );
+	
 	//set EDECCR for catching exception
 	/*dummy = 8; //2;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECCR, dummy);*/
+	retval = target_cs_dbg_wr32( target, EDECCR, dummy);*/
 
 	//set HDE(bit14) for enable BP, WP and Halt Instruction
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + EDSCR, &dummy);
-	dummy |= 1 << 14; //set HDE to enable halt
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + EDSCR, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + EDSCR, &dummy);
-	LOG_DEBUG("Read %d EDSCR after set HDE 0x%08" PRIx32, retval, dummy);
+	LOG_DEBUG("armv8: Enable HDE");
+	retval = armv8_dbg_rd_EDSCR( target, &dummy );
+	dummy |= (1 << 14); //set HDE to enable halt
+	retval = armv8_dbg_wr_EDSCR( target, dummy);
+	retval = armv8_dbg_rd_EDSCR( target, &dummy );
+	armv8_dbg_ClearStickyErrors( target );
 
 	/* Strong Qu: Write 0 to DBGOSLAR(OS Lock Access Register, FC33_0300) */
 	LOG_DEBUG("Clear DBGOSLAR.");
-    retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_OSLAR, 0);
+    retval = armv8_dbg_wr_OSLAR_EL1( target, 0);
 	if (retval != ERROR_OK)
     {
 		LOG_ERROR("Failed to clear DBGOSLAR.");
@@ -277,22 +474,19 @@ static int cortex_a53_init_debug_access(struct target *target)
 
 	/* Unlocking the debug registers for modification
 	 * The debugport might be uninitialised so try twice */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+	retval = target_cs_dbg_wr32( target, CPUDBG_LOCKACCESS, 0xC5ACCE55);
 	if (retval != ERROR_OK) {
 		/* try again */
-		retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_LOCKACCESS, 0xC5ACCE55);
+		retval = target_cs_dbg_wr32( target, CPUDBG_LOCKACCESS, 0xC5ACCE55);
 		if (retval == ERROR_OK)
-			LOG_USER(
+			LOG_DEBUG(
 				"Locking debug access failed on first, but succeeded on second try.");
 	}
 	if (retval != ERROR_OK)
 		return retval;
 	/* Clear Sticky Power Down status Bit in PRSR to enable access to
 	   the registers in the Core Power Domain */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_PRSR, &dummy);
+	retval = armv8_dbg_rd_EDPRSR( target, &dummy);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -314,18 +508,17 @@ static int cortex_a53_exec_opcode(struct target *target,
 {
 	uint32_t dscr;
 	int retval;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
 
 	//SQU: why not just read it? dscr = dscr_p ? *dscr_p : 0;
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
-	LOG_DEBUG("exec opcode=0x%08X as AArch64=%d (dscr=0x%08X)", opcode, isAArch64(dscr), dscr);
+	LOG_DEBUG("armv8 exec opcode: 0x%08" PRIx32, opcode );
+	retval = armv8_dbg_rd_EDSCR( target, &dscr );
+	LOG_DEBUG("AArch64=%d (dscr=0x%08X)", isAArch64(dscr), dscr);
 
 	/* Wait for InstrCompl bit to be set */
 	long long then = timeval_ms();
 	while ((dscr & DSCR_INSTR_COMP) == 0) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		LOG_DEBUG("armv8-exec-opcode-poll(1)");
+		retval = armv8_dbg_rd_EDSCR( target, &dscr );
 		if (retval != ERROR_OK) {
 			LOG_ERROR("Could not read DSCR register, opcode = 0x%08" PRIx32, opcode);
 			return retval;
@@ -339,36 +532,36 @@ static int cortex_a53_exec_opcode(struct target *target,
     //override opcode. SQU TODO: instead of hack here, might need to change to caller to use right opcode for right state
 	if(opcode==0xE12FF000)
 	{//in case of ARMV4_5_MSR(0, 0) for setting CPSR
-		//LOG_USER("SQU: ARMv8: set CPSR");
+		//LOG_DEBUG("SQU: ARMv8: set CPSR");
 		if(isAArch64(dscr)) opcode=ARMV8_A64_MSR(3, 3, 4, 5, 0, 0); //MSR DSPSR_EL0, R0
         else opcode=ARMV8_T32_MCR(15, 3, 0, 4, 5, 0);
 	}
 	else if(opcode==0xE1A0F000)
 	{//in case of MOV pc, r0
-		//LOG_USER("SQU: ARMv8: set pc ");
+		//LOG_DEBUG("SQU: ARMv8: set pc ");
         if(isAArch64(dscr)) opcode=ARMV8_A64_MSR(3, 3, 4, 5, 1, 0); //MSR DLR_EL0, R0
         else opcode=ARMV8_T32_MCR(15, 3, 0, 4, 5, 1);
 	}
 	else if(opcode==0xE10F0000)
 	{//in case of ARMV4_5_MRS(0, 0) for reading CPSR
-		//LOG_USER("SQU: ARMv8: read CPSR");
+		//LOG_DEBUG("SQU: ARMv8: read CPSR");
 		if(isAArch64(dscr)) opcode=ARMV8_A64_MRS(3, 3, 4, 5, 0, 0); //MRS R0, DSPSR_EL0
         else opcode=ARMV8_T32_MRC(15, 3, 0, 4, 5, 0); //change to read DSPSR
 	}
 	else if(opcode==0xF3F28030)
 	{//in case of MRS r0, spsr
-		LOG_USER("ARMv8: read spsr");
+		LOG_DEBUG("ARMv8: read spsr");
         opcode = (opcode>>16) | (opcode<<16);
  	}
 	else if(opcode==0xE1A0000F)
 	{//in case of MOV r0, pc
-		//LOG_USER("SQU: ARMv8: read pc");
+		//LOG_DEBUG("SQU: ARMv8: read pc");
         if(isAArch64(dscr)) opcode=ARMV8_A64_MRS(3, 3, 4, 5, 1, 0); //MRS R0, DLR_EL0
         else opcode=ARMV8_T32_MRC(15, 3, 0, 4, 5, 1); //change to read DLR
  	}
     else if((opcode&0xFF000000)==0xEE000000) //MRC/MCR
     {
-        //LOG_USER("SQU: MCR/MRC L=%d cp=%d op1=%d CRn=%d CRm=%d op2=%d Rt=%d", (opcode&0x100000)>>20, (opcode&0xF00)>>8, (opcode&0xE00000)>>21, (opcode&0xF0000)>>16, opcode&0xF,(opcode&0xE0)>>5,(opcode&0xF000)>>12);
+        //LOG_DEBUG("SQU: MCR/MRC L=%d cp=%d op1=%d CRn=%d CRm=%d op2=%d Rt=%d", (opcode&0x100000)>>20, (opcode&0xF00)>>8, (opcode&0xE00000)>>21, (opcode&0xF0000)>>16, opcode&0xF,(opcode&0xE0)>>5,(opcode&0xF000)>>12);
         if(isAArch64(dscr)) //convert MCR/MRC to MSR/MRS
 //    	if(target->is_64b)
         {
@@ -417,15 +610,14 @@ static int cortex_a53_exec_opcode(struct target *target,
     	if(!target->is_64b) LOG_ERROR("SQU: Exec AArch64 opcode=0x%x for AArch32 state", opcode);
     }
 
-	retval = mem_ap_sel_write_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_ITR, opcode);
+	retval = target_cs_dbg_queued_wr32( target, CPUDBG_ITR, opcode);
 	if (retval != ERROR_OK)
 		return retval;
 
 	then = timeval_ms();
 	do {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		LOG_DEBUG("armv8-exec-opcode-poll(2)");
+		retval = armv8_dbg_rd_EDSCR( target, &dscr );
 		if (retval != ERROR_OK) {
 			LOG_ERROR("Could not read DSCR register");
 			return retval;
@@ -439,7 +631,7 @@ static int cortex_a53_exec_opcode(struct target *target,
 	{
 		LOG_ERROR("Err set for opcode = 0x%x, with DSCR=0x%x", opcode, dscr);
 		//clear the error
-		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDRCR, 1<<2); //set EDRCR.CSE to clear EDSCR.ERR
+		target_cs_dbg_queued_wr32( target, EDRCR, 1<<2); //set EDRCR.CSE to clear EDSCR.ERR
 	}
 	if (dscr_p)
 		*dscr_p = dscr;
@@ -448,20 +640,6 @@ static int cortex_a53_exec_opcode(struct target *target,
 }
 
 
-/* Write to memory mapped registers directly with no cache or mmu handling */
-static int cortex_a53_dap_write_memap_register_u32(struct target *target,
-	uint32_t address,
-	uint32_t value)
-{
-	int retval;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, address, value);
-
-	return retval;
-}
-
 /*
  * Cortex-A8 implementation of Debug Programmer's Model
  *
@@ -473,29 +651,26 @@ static int cortex_a53_dap_write_memap_register_u32(struct target *target,
  * be the places to enable/disable that mode.
  */
 
-static inline struct cortex_a_common *dpm_to_a(struct arm_dpm *dpm)
-{
-	return container_of(dpm, struct cortex_a_common, armv7a_common.dpm);
-}
 
-static int cortex_a53_write_dcc(struct cortex_a_common *a, uint64_t data)
+static int cortex_a53_write_dcc(struct armv8 *armv8, uint64_t data)
 {
+	struct cortex_a_common *cortex_a = armv8_to_cortex_a(armv8);
+	struct target *target = armv8_to_target(armv8);
+
 	LOG_DEBUG("write DCC 0x%" PRIx64, data);
-	if(isAArch64(a->cpudbg_dscr))
+	if(isAArch64(cortex_a->cpudbg_dscr))
 	{
-		mem_ap_sel_write_u32(a->armv7a_common.arm.dap,
-			a->armv7a_common.debug_ap, a->armv7a_common.debug_base + CPUDBG_DTRTX, data>>32);
+		target_cs_dbg_queued_wr32( target, CPUDBG_DTRTX, data>>32);
 	}
-	return mem_ap_sel_write_u32(a->armv7a_common.arm.dap,
-		a->armv7a_common.debug_ap, a->armv7a_common.debug_base + CPUDBG_DTRRX, (uint32_t)data);
+	return target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, (uint32_t)data);
 }
 
-static int cortex_a53_read_dcc(struct cortex_a_common *a, uint64_t *data,
+static int cortex_a53_read_dcc(struct target *target, uint64_t *data,
 	uint32_t *dscr_p)
 {
-	struct adiv5_dap *swjdp = a->armv7a_common.arm.dap;
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
+	int n;
 	uint32_t *pdw=(uint32_t*)data;
 
 	if (dscr_p)
@@ -503,10 +678,13 @@ static int cortex_a53_read_dcc(struct cortex_a_common *a, uint64_t *data,
 
 	/* Wait for DTRRXfull */
 	long long then = timeval_ms();
+	n = 0;
 	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, a->armv7a_common.debug_ap,
-				a->armv7a_common.debug_base + CPUDBG_DSCR,
-				&dscr);
+		if( n ){
+			LOG_DEBUG("armv8-read-dcc-poll");
+		}
+		n=1;
+		retval = armv8_dbg_rd_EDSCR( target, &dscr );
 		if (retval != ERROR_OK)
 			return retval;
 		if (timeval_ms() > then + 1000) {
@@ -515,15 +693,15 @@ static int cortex_a53_read_dcc(struct cortex_a_common *a, uint64_t *data,
 		}
 	}
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, a->armv7a_common.debug_ap,
-			a->armv7a_common.debug_base + CPUDBG_DTRTX, pdw);
+	retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, pdw);
 	if (retval != ERROR_OK)
 		return retval;
+	
 	if(isAArch64(dscr))
 	{
-		mem_ap_sel_read_atomic_u32(swjdp, a->armv7a_common.debug_ap,
-			a->armv7a_common.debug_base + CPUDBG_DTRRX, pdw+1); //DTRRX holds high dword for 64bit data
-	} else *(pdw+1)=0;
+		target_cs_dbg_rd32( target, CPUDBG_DTRRX, pdw+1); //DTRRX holds high dword for 64bit data
+	} else
+		*(pdw+1)=0;
 	/* LOG_DEBUG("read DCC 0x%08" PRIx32, *data); */
 
 	if (dscr_p)
@@ -534,17 +712,14 @@ static int cortex_a53_read_dcc(struct cortex_a_common *a, uint64_t *data,
 
 static int cortex_a53_dpm_prepare(struct arm_dpm *dpm)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
-	struct adiv5_dap *swjdp = a->armv7a_common.arm.dap;
+	struct target		*target		= arm_dpm_to_target( dpm );
 	uint32_t dscr;
 	int retval;
 
 	/* set up invariant:  INSTR_COMP is set after every DPM operation */
 	long long then = timeval_ms();
 	for (;; ) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, a->armv7a_common.debug_ap,
-				a->armv7a_common.debug_base + CPUDBG_DSCR,
-				&dscr);
+		retval = armv8_dbg_rd_EDSCR( target, &dscr);
 		if (retval != ERROR_OK)
 			return retval;
 		if ((dscr & DSCR_INSTR_COMP) != 0)
@@ -560,7 +735,7 @@ static int cortex_a53_dpm_prepare(struct arm_dpm *dpm)
 		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
 		/* Clear DCCRX */
 		retval = cortex_a53_exec_opcode(
-				a->armv7a_common.arm.target,
+						target,
 				ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 				&dscr);
 		if (retval != ERROR_OK)
@@ -579,32 +754,32 @@ static int cortex_a53_dpm_finish(struct arm_dpm *dpm)
 static int cortex_a53_instr_execution(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t *data)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
+	struct target		*target		= arm_dpm_to_target( dpm );
 	int retval;
 	uint32_t dscr = DSCR_INSTR_COMP;
 
 	/* the opcode, writing data to DCC */
 	retval = cortex_a53_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			opcode,
 			&dscr);
-	if (retval != ERROR_OK)
-		return retval;
+	return retval;
 }
 
 static int cortex_a53_instr_write_data64_dcc(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t data)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
+	struct target		*target		= arm_dpm_to_target( dpm );
+	struct armv8		*armv8		= target_to_armv8( target );
 	int retval;
 	uint32_t dscr = DSCR_INSTR_COMP;
 
-	retval = cortex_a53_write_dcc(a, data);
+	retval = cortex_a53_write_dcc(armv8, data);
 	if (retval != ERROR_OK)
 		return retval;
 
 	return cortex_a53_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			opcode,
 			&dscr);
 }
@@ -618,18 +793,19 @@ static int cortex_a53_instr_write_data_dcc(struct arm_dpm *dpm,
 static int cortex_a53_instr_write_data64_r0_mrs(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t data)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
+	struct target		*target		= arm_dpm_to_target( dpm );
+	struct armv8		*armv8		= target_to_armv8( target );
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
-	retval = cortex_a53_write_dcc(a, data);
+	retval = cortex_a53_write_dcc(armv8, data);
 	if (retval != ERROR_OK)
 		return retval;
 
 		
 		/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15 */
 	retval = cortex_a53_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			ARMV8_A64_MRS(2, 3, 0, 5, 0, 0),
 			&dscr);
 	if (retval != ERROR_OK)
@@ -637,7 +813,7 @@ static int cortex_a53_instr_write_data64_r0_mrs(struct arm_dpm *dpm,
 
 	/* then the opcode, taking data from R0 */
 	retval = cortex_a53_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			opcode,
 			&dscr);
 
@@ -648,17 +824,18 @@ static int cortex_a53_instr_write_data64_r0_mrs(struct arm_dpm *dpm,
 static int cortex_a53_instr_write_data64_r0(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t data)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
+	struct target		*target		= arm_dpm_to_target( dpm );
+	struct armv8		*armv8		= target_to_armv8( target );
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
-	retval = cortex_a53_write_dcc(a, data);
+	retval = cortex_a53_write_dcc(armv8, data);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15 */
 	retval = cortex_a53_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 			&dscr);
 	if (retval != ERROR_OK)
@@ -666,7 +843,7 @@ static int cortex_a53_instr_write_data64_r0(struct arm_dpm *dpm,
 
 	/* then the opcode, taking data from R0 */
 	retval = cortex_a53_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			opcode,
 			&dscr);
 
@@ -681,7 +858,7 @@ static int cortex_a53_instr_write_data_r0(struct arm_dpm *dpm,
 
 static int cortex_a53_instr_cpsr_sync(struct arm_dpm *dpm)
 {
-	struct target *target = dpm->arm->target;
+	struct target *target = arm_dpm_to_target(dpm);
 	uint32_t dscr = DSCR_INSTR_COMP;
 
 	/* "Prefetch flush" after modifying execution status in CPSR */
@@ -693,19 +870,19 @@ static int cortex_a53_instr_cpsr_sync(struct arm_dpm *dpm)
 static int cortex_a53_instr_read_data64_dcc(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t *data)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
-	int retval;
+	struct target		*target   = arm_dpm_to_target( dpm );
+ 	int retval;
 	uint32_t dscr = DSCR_INSTR_COMP;
 
 	/* the opcode, writing data to DCC */
 	retval = cortex_a53_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			opcode,
 			&dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
-	return cortex_a53_read_dcc(a, data, &dscr);
+	return cortex_a53_read_dcc(target, data, &dscr);
 }
 
 static int cortex_a53_instr_read_data_dcc(struct arm_dpm *dpm,
@@ -720,14 +897,14 @@ static int cortex_a53_instr_read_data_dcc(struct arm_dpm *dpm,
 static int cortex_a53_instr_read_data64_r0_msr(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t *data)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
+	struct target		*target		= arm_dpm_to_target(dpm);
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
-    uint64_t tmp;
+	uint64_t tmp;
 
 		/* the opcode, writing data to R0 */
 	retval = cortex_a53_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			opcode,
 			&dscr);
 	if (retval != ERROR_OK)
@@ -735,13 +912,13 @@ static int cortex_a53_instr_read_data64_r0_msr(struct arm_dpm *dpm,
 
 	/* write R0 to DCC */
 	retval = cortex_a53_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			ARMV8_A64_MSR(2, 3, 0, 5, 0, 0),
 			&dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
-    retval = cortex_a53_read_dcc(a, &tmp, &dscr);
+    retval = cortex_a53_read_dcc(target, &tmp, &dscr);
 
     *data=tmp;
 	return retval;
@@ -750,14 +927,16 @@ static int cortex_a53_instr_read_data64_r0_msr(struct arm_dpm *dpm,
 static int cortex_a53_instr_read_data64_r0(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t *data)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
+	struct target		*target		= arm_dpm_to_target( dpm );
+	struct armv8		*armv8		= target_to_armv8(target);
+	struct arm              *arm            = armv8_to_arm(armv8);
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
-    uint64_t tmp;
+	uint64_t tmp;
 
 	/* the opcode, writing data to R0 */
 	retval = cortex_a53_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			opcode,
 			&dscr);
 	if (retval != ERROR_OK)
@@ -765,17 +944,17 @@ static int cortex_a53_instr_read_data64_r0(struct arm_dpm *dpm,
 
 	/* write R0 to DCC */
 	retval = cortex_a53_exec_opcode(
-			a->armv7a_common.arm.target,
+			target,
 			ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
 			&dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
-    retval = cortex_a53_read_dcc(a, &tmp, &dscr);
+    retval = cortex_a53_read_dcc(target, &tmp, &dscr);
     if(opcode==0xE1A0000F)
 	{//in case of MOV r0, pc
 		LOG_DEBUG("SQU: ARMv8: read pc= 0x%" PRIx64, tmp);
-		if(dpm->arm->core_state==ARM_STATE_ARM) //SQU: adjust PC to make OOCD happy, because of hack in arm_dpm.c::dpm_read_reg
+		if(arm->core_state==ARM_STATE_ARM) //SQU: adjust PC to make OOCD happy, because of hack in arm_dpm.c::dpm_read_reg
 		{
 			tmp += 8;
 		}
@@ -795,77 +974,46 @@ static int cortex_a53_instr_read_data_r0(struct arm_dpm *dpm,
 	return result;
 }
 
-static int cortex_a53_bpwp_enable(struct arm_dpm *dpm, unsigned index_t,
-	const struct target_addr *pAddr, uint32_t control)
+static int cortex_a53_bpwp_enable(struct arm_dpm *dpm, unsigned idx,
+	uint64_t addr, uint32_t control)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
-	uint64_t vr = a->armv7a_common.debug_base;
-	uint64_t cr = a->armv7a_common.debug_base;
-	int retval;
+	struct target *target = arm_dpm_to_target(dpm);
+	struct armv8		*armv8		= target_to_armv8(target);
+	struct cortex_a_brp b;
 
-	switch (index_t) {
-		case 0 ... 15:	/* breakpoints */
-			vr += CPUDBG_BVR_EL1_BASE;
-			cr += CPUDBG_BCR_EL1_BASE;
-			break;
-		case 16 ... 31:	/* watchpoints */
-			vr += CPUDBG_WVR_EL1_BASE;
-			cr += CPUDBG_WCR_EL1_BASE;
-			index_t -= 16;
-			break;
-		default:
-			return ERROR_FAIL;
-	}
-	vr += index_t<<4;
-	cr += index_t<<4;
+	memset( &b, 0, sizeof(b) );
 
-	LOG_DEBUG("A8: bpwp enable, vr %08x cr %08x",
-		(unsigned) vr, (unsigned) cr);
+	b.control = control;
+	b.value   = addr;
+	b.BRPn = idx;
 
-	retval = cortex_a53_dap_write_memap_register_u32(dpm->arm->target,
-			vr, pAddr->addr);
-	if (retval != ERROR_OK)
-		return retval;
-    //SQU: assume the addr is 32 bits for now. TODO: fix it
-	retval = cortex_a53_dap_write_memap_register_u32(dpm->arm->target,
-			vr+4, 0);
-	retval = cortex_a53_dap_write_memap_register_u32(dpm->arm->target,
-			cr, control);
-	return retval;
+	return armv8_dbg_wr_bpwp_regs( armv8, &b );
 }
 
-static int cortex_a53_bpwp_disable(struct arm_dpm *dpm, unsigned index_t)
+
+static int cortex_a53_bpwp_disable(struct arm_dpm *dpm, unsigned idx)
 {
-	struct cortex_a_common *a = dpm_to_a(dpm);
-	uint32_t cr;
+	struct cortex_a_brp b;	
+	struct target *target        = arm_dpm_to_target(dpm);
+	struct armv8  *armv8         = target_to_armv8(target);
 
-	switch (index_t) {
-		case 0 ... 15:
-			cr = a->armv7a_common.debug_base + CPUDBG_BCR_EL1_BASE;
-			break;
-		case 16 ... 31:
-			cr = a->armv7a_common.debug_base + CPUDBG_WCR_EL1_BASE;
-			index_t -= 16;
-			break;
-		default:
-			return ERROR_FAIL;
-	}
-	cr += index_t<<4;
+	memset( &b, 0, sizeof(b) );
 
-	LOG_DEBUG("A8: bpwp disable, cr %08x", (unsigned) cr);
+	b.control = 0;
+	b.value   = 0;
+	b.BRPn    = idx;
 
 	/* clear control register */
-	return cortex_a53_dap_write_memap_register_u32(dpm->arm->target, cr, 0);
+	return armv8_dbg_wr_bpwp_regs( armv8, &b );
 }
 
-static int cortex_a53_dpm_setup(struct armv8_common *armv8,uint32_t dfr0)
+static int cortex_a53_dpm_setup(struct armv8 *armv8,uint32_t dfr0)
 {
-	struct cortex_a_common *a = &armv8->cortex_a_common;
-	struct arm_dpm *dpm = &a->armv7a_common.dpm;
-	struct armv8_dpm *armv8_dpm = &armv8->armv8.armv8_dpm;
+	struct armv8_dpm	*armv8_dpm	= armv8_to_armv8_dpm( armv8 );
+	struct arm_dpm		*dpm            = armv8_to_arm_dpm(armv8);
 	int retval;
 
-	dpm->arm = &a->armv7a_common.arm;
+	dpm->arm = armv8_to_arm(armv8);
 	dpm->didr = (dfr0>>8&0xF00000)|(dfr0<<8&0xF0000000)|(dfr0<<12&0xF000000);
 
 	dpm->prepare = cortex_a53_dpm_prepare;
@@ -881,8 +1029,6 @@ static int cortex_a53_dpm_setup(struct armv8_common *armv8,uint32_t dfr0)
 	dpm->bpwp_enable = cortex_a53_bpwp_enable;
 	dpm->bpwp_disable = cortex_a53_bpwp_disable;
 
-	armv8_dpm->arm_dpm = dpm;
-	armv8_dpm->armv8 = &armv8->armv8;
 	armv8_dpm->instr_write_data64_dcc = cortex_a53_instr_write_data64_dcc;
 	armv8_dpm->instr_write_data64_r0 = cortex_a53_instr_write_data64_r0;
 	armv8_dpm->instr_read_data64_dcc = cortex_a53_instr_read_data64_dcc;
@@ -914,7 +1060,6 @@ static struct target *get_cortex_a53(struct target *target, int32_t coreid)
 	}
 	return target;
 }
-static int cortex_a53_halt(struct target *target);
 
 static int cortex_a53_halt_smp(struct target *target)
 {
@@ -950,12 +1095,12 @@ static int cortex_a53_poll(struct target *target)
 {
 	int retval = ERROR_OK;
 	uint32_t dscr;
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	struct armv8		*armv8		= target_to_armv8( target );
+	struct cortex_a_common	*cortex_a	= armv8_to_cortex_a(armv8);
+	
 	enum target_state prev_target_state = target->state;
 
-    dap_ap_select(swjdp, 1);  //swjdp->apsel=1;
+	//	LOG_DEBUG("armv8-poll target");
 	/*  toggle to another core is done by gdb as follow */
 	/*  maint packet J core_id */
 	/*  continue */
@@ -968,11 +1113,18 @@ static int cortex_a53_poll(struct target *target)
 		target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 		return retval;
 	}
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = armv8_dbg_rd_EDSCR( target, &dscr );
 	if (retval != ERROR_OK)
 		return retval;
-	cortex_a53->cpudbg_dscr = dscr;
+
+	/* if HDE bit is not set */
+	if( !armv8_edscr_get_HDE( dscr ) ){
+		/* Debug state is not configured */
+		/* maybe we have a "late attach" */
+		cortex_a53_init_debug_access(target);
+	}
+	
+	cortex_a->cpudbg_dscr = dscr;
 
 	if (DSCR_RUN_MODE(dscr) == (DSCR_CORE_HALTED | DSCR_CORE_RESTARTED)) {
 
@@ -1030,27 +1182,24 @@ static int cortex_a53_poll(struct target *target)
 static int cortex_a53_halt(struct target *target)
 {
 	int retval = ERROR_OK;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	uint32_t dummy;
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-					armv7a->debug_base + EDSCR, &dummy);
-	LOG_USER("Before halt EDSCR = 0x%08" PRIx32, dummy);
-	/*retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDPRSR, &dummy);
-	LOG_USER("And EDPRSR = 0x%08" PRIx32, dummy);
+	LOG_DEBUG("armv8-halt");
+	retval = armv8_dbg_rd_EDSCR( target, &dummy);
+	/*retval = target_cs_dbg_rd32( target, EDPRSR, &dummy);
+	LOG_DEBUG("And EDPRSR = 0x%08" PRIx32, dummy);
 	cortex_a53_dbg_dump(target);
 	cortex_a53_cti_dump(target);
-	LOG_USER("\n Now set CTIAPPULSE to request halt");*/
+	LOG_DEBUG("\n Now set CTIAPPULSE to request halt");*/
 
 	/*
 	 * Tell the core to be halted by set CTIAPPPULSE with right channel to trigger.
 	 * SS of EDECR and EDESR are for single step.
 	 * For ARMv7 it used to be setting 1 to CPUDBG_DRCR and read CPUDBG_DSCR
 	 */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIAPPPULSE, 1<<CTIDBGCHAN_HALT); //trigger dbg req evt
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDSCR, &dummy);
-	LOG_USER("After CTI triggered: %d EDSCR 0x%08" PRIx32, retval, dummy);
+	retval = armv8_cti_wr_HALT( target ); //trigger dbg req evt
+	retval = armv8_dbg_rd_EDSCR( target, &dummy);
+	LOG_DEBUG("After CTI triggered: %d EDSCR 0x%08" PRIx32, retval, dummy);
 	//cortex_a53_cti_dump(target);
 
 	/*
@@ -1059,9 +1208,10 @@ static int cortex_a53_halt(struct target *target)
 
 	long long then = timeval_ms();
 	for (;; ) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDPRSR, &dummy);
+		retval = armv8_dbg_rd_EDPRSR( target, &dummy);
 		if (retval != ERROR_OK)
 			return retval;
+		/* Look for halted bit */
 		if ((dummy & 0x10) == 0x10)
 			break;
 		if (timeval_ms() > then + 1000) {
@@ -1070,10 +1220,9 @@ static int cortex_a53_halt(struct target *target)
 			return ERROR_FAIL;
 		}
 	}
-	//LOG_USER("Halt success with EDPRSR = 0x%08" PRIx32, dummy);
+	//LOG_DEBUG("Halt success with EDPRSR = 0x%08" PRIx32, dummy);
 	//check DLR_EL0 and DSPSR_EL0
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDSCR, &dummy);
-	LOG_USER(" EDSCR = 0x%08" PRIx32, dummy);
+	retval = armv8_dbg_rd_EDSCR( target, &dummy);
 	if(isAArch64(dummy))
 	{
 		target->is_64b=true;
@@ -1089,114 +1238,114 @@ static int cortex_a53_halt(struct target *target)
 	{
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 1, 1, 0, 0), &dummy); //read SCR_EL3 to X0
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
-		LOG_USER("Running in AArch64. SCR_EL3=0x%x",dummy);
-//		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x400);//SCR:RW=0,NS=1
-		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
+		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
+		LOG_DEBUG("Running in AArch64. SCR_EL3=0x%x",dummy);
+//		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x400);//SCR:RW=0,NS=1
+		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 6, 1, 1, 0, 0), &dummy); //SCR_EL3=X0
 
 		      cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 4, 1, 1, 0, 0), &dummy); //read HCR_EL2 to X0
               cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-              retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
-              LOG_USER("Running in AArch64. HCR_EL2=0x%x",dummy);
-/*              mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
+              retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
+              LOG_DEBUG("Running in AArch64. HCR_EL2=0x%x",dummy);
+/*              target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
               cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
               cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 4, 1, 1, 0, 0), &dummy); //HCR_EL2=X0
 */
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 12, 0, 2, 0), &dummy);    // MRS RMR_EL3, R0
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
-		LOG_USER("Read RMR_EL# before DRPS = 0x%x", dummy);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
+		LOG_DEBUG("Read RMR_EL# before DRPS = 0x%x", dummy);
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 3, 4, 5, 0, 0), &dummy);    // MRS DSPSR_EL0, R0
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
-		LOG_USER("Read DSPSR_EL0 before DRPS = 0x%x", dummy);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
+		LOG_DEBUG("Read DSPSR_EL0 before DRPS = 0x%x", dummy);
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 3, 4, 5, 1, 0), &dummy);     // MRS DLR_EL0, R0, mov pc?
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
 
-		LOG_USER("Read DLR_EL0 before DRPS = 0x%x", dummy);
+		LOG_DEBUG("Read DLR_EL0 before DRPS = 0x%x", dummy);
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 0, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL1, R0, mov pc?
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
 
-		LOG_USER("Read SPSR_EL1 before DRPS = 0x%x", dummy);
+		LOG_DEBUG("Read SPSR_EL1 before DRPS = 0x%x", dummy);
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 4, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL2, R0, mov pc?
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
 
-		LOG_USER("Read SPSR_EL2 before DRPS = 0x%x", dummy);
+		LOG_DEBUG("Read SPSR_EL2 before DRPS = 0x%x", dummy);
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL3, R0, mov pc?
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
 
-		LOG_USER("Read SPSR_EL3 before DRPS = 0x%x", dummy);
+		LOG_DEBUG("Read SPSR_EL3 before DRPS = 0x%x", dummy);
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL3, R0, mov pc?
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
 
-		LOG_USER("Read SPSR_EL3 before DRPS = 0x%x", dummy);
+		LOG_DEBUG("Read SPSR_EL3 before DRPS = 0x%x", dummy);
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 0, 0, 2, 2, 0), &dummy);     // MRS MDSCR_EL1, R0, mov pc?
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
 
-		LOG_USER("Read MDSCR_EL1 before DRPS = 0x%x", dummy);
+		LOG_DEBUG("Read MDSCR_EL1 before DRPS = 0x%x", dummy);
 		// write forever loop into the memory 0xFE800000
 		//dummy = 0xEAFFFFFE;
         //retval = cortex_a53_write_phys_memory(target, 0xFE800000, 4, 1, &dummy);
 
 		// write spsr_el3 
-		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, 0);
-//		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x1c5);//0,
-		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x1d1);//0, for EL1 ARCH32 bits.
+		target_cs_dbg_queued_wr32( target, CPUDBG_DTRTX, 0);
+//		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x1c5);//0,
+		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x1d1);//0, for EL1 ARCH32 bits.
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 6, 4, 0, 0, 0), &dummy); //SPSR_EL3 ,=X0
 
-		LOG_USER("DRPS");
+		LOG_DEBUG("DRPS");
 		cortex_a53_exec_opcode(target, 0xD6BF03E0, &dummy); //0x8F00F3DE=>ERET 0xD6BF03E0=>DRPS
 
 		// dummy has Arch32, 64 target type information.
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDSCR, &dummy);
-	    LOG_USER("after DRPS, EDSCR = 0x%08" PRIx32, dummy);
+		retval = armv8_dbg_rd_EDSCR( target, &dummy);
+	    LOG_DEBUG("after DRPS, EDSCR = 0x%08" PRIx32, dummy);
 		
 		// set to DSPSR_EL0 to 0x1d0
-		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, 0);
-		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x1D1);
-//		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x1D6); // set to Monitor mode
+		target_cs_dbg_queued_wr32( target, CPUDBG_DTRTX, 0);
+		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x1D1);
+//		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x1D6); // set to Monitor mode
 //		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);    //X0=DTRRX
 //		cortex_a53_exec_opcode(target, ARMV8_T32_MRC(14, 0, 0, 5, 0, 0), &dummy);    //X0=DTRRX
 //		cortex_a53_exec_opcode(target, ARMV8_T32_MCR(15, 3, 0, 4, 5, 0), &dummy);    // MSR DSPSR_EL0, R0
 		cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dummy);    //X0=DTRRX
 		cortex_a53_exec_opcode(target, ARMV4_5_MCR(15, 3, 0, 4, 5, 0), &dummy);    // MSR DSPSR_EL0, R0
 
-	    LOG_USER("Asic ROM base is = 0x%08" PRIx64, target->romcbase);
+	    LOG_DEBUG("Asic ROM base is = 0x%08" PRIx64, target->romcbase);
 		// set to 0xFE800000 as PC
-		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRTX, 0);
-//		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0x100000); //for 8916
-		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, target->romcbase); //0x100084 is for 8916
-//		mem_ap_sel_write_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DTRRX, 0xFE800000);
+		target_cs_dbg_queued_wr32( target, CPUDBG_DTRTX, 0);
+//		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x100000); //for 8916
+		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, target->romcbase); //0x100084 is for 8916
+//		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0xFE800000);
 //		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);     //X0=DTRRX
 //		cortex_a53_exec_opcode(target, ARMV8_T32_MRC(14, 0, 0, 5, 0, 0), &dummy);    //X0=DTRRX / DBGDTRRXint
 //		cortex_a53_exec_opcode(target, ARMV8_T32_MCR(15, 3, 0, 4, 5, 1), &dummy);     // MSR DLR_EL0, R0, mov pc?
 		cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dummy);    //X0=DTRRX / DBGDTRRXint
 		cortex_a53_exec_opcode(target, ARMV4_5_MCR(15, 3, 0, 4, 5, 1), &dummy);     // MSR DLR_EL0, R0, mov pc?
-	    retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDSCR, &dummy);
-	    LOG_USER("after DRPS, EDSCR = 0x%08" PRIx32, dummy);
+	    retval = armv8_dbg_rd_EDSCR( target, &dummy);
+	    LOG_DEBUG("after DRPS, EDSCR = 0x%08" PRIx32, dummy);
 
 		//send CTI ACK
-		retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINTACK, 1);
+		retval = target_cs_cti_wr32( target, CTIINTACK, 1);
 		then = timeval_ms();
 		for (;; ) {
-			retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTITRIGOUTSTATUS, &dummy);
+			retval = target_cs_cti_rd32( target, CTITRIGOUTSTATUS, &dummy);
 			if (retval != ERROR_OK) return retval;
 			if ((dummy & 1) == 0) break;
 			if (timeval_ms() > then + 100000) {
@@ -1205,11 +1354,11 @@ static int cortex_a53_halt(struct target *target)
 			}
 		}
 		//resume
-		retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIAPPPULSE, 1<<CTIDBGCHAN_RESTART); //restart
+		retval = armv8_cti_wr_RESTART( target ); //restart
 		if (retval != ERROR_OK) 	return retval;
 		then = timeval_ms();
 		for (;; ) {
-			retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDPRSR, &dummy);
+			retval = armv8_dbg_rd_EDPRSR( target, &dummy);
 			if (retval != ERROR_OK) return retval;
 			if ((dummy & (1<<11)) != 0) break;
 			if (timeval_ms() > then + 1000) {
@@ -1218,9 +1367,9 @@ static int cortex_a53_halt(struct target *target)
 			}
 		}
 
-		retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIAPPPULSE, 1<<CTIDBGCHAN_HALT); //trigger dbg req evt
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDSCR, &dummy);
-		LOG_USER("After My CTI1 triggered: %d EDSCR 0x%08" PRIx32, retval, dummy);
+		retval = armv8_cti_wr_HALT( target ); //trigger dbg req evt
+		retval = armv8_dbg_rd_EDSCR( target, &dummy);
+		LOG_DEBUG("After My CTI1 triggered: %d EDSCR 0x%08" PRIx32, retval, dummy);
 
 		target->is_64b=false;
 		target->type->arch_state=armv7a_arch_state;
@@ -1235,11 +1384,12 @@ static int cortex_a53_halt(struct target *target)
 static int cortex_a53_internal_restore(struct target *target, int current,
 	struct target_addr *pAddr, int handle_breakpoints, int debug_execution)
 {
-	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a);
-	struct armv8 *armv8 = &armv8_common->armv8;
-	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
-	struct arm *arm = &armv7a->arm;
+	struct armv8 *armv8;
+	struct arm   *arm;
+
+	armv8 = target_to_armv8( target );
+	arm   = armv8_to_arm(armv8);
+	
 	int retval;
 
 	if(!target->is_64b)
@@ -1278,7 +1428,7 @@ static int cortex_a53_internal_restore(struct target *target, int current,
 		arm->pc->dirty = 1;
 		arm->pc->valid = 1;
 		/* restore dpm_mode at system halt */
-		dpm_modeswitch(arm->dpm, ARM_MODE_ANY);
+		dpm_modeswitch( arm_to_arm_dpm(arm), ARM_MODE_ANY);
 	}
 	else
 	{
@@ -1320,9 +1470,8 @@ static int cortex_a53_internal_restore(struct target *target, int current,
 
 static int cortex_a53_internal_restart(struct target *target)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *arm = &armv7a->arm;
-	struct adiv5_dap *swjdp = arm->dap;
+	struct armv8 *armv8 = target_to_armv8(target);
+	struct arm *arm = armv8_to_arm(armv8);
 	int retval;
 	uint32_t dscr, dummy;
 
@@ -1334,14 +1483,14 @@ static int cortex_a53_internal_restart(struct target *target)
 	 * disable IRQs by default, with optional override...
 	 */
     /* SQU: for ARMv8, need to do acknowledge halt event then trigger restart */
-	/*retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTITRIGOUTSTATUS, &dummy);
-	LOG_USER("SQU Before CTI ACK: DSCR= 0x%x  CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);*/
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIINTACK, 1);
+	/*retval = armv8_dbg_rd_EDSCR( target, &dscr );
+	retval = target_cs_cti_rd32( target, CTITRIGOUTSTATUS, &dummy);
+	LOG_DEBUG("SQU Before CTI ACK: DSCR= 0x%x  CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);*/
+	retval = target_cs_cti_wr32( target, CTIINTACK, 1);
 
 	long long then = timeval_ms();
 	for (;; ) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTITRIGOUTSTATUS, &dummy);
+		retval = armv8_cti_rd_STATUS( target, &dummy );
 		if (retval != ERROR_OK)
 			return retval;
 		if ((dummy & 1) == 0)
@@ -1351,23 +1500,21 @@ static int cortex_a53_internal_restart(struct target *target)
 			return ERROR_FAIL;
 		}
 	}
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = armv8_dbg_rd_EDSCR( target, &dscr );
 	if (retval != ERROR_OK)
 		return retval;
-	//LOG_USER("SQU After CTI ACK: DSCR= 0x%x; CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);
+	//LOG_DEBUG("SQU After CTI ACK: DSCR= 0x%x; CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);
 
 	if ((dscr & DSCR_INSTR_COMP) == 0)
 		LOG_ERROR("DSCR InstrCompl must be set before leaving debug!");
 
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->cti_base + CTIAPPPULSE, 1<<CTIDBGCHAN_RESTART);
+	retval = armv8_cti_wr_RESTART( target );
 	if (retval != ERROR_OK)
 		return retval;
 
 	then = timeval_ms();
 	for (;; ) {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + EDPRSR, &dummy);
+		retval = armv8_dbg_rd_EDPRSR( target, &dummy );
 		if (retval != ERROR_OK)
 			return retval;
 		if ((dummy & (1<<11)) != 0)
@@ -1377,24 +1524,24 @@ static int cortex_a53_internal_restart(struct target *target)
 			return ERROR_FAIL;
 		}
 	}
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDPRSR, &dummy);
-	//LOG_USER("Successfully restart with DSCR= 0x%x EDPRSR= 0x%" PRIx32, dscr, dummy);
+	retval = armv8_dbg_rd_EDSCR( target, &dscr );
+	retval = armv8_dbg_rd_EDPRSR( target, &dummy );
+	//LOG_DEBUG("Successfully restart with DSCR= 0x%x EDPRSR= 0x%" PRIx32, dscr, dummy);
 	//for AArch32: dump DFSR, HSR, DFAR, HDAR, HPFAR
 	//HSR: MRC p15,4,<Rt>,c5,c2,0
-	/*retval = armv7a->arm.mrc(target, 15, 4, 0, 5, 2, &dummy);
-	LOG_USER("HSR= 0x%x", dummy);*/
+	/*retval = arm->mrc(target, 15, 4, 0, 5, 2, &dummy);
+	LOG_DEBUG("HSR= 0x%x", dummy);*/
 	//DFSR: MRC p15,0,<Rt>,c5,c0,0
-	/*retval = armv7a->arm.mrc(target, 15, 0, 0, 5, 0, &dummy);
-	LOG_USER("DFSR= 0x%x", dummy);
-	retval = armv7a->arm.mrc(target, 14, 0, 2, 0, 2, &dummy); //DBGDSCRext
-	LOG_USER("DBGDSCRext= 0x%x", dummy);
-	retval = armv7a->arm.mrc(target, 14, 0, 0, 0, 1, &dummy); //DBGDSCRint
-	LOG_USER("DBGDSCRint= 0x%x", dummy);*/
+	/*retval = arm->mrc(target, 15, 0, 0, 5, 0, &dummy);
+	LOG_DEBUG("DFSR= 0x%x", dummy);
+	retval = arm->mrc(target, 14, 0, 2, 0, 2, &dummy); //DBGDSCRext
+	LOG_DEBUG("DBGDSCRext= 0x%x", dummy);
+	retval = arm->mrc(target, 14, 0, 0, 0, 1, &dummy); //DBGDSCRint
+	LOG_DEBUG("DBGDSCRint= 0x%x", dummy);*/
 
 	//set EDECCR after restart. Might be too late ?!
 	/*dummy = 8;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECCR, dummy);*/
+	retval = target_cs_dbg_wr32( target, EDECCR, dummy);*/
 
 	target->debug_reason = DBG_REASON_NOTHALTED;
 	target->state = TARGET_RUNNING;
@@ -1454,11 +1601,11 @@ static int cortex_a53_resume_64(struct target *target, int current,
 	if (!debug_execution) {
 		target->state = TARGET_RUNNING;
 		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
-		LOG_DEBUG("target resumed at 0x%" PRIx64, addr.addr);
+		LOG_DEBUG("target resumed at %s", target_addr2str1(target, &addr));
 	} else {
 		target->state = TARGET_DEBUG_RUNNING;
 		target_call_event_callbacks(target, TARGET_EVENT_DEBUG_RESUMED);
-		LOG_DEBUG("target debug resumed at 0x%" PRIx64, addr.addr);
+		LOG_DEBUG("target debug resumed at %s", target_addr2str1(target,&addr));
 	}
 
 	return ERROR_OK;
@@ -1467,22 +1614,18 @@ static int cortex_a53_resume_64(struct target *target, int current,
 
 static int cortex_a53_debug_entry(struct target *target)
 {
-	int i;
-	uint32_t regfile[16], cpsr, dscr, dummy;
+	uint32_t cpsr, dscr, dummy;
 	int retval = ERROR_OK;
-	struct working_area *regfile_working_area = NULL;
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-   	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a53);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *arm = &armv7a->arm;
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-	struct reg *reg;
+	struct armv8		*armv8		= target_to_armv8( target );
+	struct cortex_a_common	*cortex_a	= target_to_cortex_a(target);
+	struct armv7a_common	*armv7a		= armv8_to_armv7a( armv8 );
+	struct arm_dpm		*arm_dpm	= armv8_to_arm_dpm( armv8 );
+	struct armv8_dpm	*armv8_dpm	= armv8_to_armv8_dpm( armv8 );
 
-	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a53->cpudbg_dscr);
+	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a->cpudbg_dscr);
 
 	/* REVISIT surely we should not re-read DSCR !! */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = armv8_dbg_rd_EDSCR( target, &dscr );
 	if (retval != ERROR_OK)
 		return retval;
 	/* REVISIT see A8 TRM 12.11.4 steps 2..3 -- make sure that any
@@ -1492,64 +1635,62 @@ static int cortex_a53_debug_entry(struct target *target)
 
 	/*SQU: ARMv8 does not have DSCR_ITR_EN(bit13). Should disable IRQ? Need to revisit*/
 	/*dscr |= 3<<22; //INTdis=b'11
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, dscr);
+	retval = armv8_dbg_wr_EDSCR( target, dscr );
 	if (retval != ERROR_OK) return retval;*/
 
 	/* disable exception. Cannot do it in init as dpm might not ready?
 	MCR p15,0,<Rt>,c1,c3,1 ; Write Rt to SDCR
 	MCR p15,0,<Rt>,c1,c1,1 ; Write Rt to SDER */
-	/*retval = armv7a->arm.mrc(target, 15, 0, 1, 1, 3, &dummy);
-	LOG_USER("SDCR is 0x%x. Will edit it", dummy);
+	/*retval = arm->mrc(target, 15, 0, 1, 1, 3, &dummy);
+	LOG_DEBUG("SDCR is 0x%x. Will edit it", dummy);
 	dummy |= 0x8000;
 	dummy &= 0xFFFFDFFF;
-	retval = armv7a->arm.mcr(target, 15, 0, 1, 1, 3, dummy);
-	retval = armv7a->arm.mrc(target, 15, 0, 1, 1, 1, &dummy);
-	LOG_USER("SDER is 0x%x. Will edit it", dummy);
+	retval = arm->mcr(target, 15, 0, 1, 1, 3, dummy);
+	retval = arm->mrc(target, 15, 0, 1, 1, 1, &dummy);
+	LOG_DEBUG("SDER is 0x%x. Will edit it", dummy);
 	dummy=0;
-	retval = armv7a->arm.mcr(target, 15, 0, 1, 1, 1, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);*/
-	/*retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECCR, &dummy);
+	retval = arm->mcr(target, 15, 0, 1, 1, 1, dummy);
+	retval = armv8_dbg_rd_EDSCR( target, &dscr );*/
+	/*retval = target_cs_dbg_rd32( target, EDECCR, &dummy);
 	LOG_DEBUG("DSCR= 0x%x  EDECCR=0x%x => reset", dscr, dummy);
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECCR, 0);*/
+	retval = target_cs_dbg_wr32( target, EDECCR, 0);*/
 	/*dummy=0x11223344;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + DBGDTRTX_EL0, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_wr32( target, DBGDTRTX_EL0, dummy);
+	retval = armv8_dbg_rd_EDSCR( target, &dscr );
 	dummy = 0;
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + DBGDTRTX_EL0, &dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);*/
+	retval = target_cs_dbg_rd32( target, DBGDTRTX_EL0, &dummy);
+	retval = armv8_dbg_rd_EDSCR( target, &dscr );*/
 
 	/*dummy=0x5A5A55AA;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + DBGDTRRX_EL0, dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_wr32( target, DBGDTRRX_EL0, dummy);
+	retval = armv8_dbg_rd_EDSCR( target, &dscr );
 	dummy = 0;
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + DBGDTRRX_EL0, &dummy);
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DSCR, &dscr);*/
-	mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDPRSR, &dummy);
+	retval = target_cs_dbg_rd32( target, DBGDTRRX_EL0, &dummy);
+	retval = armv8_dbg_rd_EDSCR( target, &dscr );*/
+	armv8_dbg_rd_EDPRSR( target, &dummy );
 
 	/* Examine debug reason */
-	armv8_dpm_report_dscr(&armv7a->dpm, cortex_a53->cpudbg_dscr);
+	armv8_dpm_report_dscr(arm_dpm, cortex_a->cpudbg_dscr);
 	/* save address of instruction that triggered the watchpoint? */
 	if (target->debug_reason == DBG_REASON_WATCHPOINT) {
 		struct target_addr wfar;
 		uint32_t regval;
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_WFAR,
-				&regval);
+		retval = target_cs_dbg_rd32( target, CPUDBG_WFAR, &regval);
 		if (retval != ERROR_OK)
 			return retval;
 		
 		TARGET_ADDR_INIT( &wfar, regval );
-		armv8_dpm_report_wfar(&armv7a->dpm, wfar.addr);
+		armv8_dpm_report_wfar( arm_dpm, wfar.addr);
 	}
 
 	/* REVISIT fast_reg_read is never set in original cortex_a code. And many changes needed for support. So just take the code out */
 
 	/* Examine target state and mode */
-	/*if (cortex_a53->fast_reg_read)
+	/*if (cortex_a->fast_reg_read)
 		target_alloc_working_area(target, 64, &regfile_working_area);*/
 
 	/* First load register acessible through core debug port*/
-	retval = armv8_dpm_read_current_registers(&armv8->armv8.armv8_dpm);
+	retval = armv8_dpm_read_current_registers( armv8_dpm );
 	/* Are we in an exception handler */
 	if (armv7a->post_debug_entry) {
 		retval = armv7a->post_debug_entry(target);
@@ -1562,29 +1703,31 @@ static int cortex_a53_debug_entry(struct target *target)
 
 static int cortex_a53_post_debug_entry(struct target *target)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
+	struct armv8		*armv8		= target_to_armv8(target);
+	struct cortex_a_common	*cortex_a	= armv8_to_cortex_a(armv8);
+	struct armv7a_common	*armv7a		= armv8_to_armv7a(armv8);
+	struct arm              *arm            = armv8_to_arm(armv8);
 	int retval;
 
 	/* MRC p15,0,<Rt>,c1,c0,0 ; Read CP15 System Control Register */
-	retval = armv7a->arm.mrc(target, 15,
+	retval = arm->mrc(target, 15,
 		0, 0,	/* op1, op2 */
 		1, 0,	/* CRn, CRm */
-		&cortex_a53->cp15_control_reg);
+		&cortex_a->cp15_control_reg);
 	if (retval != ERROR_OK)
 		return retval;
 
-	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32, cortex_a53->cp15_control_reg);
-	if(cortex_a53->cp15_control_reg & 0x1U)
+	LOG_DEBUG("cp15_control_reg: %8.8" PRIx32, cortex_a->cp15_control_reg);
+	if(cortex_a->cp15_control_reg & 0x1U)
 	{//SQU: disable MMU and D/I cache by set SCTLR. TODO: revisit later
-		//retval = armv7a->arm.mcr(target, 15, 0, 0, 1, 0, cortex_a53->cp15_control_reg&0xFFFFEFFA);
-		retval = armv7a->arm.mcr(target, 15, 0, 0, 1, 0, 0xC55878); //SQU: this is T32 setting
-		retval = armv7a->arm.mrc(target, 15, 0, 0, 1, 0, &cortex_a53->cp15_control_reg);
+		//retval = arm->mcr(target, 15, 0, 0, 1, 0, cortex_a->cp15_control_reg&0xFFFFEFFA);
+		retval = arm->mcr(target, 15, 0, 0, 1, 0, 0xC55878); //SQU: this is T32 setting
+		retval = arm->mrc(target, 15, 0, 0, 1, 0, &cortex_a->cp15_control_reg);
         if (retval != ERROR_OK)
 		    return retval;
-	    LOG_USER("SQU: override to disable cache => SCTLR=0x%x", cortex_a53->cp15_control_reg);
+	    LOG_DEBUG("SQU: override to disable cache => SCTLR=0x%x", cortex_a->cp15_control_reg);
 	}
-	cortex_a53->cp15_control_reg_curr = cortex_a53->cp15_control_reg;
+	cortex_a->cp15_control_reg_curr = cortex_a->cp15_control_reg;
 
 	if (armv7a->armv7a_mmu.armv7a_cache.ctype == -1)
 		armv7a_identify_cache(target);
@@ -1593,13 +1736,13 @@ static int cortex_a53_post_debug_entry(struct target *target)
 		armv7a->armv7a_mmu.mmu_enabled = 0;
 	} else {
 		armv7a->armv7a_mmu.mmu_enabled =
-			(cortex_a53->cp15_control_reg & 0x1U) ? 1 : 0;
+			(cortex_a->cp15_control_reg & 0x1U) ? 1 : 0;
 	}
 	armv7a->armv7a_mmu.armv7a_cache.d_u_cache_enabled =
-		(cortex_a53->cp15_control_reg & 0x4U) ? 1 : 0;
+		(cortex_a->cp15_control_reg & 0x4U) ? 1 : 0;
 	armv7a->armv7a_mmu.armv7a_cache.i_cache_enabled =
-		(cortex_a53->cp15_control_reg & 0x1000U) ? 1 : 0;
-	cortex_a53->curr_mode = armv7a->arm.core_mode;
+		(cortex_a->cp15_control_reg & 0x1000U) ? 1 : 0;
+	cortex_a->curr_mode = arm->core_mode;
 
 	return ERROR_OK;
 }
@@ -1607,11 +1750,9 @@ static int cortex_a53_post_debug_entry(struct target *target)
 static int cortex_a53_step_64(struct target *target, int current, const struct target_addr *pAddr,
 	int handle_breakpoints)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *arm = &armv7a->arm;
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	struct armv8		*armv8	= target_to_armv8( target );
+	struct arm		*arm	= armv8_to_arm(armv8);
 	struct breakpoint *breakpoint = NULL;
-	struct breakpoint stepbreakpoint;
 	struct reg *r;
 	int retval;
 	struct target_addr addr;
@@ -1651,7 +1792,7 @@ static int cortex_a53_step_64(struct target *target, int current, const struct t
  */
 	target->debug_reason = DBG_REASON_SINGLESTEP;
 
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECR, 1<<2); //set EDECR.SS
+	retval = target_cs_dbg_wr32( target, EDECR, 1<<2); //set EDECR.SS
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1669,7 +1810,7 @@ static int cortex_a53_step_64(struct target *target, int current, const struct t
 			return ERROR_FAIL;
 		}
 	}
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + EDECR, 0); //clr EDECR.SS
+	retval = target_cs_dbg_wr32( target, EDECR, 0); //clr EDECR.SS
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1687,16 +1828,16 @@ static int cortex_a53_step_64(struct target *target, int current, const struct t
 
 static int cortex_a53_restore_context(struct target *target, bool bpwp)
 {
-	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv8_common *armv8_common = cortex_a_to_armv8(cortex_a);
-	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
+	struct armv8		*armv8		= target_to_armv8( target );
+	struct armv8_dpm	*armv8_dpm	= armv8_to_armv8_dpm( armv8 );
+	struct armv7a_common	*armv7a		= armv8_to_armv7a( armv8 );
 
 	LOG_DEBUG(" ");
 
 	if (armv7a->pre_restore_context)
 		armv7a->pre_restore_context(target);
 
-	return armv8_dpm_write_dirty_registers(&armv8_common->armv8.armv8_dpm, bpwp);
+	return armv8_dpm_write_dirty_registers( armv8_dpm, bpwp );
 }
 
 /*
@@ -1711,9 +1852,10 @@ static int cortex_a53_set_breakpoint(struct target *target,
 	int brp_i = 0;
 	uint32_t control;
 	uint8_t byte_addr_select = 0x0F;
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
-	struct cortex_a_brp *brp_list = cortex_a53->brp_list;
+
+	struct armv8           *armv8    = target_to_armv8( target );
+	struct cortex_a_common *cortex_a = armv8_to_cortex_a( armv8 );
+	struct cortex_a_brp    *brp_list = cortex_a->brp_list;
 
 	if (breakpoint->set) {
 		LOG_WARNING("breakpoint already set");
@@ -1721,9 +1863,9 @@ static int cortex_a53_set_breakpoint(struct target *target,
 	}
 
 	if (breakpoint->type == BKPT_HARD) {
-		while (brp_list[brp_i].used && (brp_i < cortex_a53->brp_num))
+		while (brp_list[brp_i].used && (brp_i < cortex_a->brp_num))
 			brp_i++;
-		if (brp_i >= cortex_a53->brp_num) {
+		if (brp_i >= cortex_a->brp_num) {
 			LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
 			return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 		}
@@ -1737,23 +1879,12 @@ static int cortex_a53_set_breakpoint(struct target *target,
 		brp_list[brp_i].used = 1;
 		brp_list[brp_i].value = (breakpoint->address & 0xFFFFFFFC);
 		brp_list[brp_i].control = control;
-		retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-				+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
-				brp_list[brp_i].value);
-		if (retval != ERROR_OK)
-			return retval;
-        //SQU: assume 0 hold high 32bits addr. TODO: fix it
-		retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-				+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn + 4,
-				0);
-		retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-				+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
-				brp_list[brp_i].control);
+		retval = armv8_dbg_wr_bpwp_regs( armv8, brp_list + brp_i);
 		if (retval != ERROR_OK)
 			return retval;
-		LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
+		LOG_DEBUG("brp %i control 0x%0" PRIx32 " value %s", brp_i,
 			brp_list[brp_i].control,
-			brp_list[brp_i].value);
+			  target_addr64str1( target, brp_list[brp_i].value));
 	} else if (breakpoint->type == BKPT_SOFT) {
 		uint8_t code[4];
 		struct target_addr tmp_addr;
@@ -1761,10 +1892,12 @@ static int cortex_a53_set_breakpoint(struct target *target,
 			buf_set_u32(code, 0, 32, ARMV8_T_HLT(0x11)); //ARMV5_T_BKPT(0x11)
 		else
 		{
-			if(target->is_64b) buf_set_u32(code, 0, 32, ARMV8_A64_HLT(0x11));
-			else buf_set_u32(code, 0, 32, ARMV8_A32_HLT(0x11)); //ARMV5_BKPT(0x11)
+			if(target->is_64b)
+				buf_set_u32(code, 0, 32, ARMV8_A64_HLT(0x11));
+			else
+				buf_set_u32(code, 0, 32, ARMV8_A32_HLT(0x11)); //ARMV5_BKPT(0x11)
 		}
-		TARGET_ADDR_INIT( &tmp_addr,  breakpoint->address & (~1) );
+		TARGET_ADDR_INIT( &tmp_addr, breakpoint->address & (~1) );
 		retval = target64_read_memory(target,
 				&tmp_addr,
 				breakpoint->length, 1,
@@ -1791,9 +1924,10 @@ static int cortex_a53_set_context_breakpoint(struct target *target,
 	int brp_i = 0;
 	uint32_t control;
 	uint8_t byte_addr_select = 0x0F;
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
-	struct cortex_a_brp *brp_list = cortex_a53->brp_list;
+
+	struct armv8           *armv8           = target_to_armv8( target );
+	struct cortex_a_common *cortex_a	= armv8_to_cortex_a( armv8 );
+	struct cortex_a_brp    *brp_list	= cortex_a->brp_list;
 
 	if (breakpoint->set) {
 		LOG_WARNING("breakpoint already set");
@@ -1801,10 +1935,10 @@ static int cortex_a53_set_context_breakpoint(struct target *target,
 	}
 	/*check available context BRPs*/
 	while ((brp_list[brp_i].used ||
-		(brp_list[brp_i].type != BRP_CONTEXT)) && (brp_i < cortex_a53->brp_num))
+		(brp_list[brp_i].type != BRP_CONTEXT)) && (brp_i < cortex_a->brp_num))
 		brp_i++;
 
-	if (brp_i >= cortex_a53->brp_num) {
+	if (brp_i >= cortex_a->brp_num) {
 		LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
 		return ERROR_FAIL;
 	}
@@ -1816,24 +1950,7 @@ static int cortex_a53_set_context_breakpoint(struct target *target,
 	brp_list[brp_i].used = 1;
 	brp_list[brp_i].value = (breakpoint->asid);
 	brp_list[brp_i].control = control;
-	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
-			brp_list[brp_i].value);
-	if (retval != ERROR_OK)
-		return retval;
-    //SQU: assume the addr is 32bits. TODO: fix it
-	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn + 4,
-			0);
-
-	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
-			brp_list[brp_i].control);
-	if (retval != ERROR_OK)
-		return retval;
-	LOG_DEBUG("brp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
-		brp_list[brp_i].control,
-		brp_list[brp_i].value);
+	armv8_dbg_wr_bpwp_regs( armv8, brp_list + brp_i );
 	return ERROR_OK;
 
 }
@@ -1848,31 +1965,32 @@ static int cortex_a53_set_hybrid_breakpoint(struct target *target, struct breakp
 	uint8_t IVA_byte_addr_select = 0x0F;
 	uint8_t CTX_machmode = 0x03;
 	uint8_t IVA_machmode = 0x01;
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
-	struct cortex_a_brp *brp_list = cortex_a53->brp_list;
 
+	struct armv8           *armv8    = target_to_armv8( target );
+	struct cortex_a_common *cortex_a = armv8_to_cortex_a( armv8 );
+	struct cortex_a_brp    *brp_list = cortex_a->brp_list;
+	
 	if (breakpoint->set) {
 		LOG_WARNING("breakpoint already set");
 		return retval;
 	}
 	/*check available context BRPs*/
 	while ((brp_list[brp_1].used ||
-		(brp_list[brp_1].type != BRP_CONTEXT)) && (brp_1 < cortex_a53->brp_num))
+		(brp_list[brp_1].type != BRP_CONTEXT)) && (brp_1 < cortex_a->brp_num))
 		brp_1++;
 
 	printf("brp(CTX) found num: %d\n", brp_1);
-	if (brp_1 >= cortex_a53->brp_num) {
+	if (brp_1 >= cortex_a->brp_num) {
 		LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
 		return ERROR_FAIL;
 	}
 
 	while ((brp_list[brp_2].used ||
-		(brp_list[brp_2].type != BRP_NORMAL)) && (brp_2 < cortex_a53->brp_num))
+		(brp_list[brp_2].type != BRP_NORMAL)) && (brp_2 < cortex_a->brp_num))
 		brp_2++;
 
 	printf("brp(IVA) found num: %d\n", brp_2);
-	if (brp_2 >= cortex_a53->brp_num) {
+	if (brp_2 >= cortex_a->brp_num) {
 		LOG_ERROR("ERROR Can not find free Breakpoint Register Pair");
 		return ERROR_FAIL;
 	}
@@ -1887,53 +2005,29 @@ static int cortex_a53_set_hybrid_breakpoint(struct target *target, struct breakp
 	brp_list[brp_1].used = 1;
 	brp_list[brp_1].value = (breakpoint->asid);
 	brp_list[brp_1].control = control_CTX;
-	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_1].BRPn,
-			brp_list[brp_1].value);
-	if (retval != ERROR_OK)
-		return retval;
-    //SQU: assume addr is 32bit. TODO: fix it
-	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_1].BRPn + 4,
-			0);
-	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_1].BRPn,
-			brp_list[brp_1].control);
-	if (retval != ERROR_OK)
-		return retval;
+
+	retval = armv8_dbg_wr_bpwp_regs( armv8, brp_list + brp_1 );
 
 	control_IVA = ((IVA_machmode & 0x7) << 20)
 		| (brp_1 << 16)
 		| (IVA_byte_addr_select << 5)
 		| (3 << 1) | 1;
 	brp_list[brp_2].used = 1;
-	brp_list[brp_2].value = (breakpoint->address & 0xFFFFFFFC);
+	brp_list[brp_2].value = (breakpoint->address & (~3ULL));
 	brp_list[brp_2].control = control_IVA;
-	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_2].BRPn,
-			brp_list[brp_2].value);
-	if (retval != ERROR_OK)
-		return retval;
-    //SQU assume 32bit. TODO: fix it
-	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_2].BRPn + 4,
-			0);
-
-	retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-			+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_2].BRPn,
-			brp_list[brp_2].control);
-	if (retval != ERROR_OK)
-		return retval;
 
-	return ERROR_OK;
+	retval = armv8_dbg_wr_bpwp_regs( armv8, brp_list + brp_2 );
+	
+	return retval;
 }
 
 static int cortex_a53_unset_breakpoint(struct target *target, struct breakpoint *breakpoint)
 {
 	int retval;
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
-	struct cortex_a_brp *brp_list = cortex_a53->brp_list;
+
+	struct armv8           *armv8    = target_to_armv8( target );
+	struct cortex_a_common *cortex_a = armv8_to_cortex_a( armv8 );
+	struct cortex_a_brp    *brp_list = cortex_a->brp_list;
 
 	if (!breakpoint->set) {
 		LOG_WARNING("breakpoint not set");
@@ -1944,83 +2038,47 @@ static int cortex_a53_unset_breakpoint(struct target *target, struct breakpoint
 		if ((breakpoint->address != 0) && (breakpoint->asid != 0)) {
 			int brp_i = breakpoint->set - 1;
 			int brp_j = breakpoint->linked_BRP;
-			if ((brp_i < 0) || (brp_i >= cortex_a53->brp_num)) {
+			if ((brp_i < 0) || (brp_i >= cortex_a->brp_num)) {
 				LOG_DEBUG("Invalid BRP number in breakpoint");
 				return ERROR_OK;
 			}
-			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
-				brp_list[brp_i].control, brp_list[brp_i].value);
 			brp_list[brp_i].used = 0;
 			brp_list[brp_i].value = 0;
 			brp_list[brp_i].control = 0;
-			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
-					brp_list[brp_i].control);
-			if (retval != ERROR_OK)
-				return retval;
-			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
-					brp_list[brp_i].value);
+			/* write control first */
+			retval = armv8_dbg_wr_bpwp_regs( armv8, brp_list + brp_i );
 			if (retval != ERROR_OK)
 				return retval;
-            //SQU: assume 32bit addr. TODO: fix it
-			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn + 4,
-					0);
-			if ((brp_j < 0) || (brp_j >= cortex_a53->brp_num)) {
+			if ((brp_j < 0) || (brp_j >= cortex_a->brp_num)) {
 				LOG_DEBUG("Invalid BRP number in breakpoint");
 				return ERROR_OK;
 			}
-			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_j,
-				brp_list[brp_j].control, brp_list[brp_j].value);
 			brp_list[brp_j].used = 0;
 			brp_list[brp_j].value = 0;
 			brp_list[brp_j].control = 0;
-			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_j].BRPn,
-					brp_list[brp_j].control);
+			retval = armv8_dbg_wr_bpwp_regs( armv8, brp_list + brp_j );
 			if (retval != ERROR_OK)
 				return retval;
-			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_j].BRPn,
-					brp_list[brp_j].value);
-			if (retval != ERROR_OK)
-				return retval;
-            //SQU: assume 32bit addr. TODO: fix it
-			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_j].BRPn + 4,
-					0);
 			breakpoint->linked_BRP = 0;
 			breakpoint->set = 0;
 			return ERROR_OK;
 
 		} else {
 			int brp_i = breakpoint->set - 1;
-			if ((brp_i < 0) || (brp_i >= cortex_a53->brp_num)) {
+			if ((brp_i < 0) || (brp_i >= cortex_a->brp_num)) {
 				LOG_DEBUG("Invalid BRP number in breakpoint");
 				return ERROR_OK;
 			}
-			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value 0x%0" PRIx32, brp_i,
-				brp_list[brp_i].control, brp_list[brp_i].value);
+			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value %s" PRIx32, brp_i,
+				  brp_list[brp_i].control, target_addr64str1(target,brp_list[brp_i].value));
 			brp_list[brp_i].used = 0;
 			brp_list[brp_i].value = 0;
 			brp_list[brp_i].control = 0;
-			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BCR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
-					brp_list[brp_i].control);
+			retval = armv8_dbg_wr_bpwp_regs( armv8, brp_list + brp_i );
 			if (retval != ERROR_OK)
 				return retval;
-			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn,
-					brp_list[brp_i].value);
-			if (retval != ERROR_OK)
-				return retval;
-            //SQU: assume 32bit addr. TODO: fix it
-			retval = cortex_a53_dap_write_memap_register_u32(target, armv7a->debug_base
-					+ CPUDBG_BVR_EL1_BASE + 16 * brp_list[brp_i].BRPn + 4,
-					0);
 
-            breakpoint->set = 0;
+			breakpoint->set = 0;
 			return ERROR_OK;
 		}
 	} else {
@@ -2049,15 +2107,16 @@ static int cortex_a53_unset_breakpoint(struct target *target, struct breakpoint
 static int cortex_a53_add_breakpoint(struct target *target,
 	struct breakpoint *breakpoint)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
-
-	if ((breakpoint->type == BKPT_HARD) && (cortex_a53->brp_num_available < 1)) {
+	struct armv8 *armv8                = target_to_armv8( target );
+	struct cortex_a_common *cortex_a   = armv8_to_cortex_a(armv8);
+	
+	if ((breakpoint->type == BKPT_HARD) && (cortex_a->brp_num_available < 1)) {
 		LOG_INFO("no hardware breakpoint available");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
 	if (breakpoint->type == BKPT_HARD)
-		cortex_a53->brp_num_available--;
+		cortex_a->brp_num_available--;
 
 	return cortex_a53_set_breakpoint(target, breakpoint, 0x00);	/* Exact match */
 }
@@ -2065,15 +2124,16 @@ static int cortex_a53_add_breakpoint(struct target *target,
 static int cortex_a53_add_context_breakpoint(struct target *target,
 	struct breakpoint *breakpoint)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8 *armv8                = target_to_armv8( target );
+	struct cortex_a_common *cortex_a   = armv8_to_cortex_a(armv8);
 
-	if ((breakpoint->type == BKPT_HARD) && (cortex_a53->brp_num_available < 1)) {
+	if ((breakpoint->type == BKPT_HARD) && (cortex_a->brp_num_available < 1)) {
 		LOG_INFO("no hardware breakpoint available");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
 	if (breakpoint->type == BKPT_HARD)
-		cortex_a53->brp_num_available--;
+		cortex_a->brp_num_available--;
 
 	return cortex_a53_set_context_breakpoint(target, breakpoint, 0x02);	/* asid match */
 }
@@ -2081,15 +2141,16 @@ static int cortex_a53_add_context_breakpoint(struct target *target,
 static int cortex_a53_add_hybrid_breakpoint(struct target *target,
 	struct breakpoint *breakpoint)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8 *armv8                = target_to_armv8( target );
+	struct cortex_a_common *cortex_a   = armv8_to_cortex_a(armv8);
 
-	if ((breakpoint->type == BKPT_HARD) && (cortex_a53->brp_num_available < 1)) {
+	if ((breakpoint->type == BKPT_HARD) && (cortex_a->brp_num_available < 1)) {
 		LOG_INFO("no hardware breakpoint available");
 		return ERROR_TARGET_RESOURCE_NOT_AVAILABLE;
 	}
 
 	if (breakpoint->type == BKPT_HARD)
-		cortex_a53->brp_num_available--;
+		cortex_a->brp_num_available--;
 
 	return cortex_a53_set_hybrid_breakpoint(target, breakpoint);	/* ??? */
 }
@@ -2097,12 +2158,13 @@ static int cortex_a53_add_hybrid_breakpoint(struct target *target,
 
 static int cortex_a53_remove_breakpoint(struct target *target, struct breakpoint *breakpoint)
 {
-	struct cortex_a_common *cortex_a53 = target_to_cortex_a(target);
+	struct armv8 *armv8                = target_to_armv8( target );
+	struct cortex_a_common *cortex_a   = armv8_to_cortex_a(armv8);
 
 	if (breakpoint->set) {
 		cortex_a53_unset_breakpoint(target, breakpoint);
 		if (breakpoint->type == BKPT_HARD)
-			cortex_a53->brp_num_available++;
+			cortex_a->brp_num_available++;
 	}
 
 	return ERROR_OK;
@@ -2114,7 +2176,8 @@ static int cortex_a53_remove_breakpoint(struct target *target, struct breakpoint
 
 static int cortex_a53_assert_reset(struct target *target)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct armv8 *armv8           = target_to_armv8( target );
+	struct arm *arm               = armv8_to_arm(armv8);
 
 	LOG_DEBUG(" ");
 
@@ -2134,7 +2197,7 @@ static int cortex_a53_assert_reset(struct target *target)
 	}
 
 	/* registers are now invalid */
-	register_cache_invalidate(armv7a->arm.core_cache);
+	register_cache_invalidate(arm->core_cache);
 
 	target->state = TARGET_RESET;
 
@@ -2172,12 +2235,11 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 	uint32_t count, const uint8_t *buffer)
 {
 	/* write memory through APB-AP */
+	struct armv8         *armv8  = target_to_armv8( target );
+	struct arm *arm = armv8_to_arm(armv8);
 
-	struct target_addr tmp_addr;
+	
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct arm *arm = &armv7a->arm;
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
 	int total_bytes = count * size;
 	int total_u32;
 	int start_byte = pAddr->addr & 0x3;
@@ -2185,9 +2247,10 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 	struct reg *reg;
 	uint32_t dscr;
 	uint8_t *tmp_buff = NULL;
-
-	LOG_DEBUG("Writing APB-AP memory address 0x%" PRIx64 " size %d"  PRIu32 " count%"  PRIu32,
-			  pAddr->addr, (int)size, count);
+	struct target_addr tmp_addr;
+	
+	LOG_DEBUG("Writing APB-AP memory address %s size %d"  PRIu32 " count%"  PRIu32,
+			  target_addr2str1(target,pAddr), (int)size, count);
 	if (target->state != TARGET_HALTED) {
 		LOG_WARNING("target not halted");
 		return ERROR_TARGET_NOT_HALTED;
@@ -2204,7 +2267,7 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 	reg->dirty = true;
 
 	/*  clear any abort  */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DRCR, 1<<2);
+	retval = target_cs_dbg_wr32( target, CPUDBG_DRCR, 1<<2);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -2251,22 +2314,19 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 	/* We now have a 32 bit aligned buffer that can be written */
 
 	/* Read DSCR */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = armv8_dbg_rd_EDSCR( target, &dscr );
 	if (retval != ERROR_OK)
 		goto error_free_buff_w;
 
 	/* Set DTR mode to Fast (2) */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_FAST_MODE;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, dscr);
+	retval = armv8_dbg_wr_EDSCR( target, dscr );
 	if (retval != ERROR_OK)
 		goto error_free_buff_w;
 
 	/* Copy the destination address into R0 */
 	/*  - pend an instruction  MRC p14, 0, R0, c5, c0 */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_ITR, ARMV4_5_MRC(14, 0, 0, 0, 5, 0));
+	retval = target_cs_dbg_wr32( target, CPUDBG_ITR, ARMV4_5_MRC(14, 0, 0, 0, 5, 0));
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 	/* Write address into DTRRX, which triggers previous instruction */
@@ -2275,43 +2335,37 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 	tmp_addr = *pAddr;
 	/* round down to 32bits */
 	tmp_addr.addr &= (~0x03);
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DTRRX, tmp_addr.addr );
+	retval = target_cs_dbg_wr32( target, CPUDBG_DTRRX, tmp_addr.addr );
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
 	/* Write the data transfer instruction into the ITR
 	 * (STC p14, c5, [R0], 4)
 	 */
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_ITR, ARMV4_5_STC(0, 1, 0, 1, 14, 5, 0, 4));
+	retval = target_cs_dbg_wr32( target, CPUDBG_ITR, ARMV4_5_STC(0, 1, 0, 1, 14, 5, 0, 4));
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
 	/* Do the write */
-	retval = mem_ap_sel_write_buf_noincr(swjdp, armv7a->debug_ap,
-					tmp_buff, 4, total_u32, armv7a->debug_base + CPUDBG_DTRRX);
+	retval = target_cs_dbg_wr_bulk_noinc(target, CPUDBG_DTRRX, 4, total_u32,tmp_buff );
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
 
 	/* Switch DTR mode back to non-blocking (0) */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	retval = mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, dscr);
+	retval = armv8_dbg_wr_EDSCR( target, dscr );
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
     /* Check for sticky abort flags in the DSCR */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = armv8_dbg_rd_EDSCR( target, &dscr );
 	if (retval != ERROR_OK)
 		goto error_free_buff_w;
 	if (dscr & (DSCR_STICKY_ABORT_PRECISE | DSCR_STICKY_ABORT_IMPRECISE)) {
 		/* Abort occurred - clear it and exit */
 		LOG_ERROR("abort occurred - dscr = 0x%08" PRIx32, dscr);
-		mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-					armv7a->debug_base + CPUDBG_DRCR, 1<<2);
+		armv8_dbg_ClearStickyErrors( target );
 		goto error_free_buff_w;
 	}
 
@@ -2321,11 +2375,9 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 
 error_unset_dtr_w:
 	/* Unset DTR mode */
-	mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	armv8_dbg_rd_EDSCR( target, &dscr );
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, dscr);
+	armv8_dbg_wr_EDSCR( target, dscr);
 error_free_buff_w:
 	LOG_ERROR("error");
 	free(tmp_buff);
@@ -2336,12 +2388,12 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 	const struct target_addr *pAddr, uint32_t size,
 	uint32_t count, uint8_t *buffer)
 {
+	struct armv8         *armv8  = target_to_armv8( target );
+	struct arm           *arm    = armv8_to_arm(armv8);
+	
 	/* read memory through APB-AP */
 	struct target_addr tmp_addr;
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-	struct arm *arm = &armv7a->arm;
 	int total_bytes = count * size;
 	int total_u32;
 	int start_byte = pAddr->addr & 0x3;
@@ -2352,8 +2404,8 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 	uint8_t buf[8];
 	uint8_t *u8buf_ptr;
 
-	LOG_DEBUG("Reading APB-AP memory address 0x%" PRIx64 " size %d"  PRIu32 " count%"  PRIu32,
-			  pAddr->addr, size, count);
+	LOG_DEBUG("Reading APB-AP memory address %s size %d"  PRIu32 " count%"  PRIu32,
+			  target_addr2str1(target,pAddr), size, count);
 	if (target->state != TARGET_HALTED) {
 		LOG_WARNING("target not halted");
 		return ERROR_TARGET_NOT_HALTED;
@@ -2370,13 +2422,12 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 
 	/*  clear any abort  */
 	retval =
-		mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap, armv7a->debug_base + CPUDBG_DRCR, 1<<2);
+		armv8_dbg_ClearStickyErrors( target );
 	if (retval != ERROR_OK)
 		goto error_free_buff_r;
 
 	/* Read DSCR */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = armv8_dbg_rd_EDSCR( target, &dscr );
 
 	/* This algorithm comes from either :
 	 * Cortex-A8 TRM Example 12-24
@@ -2386,15 +2437,13 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 
 	/* Set DTR access mode to stall mode b01  */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_STALL_MODE;
-	retval +=  mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DSCR, dscr);
+	retval +=  armv8_dbg_wr_EDSCR( target, dscr );
 
 	/* Write R0 with value 'address' using write procedure for stall mode */
 	/*   - Write the address for read access into DTRRX */
 	tmp_addr = *pAddr;
 	tmp_addr.addr &= (~0x03);
-	retval += mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_DTRRX, tmp_addr.addr );
+	retval += target_cs_dbg_wr32( target, CPUDBG_DTRRX, tmp_addr.addr );
 	/*  - Copy value from DTRRX to R0 using instruction mrc p14, 0, r0, c5, c0 */
 	cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dscr);
 
@@ -2407,8 +2456,8 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_FAST_MODE;
 	target_buffer_set_u32(target, u8buf_ptr + 4, dscr);
 	/*  group the 2 access CPUDBG_ITR 0x84 and CPUDBG_DSCR 0x88 */
-	retval += mem_ap_sel_write_buf(swjdp, armv7a->debug_ap, u8buf_ptr, 4, 2,
-			armv7a->debug_base + CPUDBG_ITR);
+
+	retval = target_cs_dbg_wr_bulk(target,CPUDBG_ITR, 4,2, u8buf_ptr );
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_r;
 
@@ -2434,36 +2483,31 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 	 *
 	 * This data is read in aligned to 32 bit boundary.
 	 */
-	retval = mem_ap_sel_read_buf_noincr(swjdp, armv7a->debug_ap, u8buf_ptr, 4, total_u32,
-									armv7a->debug_base + CPUDBG_DTRTX);
+	retval = target_cs_dbg_rd_bulk_noinc(target, CPUDBG_DTRTX, 4, total_u32,  u8buf_ptr );
 	if (retval != ERROR_OK)
 			goto error_unset_dtr_r;
 
 	/* set DTR access mode back to non blocking b00  */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	retval =  mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-					armv7a->debug_base + CPUDBG_DSCR, dscr);
+	retval =  armv8_dbg_wr_EDSCR( target, dscr );
 	if (retval != ERROR_OK)
 		goto error_free_buff_r;
 
 	/* Wait for the final read instruction to finish */
 	do {
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-					armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		retval = armv8_dbg_rd_EDSCR( target, &dscr );
 		if (retval != ERROR_OK)
 			goto error_free_buff_r;
 	} while ((dscr & DSCR_INSTR_COMP) == 0);
 
 	/* Check for sticky abort flags in the DSCR */
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	retval = armv8_dbg_rd_EDSCR( target, &dscr );
 	if (retval != ERROR_OK)
 		goto error_free_buff_r;
 	if (dscr & (DSCR_STICKY_ABORT_PRECISE | DSCR_STICKY_ABORT_IMPRECISE)) {
 		/* Abort occurred - clear it and exit */
 		LOG_ERROR("abort occurred - dscr = 0x%08" PRIx32, dscr);
-		mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-					armv7a->debug_base + CPUDBG_DRCR, 1<<2);
+		armv8_dbg_ClearStickyErrors( target );
 		goto error_free_buff_r;
 	}
 
@@ -2478,11 +2522,9 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 
 error_unset_dtr_r:
 	/* Unset DTR mode */
-	mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+	armv8_dbg_rd_EDSCR( target, &dscr );
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	mem_ap_sel_write_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, dscr);
+	armv8_dbg_wr_EDSCR( target, dscr);
 error_free_buff_r:
 	LOG_ERROR("error");
 	free(tmp_buff);
@@ -2497,57 +2539,35 @@ error_free_buff_r:
  * ap number for every access.
  */
 
-static int cortex_a53_read_phys_memory_64(struct target *target,
-	const struct target_addr *pAddr, uint32_t size,
-	uint64_t count, uint8_t *buffer)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-	int retval = ERROR_COMMAND_SYNTAX_ERROR;
-	uint8_t apsel = swjdp->apsel;
-	LOG_DEBUG("Reading memory at real address 0x%" PRIx64 "; size %d; count %" PRId64,
-		pAddr->addr, size, count);
-
-	if (count && buffer) {
-
-		if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
-			if(pAddr->addr==0)
-			{
-				LOG_ERROR("SQU: trying to read @0x0 will cause exception. Return error directly for now to avoid handling exception");
-				return -107;
-			}
-			/* read memory through AHB-AP */
-			/* FIXME: Add support for 64bit addresses */
-			retval = mem_ap_sel_read_buf(swjdp, armv7a->memory_ap, buffer, size, count, pAddr->addr);
-		} else {
-
-			/* read memory through APB-AP */
-			if (!armv7a->is_armv7r) {
-				/*  disable mmu */
-				retval = cortex_a53_mmu_modify(target, 0);
-				if (retval != ERROR_OK)
-					return retval;
-			}
-			retval = cortex_a53_read_apb_ab_memory(target, pAddr, size, count, buffer);
-		}
-	}
-	return retval;
-}
 
 static int cortex_a53_read_memory_64(struct target *target, const struct target_addr *pAddr,
 	uint64_t size, uint64_t count, uint8_t *buffer)
 {
+	struct target_addr resolved;
+	struct target_addr phys;
 	int mmu_enabled = 0;
-	struct target_addr v_addr, p_addr;
 	int retval;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-	uint8_t apsel = swjdp->apsel;
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
 
 	/* cortex_a53 handles unaligned memory access */
-	LOG_DEBUG("Reading memory at address 0x%" PRIx64 "; size %d; count %" PRId64, pAddr->addr, (int)size, count);
+	LOG_DEBUG("Reading memory at address %s; size %d; count %" PRId64,
+			  target_addr2str1(target,pAddr), (int)size, count);
+
+	int dp;
+	dp = target_addr_resolve_route( target, pAddr, &resolved );
+	if ( dp >= 0 ){
+		/* request is to some dap port - go read it */
+		retval = target_cs_rd_bulk( target, &resolved, size, count, buffer);
+		return retval;
+		
+	}
 
 	/* determine if MMU was enabled on target stop */
+	/* is this a *virtual* or *physical* access */
 	retval = cortex_a53_mmu(target, &mmu_enabled);
 	if (retval != ERROR_OK)
 	{
@@ -2558,74 +2578,80 @@ static int cortex_a53_read_memory_64(struct target *target, const struct target_
 		 */
 		mmu_enabled=0;
 	}
-	//SQUTODO: change to 64b
-	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
-		if (!mmu_enabled) {
-			p_addr = *pAddr;
-		} else {
-			v_addr = *pAddr;
-			/* Change to virtual */
-			v_addr.route = TA_ROUTE_VIRTUAL;
-			retval = cortex_a53_virt2phys_64(target, &v_addr, &p_addr );
-			if (retval != ERROR_OK)
-				return retval;
-
-			LOG_DEBUG("Reading at virtual address. Translating v:0x%" PRIx64 " to r:0x%" PRIx64,
-				  v_addr.addr, p_addr.addr );
-		}
-		retval = cortex_a53_read_phys_memory_64(target, &p_addr, size, count, buffer);
-	} else {
-		if (mmu_enabled) {
-			retval = cortex_a53_check_address(target, pAddr);
-			if (retval != ERROR_OK)
-				return retval;
-			/* enable MMU as we could have disabled it for phys access */
-			retval = cortex_a53_mmu_modify(target, 1);
-			if (retval != ERROR_OK)
-				return retval;
+	
+	/* mmu=off means physical*/
+	/* check for memory bus */
+	if ( !mmu_enabled ){
+		resolved = *pAddr;
+		resolved.route = TA_ROUTE_PHYSICAL;
+		retval = target_addr_resolve_route( target, &resolved, &phys );
+		if( retval >= 0 ){
+			/* Found - use it */
+			return target_cs_rd_bulk(target, &phys, size,count, buffer );
 		}
-		retval = cortex_a53_read_apb_ab_memory(target, pAddr, size, count, buffer);
+		/* memory bus does not exist try something else */
 	}
+		
+	retval = cortex_a53_check_address(target, pAddr);
+	if (retval != ERROR_OK)
+		return retval;
+	/* enable MMU as we could have disabled it for phys access */
+	retval = cortex_a53_mmu_modify(target, 1);
+	if (retval != ERROR_OK){
+		return retval;
+	}
+	retval = cortex_a53_read_apb_ab_memory(target, pAddr, size, count, buffer);
 	return retval;
 }
 
 
-
 static int cortex_a53_write_phys_memory_64(struct target *target,
 	const struct target_addr *pAddr, uint32_t size,
 	uint64_t count, const uint8_t *buffer)
 {
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-	int retval = ERROR_COMMAND_SYNTAX_ERROR;
-	uint8_t apsel = swjdp->apsel;
+	struct target_addr              resolved;
+	struct armv8          *armv8  = target_to_armv8( target );
+	struct armv7a_common  *armv7a = armv8_to_armv7a(armv8);
+	struct arm_dpm        *dpm    = armv8_to_arm_dpm(armv8);
 
-	LOG_DEBUG("Writing memory to real address 0x%" PRIx64 "; size %d; count %" PRId64, pAddr->addr,
-		size, count);
-
-	if (count && buffer) {
-
-		if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+		
+	int retval = ERROR_COMMAND_SYNTAX_ERROR;
+	
+	LOG_DEBUG("Writing memory to real address %s; size %d; count %" PRId64,
+			  target_addr2str1(target,pAddr),
+			  size, count);
 
-			/* write memory through AHB-AP */
-			/* FIXME: Add 64bit support */
-			retval = mem_ap_sel_write_buf(swjdp, armv7a->memory_ap, buffer, size, count, pAddr->addr);
-		} else {
+	if( 0 == count ){
+		return ERROR_OK;
+	}
 
-			/* write memory through APB-AP */
-			if (!armv7a->is_armv7r) {
-				retval = cortex_a53_mmu_modify(target, 0);
-				if (retval != ERROR_OK)
-					return retval;
-			}
-			return cortex_a53_write_apb_ab_memory(target, pAddr, size, count, buffer);
+	/* is this really dap port request */
+	if ( target_addr_resolve_route(target,pAddr, &resolved) >= 0 ){
+		/* redirect via dap */
+		retval = target_cs_wr_bulk( target, &resolved, size, count, buffer);
+		if( retval != ERROR_OK ){
+			return retval;
 		}
+		goto cache_clean;
 	}
 
+	/* write memory through APB-AP */
+	if (!armv7a->is_armv7r) {
+			retval = cortex_a53_mmu_modify(target, 0);
+			if (retval != ERROR_OK)
+				return retval;
+	}
+	return cortex_a53_write_apb_ab_memory(target, pAddr, size, count, buffer);
+	
+ cache_clean:
+
 
 	/* REVISIT this op is generic ARMv7-A/R stuff */
 	if (retval == ERROR_OK && target->state == TARGET_HALTED) {
-		struct arm_dpm *dpm = armv7a->arm.dpm;
 
 		retval = dpm->prepare(dpm);
 		if (retval != ERROR_OK)
@@ -2686,44 +2712,39 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 static int cortex_a53_write_memory_64(struct target *target, const struct target_addr *pAddr,
 	uint64_t size, uint64_t count, const uint8_t *buffer)
 {
+	struct target_addr resolved;
 	int mmu_enabled = 0;
-	struct target_addr phys_addr;
 	int retval;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-	uint8_t apsel = swjdp->apsel;
 
+
+	if (target->state != TARGET_HALTED) {
+		LOG_WARNING("target not halted");
+		return ERROR_TARGET_NOT_HALTED;
+	}
+	
 	if( pAddr->route == TA_ROUTE_PHYSICAL ){
-	  return cortex_a53_write_phys_memory_64( target, pAddr, size, count, buffer );
+		return cortex_a53_write_phys_memory_64( target, pAddr, size, count, buffer );
 	}
 
 	/* cortex_a53 handles unaligned memory access */
-	LOG_DEBUG("Writing memory at address 0x%" PRIx64 "; size %d; count %" PRId64,
-		  pAddr->addr, (int)size, count);
+	LOG_DEBUG("Writing memory at address %s; size %d; count %" PRId64,
+			  target_addr2str1(target,pAddr), (int)size, count);
 
 	/* determine if MMU was enabled on target stop */
 	retval = cortex_a53_mmu(target, &mmu_enabled);
 	if (retval != ERROR_OK)
 		return retval;
 
-	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
-		LOG_DEBUG("Writing memory to address 0x%" PRIx64 "; size %d; count %" PRId64, pAddr->addr, (int)size,
-			count);
+	int dp;
+	dp = target_addr_resolve_route(target,pAddr,&resolved);
+	if (dp >=0){
+		retval = target_cs_wr_bulk( target, &resolved, size,	count, buffer);
+	} else {
 		if (!mmu_enabled) {
-			phys_addr = *pAddr;
+			resolved = *pAddr;
+			resolved.route = TA_ROUTE_PHYSICAL;
+			retval = cortex_a53_write_phys_memory_64( target, &resolved, size, count, buffer );			
 		} else {
-			retval = cortex_a53_virt2phys_64(target, pAddr, &phys_addr);
-			if (retval != ERROR_OK)
-				return retval;
-
-			LOG_DEBUG("Writing to virtual address. Translating v:0x%" PRIx64 " to r:0x%" PRIx64,
-				  pAddr->addr,
-				  phys_addr.addr );
-		}
-		retval = cortex_a53_write_phys_memory_64(target, &phys_addr, size,
-				count, buffer);
-	} else {
-		if (mmu_enabled) {
 			retval = cortex_a53_check_address(target, pAddr);
 			if (retval != ERROR_OK)
 				return retval;
@@ -2731,8 +2752,8 @@ static int cortex_a53_write_memory_64(struct target *target, const struct target
 			retval = cortex_a53_mmu_modify(target, 1);
 			if (retval != ERROR_OK)
 				return retval;
+			retval = cortex_a53_write_apb_ab_memory(target, pAddr, size, count, buffer);
 		}
-		retval = cortex_a53_write_apb_ab_memory(target, pAddr, size, count, buffer);
 	}
 	return retval;
 }
@@ -2745,9 +2766,7 @@ static int cortex_a53_write_buffer_64(struct target *target, const struct target
 
 static int cortex_a53_handle_target_request(void *priv)
 {
-	struct target *target = priv;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	struct target         *target = priv;
 	int retval;
 
 	if (!target_was_examined(target))
@@ -2758,17 +2777,14 @@ static int cortex_a53_handle_target_request(void *priv)
 	if (target->state == TARGET_RUNNING) {
 		uint32_t request;
 		uint32_t dscr;
-		retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-				armv7a->debug_base + CPUDBG_DSCR, &dscr);
+		retval = armv8_dbg_rd_EDSCR( target, &dscr );
 
 		/* check if we have data */
 		while ((dscr & DSCR_DTR_TX_FULL) && (retval == ERROR_OK)) {
-			retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-					armv7a->debug_base + CPUDBG_DTRTX, &request);
+			retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &request);
 			if (retval == ERROR_OK) {
 				target_request(target, request);
-				retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-						armv7a->debug_base + CPUDBG_DSCR, &dscr);
+				retval = armv8_dbg_rd_EDSCR( target, &dscr );
 			}
 		}
 	}
@@ -2782,24 +2798,26 @@ static int cortex_a53_handle_target_request(void *priv)
 
 static int cortex_a53_examine_first(struct target *target)
 {
-	struct cortex_a_common *cortex_a = target_to_cortex_a(target);
-	struct armv8_common *armv8 = cortex_a_to_armv8(cortex_a);
-	struct armv7a_common *armv7a = &cortex_a->armv7a_common;
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
+	struct armv8           *armv8    = target_to_armv8( target );
+	struct arm             *arm      = armv8_to_arm(armv8);
+	struct cortex_a_common *cortex_a = armv8_to_cortex_a( armv8 );
+	struct coresight_settings *coresight = target_to_coresight(target);
+
 	int i;
 	int retval = ERROR_OK;
-	uint32_t dfr0, cpuid;
+	uint64_t dfr0;
+	uint32_t cpuid;
 
 	/* We do one extra read to ensure DAP is configured,
 	 * we call ahbap_debugport_init(swjdp) instead
 	 */
-	dap_ap_select(swjdp, 1); //swjdp->apsel=1;
-	retval = ahbap_debugport_init(swjdp);
+	
+	retval = target_cs_debugport_init(target);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* Search for the APB-AB - it is needed for access to debug registers */
-	retval = dap_find_ap(swjdp, AP_TYPE_APB_AP, &armv7a->debug_ap);
+	retval = target_cs_discover_ap( target, AP_TYPE_APB_AP, &(coresight->dbgbus) );
 	if (retval != ERROR_OK) {
 		LOG_ERROR("Could not find APB-AP for debug access");
 		return retval;
@@ -2808,66 +2826,63 @@ static int cortex_a53_examine_first(struct target *target)
 	/* SQU: tricky here. For 8916 it has AXI_AP but not AHB_AP as port 0 for sys-mem.And port3 is AHB_AP but it is RPM/Cortex M3
 	 * So either hard coded the memory_ap as port 0 or search AXI_AP first, or check AP type variant. Will take option 3.
 	 */
-	retval = dap_find_ap(swjdp, AP_TYPE_AHB_AP, &armv7a->memory_ap);
-	if (retval != ERROR_OK) {
+	retval = target_cs_discover_ap( target, AP_TYPE_AHB_AP, &(coresight->membus) );
+	if (retval != ERROR_OK ){
 		/* AHB-AP not found - use APB-AP */
 		LOG_DEBUG("Could not find AHB-AP - Will try AXI-AP for memory access");
 		/* Search for the AXI-AP */
-		retval = dap_find_ap(swjdp, AP_TYPE_AXI_AP, &armv7a->memory_ap);
+		retval = target_cs_discover_ap( target, AP_TYPE_AXI_AP, &(coresight->membus) );
 		if (retval != ERROR_OK) {
 			/* AXI-AP not found - use APB-AP */
-			LOG_DEBUG("Could not find AXI/AHB-AP - using APB-AP for memory access");
-			armv7a->memory_ap_available = false;
-		} else {
-			armv7a->memory_ap_available = true;
+			LOG_DEBUG("%s: mem-ap not found AXI/AHB-AP - using APB-AP for memory access", target_name(target));
+			/* mark this as "not-found" by making route = DEFAULT */
+			TARGET_ADDR_INIT( &(coresight->membus.addr),0 );
 		}
-	} else {
-		armv7a->memory_ap_available = true;
 	}
 
-	if (!target->dbgbase_set) {
+	if ( coresight->dbgbus.is_forced ){
+		/* user specified this, we do not search the ROM table */
+	} else {
 		uint32_t dbgbase;
 		/* Get ROM Table base */
 		uint32_t apid;
+		uint32_t tmp;
 		int32_t coreidx = target->coreid;
 		LOG_DEBUG("%s's dbgbase is not set, trying to detect using the ROM table",
 			  target->cmd_name);
         
-		retval = dap_get_debugbase(swjdp, 1, &dbgbase, &apid);
+		retval = target_cs_get_debugbase2( target, &(coresight->dbgbus.addr), &dbgbase, &apid);
 		if (retval != ERROR_OK)
 			return retval;
 		/* Lookup 0x15 -- Processor DAP */
-		retval = dap_lookup_cs_component(swjdp, 1, dbgbase, 0x15,
-				&armv7a->debug_base, &coreidx);
+		retval = target_cs_lookup_component(target, &(coresight->dbgbus.addr), dbgbase, 0x15, &tmp, &coreidx);
 		if (retval != ERROR_OK)
 			return retval;
-		LOG_DEBUG("Detected core %" PRId32 " dbgbase: %08" PRIx32,
-			  coreidx, armv7a->debug_base);
-	} else
-		armv7a->debug_base = target->dbgbase;
-	armv7a->cti_base = target->ctibase;
+		coresight->dbgbus.addr.addr = tmp;
+		LOG_DEBUG("Detected core %" PRId32 " dbgbase: %08" PRIx32, target->coreid, tmp );
+	}
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_CPUID, &cpuid);
-	if (retval != ERROR_OK)
-		return retval;
-    //if(cpuid==0x410FD030) => 8916
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + CPUDBG_CPUID, &cpuid);
+	/* FIXME: Need to write code to find the CTI */
+
+	//if(cpuid==0x410FD030) => 8916
+	retval = target_cs_dbg_rd32( target, CPUDBG_CPUID, &cpuid);
 	if (retval != ERROR_OK) {
-		LOG_DEBUG("Examine %s failed", "CPUID");
+		LOG_DEBUG("cortex_a53[%d]: Read CPUID Fails: %d", target->coreid, retval );
 		return retval;
 	}
+	LOG_DEBUG("cortex_a53[%d] cpuid: 0x%08" PRIx32, target->coreid, cpuid );
+	armv8->midr_el1_reg = cpuid;
 
-	retval = mem_ap_sel_read_atomic_u32(swjdp, armv7a->debug_ap,
-			armv7a->debug_base + ID_AA64DFR0_EL1_L, &dfr0);
+
+	retval = target_cs_dbg_rd64( target, EDDFR, &dfr0);
 	if (retval != ERROR_OK) {
-		LOG_DEBUG("Examine %s failed", "ID_AA64DFR0_EL1");
+		LOG_DEBUG("Examine %s failed", "EDDFR");
 		return retval;
 	}
-	LOG_DEBUG("cpuid = 0x%08" PRIx32, cpuid);
-	LOG_DEBUG("didr = 0x%08" PRIx32, dfr0);
-	armv7a->arm.core_type = ARM_MODE_MON;
+	armv8->eddfr_reg = dfr0;
+	LOG_DEBUG("cortex_a53[%d] eddfr: 0x%08" PRIx64, target->coreid, dfr0 );
+	
+	arm->core_type = ARM_MODE_MON;
 	retval = cortex_a53_dpm_setup(armv8, dfr0);
 	if (retval != ERROR_OK)
 		return retval;
@@ -2930,13 +2945,13 @@ static int cortex_a53_read_phys_memory_WRAPPER(struct target *target, uint32_t a
 
 
 static int cortex_a53_init_arch_info(struct target *target,
-	struct cortex_a_common *cortex_a53)
+	struct cortex_a_common *cortex_a)
 {
-	struct armv7a_common *armv7a = &cortex_a53->armv7a_common;
+	struct armv7a_common *armv7a = &cortex_a->HIDE_armv7a_common;
 
 	/* Setup struct cortex_a_common */
-	cortex_a53->common_magic = CORTEX_A_COMMON_MAGIC;
-	cortex_a53->fast_reg_read = 0;
+	cortex_a->common_cortex_a_magic = CORTEX_A_COMMON_MAGIC;
+	cortex_a->fast_reg_read = 0;
 
 	/* register arch-specific functions */
 	armv7a->examine_debug_reason = NULL;
@@ -2954,42 +2969,38 @@ static int cortex_a53_init_arch_info(struct target *target,
 	return ERROR_OK;
 }
 
-void cortex_a53_connect_dap(struct target *target, struct adiv5_dap *dap)
-{
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-
-	dap->memaccess_tck = 8;
-	dap->tar_autoincr_block = (1 << 10);
-
-	armv7a->arm.dap = dap;
-}
 
 static int cortex_a53_target_create(struct target *target, Jim_Interp *interp)
 {
-	struct armv8_common* a53_armv8_common = calloc(1, sizeof(struct armv8_common));
-	struct cortex_a_common *cortex_a53 = &a53_armv8_common->cortex_a_common;
+	struct armv8_common    *armv8_common  = calloc(1, sizeof(struct armv8_common));
+	struct armv8           *armv8         = &(armv8_common->HIDE_armv8);
+	struct cortex_a_common *cortex_a      = &(armv8_common->HIDE_cortex_a_common);
+	
+	armv8->armv8_magic = ARMV8_MAGIC;
 
-	cortex_a53->armv7a_common.is_armv7r = false;
-	cortex_a53_init_arch_info(target, cortex_a53);
-	a53_armv8_common->armv8.arm=&cortex_a53->armv7a_common.arm; //set the pointer to legacy arm core struct
+	cortex_a53_init_arch_info(target, cortex_a);
 
     /* If it's not set, assume transport select is not swd. Nothing sets up the JTAG DAP so we have to. */
 	if (!global_dap)
 		global_dap = adiv5_jtag_dap_new(target->tap);
 
-	cortex_a53_connect_dap(target, global_dap);
+	target_cs_connect_dap(target, global_dap);
 
     return ERROR_OK;
 }
 
 static int cortex_a53_mmu(struct target *target, int *enabled)
 {
+	struct cortex_a_common *cortex_a;
+	struct armv7a_common   *armv7a;
 	if (target->state != TARGET_HALTED) {
 		LOG_ERROR("%s: target not halted", __func__);
 		return ERROR_TARGET_INVALID;
 	}
 
-	*enabled = target_to_cortex_a(target)->armv7a_common.armv7a_mmu.mmu_enabled;
+	cortex_a = target_to_cortex_a(target);
+	armv7a   = cortex_a_to_armv7a(cortex_a);
+	*enabled = armv7a->armv7a_mmu.mmu_enabled;
 	return ERROR_OK;
 }
 
@@ -2997,24 +3008,21 @@ static int cortex_a53_virt2phys_64(struct target *target,
 				   const struct target_addr *in_pVirt,
 				   struct target_addr *out_pPhys )
 {
+	struct target_addr resolved;
 	int retval = ERROR_FAIL;
-	struct armv7a_common *armv7a = target_to_armv7a(target);
-	struct adiv5_dap *swjdp = armv7a->arm.dap;
-	uint8_t apsel = swjdp->apsel;
-	uint32_t FIXME;
-	if (armv7a->memory_ap_available && (apsel == armv7a->memory_ap)) {
-		
-		retval = armv7a_mmu_translate_va(target,
-						 in_pVirt->addr, &FIXME );
-		if (retval != ERROR_OK)
-			goto done;
-		TARGET_ADDR_PHYS( out_pPhys, FIXME );
+	uint32_t FIXME; /* 64bit! */
+	
+	int dp;
+	dp = target_addr_resolve_route(target,in_pVirt, &resolved);
+	if ( dp >= 0 ){
+		/* Assume it is a physical address */
+		*out_pPhys = resolved;
 	} else {/*  use this method if armv7a->memory_ap not selected
 		 *  mmu must be enable in order to get a correct translation */
 		retval = cortex_a53_mmu_modify(target, 1);
 		if (retval != ERROR_OK)
 			goto done;
-		retval = armv7a_mmu_translate_va_pa(target, in_pVirt->addr,  &FIXME, 1);
+		retval = armv7a_mmu_translate_va_pa(target, in_pVirt->addr, &FIXME, 1);
 		TARGET_ADDR_PHYS( out_pPhys, FIXME );
 	}
 done:
@@ -3025,7 +3033,8 @@ done:
 COMMAND_HANDLER(cortex_a53_handle_cache_info_command)
 {
 	struct target *target = get_current_target(CMD_CTX);
-	struct armv7a_common *armv7a = target_to_armv7a(target);
+	struct armv8 *armv8 = target_to_armv8( target );
+	struct armv7a_common *armv7a = armv8_to_armv7a( armv8 );
 
 	return armv7a_handle_cache_info_command(CMD_CTX,
 			&armv7a->armv7a_mmu.armv7a_cache);
@@ -3115,11 +3124,12 @@ static const struct command_registration cortex_a53_exec_command_handlers[] = {
 		.help = "Initialize core debug",
 		.usage = "",
 	},
-	{   .name = "smp_off",
-	    .handler = cortex_a53_handle_smp_off_command,
-	    .mode = COMMAND_EXEC,
-	    .help = "Stop smp handling",
-	    .usage = "",},
+	{
+		.name = "smp_off",
+		.handler = cortex_a53_handle_smp_off_command,
+		.mode = COMMAND_EXEC,
+		.help = "Stop smp handling",
+		.usage = "",},
 	{
 		.name = "smp_on",
 		.handler = cortex_a53_handle_smp_on_command,
diff --git a/src/target/cortex_m.c b/src/target/cortex_m.c
index cc80a8a..df34286 100755
--- a/src/target/cortex_m.c
+++ b/src/target/cortex_m.c
@@ -62,27 +62,26 @@
 static int cortex_m_store_core_reg_u32(struct target *target,
 		uint32_t num, uint32_t value);
 
+
 static int cortexm_dap_read_coreregister_u32(struct target *target,
 	uint32_t *value, int regnum)
 {
-	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = armv7m->arm.dap;
 	int retval;
 	uint32_t dcrdr;
 
 	/* because the DCB_DCRDR is used for the emulated dcc channel
 	 * we have to save/restore the DCB_DCRDR when used */
 	if (target->dbg_msg_enabled) {
-		retval = mem_ap_read_u32(swjdp, DCB_DCRDR, &dcrdr);
+		retval = target_cs_dbg_queued_rd32( target, DCB_DCRDR, &dcrdr);
 		if (retval != ERROR_OK)
 			return retval;
 	}
 
-	retval = mem_ap_write_u32(swjdp, DCB_DCRSR, regnum);
+	retval = target_cs_dbg_queued_wr32( target,DCB_DCRSR, regnum);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = mem_ap_read_atomic_u32(swjdp, DCB_DCRDR, value);
+	retval = target_cs_dbg_rd32( target, DCB_DCRDR, value);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -90,7 +89,7 @@ static int cortexm_dap_read_coreregister_u32(struct target *target,
 		/* restore DCB_DCRDR - this needs to be in a separate
 		 * transaction otherwise the emulated DCC channel breaks */
 		if (retval == ERROR_OK)
-			retval = mem_ap_write_atomic_u32(swjdp, DCB_DCRDR, dcrdr);
+			retval = target_cs_dbg_wr32( target, DCB_DCRDR, dcrdr);
 	}
 
 	return retval;
@@ -99,24 +98,23 @@ static int cortexm_dap_read_coreregister_u32(struct target *target,
 static int cortexm_dap_write_coreregister_u32(struct target *target,
 	uint32_t value, int regnum)
 {
-	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = armv7m->arm.dap;
+
 	int retval;
 	uint32_t dcrdr;
 
 	/* because the DCB_DCRDR is used for the emulated dcc channel
 	 * we have to save/restore the DCB_DCRDR when used */
 	if (target->dbg_msg_enabled) {
-		retval = mem_ap_read_u32(swjdp, DCB_DCRDR, &dcrdr);
+		retval = target_cs_dbg_queued_rd32( target, DCB_DCRDR, &dcrdr);
 		if (retval != ERROR_OK)
 			return retval;
 	}
 
-	retval = mem_ap_write_u32(swjdp, DCB_DCRDR, value);
+	retval = target_cs_dbg_queued_wr32( target,DCB_DCRDR, value);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = mem_ap_write_atomic_u32(swjdp, DCB_DCRSR, regnum | DCRSR_WnR);
+	retval = target_cs_dbg_wr32( target, DCB_DCRSR, regnum | DCRSR_WnR);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -124,7 +122,7 @@ static int cortexm_dap_write_coreregister_u32(struct target *target,
 		/* restore DCB_DCRDR - this needs to be in a seperate
 		 * transaction otherwise the emulated DCC channel breaks */
 		if (retval == ERROR_OK)
-			retval = mem_ap_write_atomic_u32(swjdp, DCB_DCRDR, dcrdr);
+			retval = target_cs_dbg_wr32( target, DCB_DCRDR, dcrdr);
 	}
 
 	return retval;
@@ -134,32 +132,31 @@ static int cortex_m_write_debug_halt_mask(struct target *target,
 	uint32_t mask_on, uint32_t mask_off)
 {
 	struct cortex_m_common *cortex_m = target_to_cm(target);
-	struct adiv5_dap *swjdp = cortex_m->armv7m.arm.dap;
 
 	/* mask off status bits */
 	cortex_m->dcb_dhcsr &= ~((0xFFFF << 16) | mask_off);
 	/* create new register mask */
 	cortex_m->dcb_dhcsr |= DBGKEY | C_DEBUGEN | mask_on;
 
-	return mem_ap_write_atomic_u32(swjdp, DCB_DHCSR, cortex_m->dcb_dhcsr);
+	return target_cs_dbg_wr32( target, DCB_DHCSR, cortex_m->dcb_dhcsr);
 }
 
 static int cortex_m_clear_halt(struct target *target)
 {
 	struct cortex_m_common *cortex_m = target_to_cm(target);
-	struct adiv5_dap *swjdp = cortex_m->armv7m.arm.dap;
+
 	int retval;
 
 	/* clear step if any */
 	cortex_m_write_debug_halt_mask(target, C_HALT, C_STEP);
 
 	/* Read Debug Fault Status Register */
-	retval = mem_ap_read_atomic_u32(swjdp, NVIC_DFSR, &cortex_m->nvic_dfsr);
+	retval = target_cs_dbg_rd32( target, NVIC_DFSR, &cortex_m->nvic_dfsr);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* Clear Debug Fault Status */
-	retval = mem_ap_write_atomic_u32(swjdp, NVIC_DFSR, cortex_m->nvic_dfsr);
+	retval = target_cs_dbg_wr32( target, NVIC_DFSR, cortex_m->nvic_dfsr);
 	if (retval != ERROR_OK)
 		return retval;
 	LOG_DEBUG(" NVIC_DFSR 0x%" PRIx32 "", cortex_m->nvic_dfsr);
@@ -170,7 +167,6 @@ static int cortex_m_clear_halt(struct target *target)
 static int cortex_m_single_step_core(struct target *target)
 {
 	struct cortex_m_common *cortex_m = target_to_cm(target);
-	struct adiv5_dap *swjdp = cortex_m->armv7m.arm.dap;
 	uint32_t dhcsr_save;
 	int retval;
 
@@ -182,12 +178,12 @@ static int cortex_m_single_step_core(struct target *target)
 	 * HALT can put the core into an unknown state.
 	 */
 	if (!(cortex_m->dcb_dhcsr & C_MASKINTS)) {
-		retval = mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
+		retval = target_cs_dbg_wr32( target, DCB_DHCSR,
 				DBGKEY | C_MASKINTS | C_HALT | C_DEBUGEN);
 		if (retval != ERROR_OK)
 			return retval;
 	}
-	retval = mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
+	retval = target_cs_dbg_wr32( target, DCB_DHCSR,
 			DBGKEY | C_MASKINTS | C_STEP | C_DEBUGEN);
 	if (retval != ERROR_OK)
 		return retval;
@@ -202,13 +198,13 @@ static int cortex_m_single_step_core(struct target *target)
 
 static int cortex_m_enable_fpb(struct target *target)
 {
-	int retval = target_write_u32(target, FP_CTRL, 3);
+	int retval = target_cs_dbg_wr32( target, FP_CTRL, 3);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* check the fpb is actually enabled */
 	uint32_t fpctrl;
-	retval = target_read_u32(target, FP_CTRL, &fpctrl);
+	retval = target_cs_dbg_rd32( target, FP_CTRL, &fpctrl);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -225,27 +221,26 @@ static int cortex_m_endreset_event(struct target *target)
 	uint32_t dcb_demcr;
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 	struct armv7m_common *armv7m = &cortex_m->armv7m;
-	struct adiv5_dap *swjdp = cortex_m->armv7m.arm.dap;
 	struct cortex_m_fp_comparator *fp_list = cortex_m->fp_comparator_list;
 	struct cortex_m_dwt_comparator *dwt_list = cortex_m->dwt_comparator_list;
 
 	/* REVISIT The four debug monitor bits are currently ignored... */
-	retval = mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &dcb_demcr);
+	retval = target_cs_dbg_rd32( target, DCB_DEMCR, &dcb_demcr);
 	if (retval != ERROR_OK)
 		return retval;
 	LOG_DEBUG("DCB_DEMCR = 0x%8.8" PRIx32 "", dcb_demcr);
 
 	/* this register is used for emulated dcc channel */
-	retval = mem_ap_write_u32(swjdp, DCB_DCRDR, 0);
+	retval = target_cs_dbg_queued_wr32( target,DCB_DCRDR, 0);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* Enable debug requests */
-	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m->dcb_dhcsr);
+	retval = target_cs_dbg_rd32( target, DCB_DHCSR, &cortex_m->dcb_dhcsr);
 	if (retval != ERROR_OK)
 		return retval;
 	if (!(cortex_m->dcb_dhcsr & C_DEBUGEN)) {
-		retval = mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN);
+		retval = target_cs_dbg_queued_wr32( target,DCB_DHCSR, DBGKEY | C_DEBUGEN);
 		if (retval != ERROR_OK)
 			return retval;
 	}
@@ -260,7 +255,7 @@ static int cortex_m_endreset_event(struct target *target)
 	 * choices *EXCEPT* explicitly scripted overrides like "vector_catch"
 	 * or manual updates to the NVIC SHCSR and CCR registers.
 	 */
-	retval = mem_ap_write_u32(swjdp, DCB_DEMCR, TRCENA | armv7m->demcr);
+	retval = target_cs_dbg_queued_wr32( target,DCB_DEMCR, TRCENA | armv7m->demcr);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -279,34 +274,34 @@ static int cortex_m_endreset_event(struct target *target)
 
 	/* Restore FPB registers */
 	for (i = 0; i < cortex_m->fp_num_code + cortex_m->fp_num_lit; i++) {
-		retval = target_write_u32(target, fp_list[i].fpcr_address, fp_list[i].fpcr_value);
+		retval = target_cs_dbg_wr32( target, fp_list[i].fpcr_address, fp_list[i].fpcr_value);
 		if (retval != ERROR_OK)
 			return retval;
 	}
 
 	/* Restore DWT registers */
 	for (i = 0; i < cortex_m->dwt_num_comp; i++) {
-		retval = target_write_u32(target, dwt_list[i].dwt_comparator_address + 0,
+		retval = target_cs_dbg_wr32( target, dwt_list[i].dwt_comparator_address + 0,
 				dwt_list[i].comp);
 		if (retval != ERROR_OK)
 			return retval;
-		retval = target_write_u32(target, dwt_list[i].dwt_comparator_address + 4,
+		retval = target_cs_dbg_wr32( target, dwt_list[i].dwt_comparator_address + 4,
 				dwt_list[i].mask);
 		if (retval != ERROR_OK)
 			return retval;
-		retval = target_write_u32(target, dwt_list[i].dwt_comparator_address + 8,
+		retval = target_cs_dbg_wr32( target, dwt_list[i].dwt_comparator_address + 8,
 				dwt_list[i].function);
 		if (retval != ERROR_OK)
 			return retval;
 	}
-	retval = dap_run(swjdp);
+	retval = target_cs_dap_run(target);
 	if (retval != ERROR_OK)
 		return retval;
 
 	register_cache_invalidate(armv7m->arm.core_cache);
 
 	/* make sure we have latest dhcsr flags */
-	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m->dcb_dhcsr);
+	retval = target_cs_dbg_rd32( target, DCB_DHCSR, &cortex_m->dcb_dhcsr);
 
 	return retval;
 }
@@ -339,50 +334,49 @@ static int cortex_m_examine_exception_reason(struct target *target)
 {
 	uint32_t shcsr = 0, except_sr = 0, cfsr = -1, except_ar = -1;
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = armv7m->arm.dap;
 	int retval;
 
-	retval = mem_ap_read_u32(swjdp, NVIC_SHCSR, &shcsr);
+	retval = target_cs_dbg_queued_rd32( target, NVIC_SHCSR, &shcsr);
 	if (retval != ERROR_OK)
 		return retval;
 	switch (armv7m->exception_number) {
 		case 2:	/* NMI */
 			break;
 		case 3:	/* Hard Fault */
-			retval = mem_ap_read_atomic_u32(swjdp, NVIC_HFSR, &except_sr);
+			retval = target_cs_dbg_rd32( target, NVIC_HFSR, &except_sr);
 			if (retval != ERROR_OK)
 				return retval;
 			if (except_sr & 0x40000000) {
-				retval = mem_ap_read_u32(swjdp, NVIC_CFSR, &cfsr);
+				retval = target_cs_dbg_queued_rd32( target, NVIC_CFSR, &cfsr);
 				if (retval != ERROR_OK)
 					return retval;
 			}
 			break;
 		case 4:	/* Memory Management */
-			retval = mem_ap_read_u32(swjdp, NVIC_CFSR, &except_sr);
+			retval = target_cs_dbg_queued_rd32( target, NVIC_CFSR, &except_sr);
 			if (retval != ERROR_OK)
 				return retval;
-			retval = mem_ap_read_u32(swjdp, NVIC_MMFAR, &except_ar);
+			retval = target_cs_dbg_queued_rd32( target, NVIC_MMFAR, &except_ar);
 			if (retval != ERROR_OK)
 				return retval;
 			break;
 		case 5:	/* Bus Fault */
-			retval = mem_ap_read_u32(swjdp, NVIC_CFSR, &except_sr);
+			retval = target_cs_dbg_queued_rd32( target, NVIC_CFSR, &except_sr);
 			if (retval != ERROR_OK)
 				return retval;
-			retval = mem_ap_read_u32(swjdp, NVIC_BFAR, &except_ar);
+			retval = target_cs_dbg_queued_rd32( target, NVIC_BFAR, &except_ar);
 			if (retval != ERROR_OK)
 				return retval;
 			break;
 		case 6:	/* Usage Fault */
-			retval = mem_ap_read_u32(swjdp, NVIC_CFSR, &except_sr);
+			retval = target_cs_dbg_queued_rd32( target, NVIC_CFSR, &except_sr);
 			if (retval != ERROR_OK)
 				return retval;
 			break;
 		case 11:	/* SVCall */
 			break;
 		case 12:	/* Debug Monitor */
-			retval = mem_ap_read_u32(swjdp, NVIC_DFSR, &except_sr);
+			retval = target_cs_dbg_queued_rd32( target, NVIC_DFSR, &except_sr);
 			if (retval != ERROR_OK)
 				return retval;
 			break;
@@ -394,7 +388,7 @@ static int cortex_m_examine_exception_reason(struct target *target)
 			except_sr = 0;
 			break;
 	}
-	retval = dap_run(swjdp);
+	retval = target_cs_dap_run(target);
 	if (retval == ERROR_OK)
 		LOG_DEBUG("%s SHCSR 0x%" PRIx32 ", SR 0x%" PRIx32
 			", CFSR 0x%" PRIx32 ", AR 0x%" PRIx32,
@@ -411,13 +405,12 @@ static int cortex_m_debug_entry(struct target *target)
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 	struct armv7m_common *armv7m = &cortex_m->armv7m;
 	struct arm *arm = &armv7m->arm;
-	struct adiv5_dap *swjdp = armv7m->arm.dap;
 	struct reg *r;
 
 	LOG_DEBUG(" ");
 
 	cortex_m_clear_halt(target);
-	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m->dcb_dhcsr);
+	retval = target_cs_dbg_rd32( target, DCB_DHCSR, &cortex_m->dcb_dhcsr);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -491,11 +484,9 @@ static int cortex_m_poll(struct target *target)
 	int retval = ERROR_OK;
 	enum target_state prev_target_state = target->state;
 	struct cortex_m_common *cortex_m = target_to_cm(target);
-	struct adiv5_dap *swjdp = cortex_m->armv7m.arm.dap;
 
-    dap_ap_select(swjdp, 3); //swjdp->apsel=3;
 	/* Read from Debug Halting Control and Status Register */
-	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m->dcb_dhcsr);
+	retval = target_cs_dbg_rd32( target,DCB_DHCSR, &cortex_m->dcb_dhcsr);
 	if (retval != ERROR_OK) {
 		target->state = TARGET_UNKNOWN;
 		return retval;
@@ -516,7 +507,7 @@ static int cortex_m_poll(struct target *target)
 		detected_failure = ERROR_FAIL;
 
 		/* refresh status bits */
-		retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m->dcb_dhcsr);
+		retval = target_cs_dbg_rd32( target,DCB_DHCSR, &cortex_m->dcb_dhcsr);
 		if (retval != ERROR_OK)
 			return retval;
 	}
@@ -620,7 +611,6 @@ static int cortex_m_halt(struct target *target)
 static int cortex_m_soft_reset_halt(struct target *target)
 {
 	struct cortex_m_common *cortex_m = target_to_cm(target);
-	struct adiv5_dap *swjdp = cortex_m->armv7m.arm.dap;
 	uint32_t dcb_dhcsr = 0;
 	int retval, timeout = 0;
 
@@ -631,13 +621,13 @@ static int cortex_m_soft_reset_halt(struct target *target)
 	LOG_WARNING("soft_reset_halt is deprecated, please use 'reset halt' instead.");
 
 	/* Enter debug state on reset; restore DEMCR in endreset_event() */
-	retval = mem_ap_write_u32(swjdp, DCB_DEMCR,
+	retval = target_cs_dbg_queued_wr32( target,DCB_DEMCR,
 			TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* Request a core-only reset */
-	retval = mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR,
+	retval = target_cs_dbg_wr32( target, NVIC_AIRCR,
 			AIRCR_VECTKEY | AIRCR_VECTRESET);
 	if (retval != ERROR_OK)
 		return retval;
@@ -647,9 +637,9 @@ static int cortex_m_soft_reset_halt(struct target *target)
 	register_cache_invalidate(cortex_m->armv7m.arm.core_cache);
 
 	while (timeout < 100) {
-		retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &dcb_dhcsr);
+		retval = target_cs_dbg_rd32( target,DCB_DHCSR, &dcb_dhcsr);
 		if (retval == ERROR_OK) {
-			retval = mem_ap_read_atomic_u32(swjdp, NVIC_DFSR,
+			retval = target_cs_dbg_rd32( target,NVIC_DFSR,
 					&cortex_m->nvic_dfsr);
 			if (retval != ERROR_OK)
 				return retval;
@@ -791,7 +781,6 @@ static int cortex_m_step(struct target *target, int current,
 {
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 	struct armv7m_common *armv7m = &cortex_m->armv7m;
-	struct adiv5_dap *swjdp = armv7m->arm.dap;
 	struct breakpoint *breakpoint = NULL;
 	struct reg *pc = armv7m->arm.pc;
 	bool bkpt_inst_found = false;
@@ -893,7 +882,7 @@ static int cortex_m_step(struct target *target, int current,
 
 					/* Wait for pending handlers to complete or timeout */
 					do {
-						retval = mem_ap_read_atomic_u32(swjdp,
+						retval = target_cs_dbg_rd32( target,
 								DCB_DHCSR,
 								&cortex_m->dcb_dhcsr);
 						if (retval != ERROR_OK) {
@@ -928,7 +917,7 @@ static int cortex_m_step(struct target *target, int current,
 		}
 	}
 
-	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m->dcb_dhcsr);
+	retval = target_cs_dbg_rd32( target,DCB_DHCSR, &cortex_m->dcb_dhcsr);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -964,7 +953,7 @@ static int cortex_m_step(struct target *target, int current,
 static int cortex_m_assert_reset(struct target *target)
 {
 	struct cortex_m_common *cortex_m = target_to_cm(target);
-	struct adiv5_dap *swjdp = cortex_m->armv7m.arm.dap;
+	struct adiv5_dap *dap = target_cs_to_dap(target);
 	enum cortex_m_soft_reset_config reset_config = cortex_m->soft_reset_config;
 
 	LOG_DEBUG("target->state: %s",
@@ -995,11 +984,11 @@ static int cortex_m_assert_reset(struct target *target)
 
 	/* Enable debug requests */
 	int retval;
-	retval = mem_ap_read_atomic_u32(swjdp, DCB_DHCSR, &cortex_m->dcb_dhcsr);
+	retval = target_cs_dbg_rd32( target,DCB_DHCSR, &cortex_m->dcb_dhcsr);
 	if (retval != ERROR_OK)
 		return retval;
 	if (!(cortex_m->dcb_dhcsr & C_DEBUGEN)) {
-		retval = mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_DEBUGEN);
+		retval = target_cs_dbg_queued_wr32( target,DCB_DHCSR, DBGKEY | C_DEBUGEN);
 		if (retval != ERROR_OK)
 			return retval;
 	}
@@ -1007,19 +996,19 @@ static int cortex_m_assert_reset(struct target *target)
 	/* If the processor is sleeping in a WFI or WFE instruction, the
 	 * C_HALT bit must be asserted to regain control */
 	if (cortex_m->dcb_dhcsr & S_SLEEP) {
-		retval = mem_ap_write_u32(swjdp, DCB_DHCSR, DBGKEY | C_HALT | C_DEBUGEN);
+		retval = target_cs_dbg_queued_wr32( target,DCB_DHCSR, DBGKEY | C_HALT | C_DEBUGEN);
 		if (retval != ERROR_OK)
 			return retval;
 	}
 
-	retval = mem_ap_write_u32(swjdp, DCB_DCRDR, 0);
+	retval = target_cs_dbg_queued_wr32( target,DCB_DCRDR, 0);
 	if (retval != ERROR_OK)
 		return retval;
 
 	if (!target->reset_halt) {
 		/* Set/Clear C_MASKINTS in a separate operation */
 		if (cortex_m->dcb_dhcsr & C_MASKINTS) {
-			retval = mem_ap_write_atomic_u32(swjdp, DCB_DHCSR,
+			retval = target_cs_dbg_wr32( target, DCB_DHCSR,
 					DBGKEY | C_DEBUGEN | C_HALT);
 			if (retval != ERROR_OK)
 				return retval;
@@ -1037,7 +1026,7 @@ static int cortex_m_assert_reset(struct target *target)
 		 * bad vector table entries.  Should this include MMERR or
 		 * other flags too?
 		 */
-		retval = mem_ap_write_atomic_u32(swjdp, DCB_DEMCR,
+		retval = target_cs_dbg_wr32( target, DCB_DEMCR,
 				TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
 		if (retval != ERROR_OK)
 			return retval;
@@ -1053,7 +1042,7 @@ static int cortex_m_assert_reset(struct target *target)
 		 * This has the disadvantage of not resetting the peripherals, so a
 		 * reset-init event handler is needed to perform any peripheral resets.
 		 */
-		retval = mem_ap_write_atomic_u32(swjdp, NVIC_AIRCR,
+		retval = target_cs_dbg_wr32( target, NVIC_AIRCR,
 				AIRCR_VECTKEY | ((reset_config == CORTEX_M_RESET_SYSRESETREQ)
 				? AIRCR_SYSRESETREQ : AIRCR_VECTRESET));
 		if (retval != ERROR_OK)
@@ -1073,7 +1062,7 @@ static int cortex_m_assert_reset(struct target *target)
 		  During the intialization CDBGPWRUPACK is pulled low and we
 		  need to wait for it to be set to 1 again.
 		*/
-		retval = dap_dp_poll_register(swjdp, DP_CTRL_STAT,
+		retval = dap_dp_poll_register(dap, DP_CTRL_STAT,
 					      CDBGPWRUPACK, CDBGPWRUPACK, 100);
 		if (retval != ERROR_OK) {
 			LOG_ERROR("Failed waitnig for CDBGPWRUPACK");
@@ -1086,7 +1075,7 @@ static int cortex_m_assert_reset(struct target *target)
 			 * after reset) on LM3S6918 -- Michael Schwingen
 			 */
 			uint32_t tmp;
-			retval = mem_ap_read_atomic_u32(swjdp, NVIC_AIRCR, &tmp);
+			retval = target_cs_dbg_rd32( target,NVIC_AIRCR, &tmp);
 			if (retval != ERROR_OK)
 				return retval;
 		}
@@ -1144,7 +1133,7 @@ int cortex_m_set_breakpoint(struct target *target, struct breakpoint *breakpoint
 		hilo = (breakpoint->address & 0x2) ? FPCR_REPLACE_BKPT_HIGH : FPCR_REPLACE_BKPT_LOW;
 		comparator_list[fp_num].used = 1;
 		comparator_list[fp_num].fpcr_value = (breakpoint->address & 0x1FFFFFFC) | hilo | 1;
-		target_write_u32(target, comparator_list[fp_num].fpcr_address,
+		target_cs_dbg_wr32( target, comparator_list[fp_num].fpcr_address,
 			comparator_list[fp_num].fpcr_value);
 		LOG_DEBUG("fpc_num %i fpcr_value 0x%" PRIx32 "",
 			fp_num,
@@ -1218,7 +1207,7 @@ int cortex_m_unset_breakpoint(struct target *target, struct breakpoint *breakpoi
 		}
 		comparator_list[fp_num].used = 0;
 		comparator_list[fp_num].fpcr_value = 0;
-		target_write_u32(target, comparator_list[fp_num].fpcr_address,
+		target_cs_dbg_wr32( target, comparator_list[fp_num].fpcr_address,
 			comparator_list[fp_num].fpcr_value);
 	} else {
 		/* restore original instruction (kept in target endianness) */
@@ -1335,11 +1324,11 @@ int cortex_m_set_watchpoint(struct target *target, struct watchpoint *watchpoint
 	watchpoint->set = dwt_num + 1;
 
 	comparator->comp = watchpoint->address;
-	target_write_u32(target, comparator->dwt_comparator_address + 0,
+	target_cs_dbg_wr32( target, comparator->dwt_comparator_address + 0,
 		comparator->comp);
 
 	comparator->mask = mask;
-	target_write_u32(target, comparator->dwt_comparator_address + 4,
+	target_cs_dbg_wr32( target, comparator->dwt_comparator_address + 4,
 		comparator->mask);
 
 	switch (watchpoint->rw) {
@@ -1353,7 +1342,7 @@ int cortex_m_set_watchpoint(struct target *target, struct watchpoint *watchpoint
 			comparator->function = 7;
 			break;
 	}
-	target_write_u32(target, comparator->dwt_comparator_address + 8,
+	target_cs_dbg_wr32( target, comparator->dwt_comparator_address + 8,
 		comparator->function);
 
 	LOG_DEBUG("Watchpoint (ID %d) DWT%d 0x%08x 0x%x 0x%05x",
@@ -1390,7 +1379,7 @@ int cortex_m_unset_watchpoint(struct target *target, struct watchpoint *watchpoi
 	comparator = cortex_m->dwt_comparator_list + dwt_num;
 	comparator->used = 0;
 	comparator->function = 0;
-	target_write_u32(target, comparator->dwt_comparator_address + 8,
+	target_cs_dbg_wr32( target, comparator->dwt_comparator_address + 8,
 		comparator->function);
 
 	watchpoint->set = false;
@@ -1606,7 +1595,6 @@ static int cortex_m_read_memory(struct target *target, uint32_t address,
 	uint32_t size, uint32_t count, uint8_t *buffer)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = armv7m->arm.dap;
 
 	if (armv7m->arm.is_armv6m) {
 		/* armv6m does not handle unaligned memory access */
@@ -1614,14 +1602,13 @@ static int cortex_m_read_memory(struct target *target, uint32_t address,
 			return ERROR_TARGET_UNALIGNED_ACCESS;
 	}
 
-	return mem_ap_read(swjdp, buffer, size, count, address, true);
+	return target_cs_dbg_rd_bulk( target, address, size, count, buffer);
 }
 
 static int cortex_m_write_memory(struct target *target, uint32_t address,
 	uint32_t size, uint32_t count, const uint8_t *buffer)
 {
 	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = armv7m->arm.dap;
 
 	if (armv7m->arm.is_armv6m) {
 		/* armv6m does not handle unaligned memory access */
@@ -1629,7 +1616,7 @@ static int cortex_m_write_memory(struct target *target, uint32_t address,
 			return ERROR_TARGET_UNALIGNED_ACCESS;
 	}
 
-	return mem_ap_write(swjdp, buffer, size, count, address, true);
+	return target_cs_dbg_wr_bulk( target, address, size, count,buffer );
 }
 
 static int cortex_m_init_target(struct command_context *cmd_ctx,
@@ -1721,7 +1708,7 @@ void cortex_m_dwt_setup(struct cortex_m_common *cm, struct target *target)
 	struct cortex_m_dwt_comparator *comparator;
 	int reg, i;
 
-	target_read_u32(target, DWT_CTRL, &dwtcr);
+	target_cs_dbg_rd32( target, DWT_CTRL, &dwtcr);
 	if (!dwtcr) {
 		LOG_DEBUG("no DWT");
 		return;
@@ -1766,7 +1753,7 @@ fail1:
 				dwt_comp + 3 * i + j);
 
 		/* make sure we clear any watchpoints enabled on the target */
-		target_write_u32(target, comparator->dwt_comparator_address + 8, 0);
+		target_cs_dbg_wr32( target, comparator->dwt_comparator_address + 8, 0);
 	}
 
 	*register_get_last_cache_p(&target->reg_cache) = cache;
@@ -1794,14 +1781,12 @@ int cortex_m_examine(struct target *target)
 	uint32_t cpuid, fpcr, mvfr0, mvfr1;
 	int i;
 	struct cortex_m_common *cortex_m = target_to_cm(target);
-	struct adiv5_dap *swjdp = cortex_m->armv7m.arm.dap;
 	struct armv7m_common *armv7m = target_to_armv7m(target);
 
 	/* stlink shares the examine handler but does not support
 	 * all its calls */
 	if (!armv7m->stlink) {
-		dap_ap_select(swjdp, 3);//swjdp->apsel=3;
-		retval = ahbap_debugport_init(swjdp);
+		retval = target_cs_debugport_init(target);
 		if (retval != ERROR_OK)
 			return retval;
 	}
@@ -1810,21 +1795,23 @@ int cortex_m_examine(struct target *target)
 		target_set_examined(target);
 
 		/* Read from Device Identification Registers */
-		retval = target_read_u32(target, CPUID, &cpuid);
+		retval = target_cs_dbg_rd32( target, CPUID, &cpuid);
 		if (retval != ERROR_OK)
 			return retval;
 
 		/* Get CPU Type */
 		i = (cpuid >> 4) & 0xf;
 
-		LOG_DEBUG("Cortex-M%d r%" PRId8 "p%" PRId8 " processor detected",
-				i, (uint8_t)((cpuid >> 20) & 0xf), (uint8_t)((cpuid >> 0) & 0xf));
-		LOG_DEBUG("cpuid: 0x%8.8" PRIx32 "", cpuid);
+		LOG_DEBUG("cpuid: 0x%08" PRIx32 " Cortex-M%d r%" PRId8 "p%" PRId8 " processor detected",
+			  cpuid,
+			  i,
+			  (uint8_t)((cpuid >> 20) & 0xf),
+			  (uint8_t)((cpuid >> 0) & 0xf));
 
 		/* test for floating point feature on cortex-m4 */
 		if (i == 4) {
-			target_read_u32(target, MVFR0, &mvfr0);
-			target_read_u32(target, MVFR1, &mvfr1);
+			target_cs_dbg_rd32( target, MVFR0, &mvfr0);
+			target_cs_dbg_rd32( target, MVFR1, &mvfr1);
 
 			if ((mvfr0 == MVFR0_DEFAULT_M4) && (mvfr1 == MVFR1_DEFAULT_M4)) {
 				LOG_DEBUG("Cortex-M%d floating point feature FPv4_SP found", i);
@@ -1836,14 +1823,22 @@ int cortex_m_examine(struct target *target)
 		}
 
 		if ((!armv7m->stlink) && (i == 4 || i == 3)) {
-			/* Cortex-M3/M4 has 4096 bytes autoincrement range */
+			/* This orginal comment is *WRONG*
+			 *   Cortex-M3/M4 has 4096 bytes autoincrement range
+			 * TRUTH:
+			 *   Some do, some do not ..
+			 *   there is no means to query the dap
+			 *   and determine the actual implimentation.
+			 */
+#if 0
 			armv7m->arm.dap->tar_autoincr_block = (1 << 12);
+#endif
 		}
 
 		/* NOTE: FPB and DWT are both optional. */
 
 		/* Setup FPB */
-		target_read_u32(target, FP_CTRL, &fpcr);
+		target_cs_dbg_rd32( target, FP_CTRL, &fpcr);
 		cortex_m->auto_bp_type = 1;
 		/* bits [14:12] and [7:4] */
 		cortex_m->fp_num_code = ((fpcr >> 8) & 0x70) | ((fpcr >> 4) & 0xF);
@@ -1859,7 +1854,7 @@ int cortex_m_examine(struct target *target)
 			cortex_m->fp_comparator_list[i].fpcr_address = FP_COMP0 + 4 * i;
 
 			/* make sure we clear any breakpoints enabled on the target */
-			target_write_u32(target, cortex_m->fp_comparator_list[i].fpcr_address, 0);
+			target_cs_dbg_wr32( target, cortex_m->fp_comparator_list[i].fpcr_address, 0);
 		}
 		LOG_DEBUG("FPB fpcr 0x%" PRIx32 ", numcode %i, numlit %i",
 			fpcr,
@@ -1881,13 +1876,11 @@ int cortex_m_examine(struct target *target)
 
 static int cortex_m_dcc_read(struct target *target, uint8_t *value, uint8_t *ctrl)
 {
-	struct armv7m_common *armv7m = target_to_armv7m(target);
-	struct adiv5_dap *swjdp = armv7m->arm.dap;
 	uint16_t dcrdr;
 	uint8_t buf[2];
 	int retval;
 
-	retval = mem_ap_read(swjdp, buf, 2, 1, DCB_DCRDR, false);
+	retval = target_cs_dbg_rd_bulk_noinc( target,  DCB_DCRDR, 2, 1, buf);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1901,7 +1894,7 @@ static int cortex_m_dcc_read(struct target *target, uint8_t *value, uint8_t *ctr
 	 * signify we have read data */
 	if (dcrdr & (1 << 0)) {
 		target_buffer_set_u16(target, buf, 0);
-		retval = mem_ap_write(swjdp, buf, 2, 1, DCB_DCRDR, false);
+		retval = target_cs_dbg_wr_bulk_noinc( target, DCB_DCRDR, 2, 1, buf);
 		if (retval != ERROR_OK)
 			return retval;
 	}
@@ -1989,33 +1982,18 @@ static int cortex_m_init_arch_info(struct target *target,
 	return ERROR_OK;
 }
 
-void cortex_m_connect_dap(struct target *target, struct adiv5_dap *dap)
-{
-	struct armv7m_common *armv7m = target_to_armv7m(target);
-
-	/* Leave (only) generic DAP stuff for debugport_init(); */
-	dap->memaccess_tck = 8;
-
-	/* Cortex-M3/M4 has 4096 bytes autoincrement range
-	 * but set a safe default to 1024 to support Cortex-M0
-	 * this will be changed in cortex_m3_examine if a M3/M4 is detected */
-	dap->tar_autoincr_block = (1 << 10);
-
-	armv7m->arm.dap = dap;
-}
-
 static int cortex_m_target_create(struct target *target, Jim_Interp *interp)
 {
 	struct cortex_m_common *cortex_m = calloc(1, sizeof(struct cortex_m_common));
 
-	cortex_m->common_magic = CORTEX_M_COMMON_MAGIC;
+	cortex_m->common_cortex_m_magic = CORTEX_M_COMMON_MAGIC;
 	cortex_m_init_arch_info(target, cortex_m);
 
 	/* If it's not set, assume transport select is not swd. Nothing sets up the JTAG DAP so we have to. */
 	if (!global_dap)
 		global_dap = adiv5_jtag_dap_new(target->tap);
 
-	cortex_m_connect_dap(target, global_dap);
+	target_cs_connect_dap(target, global_dap);
 
 	return ERROR_OK;
 }
@@ -2025,7 +2003,7 @@ static int cortex_m_target_create(struct target *target, Jim_Interp *interp)
 static int cortex_m_verify_pointer(struct command_context *cmd_ctx,
 	struct cortex_m_common *cm)
 {
-	if (cm->common_magic != CORTEX_M_COMMON_MAGIC) {
+	if ( !is_cortex_m(cm)) {
 		command_print(cmd_ctx, "target is not a Cortex-M");
 		return ERROR_TARGET_INVALID;
 	}
@@ -2057,7 +2035,6 @@ COMMAND_HANDLER(handle_cortex_m_vector_catch_command)
 	struct target *target = get_current_target(CMD_CTX);
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 	struct armv7m_common *armv7m = &cortex_m->armv7m;
-	struct adiv5_dap *swjdp = armv7m->arm.dap;
 	uint32_t demcr = 0;
 	int retval;
 
@@ -2065,7 +2042,7 @@ COMMAND_HANDLER(handle_cortex_m_vector_catch_command)
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &demcr);
+	retval = target_cs_dbg_rd32( target,DCB_DEMCR, &demcr);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -2102,10 +2079,10 @@ write:
 		demcr |= catch;
 
 		/* write, but don't assume it stuck (why not??) */
-		retval = mem_ap_write_u32(swjdp, DCB_DEMCR, demcr);
+		retval = target_cs_dbg_queued_wr32( target,DCB_DEMCR, demcr);
 		if (retval != ERROR_OK)
 			return retval;
-		retval = mem_ap_read_atomic_u32(swjdp, DCB_DEMCR, &demcr);
+		retval = target_cs_dbg_rd32( target, DCB_DEMCR, &demcr);
 		if (retval != ERROR_OK)
 			return retval;
 
diff --git a/src/target/cortex_m.h b/src/target/cortex_m.h
index 046426d..8b873bc 100755
--- a/src/target/cortex_m.h
+++ b/src/target/cortex_m.h
@@ -162,7 +162,7 @@ enum cortex_m_isrmasking_mode {
 };
 
 struct cortex_m_common {
-	int common_magic;
+	int common_cortex_m_magic;
 
 	/* Context information */
 	uint32_t dcb_dhcsr;
@@ -190,11 +190,30 @@ struct cortex_m_common {
 	struct armv7m_common armv7m;
 };
 
+static inline struct armv7m_common *cortex_m_to_armv7m( struct cortex_m_common *c )
+{
+	return &(c->armv7m);
+}
+
+static inline struct arm *cortex_m_to_arm( struct cortex_m_common *c )
+{
+	return armv7m_to_arm( cortex_m_to_armv7m(c) );
+}
+
+
+static inline bool is_cortex_m( struct cortex_m_common *cortex_m )
+{
+	return (CORTEX_M_COMMON_MAGIC == cortex_m->common_cortex_m_magic);
+}
+
 static inline struct cortex_m_common *
 target_to_cm(struct target *target)
 {
-	return container_of(target->arch_info,
+	struct cortex_m_common *r;
+	r = container_of(target->arch_info,
 			struct cortex_m_common, armv7m);
+	assert( is_cortex_m(r));
+	return r;
 }
 
 int cortex_m_examine(struct target *target);
diff --git a/src/target/hla_target.c b/src/target/hla_target.c
index b3cbfec..e6a0ab8 100755
--- a/src/target/hla_target.c
+++ b/src/target/hla_target.c
@@ -41,7 +41,8 @@
 #include "arm_semihosting.h"
 #include "target_request.h"
 
-#define savedDCRDR  dbgbase  /* FIXME: using target->dbgbase to preserve DCRDR */
+// #define savedDCRDR  dbgbase  /* FIXME: using target->dbgbase to preserve DCRDR */
+#define savedDCRDR  FIXME_hla_target_thing
 
 #define ARMV7M_SCS_DCRSR	DCB_DCRSR
 #define ARMV7M_SCS_DCRDR	DCB_DCRDR
diff --git a/src/target/mematts.c b/src/target/mematts.c
index a2f3465..fec0baf 100644
--- a/src/target/mematts.c
+++ b/src/target/mematts.c
@@ -26,7 +26,41 @@
 #include "log.h"
 #include "jim-subcmd.h"
 
-static struct memattr_name *mem_att_list;
+static const struct memattr_name *mem_att_list;
+
+const struct memattr_name builtin_names[] = {
+#define STD_NAME( N, R ) {  .is_deleteable = false, .name = N, .alias_of = NULL, .next = NULL, TARGET_ADDR_INITIALIZER( .tmplate, 0, R, 0 ) }
+	STD_NAME(  "default",  TA_ROUTE_DEFAULT ),
+	STD_NAME(  "phys"   ,  TA_ROUTE_PHYSICAL ),
+	/* secondary name */
+	STD_NAME(  "physical",  TA_ROUTE_PHYSICAL ),
+	STD_NAME(  "virt"    ,  TA_ROUTE_VIRTUAL  ),
+
+	/* these generally route to an ARM DAP port */
+	STD_NAME( "sysbus"   , TA_ROUTE_sysbus ),
+	STD_NAME( "dbgbus"   , TA_ROUTE_dbgbus ),
+	STD_NAME( "membus"   , TA_ROUTE_membus ),
+	
+	/* secondary name */
+	STD_NAME(  "virtual" ,  TA_ROUTE_VIRTUAL  ),
+	STD_NAME(  "arm.tz"  ,  TA_ROUTE_arm_tz ),
+	STD_NAME(  "arm.hyp"  ,  TA_ROUTE_arm_hyp ),
+	STD_NAME(  "arm.el0"  ,  TA_ROUTE_arm_el0 ),
+	STD_NAME(  "arm.el1"  ,  TA_ROUTE_arm_el1 ),
+	STD_NAME(  "arm.el2"  ,  TA_ROUTE_arm_el2 ),
+	STD_NAME(  "arm.el3"  ,  TA_ROUTE_arm_el3 ),
+
+	STD_NAME(  "arm.dap0"  ,  TA_ROUTE_arm_dap0 ),
+	STD_NAME(  "arm.dap1"  ,  TA_ROUTE_arm_dap1 ),
+	STD_NAME(  "arm.dap2"  ,  TA_ROUTE_arm_dap2 ),
+	STD_NAME(  "arm.dap3"  ,  TA_ROUTE_arm_dap3 ),
+	STD_NAME(  "arm.dap4"  ,  TA_ROUTE_arm_dap4 ),
+	STD_NAME(  "arm.dap5"  ,  TA_ROUTE_arm_dap5 ),
+	STD_NAME(  "arm.dap6"  ,  TA_ROUTE_arm_dap6 ),
+	STD_NAME(  "arm.dap7"  ,  TA_ROUTE_arm_dap7 ),
+	/* terminate */
+	{ .name = NULL }
+};
 
 static int att_notfound( Jim_GetOptInfo *goi, const char *name )
 {
@@ -34,170 +68,147 @@ static int att_notfound( Jim_GetOptInfo *goi, const char *name )
 	return JIM_ERR;
 }
 
-/* this is here for code readablity - by reducing the number of cast occurances */
-static struct memattr_name *_mem_att_unconst(const struct memattr_name *p)
-{
-	return (struct memattr_name *)(p);
-}
 
-/* this is here for code readablity - by reducing the number of cast occurances */
-static struct memattr_name **_mem_att_unconst_pp(const struct memattr_name **  pp)
+const struct memattr_name *mem_att_find_name( const char *name )
 {
-	return (struct memattr_name **)(pp);
-}
-
-static struct memattr_name *_mem_att_find_name_RAW( const char *name, int len )
-{
-	struct memattr_name *p;
-
-	if( len < 0 ){
-		len = strlen(name);
-	}
-	p = mem_att_list;
-	while(p){
-		if( 0 == strncmp( name, p->name, len ) ){
-			if( p->name[ len ] == 0 ){
-				break;
-			}
+	const struct memattr_name *p;
+	for( p = &builtin_names[0] ; p->name ; p++ ){
+		if( 0 == strcmp( name, p->name ) ){
+			return p;
 		}
-		p = _mem_att_unconst(p->next);
 	}
-	return p;
-}
-
-const struct memattr_name *mem_att_find_name_RAW( const char *name, int len )
-{
-	return _mem_att_find_name_RAW( name,len );
-}
+	/* search list */
 
-
-static struct memattr_name *_mem_att_find_name( const char *name, int len )
-{
-	struct memattr_name *p;
-
-	p = _mem_att_find_name_RAW( name, len );
-	if( p ){
-		/* resolve all aliases */
-		while( p->alias_of != NULL ){
-			p = _mem_att_unconst(p->alias_of);
+	p = mem_att_list;
+	while( p ){
+		if( 0 == strcmp( name, p->name ) ){
+			return p;
 		}
+		p = p->next;
 	}
-	return p;
-}
 
-const struct memattr_name *mem_att_find_name( const char *name, int len )
-{
-	return _mem_att_find_name( name, len );
+	return p;
 }
 
 int mem_att_create( const char *name, const struct target_addr *addr )
 {
-	struct memattr_name *att;
+	const struct memattr_name *att;
+	struct memattr_name *new_att;
 
 	/* remove const */
-	att = _mem_att_find_name( name, -1 );
+	att = mem_att_find_name( name );
 	if( att ){
 		/* duplicate! */
 		return ERROR_FAIL;
 	}
-	att = calloc( sizeof(*att) , 1 );
-	if( !att ){
+	new_att = calloc( sizeof(*new_att) , 1 );
+	if( !new_att ){
 		return ERROR_FAIL;
 	}
-	TARGET_ADDR_INIT( &(att->tmplate),0 );
-	att->tmplate = *addr;
-	att->name = strdup( name );
-	if( att->name == NULL ){
-		free(att);
+	TARGET_ADDR_INIT( &(new_att->tmplate),0 );
+	new_att->is_deleteable = true;
+	new_att->tmplate = *addr;
+	new_att->name = strdup( name );
+	if( new_att->name == NULL ){
+		free(new_att);
 		return ERROR_FAIL;
 	}
 
 
-	att->next = mem_att_list;
-	mem_att_list = att;
+	new_att->next = mem_att_list;
+	mem_att_list =new_att;
 	return ERROR_OK;
 }
 
+ 
 int mem_att_create_alias( const char *from_name, const char *to_name )
 {
-	struct memattr_name *att_new;
-	struct memattr_name *att_old;
+	struct memattr_name *alias_att;
+	const struct memattr_name *to_att;
 
-	att_new = _mem_att_find_name(from_name,-1);
-	att_old = _mem_att_find_name_RAW(to_name,-1);
-	if( (att_new != NULL) || (att_old == NULL) ){
+	/* the to name must exist */
+	to_att = mem_att_find_name( from_name );
+	if( to_att ){
+		/* this cannot exist */
 		return ERROR_FAIL;
 	}
 
-	att_new = calloc( sizeof(*att_new), 1 );
-	if( att_new == NULL ){
+	/* this must exist */
+	to_att = mem_att_find_name( to_name );
+	if( to_att == NULL ){
 		return ERROR_FAIL;
 	}
-	att_new->name = strdup( from_name );
-	if( att_new->name == NULL ){
-		free( att_new );
+	
+	alias_att = calloc( sizeof(*alias_att), 1 );
+	if( alias_att == NULL ){
+		return ERROR_FAIL;
+	}
+	alias_att->name = strdup( from_name );
+	if( alias_att->name == NULL ){
+		free( alias_att );
 		return ERROR_FAIL;
 	}
 
-	att_new->alias_of = att_old;
-	att_new->next = mem_att_list;
-	mem_att_list = att_new;
+	alias_att->is_deleteable = true;
+	alias_att->alias_of = to_att;
+	alias_att->next = mem_att_list;
+	mem_att_list = alias_att;
 	return ERROR_OK;
 }
 
 
 
 /* Delete any attribute and delete any aliases of the attribute */
-void mem_att_delete( const struct memattr_name *_att )
+void mem_att_delete( const struct memattr_name *delete_me )
 {
-	struct memattr_name **pp;
-	struct memattr_name *att;
+	struct memattr_name const **pp;
 
-	att = _mem_att_unconst(_att);
-	/*
-	 * Consider:   (A) -> (B) -> (C)
-	 * And         (D) -> (E) -> (C)
-	 *
-	 * Delete (C) - all are deleted.
-	 * Delete (B), only (A) and (B) are deleted.
-	 * Delete (A), only (A) is deleted.
-	 *
-	 * Hence, we have this "again" label.
-	 * And we use recursion to help.
-	 */
+	if( !delete_me->is_deleteable  ){
+		/* we do not delete it */
+		return;
+	}
 
+	/* First: we must delete all aliases of this item */
+	/* The alias may be pointing at this root item */
 
- again:
+ try_again:
 	pp = &(mem_att_list);
-	/* FIRST: delete any aliases of this item */
-	/* this makes sure we have no dangling alias pointers! */
 	while( *pp ){
-		if( (*pp)->alias_of == att ){
-			/* delete the alias name first */
+		if( (*pp)->alias_of == delete_me ){
 			mem_att_delete( *pp );
-			/* then search again */
-			goto again;
+			/* be cause we have a single linked list
+			 * our place in the chain may have broke
+			 * So we restart our scan 
+			 */
+			goto try_again;
 		}
-		pp = _mem_att_unconst_pp( (&( (*pp)->next )) );
+		pp = (struct memattr_name const **)(&( (*pp)->next ));
 	}
 
-	/* now search the list of normal names */
+	/* Now find this item */
 	pp = &(mem_att_list);
-	/* find it */
 	while( *pp ){
-		if( *pp == att ){
+		if( (*pp) == delete_me ){
 			break;
+		} else {
+			pp = (struct memattr_name const **)(&( (*pp)->next ));
 		}
-		pp = _mem_att_unconst_pp( (&( (*pp)->next )) );
 	}
-	/* if found, delete it */
-	if( *pp ){
-		*pp = _mem_att_unconst( att->next );
-		free( (void *)(att->name) );
-		att->name = NULL;
-		memset( att, 0, sizeof(*att) );
-		free((void *)att);
+
+	if( *pp == NULL ){
+		/* Something is wrong */
+		LOG_ERROR("memory attribute %s not found in list\n", delete_me->name );
+		return;
 	}
+	
+
+	/* remove from list */
+	*((struct memattr_name **)pp) = (struct memattr_name *)((*pp)->next);
+
+	
+	free( (void *)(delete_me->name) );
+	memset( (void *)(delete_me), 0, sizeof(*delete_me) );
+	free((void *)delete_me);
 }
 
 
@@ -238,10 +249,20 @@ const struct memattr_name *mem_att_find_addr( const struct target_addr *pAddr )
 
 static int jim_mematt_deleteall(Jim_Interp *_interp, int argc, Jim_Obj *const *argv )
 {
+	const struct memattr_name *p;
 	Jim_SetEmptyResult( _interp );
 	/* just loop till they are all deleted */
-	while( mem_att_list ){
-		mem_att_delete( mem_att_list );
+ again:
+	p = mem_att_list;
+	while( p ){
+		if( p->is_deleteable ){
+			mem_att_delete( p );
+			/* because we just broke the list
+			 * we need to start from the top 
+			 */
+			goto again;
+		}
+		p = p->next;
 	}
 	return JIM_OK;
 }
@@ -287,59 +308,57 @@ static int jim_mematt_delete(Jim_Interp *_interp, int argc, Jim_Obj *const *argv
 	}
 
 	/* get the unaliased name */
-	delete_me = mem_att_find_name_RAW( name,-1 );
+	delete_me = mem_att_find_name( name );
 	e = JIM_OK;
 	if( delete_me ){
+		if( !(delete_me->is_deleteable) ){
+			if( force ){
+				/* Ignore errors */
+				return JIM_ERR;
+			}
+			Jim_SetResultFormatted( goi.interp, "%s: builtin cannot delete", name );
+			return JIM_ERR;
+		}
 		mem_att_delete( delete_me );
+	}
+
+	if( !force ){
+		att_notfound( &goi, name );
+		e = JIM_ERR;
 	} else {
-		if( !force ){
-			att_notfound( &goi, name );
-			e = JIM_ERR;
-		}
+		e = JIM_OK;
 	}
 	return e;
 }
 
-static const Jim_Nvp nvp_routenames[] = {
-	{ "default", .value = TA_ROUTE_DEFAULT },
-	{ "phys"   , .value = TA_ROUTE_PHYSICAL },
-	/* secondary name */
-	{ "physical", .value = TA_ROUTE_PHYSICAL },
-	{ "virt"    , .value = TA_ROUTE_VIRTUAL  },
-	/* secondary name */
-	{ "virtual" , .value = TA_ROUTE_VIRTUAL  },
-	{ "arm.tz"  , .value = TA_ROUTE_arm_tz },
-	{ "arm.hyp"  , .value = TA_ROUTE_arm_hyp },
-	{ "arm.el0"  , .value = TA_ROUTE_arm_el0 },
-	{ "arm.el1"  , .value = TA_ROUTE_arm_el1 },
-	{ "arm.el2"  , .value = TA_ROUTE_arm_el2 },
-	{ "arm.el3"  , .value = TA_ROUTE_arm_el3 },
-
-	{ "arm.dap0"  , .value = TA_ROUTE_arm_dap0 },
-	{ "arm.dap1"  , .value = TA_ROUTE_arm_dap1 },
-	{ "arm.dap2"  , .value = TA_ROUTE_arm_dap2 },
-	{ "arm.dap3"  , .value = TA_ROUTE_arm_dap3 },
-	{ "arm.dap4"  , .value = TA_ROUTE_arm_dap4 },
-	{ "arm.dap5"  , .value = TA_ROUTE_arm_dap5 },
-	{ "arm.dap6"  , .value = TA_ROUTE_arm_dap6 },
-	{ "arm.dap7"  , .value = TA_ROUTE_arm_dap7 },
-	/* terminate */
-	{ .name = NULL, .value = -1 }
-};
-
 const char *target_addr_routename( const struct target_addr *pAddr )
 {
-	const Jim_Nvp *p;
+	int x;
+	const struct memattr_name *p;
 
-	p = Jim_Nvp_value2name_simple( nvp_routenames, pAddr->route );
-	if( p == NULL ){
-		return "unknown";
-	} else {
-		return p->name;
+	/* is this a user defined item? */
+	p = mem_att_list;
+	while( p ){
+		if( (p->tmplate.route == pAddr->route) &&
+			(p->tmplate.route_attributes == pAddr->route_attributes) ){
+			/* found */
+			return p->name;
+		}
+		p = p->next;
 	}
-}
 
 
+	/* try the builtin-list, since all attributes are 0 
+	 * we ignore the attribute value */
+	for( x = 0 ; builtin_names[x].name ; x++ ){
+		if( builtin_names[x].tmplate.route == pAddr->route ){
+			return builtin_names[x].name;
+		}
+	}
+
+	/* Give up */
+	return "unknown";
+}
 
 static int jim_mematt_create( Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
@@ -348,7 +367,8 @@ static int jim_mematt_create( Jim_Interp *interp, int argc, Jim_Obj *const *argv
 	char *name;
 	jim_wide attribute;
 	struct target_addr tmp;
-	Jim_Nvp *route_nvp;
+	const struct memattr_name *p;
+	char *cp;
 
 	Jim_GetOpt_Setup(&goi, interp, argc, argv);
 	/*
@@ -363,26 +383,36 @@ static int jim_mematt_create( Jim_Interp *interp, int argc, Jim_Obj *const *argv
 	}
 
 	const struct memattr_name *att;
-	att = mem_att_find_name( name, -1 );
+	att = mem_att_find_name( name );
 
 	if( att != NULL ){
 		Jim_SetResultFormatted(goi.interp,"%s: already exists", name);
 		return JIM_ERR;
 	}
 
-	e = Jim_GetOpt_Nvp( &goi, nvp_routenames, &route_nvp );
+	e = Jim_GetOpt_String( &goi, &cp, NULL );
 	if( e != JIM_OK ){
-		Jim_GetOpt_NvpUnknown( &goi, nvp_routenames, 0 );
+		Jim_SetResultFormatted(goi.interp, "?route ..");
 		return e;
 	}
+	for( p = &builtin_names[0] ; p->name ; p++ ){
+		if( 0 == strcmp( cp, p->name ) ){
+			break;
+		}
+	}
+	if( p->name == NULL ){
+		/* not found */
+		Jim_SetResultFormatted(goi.interp,"?route: %s unknown", cp );
+		return JIM_ERR;
+	}
+
 	e = Jim_GetOpt_Wide( &goi, &attribute );
 	if( e != JIM_OK ){
 		return e;
 	}
-
+	
 	TARGET_ADDR_INIT( &tmp, 0 );
-	tmp.addr  = 0;
-	tmp.route = (enum ta_route)(route_nvp->value);
+	tmp = p->tmplate;
 	tmp.route_attributes = attribute;
 
 	e = mem_att_create( name, &tmp );
@@ -414,7 +444,7 @@ static int jim_mematt_alias(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 		return e;
 	}
 	const struct memattr_name *att;
-	att = mem_att_find_name( cp_to, -1 );
+	att = mem_att_find_name( cp_to );
 	if( att == NULL ){
 		return att_notfound( &goi, cp_to );
 	}
@@ -449,7 +479,7 @@ static int jim_mematt_name_cget( Jim_Interp *_interp, int argc, Jim_Obj *const *
 	char *name;
 	const struct memattr_name *resolved;
 	const struct memattr_name *raw_att;
-
+	
 	Jim_GetOpt_Setup(&goi, _interp, argc, argv);
 
 	e = Jim_GetOpt_Nvp( &goi, mematt_cget_names, &cget );
@@ -463,7 +493,7 @@ static int jim_mematt_name_cget( Jim_Interp *_interp, int argc, Jim_Obj *const *
 		return e;
 	}
 
-	raw_att = mem_att_find_name_RAW( name, -1 );
+	raw_att = mem_att_find_name( name );
 	if( raw_att == NULL ){
 		return att_notfound( &goi, name );
 	}
@@ -505,19 +535,31 @@ static int jim_mematt_show( Jim_Interp *interp, int argc, Jim_Obj *const *argv )
 	Jim_Obj *result;
 	char buf[100];
 
-	Jim_SetResultString( interp,      "Name      | Route     | Attribute\n", -1 );
+	Jim_SetResultString( interp, "===========+=======+===========+===============\n",-1);
  	result = Jim_GetResult(interp);
-	Jim_AppendString( interp, result, "==========+===========+=============\n",-1);
-
+	Jim_AppendString( interp, result, "Name       | DelOk | Route     | Attribute\n", -1 );
+	Jim_AppendString( interp, result, "[builtin]==+=======+===========+===============\n",-1);
+
+	for( a = builtin_names ; a->name ; a++ ){
+		snprintf( buf, sizeof(buf), "%-10s | %3d   | %-10s | 0x%08llx\n",
+				  a->name,
+				  a->is_deleteable,
+				  target_addr_routename( &(a->tmplate) ),
+				  (unsigned long long)(a->tmplate.route_attributes) );
+		Jim_AppendString( interp, result, buf, -1 );
+	}
+	
+	Jim_AppendString( interp, result, "[user-def]=+=======+===========+===============\n",-1);
 	a = mem_att_list;
 	while( a ){
 		if( a->alias_of == NULL ){
-			snprintf( buf, sizeof(buf), "%-10s| %-10s| 0x%08x\n",
+			snprintf( buf, sizeof(buf), "%-10s | %3d   | %-10s | 0x%08llx\n",
 					  a->name,
+					  a->is_deleteable,
 					  target_addr_routename( &(a->tmplate) ),
-					  a->tmplate.route_attributes );
+				  (unsigned long long)(a->tmplate.route_attributes) );
 		} else {
-			snprintf( buf, sizeof(buf), "%-10s| %-10s| %s\n",
+			snprintf( buf, sizeof(buf), "%-10s |   1   | %-10s | %s\n",
 					  a->name,
 					  "alias_of:",
 					  a->alias_of->name );
@@ -525,6 +567,7 @@ static int jim_mematt_show( Jim_Interp *interp, int argc, Jim_Obj *const *argv )
 		Jim_AppendString( interp, result, buf, -1 );
 		a = a->next;
 	}
+	Jim_AppendString( interp, result, "===========+=======+===========+===============\n",-1);
 	return JIM_OK;
 }
 
@@ -619,21 +662,21 @@ int mematt_register_commands(struct command_context *cmd_ctx)
 
 
 
-int parse_memory_address( struct command_invocation *cmd, unsigned *argn, struct target_addr *addr )
+
+int parse_memory_address( struct target_addr *pAddr, const char *str1, const char *str2 )
 {
 	const struct memattr_name *atts;
 	const char *cp;
 	const char *cp2;
+#define MAX_ATTNAME 30
+	char namebuf[MAX_ATTNAME];
+	
 	int r;
 
+
 	/* NOTE: ALSO SEE:  Jim_GetOpt_Addr() */
 	/* always initialize */
-	TARGET_ADDR_INIT( addr, 0 );
-
-	if( *argn >= CMD_ARGC ){
-		command_print( cmd->ctx, "Missing address parameter\n");
-		return ERROR_COMMAND_SYNTAX_ERROR;
-	}
+	TARGET_ADDR_INIT( pAddr, 0 );
 
 	/* support these:
 	 *    address
@@ -643,55 +686,106 @@ int parse_memory_address( struct command_invocation *cmd, unsigned *argn, struct
 	 *   C++   class::member
 	 */
 
+	namebuf[0] = 0;
 	/* Assume *NONE* */
 	atts = NULL;
 	/* look for ':' */
-	cp = CMD_ARGV[ *argn ];
-	*argn += 1;
+	
+	cp = str1;
 	cp2 = strchr( cp, ':' );
 	if( cp2 ){
-		if( cp2[1] == ':' ){
-			/* NOPE: this is a C++ symbol  */
+		/* how long is this thing */
+		r = (int)(cp2-cp);
+		r++; /* +1 for null */
+		/* is it reasonable size */
+		if( r > MAX_ATTNAME ){
+			/* no name is that big */
 			cp2 = NULL;
+		} else {
+			/* copy the name over */
+			memcpy( namebuf, cp, r-1 );
+			namebuf[r-1] = 0;
 		}
 	}
 
 	/* Is there a prefix? */
 	if( cp2 ){
-		/* Yes: In this form NAME:SOMETHING */
-		atts = mem_att_find_name( cp, cp2 - cp );
+		/* this is lauterbach style */
+		/* In the form NAME:SOMETHING */
+		atts = mem_att_find_name( namebuf );
 		/* go past the ":" */
+		if( atts == NULL ){
+			/* not an att */
+			return -1;
+		}
+		if( atts != NULL ){
+			*pAddr = atts->tmplate;
+		}
 		cp = cp2+1;
-	} else {
-		/* We have NAME <whitespace> SOMETHING */
-		/* not lauterbach style, test what we have */
-		atts = mem_att_find_name( cp, -1 );
-		if( atts ){
-			/* CONFIRMED:  name whitespace address */
-			if( *argn >= CMD_ARGC ){
-				command_print( cmd->ctx, "Missing address parameter\n");
-				return ERROR_COMMAND_SYNTAX_ERROR;
-			}
-			cp = CMD_ARGV[ *argn ];
-			*argn += 1;
+		r = parse_u64(cp,&(pAddr->addr) );
+		if( r == ERROR_OK ){
+
+			/* we consumed *ONE* parameter */
+			return 1;
+		} else {
+			/* item 1 is an error */
+			return -1;
 		}
 	}
 
-	if( atts == NULL ){
-		/* assume default */
-		TARGET_ADDR_INIT( addr, 0 );
-	} else {
-		/* initialize via the specified attributes */
-		*addr = atts->tmplate;
-		addr->addr = 0;
+	
+	/* We have MAYBENAME <whitespace> SOMETHING */
+	/* this is not lauterbach style, test what we have */
+
+	/* is this an attribute? */
+	atts = mem_att_find_name( cp );
+	if( atts ){
+		/* yes - use this */
+		*pAddr = atts->tmplate;
+
+		if( str2 == NULL ){
+			/* something is wrong */
+			return -1;
+		}
+		
+		r = parse_u64(str2,&(pAddr->addr));
+		if( r == ERROR_OK ){
+			/* we consumed 2 things */
+			return 2;
+		} else {
+			/* the 2nd item is an error */
+			return -2;
+		}
 	}
 
 	/* Parse the number .. */
 	/* Try the foobar NUMBER */
-	r = parse_u64( cp, &(addr->addr) );
-	if( r != ERROR_OK ){
-		/* FUTURE: FIXME: This could be a *SYMBOL */
-		/* and that symbol could have an attribute */
+	r = parse_u64( str1, &(pAddr->addr) );
+	if( r == ERROR_OK ){
+		return 1;
+	} else {
+		return -1;
+	}
+}
+
+bool target_addr_IsDapRoute( const struct target_addr *pAddr )
+{
+	int r;
+	bool b;
+	r = target_addr_to_dap_port( pAddr );
+	if( r >= 0 ){
+		b = true;
+	} else {
+		switch( pAddr->route ){
+		default:
+			b = false;
+			break;
+		case TA_ROUTE_membus:
+		case TA_ROUTE_sysbus:
+		case TA_ROUTE_dbgbus:
+			b = true;
+			break;
+		}
 	}
-	return r;
+	return b;
 }
diff --git a/src/target/target.c b/src/target/target.c
index ffa8633..736084f 100755
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -56,6 +56,8 @@
 #include "image.h"
 #include "rtos/rtos.h"
 #include "transport/transport.h"
+#include "arm.h"
+#include "arm_adi_v5.h"
 
 /* default halt wait timeout (ms) */
 #define DEFAULT_HALT_TIMEOUT 5000
@@ -137,6 +139,7 @@ static struct target_event_callback *target_event_callbacks;
 static struct target_timer_callback *target_timer_callbacks;
 static const int polling_interval = 100;
 
+
 static const Jim_Nvp nvp_assert[] = {
 	{ .name = "assert", NVP_ASSERT },
 	{ .name = "deassert", NVP_DEASSERT },
@@ -489,13 +492,16 @@ int target_poll(struct target *target)
 	/* We can't poll until after examine */
 	if (!target_was_examined(target)) {
 		/* Fail silently lest we pollute the log */
+		LOG_INFO("poll - not examined");
 		return ERROR_FAIL;
 	}
 
 	retval = target->type->poll(target);
-	if (retval != ERROR_OK)
+	if (retval != ERROR_OK){
+		LOG_INFO("poll - fails");
 		return retval;
-
+	}
+	
 	if (target->halt_issued) {
 		if (target->state == TARGET_HALTED)
 			target->halt_issued = false;
@@ -1998,7 +2004,7 @@ int target64_read_buffer(struct target *target, const struct target_addr *pAddr,
 	return target->type->pIo64_api->read_buffer( target, pAddr, size, buffer );
 }
 
-int target64_read_buffer_default(struct target *target, struct target_addr *pAddr, uint64_t count, uint8_t *buffer)
+int target64_read_buffer_default(struct target *target, const struct target_addr *pAddr, uint64_t count, uint8_t *buffer)
 {
 	uint64_t size;
 	struct target_addr tmp_addr;
@@ -2874,6 +2880,8 @@ COMMAND_HANDLER(handle_md_command)
 	if (CMD_ARGC < 1)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
+	argn = 0;
+	
 	unsigned size = 0;
 	switch (CMD_NAME[2]) {
 	/* FIXME: Add 64bit support? what letter do we use? */
@@ -2890,10 +2898,16 @@ COMMAND_HANDLER(handle_md_command)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
-	argn = 0;
-	r = parse_memory_address(cmd, &argn, &addr );
-	if( r != ERROR_OK ){
-		return r;
+	r = parse_memory_address( &addr, CMD_ARGV[0], CMD_ARGV[1] );
+	switch(r){
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+		break;
+	case 1:
+	case 2:
+		argn = r;
+		break;
+		/* we used 1 */
 	}
 
 	int (*fn)(struct target *target,
@@ -2914,7 +2928,17 @@ COMMAND_HANDLER(handle_md_command)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 
+	if( count > 16385 ){
+		command_print(CMD_CTX,"unreasonable size to dump (>16K?) %d\n",
+					  (int)(count));
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
 	uint8_t *buffer = calloc(count, size);
+	if( !buffer ){
+		command_print(CMD_CTX, "No memory for transfer size: %d\n",
+					  (int)(size));
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
 
 	struct target *target = get_current_target(CMD_CTX);
 	int retval = fn(target, &addr, size, count, buffer);
@@ -2996,9 +3020,16 @@ COMMAND_HANDLER(handle_mw_command)
 	target_write_fn fn;
 
 	argn = 0;
-	r = parse_memory_address(cmd, &argn, &addr );
-	if( r != ERROR_OK ){
-		return r;
+	
+	r = parse_memory_address( &addr, CMD_ARGV[0],CMD_ARGV[1] );
+	switch(r){
+	default:
+		return ERROR_COMMAND_SYNTAX_ERROR;
+		break;
+	case 1:
+	case 2:
+		argn = r;
+		break;
 	}
 
 	if( addr.route == TA_ROUTE_PHYSICAL ){
@@ -3181,9 +3212,13 @@ COMMAND_HANDLER(handle_dump_image_command)
 	argn = 0;
 	filename = CMD_ARGV[argn];
 	argn++;
-	r = parse_memory_address(cmd, &argn, &addr );
-	if( r != ERROR_OK ){
-		return r;
+	r = parse_memory_address(&addr, CMD_ARGV[argn], CMD_ARGV[argn+1] );
+	switch(r){
+		return ERROR_COMMAND_SYNTAX_ERROR;
+		break;
+	case 1:
+	case 2:
+		argn += r;
 	}
 
 	COMMAND_PARSE_NUMBER(u64, CMD_ARGV[argn], size);
@@ -4295,8 +4330,11 @@ enum target_cfg_param {
 	TCFG_ENDIAN,
 	TCFG_COREID,
 	TCFG_CHAIN_POSITION,
-	TCFG_DBGBASE,
-	TCFG_CTIBASE,
+	TCFG_DEBUG_BASE,
+	TCFG_CTI_BASE,
+	TCFG_MEM_AP,
+	TCFG_SYS_AP,
+	
 	TCFG_RTOS,
 };
 
@@ -4310,12 +4348,66 @@ static Jim_Nvp nvp_config_opts[] = {
 	{ .name = "-endian" ,          .value = TCFG_ENDIAN },
 	{ .name = "-coreid",           .value = TCFG_COREID },
 	{ .name = "-chain-position",   .value = TCFG_CHAIN_POSITION },
-	{ .name = "-dbgbase",          .value = TCFG_DBGBASE },
-	{ .name = "-ctibase",          .value = TCFG_CTIBASE },
+	{ .name = "-dbg-base",         .value = TCFG_DEBUG_BASE },
+	{ .name = "-cti-base",         .value = TCFG_CTI_BASE },
+	{ .name = "-mem-ap",           .value = TCFG_MEM_AP },
+	{ .name = "-sys-ap",           .value = TCFG_SYS_AP },
 	{ .name = "-rtos",             .value = TCFG_RTOS },
 	{ .name = NULL, .value = -1 }
 };
 
+static int coresight_setting( Jim_GetOptInfo *goi,
+							  struct target *target,
+							  const Jim_Nvp *n )
+{
+	int e;
+	struct coresight_address *a;
+	struct coresight_settings *cs;
+
+	cs = target_to_coresight(target);
+	if( !cs ){
+		Jim_SetResultString( goi->interp, "no memory",-1);
+		return JIM_ERR;
+	}
+
+	a = NULL;
+	switch(n->value){
+	default:
+	err:
+		Jim_SetResultString( goi->interp, "Unknown option",-1 );
+		return JIM_ERR;
+		break;
+	case TCFG_MEM_AP:
+		a = &(cs->membus);
+		break;
+	case TCFG_SYS_AP:
+		a = &(cs->sysbus);
+		break;
+	case TCFG_CTI_BASE:
+		a = &(cs->cti);
+		break;
+	case TCFG_DEBUG_BASE:
+		a = &(cs->dbgbus);
+		break;
+	}
+
+	if( a == NULL ){
+		goto err;
+	}
+	if (goi->isconfigure) {
+		e = Jim_GetOpt_Addr( goi, &(a->addr) );
+		if (e != JIM_OK)
+			return e;
+		a->is_forced = true;
+	}
+	e = JIM_OK;
+	Jim_SetResultString(goi->interp, target_addr2str1( target, &(a->addr) ),-1 );
+	return e;
+}
+
+  
+
+
 static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 {
 	Jim_Nvp *n;
@@ -4323,6 +4415,8 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 	jim_wide w;
 	int e;
 
+	e = JIM_OK;
+	
 	/* parse config or cget options ... */
 	while (goi->argc > 0) {
 		Jim_SetEmptyResult(goi->interp);
@@ -4338,56 +4432,65 @@ static int target_configure(Jim_GetOptInfo *goi, struct target *target)
 			}
 			if (e == JIM_ERR) {
 				/* An error */
-				return e;
+				goto err;
 			}
-			/* otherwise we 'continue' below */
 		}
 		e = Jim_GetOpt_Nvp(goi, nvp_config_opts, &n);
 		if (e != JIM_OK) {
 			Jim_GetOpt_NvpUnknown(goi, nvp_config_opts, 0);
-			return e;
+			goto err;
 		}
 		switch (n->value) {
+		default:
+			LOG_ERROR("internal error: Cfg Item: %d not supported", (int)(n->value) );
+			e = JIM_ERR;
+			goto err;
+			break;
 		case TCFG_TYPE:
 			/* not setable */
 			if (goi->isconfigure) {
 				Jim_SetResultFormatted(goi->interp,
 						"not settable: %s", n->name);
-				return JIM_ERR;
+				e = JIM_ERR;
+				goto err;
 			} else {
 no_params:
 				if (goi->argc != 0) {
 					Jim_WrongNumArgs(goi->interp,
 							goi->argc, goi->argv,
 							"NO PARAMS");
-					return JIM_ERR;
+					e = JIM_ERR;
+					goto err;
 				}
 			}
 			Jim_SetResultString(goi->interp,
-					target_type_name(target), -1);
+								target_type_name(target), -1);
 			/* loop for more */
 			break;
 		case TCFG_EVENT:
 			if (goi->argc == 0) {
 				Jim_WrongNumArgs(goi->interp, goi->argc, goi->argv, "-event ?event-name? ...");
-				return JIM_ERR;
+				e = JIM_ERR;
+				goto err;
 			}
 
 			e = Jim_GetOpt_Nvp(goi, nvp_target_event, &n);
 			if (e != JIM_OK) {
 				Jim_GetOpt_NvpUnknown(goi, nvp_target_event, 1);
-				return e;
+				goto err;
 			}
 
 			if (goi->isconfigure) {
 				if (goi->argc != 1) {
 					Jim_WrongNumArgs(goi->interp, goi->argc, goi->argv, "-event ?event-name? ?EVENT-BODY?");
-					return JIM_ERR;
+					e = JIM_ERR;
+					goto err;
 				}
 			} else {
 				if (goi->argc != 0) {
 					Jim_WrongNumArgs(goi->interp, goi->argc, goi->argv, "-event ?event-name?");
-					return JIM_ERR;
+					e = JIM_ERR;
+					goto err;
 				}
 			}
 
@@ -4449,7 +4552,7 @@ no_params:
 				target_free_all_working_areas(target);
 				e = Jim_GetOpt_Wide(goi, &w);
 				if (e != JIM_OK)
-					return e;
+					goto err;
 				target->working_area_virt = w;
 				target->working_area_virt_spec = true;
 			} else {
@@ -4465,7 +4568,7 @@ no_params:
 				target_free_all_working_areas(target);
 				e = Jim_GetOpt_Wide(goi, &w);
 				if (e != JIM_OK)
-					return e;
+					goto err;
 				target->working_area_phys = w;
 				target->working_area_phys_spec = true;
 			} else {
@@ -4481,7 +4584,7 @@ no_params:
 				target_free_all_working_areas(target);
 				e = Jim_GetOpt_Wide(goi, &w);
 				if (e != JIM_OK)
-					return e;
+					goto err;
 				target->working_area_size = w;
 			} else {
 				if (goi->argc != 0)
@@ -4496,7 +4599,7 @@ no_params:
 				target_free_all_working_areas(target);
 				e = Jim_GetOpt_Wide(goi, &w);
 				if (e != JIM_OK)
-					return e;
+					goto err;
 				/* make this exactly 1 or 0 */
 				target->backup_working_area = (!!w);
 			} else {
@@ -4513,7 +4616,7 @@ no_params:
 				e = Jim_GetOpt_Nvp(goi, nvp_target_endian, &n);
 				if (e != JIM_OK) {
 					Jim_GetOpt_NvpUnknown(goi, nvp_target_endian, 1);
-					return e;
+					goto err;
 				}
 				target->endianness = n->value;
 			} else {
@@ -4533,7 +4636,7 @@ no_params:
 			if (goi->isconfigure) {
 				e = Jim_GetOpt_Wide(goi, &w);
 				if (e != JIM_OK)
-					return e;
+					goto err;
 				target->coreid = (int32_t)w;
 			} else {
 				if (goi->argc != 0)
@@ -4553,7 +4656,7 @@ no_params:
 					return e;
 				tap = jtag_tap_by_jim_obj(goi->interp, o_t);
 				if (tap == NULL)
-					return JIM_ERR;
+					goto err;
 				/* make this exactly 1 or 0 */
 				target->tap = tap;
 			} else {
@@ -4563,49 +4666,31 @@ no_params:
 			Jim_SetResultString(goi->interp, target->tap->dotted_name, -1);
 			/* loop for more e*/
 			break;
-		case TCFG_DBGBASE:
-			if (goi->isconfigure) {
-				e = Jim_GetOpt_Wide(goi, &w);
-				if (e != JIM_OK)
-					return e;
-				target->dbgbase = (uint32_t)w;
-				target->dbgbase_set = true;
-			} else {
-				if (goi->argc != 0)
-					goto no_params;
-			}
-			Jim_SetResult(goi->interp, Jim_NewWideObj(goi->interp, target->dbgbase));
-			/* loop for more */
-			break;
-		case TCFG_CTIBASE:
-			if (goi->isconfigure) {
-				e = Jim_GetOpt_Wide(goi, &w);
-				if (e != JIM_OK)
-					return e;
-				target->ctibase = (uint32_t)w;
+		case TCFG_DEBUG_BASE:
+		case TCFG_CTI_BASE:
+		case TCFG_MEM_AP:
+		case TCFG_SYS_AP:
+			e = coresight_setting( goi, target, n );
+			if( e != JIM_OK ){
+				goto err;
 			} else {
-				if (goi->argc != 0)
-					goto no_params;
+				/* loop for more */
 			}
-			Jim_SetResult(goi->interp, Jim_NewWideObj(goi->interp, target->ctibase));
-			/* loop for more */
 			break;
-
 		case TCFG_RTOS:
 			/* RTOS */
-			{
-				int result = rtos_create(goi, target);
-				if (result != JIM_OK)
-					return result;
+			e = rtos_create(goi, target);
+			if ( e != JIM_OK){
+				goto err;
 			}
 			/* loop for more */
 			break;
 		}
 	} /* while (goi->argc) */
-
-
-		/* done - we return */
-	return JIM_OK;
+	e = JIM_OK;
+ err:
+	/* done - we return */
+	return e;
 }
 
 static int jim_target_configure(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
diff --git a/src/target/target.h b/src/target/target.h
index b968bbb..e2a1183 100755
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -124,6 +124,7 @@ enum target_register_class {
 	REG_CLASS_GENERAL,
 };
 
+
 /* target_type.h contains the full definition of struct target_type */
 struct target {
 	struct target_type *type;			/* target type definition (name, access functions) */
@@ -179,11 +180,6 @@ struct target {
 	bool halt_issued;					/* did we transition to halted state? */
 	long long halt_issued_time;			/* Note time when halt was issued */
 
-	bool dbgbase_set;					/* By default the debug base is not set */
-	uint32_t dbgbase;					/* Really ARM Cortex-A specific option, but there is no
-										 * system in place to support target specific options
-										 * currently. */
-	uint32_t ctibase;					/* added to support ARMv8 by SQU*/
 	
 	bool is_64b;						/* Is target in 64bit or 32bit mode? */
 	bool force_addr64;					/* if true, force all addresses into 64bit mode */
@@ -212,7 +208,19 @@ struct target {
 	*/
 #define TARGET_ADDR2STR_SIZE 40
 	char adr2str1[ TARGET_ADDR2STR_SIZE ]; 
-	char adr2str2[ TARGET_ADDR2STR_SIZE ]; 
+	char adr2str2[ TARGET_ADDR2STR_SIZE ];
+
+	/** The Target's ARM coresight API
+	 *
+	 * NOTE: Do not think 'coresight means ARM'
+	 *
+	 * Qualcomm Hexagon V6 is coresight
+	 * Cadence/Tensilica LX5 - is coresight
+	 * And there are other non-ARM cpus using this
+	 */
+	struct coresight_settings *HIDE_coresight;
+
+	uint32_t FIXME_hla_target_thing;
 };
 
 struct target_list {
@@ -321,6 +329,8 @@ int target_unregister_event_callback(
 		enum target_event event, void *priv),
 		void *priv);
 
+
+
 /* Poll the status of the target, detect any error conditions and report them.
  *
  * Also note that this fn will clear such error conditions, so a subsequent
@@ -356,7 +366,6 @@ int target_call_timer_callbacks(void);
  */
 int target_call_timer_callbacks_now(void);
 
-struct target *get_current_target(struct command_context *cmd_ctx);
 struct target *get_target(const char *id);
 
 /**
@@ -631,7 +640,7 @@ int target32_write_buffer(struct target *target,
 		uint64_t address, uint64_t size, const uint8_t *buffer);
 
 
-int target64_read_buffer_default(struct target *target, struct target_addr *pAddr, uint64_t count, uint8_t *buffer);
+int target64_read_buffer_default(struct target *target, const struct target_addr *pAddr, uint64_t count, uint8_t *buffer);
 
 int target64_read_buffer(struct target *target,
 		const struct target_addr *pAddr, uint64_t size, uint8_t *buffer);
diff --git a/src/target/target64.c b/src/target/target64.c
new file mode 100755
index 0000000..af8bbea
--- /dev/null
+++ b/src/target/target64.c
@@ -0,0 +1,48 @@
+/***************************************************************************
+ *                                                                         *
+ *   Copyright (C) 2016 Eric Katzfey                                       *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
+ ***************************************************************************/
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+
+#include <helper/time_support.h>
+#include <jtag/jtag.h>
+#include <flash/nor/core.h>
+
+#include "target.h"
+#include "target_type.h"
+#include "target_request.h"
+#include "breakpoints.h"
+#include "register.h"
+#include "trace.h"
+#include "image.h"
+
+void target_addr_route_not_supported( struct target *target, const struct target_addr *pAddr )
+{
+	LOG_ERROR( "%s(%s): unsupported address route: %s/0x%08x (%s)",
+		   target->name,
+		   target_type_name( target),
+		   target_addr_routename( pAddr );
+		   pAddr->route_attributes,
+		   target_addr2str1( target, pAddr ) );
+}
+
+	     
diff --git a/src/target/target_addr.h b/src/target/target_addr.h
index 738c857..c139c78 100755
--- a/src/target/target_addr.h
+++ b/src/target/target_addr.h
@@ -3,30 +3,53 @@
 
 #include <jim.h>
 #include "jim-nvp.h"
+struct target;
 
 enum ta_route {
 	/* first 3 are generic */
-	TA_ROUTE_DEFAULT,
+	TA_ROUTE_DEFAULT = 0, /* default must be 0 */
 	TA_ROUTE_PHYSICAL,
 	TA_ROUTE_VIRTUAL,
 
-	
-	TA_ROUTE_arm_tz   = 0x100,
-	TA_ROUTE_arm_hyp  = 0x101,
-	TA_ROUTE_arm_el0  = 0x102,
-	TA_ROUTE_arm_el1  = 0x103,
-	TA_ROUTE_arm_el2  = 0x104,
-	TA_ROUTE_arm_el3  = 0x105,
-	TA_ROUTE_arm_dap0 = 0x200,
-	TA_ROUTE_arm_dap1 = 0x201,
-	TA_ROUTE_arm_dap2 = 0x202,
-	TA_ROUTE_arm_dap3 = 0x203,
-	TA_ROUTE_arm_dap4 = 0x204,
-	TA_ROUTE_arm_dap5 = 0x205,
-	TA_ROUTE_arm_dap6 = 0x206,
-	TA_ROUTE_arm_dap7 = 0x207,
+	/** MEMBUS = the same as the cpu
+	 *          always physical address
+	 *          sometimes faster then the CPU method
+	 */
+	TA_ROUTE_membus  = 0x100,
+	/** SYSBUS = the main or global bus on the chip
+	 * 
+	 * On simple chips this is the same as the membus
+	 * On complex chips, this is something else
+	 */
+	TA_ROUTE_sysbus  = 0x101,
+	/** DBGBUS = 90% ARM specific
+	 * 
+	 * This is the bus where the coresight registers
+	 * are defined for this chip. On simple chips
+	 * there is only one DBGBUS ... on complex chips
+	 * there can be *MANY* debug buses.
+	 */
+	TA_ROUTE_dbgbus  = 0x102,
+
+	/* ARM CPU access specific */
+	TA_ROUTE_arm_tz   = 0x200,
+	TA_ROUTE_arm_hyp  = 0x201,
+	TA_ROUTE_arm_el0  = 0x202,
+	TA_ROUTE_arm_el1  = 0x203,
+	TA_ROUTE_arm_el2  = 0x204,
+	TA_ROUTE_arm_el3  = 0x205,
+
+	/* ARM dap specific */
+	TA_ROUTE_arm_dap0 = 0x300,
+	TA_ROUTE_arm_dap1 = 0x301,
+	TA_ROUTE_arm_dap2 = 0x302,
+	TA_ROUTE_arm_dap3 = 0x303,
+	TA_ROUTE_arm_dap4 = 0x304,
+	TA_ROUTE_arm_dap5 = 0x305,
+	TA_ROUTE_arm_dap6 = 0x306,
+	TA_ROUTE_arm_dap7 = 0x307,
 	/* ... */
-	TA_ROUTE_arm_dap255 = 0x2ff,
+	TA_ROUTE_arm_dap255 = 0x3ff,
 
 	/* Non ARM solutions should add starting at 0x300 */
 
@@ -35,13 +58,24 @@ enum ta_route {
 
 
 struct target_addr {
+	/* WARNING BUG in GCC 4.9.2, fixed in GCC 5
+	 *
+	 * https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60784
+	 *
+	 * the order here matters ... otherwise GCC gives a warning.
+	 * I'm pedantic about warnings, so please check avoid changing
+	 * this order unless you test with various GCC versions.
+	 */
 	uint64_t addr;
+	uintptr_t route_attributes;
 	enum     ta_route route;
-	uint32_t route_attributes;
 };
 
+#define TARGET_ADDR_INITIALIZER( THING, ADDR, ROUTE, ATTRIBUTES ) \
+	THING.addr = ADDR, THING.route = ROUTE, THING.route_attributes = 0 
 
 struct memattr_name {
+	bool is_deleteable;
 	const char *name;
 	/* use: tmplate because template is C++ reserved word! */
 	struct target_addr tmplate;
@@ -55,17 +89,23 @@ int  mem_att_create( const char *name, const struct target_addr *tmplate );
 /* return ERROR_OK on successful creation */
 int  mem_att_create_alias( const char *alias_name, const char *base_name );
 
+/* Determine if this is an ARM DAP route or otherwise */
+bool target_addr_IsDapRoute( const struct target_addr *pAddr );
+
+/* return dap port number or -1 if not valid */
+int target_addr_to_dap_port( const struct target_addr *pAddr );
+	
 const char *target_addr_routename( const struct target_addr *pAddr );
 
 const struct memattr_name *mem_att_find_route( enum ta_route route );
 const struct memattr_name *mem_att_find_addr( const struct target_addr *pAddr );
-const struct memattr_name *mem_att_find_name( const char *name, int len );
-const struct memattr_name *mem_att_find_name_RAW( const char *name, int len );
+const struct memattr_name *mem_att_find_name( const char *name );
 int jim_memattribute( Jim_Interp *interp, int argc, Jim_Obj *const *argv);
 
 /* forward decloration */
 struct command_invocation;
-int parse_memory_address(struct command_invocation *cmd, unsigned *argc, struct target_addr *addr );
+
+int parse_memory_address( struct target_addr *puthere, const char *str1, const char *str2 );
 
 struct command_context;
 int mematt_register_commands(struct command_context *cmd_ctx);
@@ -76,4 +116,8 @@ extern struct target_addr *__target_addr_virt( struct target_addr *pAddr, uint64
 #define TARGET_ADDR_PHYS( P, A )  __target_addr_phys( P, A )
 #define TARGET_ADDR_VIRT( P, A )  __target_addr_virt( P, A )
 
+bool target_cs_isbus_avail( struct target *target, enum ta_route bus );
+/* common error message scheme for logging errors */
+void target_addr_route_not_supported( struct target *target, const struct target_addr *pAddr );
+
 #endif
diff --git a/src/target/target_type.h b/src/target/target_type.h
index 390666d..7a2b82e 100755
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -184,6 +184,7 @@ struct target_type {
 	 * Name of this type of target.  Do @b not access this
 	 * field directly, use target_type_name() instead.
 	 */
+	
 	const char *name;
 	const char *deprecated_name;
 
diff --git a/src/target/xscale.c b/src/target/xscale.c
index edb18fc..6794889 100755
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -796,7 +796,7 @@ static int xscale_arch_state(struct target *target)
 		"", "\n(processor reset)", "\n(trace buffer full)"
 	};
 
-	if (arm->common_magic != ARM_COMMON_MAGIC) {
+	if (arm->common_arm_magic != ARM_COMMON_MAGIC) {
 		LOG_ERROR("BUG: called for a non-ARMv4/5 target");
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
@@ -1621,7 +1621,7 @@ static int xscale_read_core_reg(struct target *target, struct reg *r,
 }
 
 static int xscale_write_core_reg(struct target *target, struct reg *r,
-	int num, enum arm_mode mode, uint32_t value)
+	int num, enum arm_mode mode, uint64_t value)
 {
 	/** \todo add debug handler support for core register writes */
 	LOG_ERROR("not implemented");
diff --git a/tcl/qualcomm/common/jtag_dap_cfg0.cfg b/tcl/qualcomm/common/jtag_dap_cfg0.cfg
new file mode 100644
index 0000000..bd9faec
--- /dev/null
+++ b/tcl/qualcomm/common/jtag_dap_cfg0.cfg
@@ -0,0 +1,15 @@
+# This is the 'standard A-family' dap configuration.
+# Generally all targets from msm8960 to (Before) msm8974
+#
+# Examples:  msm8960, apq8960, ipq8960,
+#
+# Generally identified by:
+#   (1) RPM is an ARM7TDMI-S
+#   (2) need to determine/document how RPM is connected
+#       option 1: in the jtag chain, option 2: jtag-ap
+
+source [find target/$_CHIPNAME/common.cfg]
+
+# FIX ME FIX ME 
+
+adapter_khz 100
diff --git a/tcl/qualcomm/common/jtag_dap_cfg1.cfg b/tcl/qualcomm/common/jtag_dap_cfg1.cfg
new file mode 100644
index 0000000..73cc5f0
--- /dev/null
+++ b/tcl/qualcomm/common/jtag_dap_cfg1.cfg
@@ -0,0 +1,19 @@
+# This is the 'standard b-family' dap configuration.
+# Generally all targets from msm8974 forward.
+#
+# This means:
+#    The RPM is a cortexM3, on Dap Port 3.
+source [find qualcomm/$_CHIPNAME/common.cfg]
+
+jtag newtap $_CHIPNAME dap -irlen 4  -expected-id $_DAP_TAPID -ignore-version
+jtag newtap $_CHIPNAME acc -irlen 5  -expected-id $_ACC_TAPID -ignore-version
+jtag newtap $_CHIPNAME msm -irlen 11 -expected-id $_MSM_TAPID -ignore-version
+
+jtag_ntrst_assert_width    10
+jtag_ntrst_delay           10
+adapter_nsrst_assert_width 1000
+adapter_nsrst_delay        10
+reset_config trst_and_srst
+
+adapter_khz 100
+
diff --git a/tcl/qualcomm/common/tcpip.ports.cfg b/tcl/qualcomm/common/tcpip.ports.cfg
new file mode 100644
index 0000000..78d5ce4
--- /dev/null
+++ b/tcl/qualcomm/common/tcpip.ports.cfg
@@ -0,0 +1,3 @@
+tcl_port        4001
+telnet_port     4002
+gdb_port        4010
diff --git a/tcl/qualcomm/msm8994/apps_core0.cfg b/tcl/qualcomm/msm8994/apps_core0.cfg
new file mode 100644
index 0000000..67108f4
--- /dev/null
+++ b/tcl/qualcomm/msm8994/apps_core0.cfg
@@ -0,0 +1,7 @@
+source [find qualcomm/$_CHIPNAME/common.cfg]
+
+set _appsX 0
+
+source [find qualcomm/$_CHIPNAME/apps_coreX.cfg]
+
+
diff --git a/tcl/qualcomm/msm8994/apps_coreX.cfg b/tcl/qualcomm/msm8994/apps_coreX.cfg
new file mode 100644
index 0000000..4d75c0e
--- /dev/null
+++ b/tcl/qualcomm/msm8994/apps_coreX.cfg
@@ -0,0 +1,12 @@
+# Assumption is the "_appsX" is define before sourcing this file.
+
+set _dbg_port arm.dap1
+set _mem_port arm.dap0
+set _axi_port arm.dap0
+
+set _appsNAME [format "apps%d" $_appsX]
+target create $_appsNAME cortex_a53 -chain-position $_CHIPNAME.dap
+$_appsNAME configure -dbg-base    [format "${_dbg_port}:0x%x" [expr 0x80810000 + ($_appsX * 0x200000)]]
+$_appsNAME configure -cti-base    [format "${_dbg_port}:0x%x" [expr 0x80820000 + ($_appsX * 0x100000)]]
+$_appsNAME configure -mem-ap      ${_mem_port}:0
+$_appsNAME configure -sys-ap      ${_axi_port}:0
diff --git a/tcl/qualcomm/msm8994/common.cfg b/tcl/qualcomm/msm8994/common.cfg
new file mode 100644
index 0000000..bd73094
--- /dev/null
+++ b/tcl/qualcomm/msm8994/common.cfg
@@ -0,0 +1,22 @@
+# -*- mode: tcl -*-
+if [ info exists _x8994x_ ] {
+	# Already done
+} else {
+	set _x8994x_ 1
+# Nothing to do */
+
+	set _CHIPNAME msm8994
+	set _DAP_TAPID  0x4BA00477
+	set _ACC_TAPID  0x000016DD
+	set _MSM_TAPID  0x009400e1
+	
+
+
+	mematt create dap.priv       arm.dap0 [expr (1<<28)+(3<<13)]
+	mematt create dap.secure     arm.dap0 [expr (2<<28)+(3<<13)]
+	mematt create dap.privsecure arm.dap0 [expr (3<<28)+(3<<13)]
+	mematt create dap.user       arm.dap0 [expr (0<<28)+(3<<13)]
+
+
+	
+}
diff --git a/tcl/qualcomm/msm8994/memmap.cfg b/tcl/qualcomm/msm8994/memmap.cfg
new file mode 100644
index 0000000..1a4e0ab
--- /dev/null
+++ b/tcl/qualcomm/msm8994/memmap.cfg
@@ -0,0 +1,260 @@
+#   Title: msm8994.std_memmap.cfg
+#   From:  "M8994AAAAANLGD10125038.1\common\tools\cmm\common\msm8994\std_memorymap.cmm
+#
+#   License: License
+#   Copyright 2016 Eric Katzfey             
+#   Description: This script setup the memory map for the target
+#   Input: None
+#   Output: None
+#   Usage: source [find qualcomm/msm8994/memmap.cfg]
+#
+#   Team: Qprobe(CoreBSP Products 8994)
+#
+#   Target: msm8994
+#
+
+set ADSP_EFS_start			0xF4E0000
+set ADSP_EFS_end			0xF4FFFFF
+set ADSP_EFS_size			0x20000
+set ADSP_EFS_log			"ADSP_EFS_log.bin"
+   
+   # ADSP SW Image - 25 MB
+set ADSP_SW_start			0xC800000
+set ADSP_SW_end				0xDBFFFFF
+set ADSP_SW_size			0x1400000
+set ADSP_SW_log				"ADSP_SW_log.bin"
+   
+set ADSP_TCM_start			0xFE400000
+set VIRT_START_ISLAND		0xF0000000
+set ISLAND_SIZE				0x80000
+   
+   # RPM Code RAM - 160 KB
+set CODERAM_start			0xFC100000
+set CODERAM_RPM_start		0x100000
+set CODERAM_end				0xFC127FFF
+set CODERAM_size			0x28000
+set CODERAM_log				"CODERAM_log.bin"
+set CODERAM_USB_log			"CODERAM.bin"
+   
+   # RPM Data RAM - 80 kB 
+set DATARAM_start			0xFC190000
+set DATARAM_RPM_start		0x190000
+set DATARAM_end				0xFC1A3FFF
+set DATARAM_size			0x10000
+set DATARAM_log				"DATARAM_log.bin"
+set DATARAM_USB_log			"DATARAM.bin"
+   
+   # RPM Message RAM - 16KB
+set MSGRAM_start			0xFC428000
+set MSGRAM_end				0xFC42FFFF
+set MSGRAM_size				0x4000
+set MSGRAM_log				"MSGRAM_log.bin"
+set MSGRAM_USB_log			"MSGRAM.bin"
+   
+   # Debug Image - 24 kB
+set SDI_start				0xFE800000
+set SDI_end					0xFE805FFF
+set SDI_size				0x6000
+set SDI_log					"SDI_log.bin"
+   
+set HLOS_1_start			0
+set HLOS_1_end				0x83FFFFF
+set HLOS_1_size				0x8400000
+set HLOS_1_log				"HLOS_1_log.bin"
+   
+set HLOS_2_start			0xFF00000
+set HLOS_2_end				0xFFFFFFF
+set HLOS_2_size				0x100000
+set HLOS_2_log				"HLOS_2_log.bin"
+   
+set HLOS_3_start			0x11000000
+set HLOS_3_end				0x1FFFFFFF
+set HLOS_3_size				0xEFFFFFF
+set HLOS_3_log				"HLOS_3_log.bin"
+   
+set HLOS_4_start			0x20000000
+set HLOS_4_end				0x7FFFFFFF
+set HLOS_4_size				0x5FFFFFFF
+set HLOS_4_log				"HLOS_4_log.bin"
+
+set MBA_Meta_start			0xD1FC000
+set MBA_Meta_end			0xD1FFFFF
+set MBA_Meta_size			0x4000
+set MBA_Meta_log			"MBA_Meta_log.bin"
+   
+set MBA_SW_start			0xD100000
+set MBA_SW_end				0xD1FBFFF
+set MBA_SW_size				0xFC000
+set MBA_SW_log				"MBA_SW_log.bin"
+   
+set MPSS_EFS_start			0xD900000
+set MPSS_EFS_end			0xDBFFFFF
+set MPSS_EFS_size			0x300000
+set MPSS_EFS_log			"MPSS_EFS_log.bin"
+   
+   # MPSS Image - 77 MB
+set MPSS_SW_start			0x7000000
+set MPSS_SW_end				0xC7FFFFF
+set MPSS_SW_size			0x5800000
+set MPSS_SW_log				"MPSS_SW_log.bin"
+   
+set MPSS_TCM_start			0xFCC00000
+   
+   # QDSS Image - 16 MB
+set QDSS_SW_start			0x10000000
+set QDSS_SW_end				0x10FFFFFF
+set QDSS_SW_size			0x1000000
+set QDSS_SW_log				"QDSS_SW_log.bin"
+   
+set SMEM_start				0xFA00000
+set SMEM_end				0xFBFFFFF
+set SMEM_size				0x200000
+set SMEM_log				"SMEM_log.bin"
+   
+set TZ_SW_start				0xFE806000
+set TZ_SW_end				0xFE83FFFF
+set TZ_SW_size				0x0003A000
+set TZ_SW_log				"TZ_SW_log.bin"
+   
+   # VSS Image - 5 MB
+set VSS_SW_start			0xF500000
+set VSS_SW_end				0xF9FFFFF
+set VSS_SW_size				0x0500000
+set VSS_SW_log				"Venus_SW_log.bin"
+   
+   # IPA memories and register spaces
+set IPA_IRAM_log			"IPA_IRAM.bin"
+set IPA_IRAM_IPA_start		0x0
+set IPA_IRAM_start			0xFD4F0000
+set IPA_IRAM_end			0xFD4F1FFF
+set IPA_IRAM_size			0x2000
+   
+set IPA_DRAM_log			"IPA_DRAM.bin"
+set IPA_DRAM_IPA_start		0x4000
+set IPA_DRAM_start			0xFD4F4000
+set IPA_DRAM_end			0xFD4F7EFF
+set IPA_DRAM_size			0x3F00
+   
+set IPA_SRAM_log			"IPA_SRAM.bin" 
+set IPA_SRAM_start			0xFD4E5100
+set IPA_SRAM_end			0xFD4E8FFF
+set IPA_SRAM_size			0x3F00
+   
+set IPA_MBOX_log			"IPA_MBOX.bin"
+set IPA_MBOX_start			0xFD4FA000
+set IPA_MBOX_end			0xFD4FA0FF
+set IPA_MBOX_size			0x100
+   
+set IPA_REG1_log			"IPA_REG1.bin"
+set IPA_REG1_start			0xFD4C4000
+set IPA_REG1_end			0xFD4D8FFF
+set IPA_REG1_size			0x15000
+   
+set IPA_REG2_log			"IPA_REG2.bin"
+set IPA_REG2_start			0xFD4E0000
+set IPA_REG2_end			0xFD4E4FFF
+set IPA_REG2_size			0x5000
+   
+set IPA_REG3_log			"IPA_REG3.bin"
+set IPA_REG3_start			0xFD4F8000
+set IPA_REG3_end			0xFD4F81FFF
+set IPA_REG3_size			0x2000
+   
+   # DDR memory - combined space used by all images
+set DDR_1_start				0x0
+set DDR_1_end				0x3FFFFFFF
+set DDR_1_size				0x40000000
+set DDR_1_log				"DDR0CS0.BIN"
+set DDR_1_USB_log			"DDRCS0_0.BIN"
+   
+set DDR_2_start				0x40000000
+set DDR_2_end				0x7FFFFFFF
+set DDR_2_size				0x40000000
+set DDR_2_log				"DDR1CS0.BIN"
+set DDR_2_USB_log			"DDRCS0_1.BIN"
+   
+set DDR_3_start				0x80000000
+set DDR_3_end				0xBFFFFFFF
+set DDR_3_size				0x40000000
+set DDR_3_log				"DDR0CS1.BIN"
+set DDR_3_USB_log			"DDRCS1_0.BIN"
+   
+set DDR_4_start				0xC0000000
+set DDR_4_end				0xF8000000
+set DDR_4_size				0x37FFFFFF
+set DDR_4_log				"DDR1CS1.BIN"
+set DDR_4_USB_log			"DDRCS1_1.BIN"
+   
+   # DDR memory sub-section - combined space used by all peripherals
+   # Saving this region will give all peripherals in one go
+set DDR_Periph_start		0x6300000
+set DDR_Periph_end			0x10000000
+set DDR_Periph_size			0x9CFFFFF
+set DDR_Periph_log			"DDRPeriph.bin"
+   
+   # This region is in the Shared IMEM block
+   # These are the cookies used to debug any image
+   # Allocation varies from target to target
+set DEBUG_REGION_START		0xFE87F934
+set DEBUG_REGION_END		0xFE87F94C
+set DEBUG_REGION_SIZE		0x18
+set DEBUG_COOKIE_VALUE		0x53444247
+set SBL1_DEBUG_COOKIE		0xFE87F944
+set MBA_DEBUG_COOKIE		0xFE87F938
+set MPSS_DEBUG_COOKIE		0xFE87F934
+set ADSP_DEBUG_COOKIE		0xFE87F93C
+set WCNSS_DEBUG_COOKIE		0xFE87F940
+set APPSBOOT_DEBUG_COOKIE	0xFE87F948
+set MDM_DEBUG_COOKIE		$MPSS_DEBUG_COOKIE
+   
+   # OCIMEM section
+set OCIMEM_start			0xFE800000
+set OCIMEM_end				0xFE87FFFF
+set OCIMEM_size				0x80000
+set OCIMEM_log				"OCIMEM.bin"
+set OCIMEM_USB_log			"OCIMEM.bin"
+   
+   # Shared IMEM section
+set SHARED_IMEM_start		0xFE87F000
+set SHARED_IMEM_end			0xFE87Ffff
+set SHARED_IMEM_size		0x1000
+set SHARED_IMEM_log			"SHARED_IMEM.bin"
+set SHARED_IMEM_USB_log     "missing"
+   
+   # Relocatable Image support
+set RELOCATION_DATA_start	[expr $SHARED_IMEM_start+		0x94C]
+set RELOCATION_DATA_end		[expr $RELOCATION_DATA_start+	0xC7]
+set RELOCATION_DATA_size		 0xC8
+   
+   # Each entry in the table is in the following format
+   # 8 bytes - image name
+   # 8 bytes - image start address
+   # 4 bytes - image size
+   
+set WCNSS_regs			"WCNSS_regs.cmm" 
+set WCNSS_mmu			"WCNSS_mmu.cmm"
+   
+set RPM_regs			"RPM_regs.cmm"
+set RPM_mmu				"RPM_regs.cmm"
+   
+set MPSS_Thread0_regs	"MPSS_Thread0_regs.cmm"
+set MPSS_Thread1_regs	"MPSS_Thread1_regs.cmm"
+set MPSS_Thread2_regs	"MPSS_Thread2_regs.cmm"
+set MPSS_Thread3_regs	"MPSS_Thread3_regs.cmm"
+   
+set ADSP_Thread0_regs	"ADSP_Thread0_regs.cmm"
+set ADSP_Thread1_regs	"ADSP_Thread1_regs.cmm"
+set ADSP_Thread2_regs	"ADSP_Thread2_regs.cmm"
+set ADSP_Thread3_regs	"ADSP_Thread3_regs.cmm"
+   
+set KPSS_Core0_regs		"KPSS_Core0_regs.cmm"
+set KPSS_Core0_mmu		"KPSS_Core0_mmu.cmm"
+   
+set KPSS_Core1_regs		"KPSS_Core1_regs.cmm"
+set KPSS_Core1_mmu		"KPSS_Core1_mmu.cmm"
+   
+set KPSS_Core2_regs		"KPSS_Core2_regs.cmm"
+set KPSS_Core2_mmu		"KPSS_Core2_mmu.cmm"
+   
+set KPSS_Core3_regs		"KPSS_Core3_regs.cmm"
+set KPSS_Core3_mmu		"KPSS_Core3_mmu.cmm"
diff --git a/tcl/qualcomm/msm8994/rpm_apps0.cfg b/tcl/qualcomm/msm8994/rpm_apps0.cfg
new file mode 100644
index 0000000..460202b
--- /dev/null
+++ b/tcl/qualcomm/msm8994/rpm_apps0.cfg
@@ -0,0 +1,24 @@
+source [find qualcomm/msm8994/common.cfg]
+
+source [find qualcomm/common/tcpip.ports.cfg]
+
+source [find qualcomm/common/jtag_dap_cfg1.cfg]
+
+source [find qualcomm/$_CHIPNAME/rpm_core.cfg]
+
+rpm configure -event gdb-attach {
+      halt
+}
+
+source [find qualcomm/$_CHIPNAME/apps_core0.cfg]
+
+apps0 configure -event gdb-attach {
+      halt
+}
+
+
+
+jtag arp_init-reset
+
+init
+
diff --git a/tcl/qualcomm/msm8994/rpm_core.cfg b/tcl/qualcomm/msm8994/rpm_core.cfg
new file mode 100644
index 0000000..d14c672
--- /dev/null
+++ b/tcl/qualcomm/msm8994/rpm_core.cfg
@@ -0,0 +1,23 @@
+# -*- mode: tcl -*-
+#
+source [find qualcomm/$_CHIPNAME/common.cfg]
+
+set _dbg_port arm.dap3
+set _axi_port arm.dap0
+
+# The RPM has a private DAP port
+target create rpm cortex_m -chain-position $_CHIPNAME.dap 
+rpm configure -dbg-base $_dbg_port:0
+rpm configure -cti-base $_dbg_port:0
+rpm configure -sys-ap   $_axi_port:0
+rpm configure -mem-ap   $_axi_port:0
+
+proc edl_mode {} {
+	targets rpm
+	halt
+	mww dap.privsecure:0xFE805fe0 0x322A4F99
+	mww dap.privsecure:0xFE805fe4 0xC67E4350
+	mww dap.privsecure:0xfe805fe8 0x77777777
+	
+	reset run
+}
diff --git a/tcl/qualcomm/msm8994/rpm_only.cfg b/tcl/qualcomm/msm8994/rpm_only.cfg
new file mode 100644
index 0000000..cf1f430
--- /dev/null
+++ b/tcl/qualcomm/msm8994/rpm_only.cfg
@@ -0,0 +1,16 @@
+source [find qualcomm/msm8994/common.cfg]
+
+source [find qualcomm/common/tcpip.ports.cfg]
+
+source [find qualcomm/common/jtag_dap_cfg1.cfg]
+
+source [find qualcomm/$_CHIPNAME/rpm_core.cfg]
+
+rpm configure -event gdb-attach {
+      halt
+}
+
+jtag arp_init-reset
+
+init
+
diff --git a/tcl/qualcomm/msm8x26/common.cfg b/tcl/qualcomm/msm8x26/common.cfg
new file mode 100644
index 0000000..8dbcf66
--- /dev/null
+++ b/tcl/qualcomm/msm8x26/common.cfg
@@ -0,0 +1,7 @@
+set _CHIPNAME msm8x26
+global _CHIPNAME
+
+set _DAP_TAPID 0x4BA00477
+set	_ACC_TAPID 0x000016DD
+set _MSM_TAPID 0x108010e1
+
diff --git a/tcl/qualcomm/msm8x26/memmap.cfg b/tcl/qualcomm/msm8x26/memmap.cfg
new file mode 100644
index 0000000..4816ae4
--- /dev/null
+++ b/tcl/qualcomm/msm8x26/memmap.cfg
@@ -0,0 +1,209 @@
+# Based on: M8626AAAAANLYD10323110.1.14274.1\common\tools\cmm\common\msm8x26\std_memorymap.cmm
+#
+#   Title: std_memorymap
+#   License: License
+#   Copyright 2016 Eric Katzfey
+#   Description: This script setup the memory map for the target
+#   Input: None
+#   Output: None
+#   Usage: do std_memorymap
+#   Team: Qprobe( CoreBSP Products 8x26 )
+#   Target: msm8x26
+
+set ADSP_EFS_start	0XFD60000
+set ADSP_EFS_end	0XFD7FFFF
+set ADSP_EFS_size	0X20000
+set ADSP_EFS_log	"ADSP_EFS_log.bin"
+
+# ADSP SW Image - 25 MB
+set ADSP_SW_start	0XE100000
+set ADSP_SW_end	0XF4DFFFF
+set ADSP_SW_size	0X14E0000
+set ADSP_SW_log	"ADSP_SW_log.bin"
+
+# RPM Code RAM - 128 KB
+set CODERAM_start	0xFC100000
+set CODERAM_RPM_start	0x100000
+set CODERAM_end	0XFC11FFFF
+set CODERAM_size	0X20000
+set CODERAM_log	"CODERAM_log.bin"
+set CODERAM_USB_log	"CODERAM.bin"
+
+# RPM Data RAM - 64 kB 
+set DATARAM_start	0xFC190000
+set DATARAM_RPM_start	0x190000
+set DATARAM_end	0xFC19FFFF
+set DATARAM_size	0X10000
+set DATARAM_log	"DATARAM_log.bin"
+set DATARAM_USB_log	"DATARAM.bin"
+
+# RPM Message RAM - 16KB
+set MSGRAM_start 0xFC428000
+set MSGRAM_end 0xFC42FFFF
+set MSGRAM_size 0x4000
+set MSGRAM_log "MSGRAM_log.bin"
+set MSGRAM_USB_log "MSGRAM.bin"
+
+
+# Debug Image - 12 kB
+set DBI_start 0XFE800000
+set DBI_end 0XFE802FFF
+set DBI_size 0X3000
+set DBI_log "DBI_log.bin"
+
+set HLOS_1_start 0
+set HLOS_1_end 0X93FFFFF
+set HLOS_1_size 0X9400000
+set HLOS_1_log "HLOS_1_log.bin"
+
+set HLOS_2_start 0XD300000
+set HLOS_2_end 0XD4FFFFF
+set HLOS_2_size 0X200000
+set HLOS_2_log "HLOS_2_log.bin"
+
+set HLOS_3_start 0X10000000
+set HLOS_3_end 0X1FFFFFFF
+set HLOS_3_size 0X10000000
+set HLOS_3_log "HLOS_3_log.bin"
+
+set HLOS_4_start 0X20000000
+set HLOS_4_end 0X3FFFFFFF
+set HLOS_4_size 0X20000000
+set HLOS_4_log "HLOS_4_log.bin"
+
+set MBA_Meta_start 0XD1FC000
+set MBA_Meta_end 0XD1FFFFF
+set MBA_Meta_size 0X4000
+set MBA_Meta_log "MBA_Meta_log.bin"
+
+set MBA_SW_start 0XD100000
+set MBA_SW_end 0XD1FBFFF
+set MBA_SW_size 0XFC000
+set MBA_SW_log "MBA_SW_log.bin"
+
+set MPSS_EFS_start 0XD900000
+set MPSS_EFS_end 0XDBFFFFF
+set MPSS_EFS_size 0X300000
+set MPSS_EFS_log "MPSS_EFS_log.bin"
+
+# MPSS Image - 77 MB
+set MPSS_SW_start 0X8400000
+set MPSS_SW_end 0XD2FFFFF
+set MPSS_SW_size 0X3F00000
+set MPSS_SW_log "MPSS_SW_log.bin"
+
+set MPSS_TCM_start 0xFCC00000
+
+# QDSS Image - 16 MB
+set QDSS_SW_start 0X10000000
+set QDSS_SW_end 0X10FFFFFF
+set QDSS_SW_size 0x1000000
+set QDSS_SW_log "QDSS_SW_log.bin"
+
+set SMEM_start 0XFA00000
+set SMEM_end 0XFBFFFFF
+set SMEM_size 0X200000
+set SMEM_log "SMEM_log.bin"
+
+set TZ_SW_start 0XFC00000
+set TZ_SW_end 0XFD5FFFF
+set TZ_SW_size 0X160000
+set TZ_SW_log "TZ_SW_log.bin"
+
+# VSS Image - 5 MB
+set VSS_SW_start 0XF500000
+set VSS_SW_end 0XF9FFFFF
+set VSS_SW_size 0X500000
+set VSS_SW_log "Venus_SW_log.bin"
+
+# WCNSS Image - 7 MB
+set WCNSS_SW_start 0XD200000
+set WCNSS_SW_end 0XD8FFFFF
+set WCNSS_SW_size 0X700000
+set WCNSS_SW_log "WCNSS_SW_log.bin"
+
+# WCNSS uBSP Image - Part of the 7MB 
+# main image when loaded. Runs out of CMEM
+set WCNSS_CMEM_start 0xFB280000
+set WCNSS_CMEM_end 0xFB29E000
+set WCNSS_CMEM_size 0x1E000
+set WCNSS_CMEM_log "WCNSS_CMEM_log.bin"
+
+# DDR memory - combined space used by all images
+set DDR_1_start 0x0
+set DDR_1_end 0x1FFFFFFF
+set DDR_1_size 0x20000000
+set DDR_1_log "DDRCS0.BIN"
+set DDR_1_USB_log "DDRCS0.BIN"
+
+set DDR_2_start 0x20000000
+set DDR_2_end 0x3FFFFFFF
+set DDR_2_size 0x40000000
+set DDR_2_log "DDRCS1.BIN"
+set DDR_2_USB_log "DDRCS1.BIN"
+
+# This region is in the Shared IMEM block
+# These are the cookies used to debug any image
+# Allocation varies from target to target
+set DEBUG_COOKIE_VALUE		0x53444247
+
+set DEBUG_REGION_START		0xFE805934
+set MPSS_DEBUG_COOKIE		0xFE805934
+set MBA_DEBUG_COOKIE		0xFE805938
+set ADSP_DEBUG_COOKIE		0xFE80593C
+set WCNSS_DEBUG_COOKIE		0xFE805940
+set SBL1_DEBUG_COOKIE		0xFE805944
+set APPSBOOT_DEBUG_COOKIE	0xFE805948
+set DEBUG_REGION_END		0xFE80594C
+set DEBUG_REGION_SIZE		0x18
+
+# OCIMEM section
+set OCIMEM_start 0xFE800000
+set OCIMEM_end 0xFE803FFFF
+set OCIMEM_size 0x40000
+set OCIMEM_log "OCIMEM.bin"
+set OCIMEM_USB_log "OCIMEM.bin"
+
+# Shared IMEM section
+set SHARED_IMEM_start 0xFE805000
+set SHARED_IMEM_end  [expr $SHARED_IMEM_start+0xFFF]
+set SHARED_IMEM_size 0x1000
+set SHARED_IMEM_log "SHARED_IMEM.bin"
+set SHARED_IMEM_USB_log "SHARED_IMEM.bin"
+
+
+
+# Relocatable Image support
+set RELOCATION_DATA_start  [expr $SHARED_IMEM_start+0x94C]
+set RELOCATION_DATA_end    [expr $RELOCATION_DATA_start+0xC7]
+set RELOCATION_DATA_size   0xC8
+# Each entry in the table is in the following format
+# 8 bytes - image name
+# 8 bytes - image start address
+# 4 bytes - image size
+
+set WCNSS_regs "WCNSS_regs.cmm"
+set WCNSS_mmu  "WCNSS_mmu.cmm"
+
+set RPM_regs "RPM_regs.cmm"
+set RPM_mmu  "RPM_regs.cmm"
+
+set MPSS_Thread0_regs "MPSS_Thread0_regs.cmm"
+set MPSS_Thread1_regs "MPSS_Thread1_regs.cmm"
+set MPSS_Thread2_regs "MPSS_Thread2_regs.cmm"
+
+set ADSP_Thread0_regs "ADSP_Thread0_regs.cmm"
+set ADSP_Thread1_regs "ADSP_Thread1_regs.cmm"
+set ADSP_Thread2_regs "ADSP_Thread2_regs.cmm"
+
+set KPSS_Core0_regs "KPSS_Core0_regs.cmm"
+set KPSS_Core0_mmu  "KPSS_Core0_mmu.cmm"
+
+set KPSS_Core1_regs "KPSS_Core1_regs.cmm"
+set KPSS_Core1_mmu  "KPSS_Core1_mmu.cmm"
+
+set KPSS_Core2_regs "KPSS_Core2_regs.cmm"
+set KPSS_Core2_mmu  "KPSS_Core2_mmu.cmm"
+
+set KPSS_Core3_regs "KPSS_Core3_regs.cmm"
+set KPSS_Core3_mmu  "KPSS_Core3_mmu.cmm"
diff --git a/tcl/qualcomm/msm8x26/rpm_core.cfg b/tcl/qualcomm/msm8x26/rpm_core.cfg
new file mode 100644
index 0000000..d960c00
--- /dev/null
+++ b/tcl/qualcomm/msm8x26/rpm_core.cfg
@@ -0,0 +1,11 @@
+#
+source [find qualcomm/$_CHIPNAME/common.cfg]
+
+set _dbg_port arm.dap3
+set _axi_port arm.dap0
+
+# The RPM has a private DAP port
+target create rpm cortex_m -chain-position $_CHIPNAME.dap
+rpm configure -dbg-base $_dbg_port:0
+rpm configure -cti-base $_dbg_port:0
+rpm configure -mem-ap   $_axi_port:0
diff --git a/tcl/qualcomm/msm8x26/rpm_only.cfg b/tcl/qualcomm/msm8x26/rpm_only.cfg
new file mode 100644
index 0000000..bb00f7d
--- /dev/null
+++ b/tcl/qualcomm/msm8x26/rpm_only.cfg
@@ -0,0 +1,16 @@
+source [find qualcomm/msm8x26/common.cfg]
+
+source [find qualcomm/common/tcpip.ports.cfg]
+
+source [find qualcomm/common/jtag_dap_cfg1.cfg]
+
+source [find qualcomm/$_CHIPNAME/rpm_core.cfg]
+
+rpm configure -event gdb-attach {
+      halt
+}
+
+jtag arp_init-reset
+
+init
+
-- 
1.9.1


From ba804bf7c2e28b5412968066a8a39b840748fd75 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 32/94] improve error reporting from commands

---
 src/helper/command.c | 66 ++++++++++++++++++++++++++++++++++++++--------------
 src/helper/command.h |  9 ++++++-
 2 files changed, 57 insertions(+), 18 deletions(-)

diff --git a/src/helper/command.c b/src/helper/command.c
index c29f113..7179d99 100755
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -118,9 +118,13 @@ static void command_log_capture_finish(struct log_capture_state *state)
 static int command_retval_set(Jim_Interp *interp, int retval)
 {
 	int *return_retval = Jim_GetAssocData(interp, "retval");
-	if (return_retval != NULL)
+	if (return_retval != NULL){
+		if( retval != ERROR_OK ){
+			LOG_DEBUG("ERROR %s", Jim_GetString( Jim_GetResult(interp), NULL ));
+		}
 		*return_retval = retval;
-
+	}
+	
 	return (retval == ERROR_OK) ? JIM_OK : JIM_ERR;
 }
 
@@ -156,11 +160,12 @@ static void script_command_args_free(char **words, unsigned nwords)
 static char **script_command_args_alloc(
 	unsigned argc, Jim_Obj * const *argv, unsigned *nwords)
 {
-	char **words = malloc(argc * sizeof(char *));
+	unsigned i;
+	/* include space for a NULL terminator in the pointer array */
+	char **words = malloc((argc+1) * sizeof(char *));
 	if (NULL == words)
 		return NULL;
-
-	unsigned i;
+		
 	for (i = 0; i < argc; i++) {
 		int len;
 		const char *w = Jim_GetString(argv[i], &len);
@@ -170,6 +175,8 @@ static char **script_command_args_alloc(
 			return NULL;
 		}
 	}
+	/* Null terminate the array of pointers */
+	words[i] = NULL;
 	*nwords = i;
 	return words;
 }
@@ -969,6 +976,17 @@ static int command_unknown_find(unsigned argc, Jim_Obj *const *argv,
 	return command_unknown_find(--argc, ++argv, (*out)->children, out, false);
 }
 
+void command_print_jim_error( Jim_Interp *interp )
+{
+	struct command_context *context;	
+	const char *cp;
+
+	context = current_command_context( interp );
+	cp = Jim_GetString( Jim_GetResult(interp), NULL );
+	command_print( context, "Error: %s", cp );
+}
+	
+
 static int command_unknown(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	const char *cmd_name = Jim_GetString(argv[0], NULL);
@@ -1009,8 +1027,13 @@ static int command_unknown(Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 	}
 	/* pass the command through to the intended handler */
 	if (c->jim_handler) {
+		int e;
 		interp->cmdPrivData = c->jim_handler_data;
-		return (*c->jim_handler)(interp, count, start);
+		e = (*c->jim_handler)(interp, count, start);
+		if( e == JIM_ERR ){
+			command_print_jim_error( interp );
+		}
+		return e;
 	}
 
 	return script_command_run(interp, count, start, c, found);
@@ -1392,7 +1415,10 @@ DEFINE_PARSE_NUM_TYPE(_llong, long long, strtoll, LLONG_MIN, LLONG_MAX)
 	int parse ## name(const char *str, type * ul) \
 	{ \
 		functype n; \
-		int retval = parse ## funcname(str, &n); \
+		if( str == NULL ){ \
+			return ERROR_COMMAND_SYNTAX_ERROR; \
+		} \
+		int retval = parse ## funcname(str, &n);	\
 		if (ERROR_OK != retval)	\
 			return retval; \
 		if (n > max) \
@@ -1422,6 +1448,10 @@ DEFINE_PARSE_LONGLONG(_s8,  int8_t,  n < INT8_MIN,  INT8_MAX)
 static int command_parse_bool(const char *in, bool *out,
 	const char *on, const char *off)
 {
+	if( in = NULL ){
+		return ERROR_COMMAND_SYNTAX_ERROR;
+	}
+	
 	if (strcasecmp(in, on) == 0)
 		*out = true;
 	else if (strcasecmp(in, off) == 0)
@@ -1433,16 +1463,18 @@ static int command_parse_bool(const char *in, bool *out,
 
 int command_parse_bool_arg(const char *in, bool *out)
 {
-	if (command_parse_bool(in, out, "on", "off") == ERROR_OK)
-		return ERROR_OK;
-	if (command_parse_bool(in, out, "enable", "disable") == ERROR_OK)
-		return ERROR_OK;
-	if (command_parse_bool(in, out, "true", "false") == ERROR_OK)
-		return ERROR_OK;
-	if (command_parse_bool(in, out, "yes", "no") == ERROR_OK)
-		return ERROR_OK;
-	if (command_parse_bool(in, out, "1", "0") == ERROR_OK)
-		return ERROR_OK;
+	if( in != NULL ){
+		if (command_parse_bool(in, out, "on", "off") == ERROR_OK)
+			return ERROR_OK;
+		if (command_parse_bool(in, out, "enable", "disable") == ERROR_OK)
+			return ERROR_OK;
+		if (command_parse_bool(in, out, "true", "false") == ERROR_OK)
+			return ERROR_OK;
+		if (command_parse_bool(in, out, "yes", "no") == ERROR_OK)
+			return ERROR_OK;
+		if (command_parse_bool(in, out, "1", "0") == ERROR_OK)
+			return ERROR_OK;
+	}
 	return ERROR_COMMAND_SYNTAX_ERROR;
 }
 
diff --git a/src/helper/command.h b/src/helper/command.h
index 16517f1..6f99b21 100755
--- a/src/helper/command.h
+++ b/src/helper/command.h
@@ -306,6 +306,13 @@ struct target *get_current_target(struct command_context *cmd_ctx);
  */
 struct command_context *current_command_context(Jim_Interp *interp);
 
+/** Print an error message base on the Jim_Result()
+ *
+ * Some commands are implimented in "jim"
+ * And error messages are not exactly well logged.
+ */
+void command_print_jim_error( Jim_Interp *interp );
+
 /**
  * Creates a new command context using the startup TCL provided and
  * the existing Jim interpreter, if any. If interp == NULL, then command_init
@@ -382,7 +389,7 @@ DECLARE_PARSE_WRAPPER(_s8, int8_t);
 		int retval_macro_tmp = parse_ ## type(in, &(out)); \
 		if (ERROR_OK != retval_macro_tmp) { \
 			command_print(CMD_CTX, stringify(out) \
-				" option value ('%s') is not valid", in); \
+			" option value ('%s') is not valid", in ? in : "(missing)"); \
 			return retval_macro_tmp; \
 		} \
 	} while (0)
-- 
1.9.1


From 8b00b0d63fb1bcfbd64009a824c846a2e1570306 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 33/94] Add basic debug flags command

---
 src/helper/jim-nvp.c | 29 +++++++++++++++++++++++++++++
 src/helper/jim-nvp.h |  2 ++
 2 files changed, 31 insertions(+)

diff --git a/src/helper/jim-nvp.c b/src/helper/jim-nvp.c
index f67811a..c10afe0 100755
--- a/src/helper/jim-nvp.c
+++ b/src/helper/jim-nvp.c
@@ -440,3 +440,32 @@ int Jim_GetOpt_ArmDapPort( Jim_GetOptInfo *goi, int *portnum )
 	
 	return JIM_OK;
 }
+
+
+int Jim_LogFlags( Jim_GetOptInfo *goi, jim_wide *w, const Jim_Nvp *lookup )
+{
+	int e;
+
+	e = JIM_OK;
+	switch( goi->argc ){
+	case 2:
+		/* FIXME: IN FUTURE - support *NAMES* via lookup */
+		/* lookup might be null */
+		/* fallthrough */
+	default:
+		Jim_SetResultString( goi->interp, "?[newvalue]",-1);
+		e = JIM_ERR;
+		break;
+	case 1:
+		e = Jim_GetOpt_Wide( goi, w );
+		break;
+	case 0:
+		/* no problem just show */
+		break;
+	}
+
+	if( e == JIM_OK ){
+		Jim_SetResultInt( goi->interp, *w );
+	}
+	return e;
+}
diff --git a/src/helper/jim-nvp.h b/src/helper/jim-nvp.h
index 70c932c..4006ed0 100755
--- a/src/helper/jim-nvp.h
+++ b/src/helper/jim-nvp.h
@@ -354,4 +354,6 @@ int Jim_GetOpt_ArmDapPort( Jim_GetOptInfo *goi, int *portnum );
  */
 int Jim_GetOpt_Enum(Jim_GetOptInfo *goi, const char *const *lookup, int *puthere);
 
+int Jim_LogFlags( Jim_GetOptInfo *goi, jim_wide *w, const Jim_Nvp *lookup );
+
 #endif
-- 
1.9.1


From a0800795611ae8c7ff2c7b6b9a69d4cf7c6ab0b6 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 34/94] Fixes to support mematts on images

---
 src/flash/nor/lpc2900.c | 2 +-
 src/flash/nor/tcl.c     | 4 ++--
 src/target/image.c      | 4 ++--
 src/target/image.h      | 4 +++-
 src/target/xscale.c     | 3 ++-
 5 files changed, 10 insertions(+), 7 deletions(-)

diff --git a/src/flash/nor/lpc2900.c b/src/flash/nor/lpc2900.c
index fe5d791..bba6500 100755
--- a/src/flash/nor/lpc2900.c
+++ b/src/flash/nor/lpc2900.c
@@ -639,7 +639,7 @@ COMMAND_HANDLER(lpc2900_handle_write_custom_command)
 	/* The image will always start at offset 0 */
 	struct image image;
 	image.base_address_set = 1;
-	image.base_address = 0;
+	TARGET_ADDR_INIT( &image.base_address,0 );
 	image.start_address_set = 0;
 
 	const char *filename = CMD_ARGV[1];
diff --git a/src/flash/nor/tcl.c b/src/flash/nor/tcl.c
index 6971cf2..d90723c 100755
--- a/src/flash/nor/tcl.c
+++ b/src/flash/nor/tcl.c
@@ -399,12 +399,12 @@ COMMAND_HANDLER(handle_flash_write_image_command)
 	struct duration bench;
 	duration_start(&bench);
 
+	TARGET_ADDR_INIT( &image.base_address,0 );
 	if (CMD_ARGC >= 2) {
 		image.base_address_set = 1;
-		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], image.base_address);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], image.base_address.addr);
 	} else {
 		image.base_address_set = 0;
-		image.base_address = 0x0;
 	}
 
 	image.start_address_set = 0;
diff --git a/src/target/image.c b/src/target/image.c
index 2246445..2a38b7b 100755
--- a/src/target/image.c
+++ b/src/target/image.c
@@ -796,11 +796,11 @@ int image_open(struct image *image, const char *url, const char *type_string)
 		/* relocate */
 		int section;
 		for (section = 0; section < image->num_sections; section++)
-			image->sections[section].base_address += image->base_address;
+			image->sections[section].base_address += image->base_address.addr;
 											/* we're done relocating. The two statements below are mainly
 											* for documenation purposes: stop anyone from empirically
 											* thinking they should use these values henceforth. */
-		image->base_address = 0;
+		image->base_address.addr = 0;
 		image->base_address_set = 0;
 	}
 
diff --git a/src/target/image.h b/src/target/image.h
index 4167b70..c790f00 100755
--- a/src/target/image.h
+++ b/src/target/image.h
@@ -38,6 +38,8 @@
 
 #define IMAGE_MEMORY_CACHE_SIZE		(2048)
 
+#include "target.h" /* for target adr */
+
 enum image_type {
 	IMAGE_BINARY,	/* plain binary */
 	IMAGE_IHEX,		/* intel hex-record format */
@@ -61,7 +63,7 @@ struct image {
 	int num_sections;		/* number of sections contained in the image */
 	struct imagesection *sections;	/* array of sections */
 	int base_address_set;	/* whether the image has a base address set (for relocation purposes) */
-	uint64_t base_address;		/* base address, if one is set */
+	struct target_addr base_address;		/* base address, if one is set */
 	int start_address_set;	/* whether the image has a start address (entry point) associated */
 	uint64_t start_address;		/* start address, if one is set */
 };
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 6794889..604b411 100755
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -3405,9 +3405,10 @@ COMMAND_HANDLER(xscale_handle_trace_image_command)
 	xscale->trace.image->start_address_set = 0;
 
 	/* a base address isn't always necessary, default to 0x0 (i.e. don't relocate) */
+	TARGET_ADDR_INIT( &(xscale->trace.image->base_address), 0);
 	if (CMD_ARGC >= 2) {
 		xscale->trace.image->base_address_set = 1;
-		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], xscale->trace.image->base_address);
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], xscale->trace.image->base_address.addr);
 	} else
 		xscale->trace.image->base_address_set = 0;
 
-- 
1.9.1


From d101dbdd0288947b55d248c0753df748d52b62b1 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 35/94] Additional file for image 64bit

---
 src/target/target.c | 61 ++++++++++++++++++++++++++++++++++++++++-------------
 1 file changed, 46 insertions(+), 15 deletions(-)

diff --git a/src/target/target.c b/src/target/target.c
index 736084f..8ec67c4 100755
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -3076,26 +3076,39 @@ COMMAND_HANDLER(handle_mw_command)
 }
 
 static COMMAND_HELPER(parse_load_image_command_CMD_ARGV, struct image *image,
-		struct target_addr *pMinAddr, struct target_addr *pMaxAddr)
+					  struct target_addr *pMinAddr, struct target_addr *pMaxAddr, unsigned *argn_out)
 {
+	int r;
 	if (CMD_ARGC < 1 || CMD_ARGC > 5)
 		return ERROR_COMMAND_SYNTAX_ERROR;
 
+	*argn_out = 0;
 	/* a base address isn't always necessary,
 	 * default to 0x0 (i.e. don't relocate) */
-	image->base_address = 0;
+	TARGET_ADDR_INIT( &(image->base_address), 0 );
 	if (CMD_ARGC >= 2) {
-		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], image->base_address);
+		r = parse_memory_address( &(image->base_address), CMD_ARGV[1], CMD_ARGV[2] );
+		switch( r ){
+		default:
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		case 1:
+			*argn_out = 0;
+			break;
+		case 2:
+			/* we used 2 args */
+			*argn_out = 1;
+			break;
+		}
 		image->base_address_set = 1;
 	} else
 		image->base_address_set = 0;
 
 	image->start_address_set = 0;
 
-	if (CMD_ARGC >= 4)
-		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[3], pMinAddr->addr);
-	if (CMD_ARGC == 5) {
-		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[4], pMaxAddr->addr);
+	if (CMD_ARGC >= (*argn_out+4))
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[*argn_out+3], pMinAddr->addr);
+	if (CMD_ARGC == (*argn_out+5)) {
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[*argn_out+4], pMaxAddr->addr);
 		/* use size (given) to find max (required) */
 		pMaxAddr->addr += pMinAddr->addr;
 	}
@@ -3108,6 +3121,7 @@ static COMMAND_HELPER(parse_load_image_command_CMD_ARGV, struct image *image,
 
 COMMAND_HANDLER(handle_load_image_command)
 {
+	unsigned argn;
 	uint8_t *buffer;
 	size_t buf_cnt;
 	uint32_t image_size;
@@ -3119,8 +3133,9 @@ COMMAND_HANDLER(handle_load_image_command)
 	TARGET_ADDR_INIT( &min_addr, 0 );
 	TARGET_ADDR_INIT( &max_addr, (uint64_t)(-1) );
 
+	argn = 0;
 	int retval = CALL_COMMAND_HANDLER(parse_load_image_command_CMD_ARGV,
-			&image, &min_addr, &max_addr);
+									  &image, &min_addr, &max_addr, &argn);
 	if (ERROR_OK != retval)
 		return retval;
 
@@ -3129,7 +3144,7 @@ COMMAND_HANDLER(handle_load_image_command)
 	struct duration bench;
 	duration_start(&bench);
 
-	if (image_open(&image, CMD_ARGV[0], (CMD_ARGC >= 3) ? CMD_ARGV[2] : NULL) != ERROR_OK)
+	if (image_open(&image, CMD_ARGV[0], (CMD_ARGC >= (argn+3)) ? CMD_ARGV[argn+2] : NULL) != ERROR_OK)
 		return ERROR_OK;
 
 	image_size = 0x0;
@@ -3208,6 +3223,7 @@ COMMAND_HANDLER(handle_dump_image_command)
 	struct target *target = get_current_target(CMD_CTX);
 	int r;
 
+	
 	/* ARGV[0] = Filename */
 	argn = 0;
 	filename = CMD_ARGV[argn];
@@ -3279,6 +3295,7 @@ COMMAND_HANDLER(handle_dump_image_command)
 
 static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 {
+	unsigned argn = 0;
 	struct target_addr tmp_addr;
 	uint8_t *buffer;
 	size_t buf_cnt;
@@ -3305,16 +3322,28 @@ static COMMAND_HELPER(handle_verify_image_command_internal, int verify)
 
 	/* FIXME: Support attribute:address? */
 	if (CMD_ARGC >= 2) {
-		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], image.base_address);
+		int r;
+		r = parse_memory_address( &(image.base_address), CMD_ARGV[1], CMD_ARGV[2] );
+		switch( r ){
+		default:
+			return ERROR_COMMAND_SYNTAX_ERROR;
+		case 1:
+			/* no problem */
+			break;
+		case 2:
+			/* one more arg used */
+			argn = 1;
+			break;
+		}
 		image.base_address_set = 1;
-	} else {
+	}  else {
 		image.base_address_set = 0;
-		image.base_address = 0x0;
+		TARGET_ADDR_INIT( &image.base_address, 0 );
 	}
 
 	image.start_address_set = 0;
 
-	retval = image_open(&image, CMD_ARGV[0], (CMD_ARGC == 3) ? CMD_ARGV[2] : NULL);
+	retval = image_open(&image, CMD_ARGV[0], (CMD_ARGC == (argn+3)) ? CMD_ARGV[(argn+2)] : NULL);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -5732,6 +5761,7 @@ static void free_fastload(void)
 
 COMMAND_HANDLER(handle_fast_load_image_command)
 {
+	unsigned argn;
 	uint8_t *buffer;
 	size_t buf_cnt;
 	uint64_t image_size;
@@ -5745,15 +5775,16 @@ COMMAND_HANDLER(handle_fast_load_image_command)
 
 	struct image image;
 
+	argn = 0;
 	int retval = CALL_COMMAND_HANDLER(parse_load_image_command_CMD_ARGV,
-			&image, &min_addr, &max_addr);
+									  &image, &min_addr, &max_addr,&argn);
 	if (ERROR_OK != retval)
 		return retval;
 
 	struct duration bench;
 	duration_start(&bench);
 
-	retval = image_open(&image, CMD_ARGV[0], (CMD_ARGC >= 3) ? CMD_ARGV[2] : NULL);
+	retval = image_open(&image, CMD_ARGV[0], (CMD_ARGC >= (argn+3)) ? CMD_ARGV[argn+2] : NULL);
 	if (retval != ERROR_OK)
 		return retval;
 
-- 
1.9.1


From a9aa95ec5586a925525f113ea6ca39fa6a63028a Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 36/94] Additional file for image 64bit part2

---
 src/target/etm.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/target/etm.c b/src/target/etm.c
index 65d80b2..3b2ebc1 100755
--- a/src/target/etm.c
+++ b/src/target/etm.c
@@ -1685,7 +1685,8 @@ COMMAND_HANDLER(handle_etm_image_command)
 	/* a base address isn't always necessary, default to 0x0 (i.e. don't relocate) */
 	if (CMD_ARGC >= 2) {
 		etm_ctx->image->base_address_set = 1;
-		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], etm_ctx->image->base_address);
+		TARGET_ADDR_INIT( &(etm_ctx->image->base_address), 0 );
+		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[1], etm_ctx->image->base_address.addr);
 	} else
 		etm_ctx->image->base_address_set = 0;
 
-- 
1.9.1


From 44c6549d1714fce1d58923702cd9181e37f22983 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 37/94] add testharness command to help automated tests

---
 src/openocd.c | 176 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 176 insertions(+)

diff --git a/src/openocd.c b/src/openocd.c
index 6b5018d..061cce0 100755
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -184,6 +184,175 @@ COMMAND_HANDLER(handle_add_script_search_dir_command)
 	return ERROR_OK;
 }
 
+
+/** The Test Harness
+ *
+ * This is here to help with an automated test scheme for openocd.
+ *
+ * Part 1
+ * ======
+ *
+ * The "global" below is volatile to force or control the optimizer.
+ * Otherwise it is hard/impossible to sometimes set breakpoints by
+ * assigning unqiue values to a global variable we can to some degree
+ * control what the optimizer can do.
+ *
+ * more specifically: it sort of turns off the optimizer at that point
+ * so you can set breakpoints at specific locations.
+ *
+ * Part 2
+ * ======
+ *
+ * The breakpoint functions exist because complex conditional
+ * breakpoints do not always work - sometimes you have a dynamic
+ * situation, and need to set a breakpoint after a long sequence
+ * of steps ... or deep within a long sequence.
+ *
+ * Part 3
+ * ======
+ * 
+ * The abort(), raise(SIGTRAP) are used to force abnormal exits
+ * in test conditions from test script that may detect a problem.
+ */
+
+
+int volatile testharness_value;
+int volatile testharness_enabled;
+char  testharness_string_buffer[30];
+
+/* PUBLIC FUNCTION so it is *NOT* optimzied as much */
+
+/* prototype so compiler cannot complain */
+void testharness_string( int newvalue );
+
+/* implimentation */
+void testharness_string( int newvalue )
+{
+	testharness_value = (testharness_value * 0x1234) + newvalue;
+	/* call something external so the optimzer cannot remove it */
+	snprintf( testharness_string_buffer,
+			  sizeof(testharness_string_buffer),
+			  "%d",
+			  testharness_value );
+	testharness_value *= 0xdead;
+	testharness_value &= 0xffff;
+}
+
+
+static int jim_testharness( Jim_Interp *interp, int argc,
+	Jim_Obj * const *argv)
+{
+	char *cp;
+	int e;
+	Jim_GetOptInfo goi;
+	Jim_GetOpt_Setup( &goi, interp, argc-1, argv+1 );
+
+	e = Jim_GetOpt_String( &goi, &cp, NULL );
+	if( e != JIM_OK ){
+		if( testharness_enabled ){
+			Jim_SetResultString( goi.interp, "test harness not enabled",-1);
+			return JIM_ERR;
+		}
+		/* 
+		 * THIS IS THE TEST HARNESS
+		 *  It is not suppose to be pretty!
+		 *  we are brutal - and unforgiving.
+		 *
+		 * If something is wrong *WE* Die fataly.
+		 */
+		LOG_OUTPUT("TEST-HARNESS Missing Parameter\n");
+		LOG_DEBUG("TEST-HARNESS Missing Parameter\n");
+		exit(EXIT_FAILURE);
+	}
+
+	LOG_OUTPUT("TEST-HARNESS: %s\n", cp );
+	LOG_DEBUG("TEST-HARNESS: %s", cp );
+
+	if( 0 == strcmp("enable", cp ) ){
+		testharness_enabled = true;
+		return JIM_OK;
+	}
+	if( 0 == strcmp("disable", cp ) ){
+		testharness_enabled = false;
+		return JIM_OK;
+	}
+
+	if( !testharness_enabled ){
+		LOG_OUTPUT("TESTHARNESS: disabled\n");
+		LOG_DEBUG("TESTHARNESS: disabled\n");
+		return JIM_OK;
+	}
+
+	if( 0 == strcmp( "msg" , cp ) ){
+		e = Jim_GetOpt_String( &goi, &cp, NULL );
+		if( e != JIM_OK ){
+			LOG_DEBUG("test harness error Cannot get message string\n");
+			exit(EXIT_FAILURE);
+		}
+		LOG_DEBUG("testharness msg: %s", cp );
+		LOG_OUTPUT("testharness msg: %s\n", cp );
+		return JIM_OK;
+	}
+		
+	
+	if( 0 == strcmp( "EXIT_SUCCESS", cp ) ){
+		/* OPENOCD redefines exit
+		 * this gives the test harness
+		 * a means to control openocd
+		 * *somewhat* gracefully.
+		 */
+		exit(EXIT_SUCCESS);
+	}
+
+	if( 0 == strcmp( "EXIT_FAILURE", cp ) ){
+		/* OPENOCD redefines exit
+		 * this gives the test harness
+		 * a means to control openocd
+		 * *somewhat* gracefully.
+		 */
+		exit(EXIT_FAILURE);
+	}
+
+	if( 0 == strcmp( "EXIT_ABORT", cp ) ){
+		/* force a core dump */
+		abort();
+	}
+
+	/* Just like Visual Studio:  DebugBreak() */
+	if( 0 == strcmp( "SIGTRAP-0", cp ) ){
+		testharness_string(111);
+		raise(SIGTRAP);
+		testharness_string(222);
+		return JIM_OK;
+	}
+	
+	if( 0 == strcmp( "SIGTRAP-1", cp ) ){
+		testharness_string(333);
+		raise(SIGTRAP);
+		testharness_string(444);
+		return JIM_OK;
+	}
+
+	/* Same idea but without raising a signal */
+	if( 0 == strcmp( "BREAKPOINT-0", cp ) ){
+		testharness_string(555);
+		return JIM_OK;
+	}
+	
+	if( 0 == strcmp( "BREAKPOINT-1", cp ) ){
+		testharness_string(666);
+		return JIM_OK;
+	}
+	
+	LOG_OUTPUT("TEST-HARNESS - Unrecoginzed command\n");
+	LOG_DEBUG("TEST-HARNESS - Unrecoginzed command\n");
+	abort();
+}
+
+		
+
+
+
 static const struct command_registration openocd_command_handlers[] = {
 	{
 		.name = "version",
@@ -215,6 +384,13 @@ static const struct command_registration openocd_command_handlers[] = {
 		.help = "dir to search for config files and scripts",
 		.usage = "<directory>"
 	},
+	{
+		.name = "testharness",
+		.jim_handler = jim_testharness,
+		.mode = COMMAND_ANY,
+		.help = "used by automated tests of Openocd",
+		.usage = "not a public api donot use"
+	},
 	COMMAND_REGISTRATION_DONE
 };
 
-- 
1.9.1


From e175ebd59c123b9c5762264f510d0b7003273ce9 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 38/94] make tcpip ports overridable

---
 tcl/qualcomm/common/tcpip.ports.cfg | 26 +++++++++++++++++++++++---
 1 file changed, 23 insertions(+), 3 deletions(-)

diff --git a/tcl/qualcomm/common/tcpip.ports.cfg b/tcl/qualcomm/common/tcpip.ports.cfg
index 78d5ce4..dd4cb8c 100644
--- a/tcl/qualcomm/common/tcpip.ports.cfg
+++ b/tcl/qualcomm/common/tcpip.ports.cfg
@@ -1,3 +1,23 @@
-tcl_port        4001
-telnet_port     4002
-gdb_port        4010
+# -*- mode: tcl -*-
+
+# Set defaults if not already setup
+global TCL_PORT
+if { ! [ info exists TCL_PORT ] } {
+	set	 TCL_PORT 4001
+}
+
+global GDB_PORT
+if { ! [ info exists GDB_PORT ] } {
+	set	 GDB_PORT 4010
+}
+
+global TELNET_PORT
+if { ! [ info exists TELNET_PORT ] } {
+	set	 TELNET_PORT 4002
+}
+
+
+tcl_port        $TCL_PORT
+telnet_port     $TELNET_PORT
+gdb_port        $GDB_PORT
+
-- 
1.9.1


From 99ee7a5cf279b8e94281b96a146e287f81fd2748 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 39/94] Add memattributes for msm8994 and support dragon board

---
 tcl/qualcomm/msm8994/common.cfg | 22 +++++++++++++++-------
 1 file changed, 15 insertions(+), 7 deletions(-)

diff --git a/tcl/qualcomm/msm8994/common.cfg b/tcl/qualcomm/msm8994/common.cfg
index bd73094..47754bf 100644
--- a/tcl/qualcomm/msm8994/common.cfg
+++ b/tcl/qualcomm/msm8994/common.cfg
@@ -8,15 +8,23 @@ if [ info exists _x8994x_ ] {
 	set _CHIPNAME msm8994
 	set _DAP_TAPID  0x4BA00477
 	set _ACC_TAPID  0x000016DD
-	set _MSM_TAPID  0x009400e1
-	
-
+	set  _MSM_TAPID {}
+	lappend _MSM_TAPID 0x009400e1
+	lappend _MSM_TAPID 0x009410e1
+	lappend _MSM_TAPID 0x109400e1	
 
-	mematt create dap.priv       arm.dap0 [expr (1<<28)+(3<<13)]
-	mematt create dap.secure     arm.dap0 [expr (2<<28)+(3<<13)]
-	mematt create dap.privsecure arm.dap0 [expr (3<<28)+(3<<13)]
-	mematt create dap.user       arm.dap0 [expr (0<<28)+(3<<13)]
+	mematt create dap0.priv       arm.dap0 [expr (1<<28)+(3<<13)]
+	mematt alias eaxi dap0.priv
+	
+	mematt create dap0.privsecure arm.dap0 [expr (3<<28)+(3<<13)]
+	mematt alias  ezaxi dap0.privsecure
 
+	mematt create dap0.user       arm.dap0 [expr (0<<28)+(3<<13)]
+	mematt alias axi dap0.user
 
+	mematt create dap0.secure     arm.dap0 [expr (2<<28)+(3<<13)]
+	
+	mematt create rpm.dbg.bus    arm.dap3 [expr 0]
+	mematt create apps.dbg.bus   arm.dap1 [expr 0]
 	
 }
-- 
1.9.1


From a829ad575836f7a14321a7b73652c478eb4b206b Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 40/94] Add tap commands to support automated test

---
 src/jtag/tcl.c | 49 +++++++++++++++++++++++++++++++++++--------------
 1 file changed, 35 insertions(+), 14 deletions(-)

diff --git a/src/jtag/tcl.c b/src/jtag/tcl.c
index 11687b9..2e56b37 100755
--- a/src/jtag/tcl.c
+++ b/src/jtag/tcl.c
@@ -308,12 +308,16 @@ static const struct command_registration jtag_command_handlers_to_move[] = {
 
 
 enum jtag_tap_cfg_param {
-	JCFG_EVENT
+	JCFG_EVENT,
+	JCFG_TAPID,
+	JCFG_IRLEN
 };
 
 static Jim_Nvp nvp_config_opts[] = {
 	{ .name = "-event",      .value = JCFG_EVENT },
-
+	{ .name = "-tapid",      .value = JCFG_TAPID },
+	{ .name = "-irlen",      .value = JCFG_IRLEN },
+	
 	{ .name = NULL,          .value = -1 }
 };
 
@@ -388,30 +392,47 @@ static int jtag_tap_configure_event(Jim_GetOptInfo *goi, struct jtag_tap *tap)
 
 static int jtag_tap_configure_cmd(Jim_GetOptInfo *goi, struct jtag_tap *tap)
 {
+	int e;
 	/* parse config or cget options */
-	while (goi->argc > 0) {
+	e = JIM_OK;
+	while ( (goi->argc > 0) && (e == JIM_OK) ){
 		Jim_SetEmptyResult(goi->interp);
 
 		Jim_Nvp *n;
-		int e = Jim_GetOpt_Nvp(goi, nvp_config_opts, &n);
+		e = Jim_GetOpt_Nvp(goi, nvp_config_opts, &n);
 		if (e != JIM_OK) {
 			Jim_GetOpt_NvpUnknown(goi, nvp_config_opts, 0);
-			return e;
+			break;
 		}
 
 		switch (n->value) {
-			case JCFG_EVENT:
-				e = jtag_tap_configure_event(goi, tap);
-				if (e != JIM_OK)
-					return e;
-				break;
-			default:
-				Jim_SetResultFormatted(goi->interp, "unknown event: %s", n->name);
-				return JIM_ERR;
+		case JCFG_EVENT:
+			e = jtag_tap_configure_event(goi, tap);
+			break;
+		case JCFG_TAPID:
+			if( goi->isconfigure ){
+				Jim_SetResultFormatted(goi->interp,"%s: readonly",n->name);
+				e = JIM_ERR;
+			} else {
+				Jim_SetResultInt( goi->interp, tap->idcode );
+			}
+			break;
+		case JCFG_IRLEN:
+			if( goi->isconfigure ){
+				Jim_SetResultFormatted(goi->interp,"%s: readonly",n->name);
+				e = JIM_ERR;
+			} else {
+				Jim_SetResultInt( goi->interp, tap->ir_length );
+			}
+			break;
+		default:
+			Jim_SetResultFormatted(goi->interp, "unknown cget option: %s", n->name);
+			e = JIM_ERR;
+			break;
 		}
 	}
 
-	return JIM_OK;
+	return e;
 }
 
 static int is_bad_irval(int ir_length, jim_wide w)
-- 
1.9.1


From e452709e1d3bbe0a471583e6f457a69cdd3c75a7 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 41/94] remove bad comment

---
 src/target/armv8_cpudbg_regs.h | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/target/armv8_cpudbg_regs.h b/src/target/armv8_cpudbg_regs.h
index 47ad643..4a162b9 100644
--- a/src/target/armv8_cpudbg_regs.h
+++ b/src/target/armv8_cpudbg_regs.h
@@ -1,5 +1,4 @@
 
-/* then this file does nothing */
 
   CORESIGHT_RW_REG( EDESR		, 0x020, "External Debug Event Status Reg" ),
   CORESIGHT_RW_REG( EDECR		, 0x024, "External Debug Execution Control Reg" ),
-- 
1.9.1


From 3556bec3b02ad19b4434e8cd2947af1fd50e5e98 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 42/94] Support multiple tapids in standard way

---
 tcl/qualcomm/common/jtag_dap_cfg1.cfg | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/tcl/qualcomm/common/jtag_dap_cfg1.cfg b/tcl/qualcomm/common/jtag_dap_cfg1.cfg
index 73cc5f0..088065c 100644
--- a/tcl/qualcomm/common/jtag_dap_cfg1.cfg
+++ b/tcl/qualcomm/common/jtag_dap_cfg1.cfg
@@ -1,3 +1,4 @@
+# -*- mode: tcl -*-
 # This is the 'standard b-family' dap configuration.
 # Generally all targets from msm8974 forward.
 #
@@ -7,7 +8,12 @@ source [find qualcomm/$_CHIPNAME/common.cfg]
 
 jtag newtap $_CHIPNAME dap -irlen 4  -expected-id $_DAP_TAPID -ignore-version
 jtag newtap $_CHIPNAME acc -irlen 5  -expected-id $_ACC_TAPID -ignore-version
-jtag newtap $_CHIPNAME msm -irlen 11 -expected-id $_MSM_TAPID -ignore-version
+set taplist {}
+foreach tapid $_MSM_TAPID {
+	lappend taplist -expected-id $tapid
+}
+eval jtag newtap $_CHIPNAME msm -irlen 11  -ignore-version $taplist
+
 
 jtag_ntrst_assert_width    10
 jtag_ntrst_delay           10
@@ -15,5 +21,5 @@ adapter_nsrst_assert_width 1000
 adapter_nsrst_delay        10
 reset_config trst_and_srst
 
-adapter_khz 100
+adapter_khz 10000
 
-- 
1.9.1


From f5f71487395a10dcfa7329d183dc952e8ed88bb8 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 43/94] cleanup/improve debug output from gdb server

---
 src/server/gdb_server.c | 26 ++++++++++++++++++++++----
 1 file changed, 22 insertions(+), 4 deletions(-)

diff --git a/src/server/gdb_server.c b/src/server/gdb_server.c
index abe7039..cd71f68 100755
--- a/src/server/gdb_server.c
+++ b/src/server/gdb_server.c
@@ -275,6 +275,16 @@ static int gdb_get_char_inner(struct connection *connection, int *next_char)
 	return retval;
 }
 
+#ifdef _DEBUG_GDB_IO_
+static int ascii_ify(int c)
+{
+	if( (c < 0x20) || (c > 0x7e) ){
+		c = '.';
+	}
+	return c;
+}
+#endif
+
 /**
  * The cool thing about this fn is that it allows buf_p and buf_cnt to be
  * held in registers in the inner loop.
@@ -285,6 +295,7 @@ static inline int gdb_get_char_fast(struct connection *connection,
 		int *next_char, char **buf_p, int *buf_cnt)
 {
 	int retval = ERROR_OK;
+	*next_char = 0;
 
 	if ((*buf_cnt)-- > 0) {
 		*next_char = **buf_p;
@@ -295,7 +306,7 @@ static inline int gdb_get_char_fast(struct connection *connection,
 			connection->input_pending = 0;
 
 #ifdef _DEBUG_GDB_IO_
-		LOG_DEBUG("returned char '%c' (0x%2.2x)", *next_char, *next_char);
+		LOG_DEBUG("returned char '%c' (0x%2.2x)", ascii_ify(*next_char), *next_char & 0x0ff);
 #endif
 
 		return ERROR_OK;
@@ -1380,7 +1391,9 @@ static int gdb_read_memory_packet(struct connection *connection,
 
 	buffer = malloc(len);
 
+#ifdef _DEBUG_GDB_IO_	
 	LOG_DEBUG("addr: 0x%" PRIx64 ", len: 0x%" PRIx32, addr, len);
+#endif
 
 	retval = target_read_buffer(target, addr, len, buffer);
 
@@ -1448,11 +1461,14 @@ static int gdb_write_memory_packet(struct connection *connection,
 
 	buffer = malloc(len);
 
-	LOG_DEBUG("addr: 0x%8.8" PRIx32 ", len: 0x%8.8" PRIx32 "", addr, len);
-
 	if (unhexify((char *)buffer, separator, len) != (int)len)
 		LOG_ERROR("unable to decode memory packet");
 
+#ifdef _DEBUG_GDB_IO_
+	LOG_DEBUG("addr: 0x%8.8" PRIx32 ", len: 0x%8.8" PRIx32 "", addr, len);
+	log_hexdump( addr, (void *)separator, len < 32 ? len : 32 );
+#endif
+
 	retval = target_write_buffer(target, addr, len, buffer);
 
 	if (retval == ERROR_OK)
@@ -1512,8 +1528,10 @@ static int gdb_write_memory_binary_packet(struct connection *connection,
 	}
 
 	if (len) {
+#ifdef _DEBUG_GDB_IO_
 		LOG_DEBUG("addr: 0x%8.8" PRIx32 ", len: 0x%8.8" PRIx32 "", addr, len);
-
+		log_hexdump( addr, (void *)separator, len < 32 ? len : 32 );
+#endif
 		retval = target_write_buffer(target, addr, len, (uint8_t *)separator);
 		if (retval != ERROR_OK)
 			gdb_connection->mem_write_error = true;
-- 
1.9.1


From fde0e22de9adf72a359609f0470ea2d67bedee21 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 44/94] Fix (part1) of gdb remote access for qprobe

---
 src/target/cortex_a53.c | 278 ++++++++++++++++++++++++++++++++++++------------
 1 file changed, 211 insertions(+), 67 deletions(-)

diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 8c09567..c53d5b0 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -36,6 +36,17 @@ static int cortex_a53_virt2phys_64(struct target *target,
 static int cortex_a53_read_apb_ab_memory(struct target *target,
 	const struct target_addr *pAddr, uint32_t size, uint32_t count, uint8_t *buffer);
 
+jim_wide cortex_a53_debugflags;
+#define _debugflag(N)  (1 <<(N))
+#define debugflag(N)  (!!(cortex_a53_debugflags & cortex_a53_debugflag_## N))
+#define cortex_a53_debugflag_OSLAR_EL1     _debugflag(0)
+#define cortex_a53_debugflag_EXEC_OPCODE   _debugflag(1)
+#define cortex_a53_debugflag_DCC_IO        _debugflag(2)
+#define cortex_a53_debugflag_MEM_IO        _debugflag(3)
+#define cortex_a53_debugflag_HW_BP         _debugflag(4)
+#define cortex_a53_debugflag_POLL          _debugflag(5)
+#define cortex_a53_debugflag_EDSCR         _debugflag(6)
+
 #define _bitof(X,V)       _bitsof( X,X,V )
 #define _bitsof( X,Y,V )  (((V) >> (Y)) & ((1<<((X)-(Y)+1))-1))
 
@@ -110,7 +121,7 @@ static int armv8_dbg_rd_EDPRSR( struct target *target, uint32_t *puthere )
 static int armv8_dbg_wr_EDSCR( struct target *target, uint32_t v )
 {
 	int r;
-	LOG_DEBUG("wr: edscr: 0x%08" PRIx32 , v );
+	// LOG_DEBUG("wr: edscr: 0x%08" PRIx32 , v );
 	r = target_cs_dbg_wr32( target, EDSCR, v );
 	return r;
 }
@@ -132,22 +143,24 @@ static int armv8_dbg_rd_EDSCR( struct target *target, uint32_t *puthere )
 	} else {
 		if( old_EDSCR != v ){
 			old_EDSCR = v;
-			
-			LOG_DEBUG("rd: edscr: 0x%08" PRIx32 " res0:%d rxful:%d txful:%d ito:%d rxo:%d txo:%d pipe:%d ite:%d",
-					  v,
-					  _bitof( 31, v ),  _bitof( 30, v ),
-					  _bitof( 29, v ),  _bitof( 28, v ),
-					  _bitof( 27, v ),  _bitof( 26, v ),
-					  _bitof( 25, v ),  _bitof( 24, v ));
-			LOG_DEBUG("intdis:%d tda:%d ma:%d res0:%d ns%d res0:%d sdd:%d res0:%d",
-					  _bitsof( 23,22,v ), _bitof( 21, v ),
-					  _bitof( 20, v ),  _bitof( 19, v ),
-					  _bitof( 18, v ),  _bitof( 17, v ),
-					  _bitof( 16, v ),  _bitof( 15, v ));
-			LOG_DEBUG("hde:%d rw:%d el:%d a:%d err:%d status:%d", 
-					  armv8_edscr_get_HDE( v ), _bitsof( 13,10, v ),
-					  _bitsof( 9,8, v ), _bitof(7,v),
-					  _bitof(6,v), _bitsof(5,0,v));
+
+			if( debugflag( EDSCR ) ){
+				LOG_DEBUG("rd: edscr: 0x%08" PRIx32 " res0:%d rxful:%d txful:%d ito:%d rxo:%d txo:%d pipe:%d ite:%d",
+						  v,
+						  _bitof( 31, v ),  _bitof( 30, v ),
+						  _bitof( 29, v ),  _bitof( 28, v ),
+						  _bitof( 27, v ),  _bitof( 26, v ),
+						  _bitof( 25, v ),  _bitof( 24, v ));
+				LOG_DEBUG("intdis:%d tda:%d ma:%d res0:%d ns%d res0:%d sdd:%d res0:%d",
+						  _bitsof( 23,22,v ), _bitof( 21, v ),
+						  _bitof( 20, v ),  _bitof( 19, v ),
+						  _bitof( 18, v ),  _bitof( 17, v ),
+						  _bitof( 16, v ),  _bitof( 15, v ));
+				LOG_DEBUG("hde:%d rw:%d el:%d a:%d err:%d status:%d", 
+						  armv8_edscr_get_HDE( v ), _bitsof( 13,10, v ),
+						  _bitsof( 9,8, v ), _bitof(7,v),
+						  _bitof(6,v), _bitsof(5,0,v));
+			}
 		}
 	}
 	if( puthere ){
@@ -170,8 +183,10 @@ static int armv8_rd_OSLAR_EL1( struct target *target, uint32_t *v)
 	if( r != ERROR_OK ){
 		LOG_DEBUG("rd: oslar-el1: error %d",r);
 	} else {
-		LOG_DEBUG("rd: oslar-el1: 0x%08" PRIx32 " oslk:%d",
-				  *v, _bitof(0,*v) );
+		if( debugflag(OSLAR_EL1) ){
+			LOG_DEBUG("rd: oslar-el1: 0x%08" PRIx32 " oslk:%d",
+					  *v, _bitof(0,*v) );
+		}
 	}
 	return r;
 }
@@ -293,22 +308,53 @@ int armv8_dbg_wr_bpwp_regs( struct armv8 *armv8, struct cortex_a_brp *p )
 		return ERROR_FAIL;
 	}
 
-	LOG_DEBUG("A8: bpwp enable, cr %08" PRIx32 " vr: 0x%s",
-			  p->control,
-			  target_addr64str1( target, p->value ) );
+	if( debugflag( HW_BP ) ){
+		LOG_DEBUG("bpwp enable, cr(0x%08" PRIx32 ")<=%08" PRIx32 " vr(0x%08" PRIx32 ")<= 0x%s",
+				  cr,
+				  p->control,
+				  vr,
+				  target_addr64str1( target, p->value ) );
+	}
 
+	/* assume OK */
 	retval = ERROR_OK;
-	if( p->control == 0 ){
+	/* PER  DDI-0487A - Page 4769 of 5534 - 
+	 * printed page: H8-4769
+	 *
+	 * Foot note b - second sentence
+	 *   "Software must ensure a breakpoint or watch point is disabled before altering the value register"
+	 *
+	 * Foot note b - first sentence
+	 * this is a pair of 32bit registers lsb first.
+	 */
+	
+	if( !(p->control & 1) ){
 		/* we are disabling write control first */
 		retval = target_cs_dbg_wr32( target, cr, p->control );
+		if( retval != ERROR_OK ){
+			return retval;
+		}
 	}
 
-	if( retval == ERROR_OK ){
-		retval = target_cs_dbg_wr64( target, vr, p->value  );
-		if( p->control ){
-			/* we are enabling write control last */
-			retval = target_cs_dbg_wr32( target, cr, p->control);
-		}
+	/* then write value */
+	uint64_t v = p->value;
+
+	/* LSB first */
+	retval = target_cs_dbg_wr32( target, vr+0, v );
+	if( retval != ERROR_OK ){
+		return retval;
+	}
+	/* then MSB */
+	v = v >> 32;
+	retval = target_cs_dbg_wr32( target, vr+4, v );
+	if( retval != ERROR_OK ){
+		return retval;
+	}
+
+	/* if we are enabling write control last */
+	if( p->control & 1 ){
+		/* we are enabling write control last */
+		retval = target_cs_dbg_wr32( target, cr, p->control);
 	}
 	return retval;
 }
@@ -510,14 +556,20 @@ static int cortex_a53_exec_opcode(struct target *target,
 	int retval;
 
 	//SQU: why not just read it? dscr = dscr_p ? *dscr_p : 0;
-	LOG_DEBUG("armv8 exec opcode: 0x%08" PRIx32, opcode );
+	if( debugflag(EXEC_OPCODE) ){
+		LOG_DEBUG("armv8 exec opcode: 0x%08" PRIx32, opcode );
+	}
 	retval = armv8_dbg_rd_EDSCR( target, &dscr );
-	LOG_DEBUG("AArch64=%d (dscr=0x%08X)", isAArch64(dscr), dscr);
+	if( debugflag(EXEC_OPCODE) ){
+		LOG_DEBUG("AArch64=%d (dscr=0x%08X)", isAArch64(dscr), dscr);
+	}
 
 	/* Wait for InstrCompl bit to be set */
 	long long then = timeval_ms();
 	while ((dscr & DSCR_INSTR_COMP) == 0) {
-		LOG_DEBUG("armv8-exec-opcode-poll(1)");
+		if( debugflag(EXEC_OPCODE) ){
+			LOG_DEBUG("armv8-exec-opcode-poll(1)");
+		}
 		retval = armv8_dbg_rd_EDSCR( target, &dscr );
 		if (retval != ERROR_OK) {
 			LOG_ERROR("Could not read DSCR register, opcode = 0x%08" PRIx32, opcode);
@@ -616,7 +668,9 @@ static int cortex_a53_exec_opcode(struct target *target,
 
 	then = timeval_ms();
 	do {
-		LOG_DEBUG("armv8-exec-opcode-poll(2)");
+		if( debugflag(EXEC_OPCODE) ){
+			LOG_DEBUG("armv8-exec-opcode-poll(2)");
+		}
 		retval = armv8_dbg_rd_EDSCR( target, &dscr );
 		if (retval != ERROR_OK) {
 			LOG_ERROR("Could not read DSCR register");
@@ -657,7 +711,9 @@ static int cortex_a53_write_dcc(struct armv8 *armv8, uint64_t data)
 	struct cortex_a_common *cortex_a = armv8_to_cortex_a(armv8);
 	struct target *target = armv8_to_target(armv8);
 
-	LOG_DEBUG("write DCC 0x%" PRIx64, data);
+	if( debugflag( DCC_IO ) ){
+		LOG_DEBUG("write DCC 0x%" PRIx64, data);
+	}
 	if(isAArch64(cortex_a->cpudbg_dscr))
 	{
 		target_cs_dbg_queued_wr32( target, CPUDBG_DTRTX, data>>32);
@@ -670,7 +726,6 @@ static int cortex_a53_read_dcc(struct target *target, uint64_t *data,
 {
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
-	int n;
 	uint32_t *pdw=(uint32_t*)data;
 
 	if (dscr_p)
@@ -678,12 +733,11 @@ static int cortex_a53_read_dcc(struct target *target, uint64_t *data,
 
 	/* Wait for DTRRXfull */
 	long long then = timeval_ms();
-	n = 0;
+
 	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
-		if( n ){
-			LOG_DEBUG("armv8-read-dcc-poll");
+		if( debugflag( DCC_IO ) ){
+			LOG_DEBUG("poll DCC");
 		}
-		n=1;
 		retval = armv8_dbg_rd_EDSCR( target, &dscr );
 		if (retval != ERROR_OK)
 			return retval;
@@ -702,7 +756,10 @@ static int cortex_a53_read_dcc(struct target *target, uint64_t *data,
 		target_cs_dbg_rd32( target, CPUDBG_DTRRX, pdw+1); //DTRRX holds high dword for 64bit data
 	} else
 		*(pdw+1)=0;
-	/* LOG_DEBUG("read DCC 0x%08" PRIx32, *data); */
+
+	if( debugflag( DCC_IO )){
+		LOG_DEBUG("read DCC 0x%08" PRIx64, *data);
+	}
 
 	if (dscr_p)
 		*dscr_p = dscr;
@@ -798,12 +855,15 @@ static int cortex_a53_instr_write_data64_r0_mrs(struct arm_dpm *dpm,
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
+	if( debugflag(EXEC_OPCODE) ){
+		LOG_DEBUG("opcode=0x%08" PRIx32 " data = 0x%016" PRIx64, opcode, data );
+	}
 	retval = cortex_a53_write_dcc(armv8, data);
 	if (retval != ERROR_OK)
 		return retval;
 
 		
-		/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15 */
+	/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15 */
 	retval = cortex_a53_exec_opcode(
 			target,
 			ARMV8_A64_MRS(2, 3, 0, 5, 0, 0),
@@ -829,6 +889,10 @@ static int cortex_a53_instr_write_data64_r0(struct arm_dpm *dpm,
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
+	if( debugflag(EXEC_OPCODE) ){
+		LOG_DEBUG("opcode=0x%08" PRIx32 " data = 0x%016" PRIx64, opcode, data );
+	}
+
 	retval = cortex_a53_write_dcc(armv8, data);
 	if (retval != ERROR_OK)
 		return retval;
@@ -882,7 +946,11 @@ static int cortex_a53_instr_read_data64_dcc(struct arm_dpm *dpm,
 	if (retval != ERROR_OK)
 		return retval;
 
-	return cortex_a53_read_dcc(target, data, &dscr);
+	retval = cortex_a53_read_dcc(target, data, &dscr);
+	if( debugflag(EXEC_OPCODE) ){
+		LOG_DEBUG("opcode=0x%08" PRIx32 " data = 0x%016" PRIx64, opcode, *data );
+	}
+	return retval;
 }
 
 static int cortex_a53_instr_read_data_dcc(struct arm_dpm *dpm,
@@ -1100,7 +1168,9 @@ static int cortex_a53_poll(struct target *target)
 	
 	enum target_state prev_target_state = target->state;
 
-	//	LOG_DEBUG("armv8-poll target");
+	if( debugflag( POLL ) ){
+		LOG_DEBUG("armv8-poll target");
+	}
 	/*  toggle to another core is done by gdb as follow */
 	/*  maint packet J core_id */
 	/*  continue */
@@ -1369,7 +1439,7 @@ static int cortex_a53_halt(struct target *target)
 
 		retval = armv8_cti_wr_HALT( target ); //trigger dbg req evt
 		retval = armv8_dbg_rd_EDSCR( target, &dummy);
-		LOG_DEBUG("After My CTI1 triggered: %d EDSCR 0x%08" PRIx32, retval, dummy);
+		LOG_DEBUG("After CTI1 triggered: %d EDSCR 0x%08" PRIx32, retval, dummy);
 
 		target->is_64b=false;
 		target->type->arch_state=armv7a_arch_state;
@@ -1765,6 +1835,11 @@ static int cortex_a53_step_64(struct target *target, int current, const struct t
 		return ERROR_TARGET_NOT_HALTED;
 	}
 
+	LOG_DEBUG("step: current: %d, address: %s, handlebps: %d",
+		  current,
+		  target_addr2str1( target, pAddr ),
+		  handle_breakpoints );
+
 	/* current = 1: continue on current pc, otherwise continue at <address> */
 	//SQUTODO: change to 64bit pc
 	r = arm->pc;
@@ -1882,9 +1957,6 @@ static int cortex_a53_set_breakpoint(struct target *target,
 		retval = armv8_dbg_wr_bpwp_regs( armv8, brp_list + brp_i);
 		if (retval != ERROR_OK)
 			return retval;
-		LOG_DEBUG("brp %i control 0x%0" PRIx32 " value %s", brp_i,
-			brp_list[brp_i].control,
-			  target_addr64str1( target, brp_list[brp_i].value));
 	} else if (breakpoint->type == BKPT_SOFT) {
 		uint8_t code[4];
 		struct target_addr tmp_addr;
@@ -2069,8 +2141,6 @@ static int cortex_a53_unset_breakpoint(struct target *target, struct breakpoint
 				LOG_DEBUG("Invalid BRP number in breakpoint");
 				return ERROR_OK;
 			}
-			LOG_DEBUG("rbp %i control 0x%0" PRIx32 " value %s" PRIx32, brp_i,
-				  brp_list[brp_i].control, target_addr64str1(target,brp_list[brp_i].value));
 			brp_list[brp_i].used = 0;
 			brp_list[brp_i].value = 0;
 			brp_list[brp_i].control = 0;
@@ -2249,8 +2319,10 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 	uint8_t *tmp_buff = NULL;
 	struct target_addr tmp_addr;
 	
-	LOG_DEBUG("Writing APB-AP memory address %s size %d"  PRIu32 " count%"  PRIu32,
-			  target_addr2str1(target,pAddr), (int)size, count);
+	if( debugflag( MEM_IO ) ){
+		LOG_DEBUG("Writing APB-AP memory address %s size %d"  PRIu32 " count%"  PRIu32,
+				  target_addr2str1(target,pAddr), (int)size, count);
+	}
 	if (target->state != TARGET_HALTED) {
 		LOG_WARNING("target not halted");
 		return ERROR_TARGET_NOT_HALTED;
@@ -2404,8 +2476,10 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 	uint8_t buf[8];
 	uint8_t *u8buf_ptr;
 
-	LOG_DEBUG("Reading APB-AP memory address %s size %d"  PRIu32 " count%"  PRIu32,
-			  target_addr2str1(target,pAddr), size, count);
+	if( debugflag( MEM_IO ) ){
+		LOG_DEBUG("Reading APB-AP memory address %s size %d"  PRIu32 " count%"  PRIu32,
+				  target_addr2str1(target,pAddr), size, count);
+	}
 	if (target->state != TARGET_HALTED) {
 		LOG_WARNING("target not halted");
 		return ERROR_TARGET_NOT_HALTED;
@@ -2554,8 +2628,28 @@ static int cortex_a53_read_memory_64(struct target *target, const struct target_
 	}
 
 	/* cortex_a53 handles unaligned memory access */
-	LOG_DEBUG("Reading memory at address %s; size %d; count %" PRId64,
-			  target_addr2str1(target,pAddr), (int)size, count);
+	if( debugflag( MEM_IO ) ){
+		LOG_DEBUG("Reading memory at address %s; size %d; count %" PRId64,
+				  target_addr2str1(target,pAddr), (int)size, count);
+	}
+	
+	/* Use Strong's hard coded hack here.
+	 * reading at zero will fail 
+	 * This solution is *WRONG* and *invalid*
+	 *
+	 * BECAUSE:  Address ZERO is a valid memory address
+	 * We should (but cannot right now) read from 
+	 * this location - and if that read fails
+	 * then we should return an error
+	 *
+	 * What is wrong: We should not hard code this
+	 * and falsely return an error for this access.
+	 * there can and will be times when zero is valid.
+	 */
+	if(pAddr->addr==0){
+		LOG_ERROR("SQU: trying to read @0x0 will cause exception. Return error directly for now to avoid handling exception");
+		return -107;
+	}
 
 	int dp;
 	dp = target_addr_resolve_route( target, pAddr, &resolved );
@@ -2621,9 +2715,11 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 		
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
 	
-	LOG_DEBUG("Writing memory to real address %s; size %d; count %" PRId64,
-			  target_addr2str1(target,pAddr),
-			  size, count);
+	if( debugflag( MEM_IO ) ){
+		LOG_DEBUG("Writing memory to real address %s; size %d; count %" PRId64,
+				  target_addr2str1(target,pAddr),
+				  size, count);
+	}
 
 	if( 0 == count ){
 		return ERROR_OK;
@@ -2667,6 +2763,9 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 		 */
 
 		/* invalidate I-Cache */
+		if( debugflag( MEM_IO ) ){
+			LOG_DEBUG("I-cache flush");
+		}
 		if (armv7a->armv7a_mmu.armv7a_cache.i_cache_enabled) {
 			/* ICIMVAU - Invalidate Cache single entry
 			 * with MVA to PoU
@@ -2685,6 +2784,9 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 		}
 
 		/* invalidate D-Cache */
+		if( debugflag( MEM_IO ) ){
+			LOG_DEBUG("d-cache flush");
+		}
 		if (armv7a->armv7a_mmu.armv7a_cache.d_u_cache_enabled) {
 			/* DCIMVAC - Invalidate data Cache line
 			 * with MVA to PoC
@@ -2727,8 +2829,20 @@ static int cortex_a53_write_memory_64(struct target *target, const struct target
 	}
 
 	/* cortex_a53 handles unaligned memory access */
-	LOG_DEBUG("Writing memory at address %s; size %d; count %" PRId64,
-			  target_addr2str1(target,pAddr), (int)size, count);
+
+	if( debugflag( MEM_IO ) ){
+		LOG_DEBUG("Writing memory at address %s; size %d; count %" PRId64,
+				  target_addr2str1(target,pAddr), (int)size, count);
+		
+		{
+			uint64_t nbytes;
+			nbytes = size * count;
+			if( nbytes > 32 ){
+				nbytes = 32;
+			}
+			log_hexdump( pAddr->addr, (void *)buffer, nbytes );
+		}
+	}
 
 	/* determine if MMU was enabled on target stop */
 	retval = cortex_a53_mmu(target, &mmu_enabled);
@@ -2759,11 +2873,6 @@ static int cortex_a53_write_memory_64(struct target *target, const struct target
 }
 
 
-static int cortex_a53_write_buffer_64(struct target *target, const struct target_addr *pAddr, uint64_t size, const uint8_t *buffer)
-{
-	return cortex_a53_write_memory_64(target, pAddr, 1, size, buffer);
-}
-
 static int cortex_a53_handle_target_request(void *priv)
 {
 	struct target         *target = priv;
@@ -2873,8 +2982,26 @@ static int cortex_a53_examine_first(struct target *target)
 	LOG_DEBUG("cortex_a53[%d] cpuid: 0x%08" PRIx32, target->coreid, cpuid );
 	armv8->midr_el1_reg = cpuid;
 
+	{
+		/* read the EDDFR as two seperate 32bit values lsb first */
+		/* table H8-2, page H8-4769, ARM DDI0478a */
+		uint32_t tmp32;
+		uint64_t tmp64;
+		
+		retval = target_cs_dbg_rd32( target, EDDFR, &tmp32 );
+		if( retval != ERROR_OK ){
+			return retval;
+		}
+		dfr0 = tmp32;
+		retval = target_cs_dbg_rd32( target, EDDFR, &tmp32 );
+		if( retval != ERROR_OK ){
+			return retval;
+		}
+		tmp64 = tmp32;
+		tmp64 = tmp64 << 32;
+		dfr0 = dfr0 | tmp64;
+	}
 
-	retval = target_cs_dbg_rd64( target, EDDFR, &dfr0);
 	if (retval != ERROR_OK) {
 		LOG_DEBUG("Examine %s failed", "EDDFR");
 		return retval;
@@ -3109,6 +3236,16 @@ COMMAND_HANDLER(cortex_a53_handle_smp_gdb_command)
 	return ERROR_OK;
 }
 
+static int jim_cortex_a53_debugflags( Jim_Interp *interp, int argc, Jim_Obj * const *argv )
+{
+	Jim_GetOptInfo goi;
+
+	Jim_GetOpt_Setup( &goi, interp, argc, argv );
+	
+	return Jim_LogFlags( &goi, &cortex_a53_debugflags, NULL );
+}
+
+
 static const struct command_registration cortex_a53_exec_command_handlers[] = {
 	{
 		.name = "cache_info",
@@ -3138,6 +3275,13 @@ static const struct command_registration cortex_a53_exec_command_handlers[] = {
 		.usage = "",
 	},
 	{
+		.name = "debugflags",
+		.jim_handler = jim_cortex_a53_debugflags,
+		.mode = COMMAND_EXEC,
+		.help = "set/display debug log flags",
+		.usage = "[number]"
+	},
+	{
 		.name = "smp_gdb",
 		.handler = cortex_a53_handle_smp_gdb_command,
 		.mode = COMMAND_EXEC,
@@ -3176,7 +3320,7 @@ static struct target_io64 cortexa53_target64 = {
 	.blank_check_memory = NULL, /* NOT SUPPORTED (64bit reasons) */
 
 	.read_buffer = target64_read_buffer_default,
-	.write_buffer = cortex_a53_write_buffer_64,
+	.write_buffer = target64_write_buffer_default,
 	.virt2phys = cortex_a53_virt2phys_64,
 	// .run_algorithm = armv4_5_run_algorithm, NOT SUPPORTED (64bit reasons)
 
-- 
1.9.1


From 473a8569662c193e057a001b86713a90f878cc2f Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 45/94] Fix (part2) of gdb remote access for qprobe

---
 src/target/arm_adi_v5.c   | 109 +++++++++++++++++++++++++++++++++-------------
 src/target/arm_adi_v5.h   |   2 +
 src/target/coresight_io.c |   8 ++--
 3 files changed, 83 insertions(+), 36 deletions(-)

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index ff6d96a..2c945e2 100755
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -80,6 +80,11 @@
 
 struct adiv5_dap *global_dap;
 
+jim_wide dap_debug_flags;
+#define _debugflag(N)  (1 <<(N))
+#define debug_flag(N)  (!!(dap_debug_flags & N))
+#define DAP_APDP_IO  _debugflag(0)
+#define DAP_MEM_IO   _debugflag(1)
 
 /***************************************************************************
  *                                                                         *
@@ -158,10 +163,14 @@ void dap_ap_select(struct adiv5_dap *dap, int ap )
 
 #if DAP_REG_CACHE	
 	if ( ap == dap->cached_ap_port) {
-		LOG_DEBUG("select-ap = %d cached\n", ap );
+		if( debug_flag(DAP_APDP_IO) ){
+			LOG_DEBUG("select-ap = %d cached\n", ap );
+		}
 		return;
 	}
-	LOG_DEBUG("select-ap = %d *new*\n", ap );
+	if( debug_flag(DAP_APDP_IO) ){
+		LOG_DEBUG("select-ap = %d *new*\n", ap );
+	}
 #endif
 	dap->cached_ap_port = ap;
 	/* invalidate where we are now */
@@ -204,7 +213,9 @@ static int dap_setup_accessport_csw(struct adiv5_dap *dap, uint32_t csw, const s
 	
 	if( (!(port->cached_csw_valid)) || (csw != port->cached_csw_reg) ){
 		
-		/* LOG_DEBUG("DAP: Set CSW %x",csw); */
+		if( debug_flag(DAP_APDP_IO) ){
+			LOG_DEBUG("DAP: Set CSW %x",csw);
+		}
 		r = dap_queue_ap_write(dap, AP_MEM_REG_CSW, csw);
 		if( r == ERROR_OK ){
 			port->cached_csw_valid = true;
@@ -466,7 +477,6 @@ static int coresight_io_chunk_wr(struct coresight_bulk *bulk )
 	for( x = 0 ; x < bulk->wip_count ; x++ ){
 
 		outvalue   = 0;
-		this_count = 1;
 
 		if( rewrite_tar ){
 			/* we have to rewrite this all the time */
@@ -474,7 +484,10 @@ static int coresight_io_chunk_wr(struct coresight_bulk *bulk )
 			struct target_addr tmp;
 			tmp = bulk->addr;
 			tmp.addr ^= ti_addr_xor;
-	
+			if( debug_flag(DAP_MEM_IO) ){
+				LOG_DEBUG("access setup: csw: 0x%08" PRIx32 " addr: 0x%016" PRIx64,
+						  csw, tmp.addr );
+			}
 			r = dap_setup_accessport( bulk->dap, csw, &tmp );
 			if( r != ERROR_OK ){
 				goto fail;
@@ -490,20 +503,25 @@ static int coresight_io_chunk_wr(struct coresight_bulk *bulk )
 		 */
 		this_size  = bulk->size;
 		/* INSERT THAT OPTIMIZATION HERE
+		 *
+		 * MEANWHILE... we only do one per loop
 		 */
+		this_count = 1;
 
-		/* How many source bytes each transfer will consume, and their location in the DRW,
-		 * depends on the type of transfer and alignment. See ARM document IHI0031C. */
+		/* How many source bytes each transfer will consume, and their
+		 * location in the DRW, depends on the type of transfer and
+		 * alignment. See ARM document IHI0031C.
+		 */
 		buff     = bulk->buffer;
 		addr     = bulk->addr.addr;
 		outvalue = 0;
 
 		/* If you are concerned about the TI xors..
-		 * Note that if they do not apply, the values
-		 * are zeroed out, which makes the xor a nop.
+		 * Note that if they do not apply, the XOR 
+		 * values are zeroed out, making it a NOP
 		 *
-		 * This just simplifies the reading and lessens
-		 * the indent level
+		 * This just simplifies the reading and 
+		 * lessens the indent level
 		 */
 		switch (this_size) {
 		case 8:
@@ -530,8 +548,11 @@ static int coresight_io_chunk_wr(struct coresight_bulk *bulk )
 			outvalue |= (uint64_t)*buff++ << (8 * (ti_addr_xor ^ ti_addr_xor2 ^ (addr++ & 3)));
 			break;
 		}
-		bulk->buffer    = buff;
-		bulk->addr.addr = addr;
+
+		if( debug_flag(DAP_MEM_IO) ){
+			LOG_DEBUG("wr addr: 0x%016" PRIx64 " <= 0x%016" PRIx64,
+					  bulk->addr.addr, outvalue );
+		}
 
 		r = ERROR_OK;
 		if( this_size == 8 ){
@@ -559,6 +580,7 @@ static int coresight_io_chunk_wr(struct coresight_bulk *bulk )
 			r = dap_queue_ap_write( bulk->dap, AP_MEM_REG_DRW, outvalue );
 		}
 		if( r != ERROR_OK ){
+			LOG_DEBUG("ERROR QUEING DAP WRITES!\n");
 			break;
 		}
 		bulk->addr.addr += this_size;
@@ -626,34 +648,44 @@ int coresight_io_bulk( struct coresight_bulk *bulk )
 			/* Determine address when TAR wraps. */
 			w = bulk->addr.addr;
 
-			/* Round up to next block */
-			w += (bulk->port->tar_wrap-1);
+			/* get an address *in* the next block */
+			w += bulk->port->tar_wrap;
+
+			/* Round down to start of that block */
 			w &= (~(bulk->port->tar_wrap-1));
 
-			/* get num-bytes to wrap */
+			/* How many bytes until that block? */
 			w = w - bulk->addr.addr;
 
-			/* bytes to count of items */
+			/* Convert bytes to count */
 			w = w / bulk->size;
 
-			if( w == 0 ){
-				/* this happens when the transfer
-				 * is not aligned, and crosses
-				 * the wrap boundary, 
-				 *
-				 * This occurs exactly on the
-				 * single transfer that crosses
-				 * the wrap boundary 
-				 */
-				w = 1;
-			}
-
-			/* If needed, clip the count */
+			/* reduce the transfer to *THIS* size */
 			if( w < bulk->wip_count ){
 				bulk->wip_count = w;
 			}
 		}
 
+		if( debug_flag(DAP_MEM_IO) ){
+			LOG_DEBUG("bulk: %c @0x%016" PRIx64 " count: 0x%08" PRIx32 " size: %d, total: %d",
+					  bulk->rw,
+					  /* bulk->target can be null! */
+					  /* do not use "target_addr2tr() */
+					  bulk->addr.addr,
+					  bulk->wip_count,
+					  (int)(bulk->size),
+					  (int)(bulk->wip_count * bulk->size));
+			{
+				int n;
+				n = bulk->wip_count;
+				if( n > 32 ){
+					n = 32;
+				}
+				log_hexdump( bulk->addr.addr, (void *)(bulk->buffer), n );
+			}
+		}
+		
+		
 		/* transfer a chunk */
 		if( bulk->rw == 'w' ){
 			r = coresight_io_chunk_wr( bulk );
@@ -2638,7 +2670,7 @@ static int jim_dap_mem_read( Jim_Interp *_interp, int _argc, Jim_Obj * const *_a
 
 		/* Print */
 		for( x = 0 ; x < n ; x++ ){
-			
+			w = 0; /* make compiler warning go away */
 			switch( rdwr.width ){
 			case 1:
 				w = rdwr.data.u8[x];
@@ -2719,6 +2751,14 @@ static int jim_dap_force_cfg( Jim_Interp *_interp, int _argc, Jim_Obj * const *_
 	return JIM_OK;
 }
 
+static int jim_dap_debug_flags( Jim_Interp *interp, int argc, Jim_Obj * const *argv )
+{
+	Jim_GetOptInfo goi;
+
+	Jim_GetOpt_Setup( &goi, interp, argc, argv );
+	
+	return Jim_LogFlags( &goi, &dap_debug_flags, NULL );
+}
 
 static const struct command_registration dap_commands[] = {
 	{
@@ -2730,6 +2770,13 @@ static const struct command_registration dap_commands[] = {
 		.usage = "[ap_num]",
 	},
 	{
+		.name = "debugflags",
+		.jim_handler = jim_dap_debug_flags,
+		.mode = COMMAND_EXEC,
+		.help = "set/display dap debug log flags",
+		.usage = "[number]"
+	},
+	{
 		.name = "force_port_cfg",
 		.jim_handler = jim_dap_force_cfg,
 		.mode = COMMAND_EXEC,
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 8618107..5f7bebd 100755
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -791,8 +791,10 @@ int target_cs_addr_queued_wr32( struct target *target, const struct target_addr
 int target_cs_addr_queued_wr64( struct target *target, const struct target_addr *addr, uint64_t value );
 
 int target_cs_dbg_rd32( struct target *target, uint64_t ofset, uint32_t *value );
+/* THINK TWICE about using this  - most DBG registers are 'pairs' of 32bit registers */
 int target_cs_dbg_rd64( struct target *target, uint64_t ofset, uint64_t *value );
 int target_cs_dbg_wr32( struct target *target, uint64_t ofset, uint32_t value );
+/* THINK TWICE about using this  - most DBG registers are 'pairs' of 32bit registers */
 int target_cs_dbg_wr64( struct target *target, uint64_t ofset, uint64_t value );
 
 
diff --git a/src/target/coresight_io.c b/src/target/coresight_io.c
index 2173647..73ff686 100644
--- a/src/target/coresight_io.c
+++ b/src/target/coresight_io.c
@@ -267,13 +267,11 @@ static int coresight_bulk_setup( struct coresight_bulk *bulk,
 
 	/* target aligned? */
 	if( bulk->addr.addr & (size-1) ){
+		LOG_DEBUG("not-aligned: TARGET-ADDRESS");
 		bulk->is_aligned = false;
 	}
 
-	/* host aligned */
-	if( ((uintptr_t)(bulk->buffer)) & (size-1) ){
-		bulk->is_aligned = false;
-	}
+	/* we do not care about host align */
 	return ERROR_OK;
 }
 
@@ -503,7 +501,7 @@ int target_cs_dbg_wr64( struct target *target,uint64_t addr, uint64_t value )
 	if( port->data_64bit ){
 		return target_cs_wr64( target, &a, value );
 	}
-	
+
 	a64 = value;
 	b64 = value;
 	if( port->big_endian ){
-- 
1.9.1


From 39600c818b8fc9536568c0264665902f9bffd662 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 46/94] Better error reporting and syntax error handling

---
 src/target/mematts.c | 15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/src/target/mematts.c b/src/target/mematts.c
index fec0baf..c196295 100644
--- a/src/target/mematts.c
+++ b/src/target/mematts.c
@@ -99,6 +99,7 @@ int mem_att_create( const char *name, const struct target_addr *addr )
 	att = mem_att_find_name( name );
 	if( att ){
 		/* duplicate! */
+		LOG_DEBUG("Duplicate attribute: %s", name);
 		return ERROR_FAIL;
 	}
 	new_att = calloc( sizeof(*new_att) , 1 );
@@ -130,12 +131,14 @@ int mem_att_create_alias( const char *from_name, const char *to_name )
 	to_att = mem_att_find_name( from_name );
 	if( to_att ){
 		/* this cannot exist */
+		LOG_DEBUG("alias from name does not exists: %s", from_name);
 		return ERROR_FAIL;
 	}
 
 	/* this must exist */
 	to_att = mem_att_find_name( to_name );
 	if( to_att == NULL ){
+		LOG_DEBUG("alias to name does not exists: %s", to_name);
 		return ERROR_FAIL;
 	}
 	
@@ -417,6 +420,7 @@ static int jim_mematt_create( Jim_Interp *interp, int argc, Jim_Obj *const *argv
 
 	e = mem_att_create( name, &tmp );
 	if( e != ERROR_OK ){
+		LOG_DEBUG("Cannot create %s", name);
 		Jim_SetResultFormatted(goi.interp,"%s: cannot create", name );
 		e = JIM_ERR;
 	} else {
@@ -625,6 +629,8 @@ static const jim_subcmd_type memattribute_cmds[] = {
 
 static int jim_mematt( Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
+	int e;
+	struct command_context *ctx;	
 	if( argc < 1 ){
 		Jim_WrongNumArgs( interp, 1, argv, "list|name|delete|create|alias");
 		return JIM_ERR;
@@ -632,7 +638,11 @@ static int jim_mematt( Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 
 	const jim_subcmd_type *ct = Jim_ParseSubCmd( interp, memattribute_cmds, argc, argv );
 
-	return Jim_CallSubCmd( interp, ct, argc, argv );
+	e = Jim_CallSubCmd( interp, ct, argc, argv );
+	if( e == JIM_ERR ){
+		command_print_jim_error(interp);
+	}
+	return e;
 }
 
 static const struct command_registration mematt_command_handlers[] = {
@@ -673,6 +683,9 @@ int parse_memory_address( struct target_addr *pAddr, const char *str1, const cha
 	
 	int r;
 
+	if( str1 == NULL ){
+		return -1; /* ERROR */
+	}
 
 	/* NOTE: ALSO SEE:  Jim_GetOpt_Addr() */
 	/* always initialize */
-- 
1.9.1


From dd8e0913a17256f4a0cf8a101680ca8aad70ac46 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 47/94] Added new config files

---
 tcl/interface/ftdi/qualcomm_pid_9531.cfg | 14 ++++++++++++++
 1 file changed, 14 insertions(+)
 create mode 100644 tcl/interface/ftdi/qualcomm_pid_9531.cfg

diff --git a/tcl/interface/ftdi/qualcomm_pid_9531.cfg b/tcl/interface/ftdi/qualcomm_pid_9531.cfg
new file mode 100644
index 0000000..2d38c1f
--- /dev/null
+++ b/tcl/interface/ftdi/qualcomm_pid_9531.cfg
@@ -0,0 +1,14 @@
+#
+# Qualcomm vid 9531
+#
+#
+
+interface ftdi
+# Do not use the Description
+# Do not use a serial number
+ftdi_vid_pid 0x05c6 0x9531
+
+ftdi_layout_init 0x0538 0x057b
+ftdi_layout_signal LED -ndata 0x0400
+ftdi_layout_signal nTRST -data 0x0010
+ftdi_layout_signal nSRST -data 0x0020 -noe 0x0100
-- 
1.9.1


From 0c5f332ac1fa2b6b6851d21474e996e2f0e9a060 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 48/94] Added new config files

---
 tcl/test/jtag_detect_taps.cfg | 35 +++++++++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)
 create mode 100644 tcl/test/jtag_detect_taps.cfg

diff --git a/tcl/test/jtag_detect_taps.cfg b/tcl/test/jtag_detect_taps.cfg
new file mode 100644
index 0000000..2fc6d47
--- /dev/null
+++ b/tcl/test/jtag_detect_taps.cfg
@@ -0,0 +1,35 @@
+# -*- mode: tcl -*-
+# the period here don't really mean much
+adapter_nsrst_assert_width 40
+adapter_nsrst_delay 20
+jtag_ntrst_assert_width 40
+jtag_ntrst_delay 20
+reset_config trst_and_srst
+adapter_khz 300
+
+init
+
+if [ info exists TAP_FILENAME ] {
+	# a filenam as specified use it
+} else {
+	set TAP_FILENAME openocd.taps.txt
+}
+	
+if { [catch { open $TAP_FILENAME w} fh ] } {
+	puts "FATAL ERROR CANNOT OPEN $TAP_FILENAME"
+	test_harness EXIT_FAILURE
+} else {
+	set all_names [jtag names]
+	puts $fh [format "n-taps: %d" [llength $all_names]]
+
+	set n 0
+	foreach this_name $all_names {
+		puts $fh [format "tap-%d-name: %s"      $n $this_name]
+		puts $fh [format "tap-%d-tapid: 0x%08x" $n [jtag cget $this_name -tapid]]
+		puts $fh [format "tap-%d-irlen: %d"     $n [jtag cget $this_name -irlen]]
+		incr n
+	}
+	close $fh
+}
+
+
-- 
1.9.1


From 364bbac5ba40cff7e8467f285df7e4aca23eedc5 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 49/94] Fix command_parse_bool

---
 src/helper/command.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/helper/command.c b/src/helper/command.c
index 7179d99..b097d6b 100755
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -1448,7 +1448,7 @@ DEFINE_PARSE_LONGLONG(_s8,  int8_t,  n < INT8_MIN,  INT8_MAX)
 static int command_parse_bool(const char *in, bool *out,
 	const char *on, const char *off)
 {
-	if( in = NULL ){
+	if( in == NULL ){
 		return ERROR_COMMAND_SYNTAX_ERROR;
 	}
 	
-- 
1.9.1


From 286a4dbde7a4d7186e94914187f040e32904e5fd Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 50/94] Warning removal

---
 src/target/mematts.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/target/mematts.c b/src/target/mematts.c
index c196295..f390dd2 100644
--- a/src/target/mematts.c
+++ b/src/target/mematts.c
@@ -630,7 +630,6 @@ static const jim_subcmd_type memattribute_cmds[] = {
 static int jim_mematt( Jim_Interp *interp, int argc, Jim_Obj *const *argv)
 {
 	int e;
-	struct command_context *ctx;	
 	if( argc < 1 ){
 		Jim_WrongNumArgs( interp, 1, argv, "list|name|delete|create|alias");
 		return JIM_ERR;
-- 
1.9.1


From bb30f58b9988bedd5a3cf4acde7fbeae01db0007 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 51/94] a) Created Jim_GetOpt_Dispatch(), b) made debug_flags
 more universally usable, specifically so they can be set before command
 objects are created

---
 src/helper/log_flags.c | 124 +++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 124 insertions(+)
 create mode 100644 src/helper/log_flags.c

diff --git a/src/helper/log_flags.c b/src/helper/log_flags.c
new file mode 100644
index 0000000..2a67143
--- /dev/null
+++ b/src/helper/log_flags.c
@@ -0,0 +1,124 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include "command.h"
+#include "log.h"
+#include "jim.h"
+#include "jim-nvp.h"
+
+debug_flag_t test_debug_flags;
+
+struct debug_flag_entry {
+	const char *name;
+	debug_flag_t *pFlags;
+	const struct debug_flag_entry *next;
+};
+
+static struct debug_flag_entry *all_debug_flags;
+
+void debug_flag_register( const char *name, debug_flag_t *w )
+{
+	const struct debug_flag_entry *p;
+	struct debug_flag_entry *np;
+
+	p= all_debug_flags;
+	while(p){
+		if( 0 == strcmp( name, p->name ) ){
+			LOG_ERROR("duplicate log flag name: %s ignored\n", name);
+			return;
+		}
+		p = p->next;
+	}
+
+	np = calloc(1,sizeof(*np));
+	np->name = strdup(name);
+	np->pFlags = w;
+	np->next = all_debug_flags;
+	all_debug_flags = np;
+}
+
+
+static int logflag_list( const Jim_Getopt_SubCmd *pcmd, Jim_GetOptInfo *goi )
+{
+	const struct debug_flag_entry *p;
+	if( goi->argc ){
+		Jim_SetResultFormatted( goi->interp, "<no-parameters>",-1);
+		return JIM_ERR;
+	}
+	Jim_Obj *o = Jim_NewListObj( goi->interp, NULL, 0 );
+
+	p = all_debug_flags;
+	while( p ){
+		Jim_ListAppendElement( goi->interp, o, Jim_NewStringObj( goi->interp, p->name, -1 ) );
+		p = p->next;
+	}
+	Jim_SetResult(goi->interp,o);
+	return JIM_OK;
+}
+
+
+static int logflag_setget(  const Jim_Getopt_SubCmd *pcmd, Jim_GetOptInfo *goi )
+{
+	const struct debug_flag_entry *p;
+	char *name;
+	int e;
+	
+
+	if( goi->argc == 0 ){
+		Jim_SetResultFormatted( goi->interp, "?name ..");
+		return JIM_ERR;
+	}
+	e = Jim_GetOpt_String( goi, &name, NULL );
+	if( e != JIM_OK ){
+		return e;
+	}
+
+	p = all_debug_flags;
+	while( p ){
+		if( 0 == strcmp( p->name, name ) ){
+			break;
+		} else {
+			p = p->next;
+		}
+	}
+
+	if( p == NULL ){
+		Jim_SetResultFormatted( goi->interp, "unknown name: %s",name);
+		return JIM_ERR;
+	}
+	
+	if( pcmd->cmd_cookie == 's' ){
+		jim_wide w;
+		e = Jim_GetOpt_Wide( goi, &w );
+		if( e != JIM_OK ){
+			return e;
+		}
+		*p->pFlags = w;
+	}
+	Jim_SetResultInt( goi->interp, *(p->pFlags) );
+	return JIM_OK;
+}
+
+
+static const Jim_Getopt_SubCmd jim_logflag_cmds[] = {
+	{ .cmd_name = "list", .cmd_handler = logflag_list },
+	{ .cmd_name = "set" , .cmd_cookie = 's', .cmd_handler = logflag_setget },
+	{ .cmd_name = "get" , .cmd_cookie = 'g', .cmd_handler = logflag_setget },
+	/* fixme: future: add named flags */
+	/* terminate */
+	{ .cmd_name = NULL }
+};
+
+
+int Jim_DebugFlag_Command( Jim_Interp *interp, int argc, Jim_Obj **argv )
+{
+	Jim_GetOptInfo goi;
+
+	Jim_GetOpt_Setup( &goi, interp, argc-1, argv+1 );
+
+	return Jim_GetOpt_Dispatch( &goi, jim_logflag_cmds );
+}
-- 
1.9.1


From a807b5b779f9959c6496c8ac9c9fc2ccd84a8366 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 52/94] Make debug flags more universal

---
 src/helper/Makefile.am | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/helper/Makefile.am b/src/helper/Makefile.am
index 9477267..4192229 100755
--- a/src/helper/Makefile.am
+++ b/src/helper/Makefile.am
@@ -17,6 +17,7 @@ libhelper_la_SOURCES = \
 	replacements.c \
 	fileio.c \
 	util.c \
+	log_flags.c \
 	jim-nvp.c
 
 if IOUTIL
-- 
1.9.1


From a882c84d599289728fe8572eb46e4bea5e81b5ee Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 53/94] Make debug flags more universal

---
 src/helper/jim-nvp.c    | 52 +++++++++++++++++++++++--------------
 src/helper/jim-nvp.h    | 16 +++++++++++-
 src/helper/log.c        |  6 +++++
 src/helper/log.h        | 11 ++++++++
 src/openocd.c           |  9 +++++++
 src/target/arm_adi_v5.c | 34 +++++-------------------
 src/target/arm_adi_v5.h |  5 ++++
 src/target/armv8.c      |  2 ++
 src/target/armv8.h      | 10 +++++++
 src/target/cortex_a53.c | 69 ++++++++++++++++---------------------------------
 10 files changed, 119 insertions(+), 95 deletions(-)

diff --git a/src/helper/jim-nvp.c b/src/helper/jim-nvp.c
index c10afe0..94a340c 100755
--- a/src/helper/jim-nvp.c
+++ b/src/helper/jim-nvp.c
@@ -442,30 +442,42 @@ int Jim_GetOpt_ArmDapPort( Jim_GetOptInfo *goi, int *portnum )
 }
 
 
-int Jim_LogFlags( Jim_GetOptInfo *goi, jim_wide *w, const Jim_Nvp *lookup )
+
+int Jim_GetOpt_Dispatch( Jim_GetOptInfo *goi, const Jim_Getopt_SubCmd *_cmds )
 {
+	char *cp;
 	int e;
+	const Jim_Getopt_SubCmd *cmds;
+	
+	if( goi->argc == 0 ){
+		Jim_SetResultString( goi->interp, "?subcommand ...", -1 );
+		return JIM_ERR;
+	}
+	
+	e = Jim_GetOpt_String( goi, &cp, NULL );
+	if( e != JIM_OK ){
+		return e;
+	}
 
-	e = JIM_OK;
-	switch( goi->argc ){
-	case 2:
-		/* FIXME: IN FUTURE - support *NAMES* via lookup */
-		/* lookup might be null */
-		/* fallthrough */
-	default:
-		Jim_SetResultString( goi->interp, "?[newvalue]",-1);
-		e = JIM_ERR;
-		break;
-	case 1:
-		e = Jim_GetOpt_Wide( goi, w );
-		break;
-	case 0:
-		/* no problem just show */
-		break;
+	cmds = _cmds;
+	while(cmds->cmd_name){
+		if( 0 == strcmp( cp, cmds->cmd_name ) ){
+			return (*(cmds->cmd_handler))( cmds, goi );
+		}
+		cmds++;
 	}
 
-	if( e == JIM_OK ){
-		Jim_SetResultInt( goi->interp, *w );
+	if( 0 == strcmp( "help", cp ) ){
+		Jim_Obj *o = Jim_NewListObj( goi->interp, NULL, 0 );
+		cmds = _cmds;
+		while( cmds->cmd_name ){
+			Jim_ListAppendElement( goi->interp, o, Jim_NewStringObj( goi->interp, cmds->cmd_name, -1 ) );
+			cmds++;
+		}
+		Jim_SetResult( goi->interp, o );
+		return JIM_OK;
 	}
-	return e;
+	Jim_SetResultFormatted( goi->interp, "unknown command: %s", cp );
+	return JIM_ERR;
 }
+	
diff --git a/src/helper/jim-nvp.h b/src/helper/jim-nvp.h
index 4006ed0..562bc2e 100755
--- a/src/helper/jim-nvp.h
+++ b/src/helper/jim-nvp.h
@@ -354,6 +354,20 @@ int Jim_GetOpt_ArmDapPort( Jim_GetOptInfo *goi, int *portnum );
  */
 int Jim_GetOpt_Enum(Jim_GetOptInfo *goi, const char *const *lookup, int *puthere);
 
-int Jim_LogFlags( Jim_GetOptInfo *goi, jim_wide *w, const Jim_Nvp *lookup );
+
+/** Common Sub Command Handler code based on GetOpt
+ *
+ */
+typedef struct jim_getopt_subcmd Jim_Getopt_SubCmd;
+
+struct jim_getopt_subcmd {
+	const char *cmd_name;
+	intptr_t    cmd_cookie;
+	int (*cmd_handler)( const Jim_Getopt_SubCmd *pcmd, Jim_GetOptInfo *goi );
+};
+
+int Jim_GetOpt_Dispatch( Jim_GetOptInfo *goi, const Jim_Getopt_SubCmd *cmds );
+	
+	
 
 #endif
diff --git a/src/helper/log.c b/src/helper/log.c
index fcda13b..0d222ca 100755
--- a/src/helper/log.c
+++ b/src/helper/log.c
@@ -267,6 +267,12 @@ static struct command_registration log_command_handlers[] = {
 			"2 (default) adds other info; 3 adds debugging.",
 		.usage = "number",
 	},
+	{
+		.name = "debug_flags",
+		.jim_handler = Jim_DebugFlag_Command,
+		.mode = COMMAND_ANY,
+		.help = "list, set, get debug log flags"
+	},
 	COMMAND_REGISTRATION_DONE
 };
 
diff --git a/src/helper/log.h b/src/helper/log.h
index deafe49..7194198 100755
--- a/src/helper/log.h
+++ b/src/helper/log.h
@@ -146,4 +146,15 @@ extern int debug_level;
 #define ERROR_WAIT						(-5)
 
 
+/*
+ * Debug Flags give finer control over logs.
+ */
+typedef uint64_t debug_flag_t;
+
+void debug_flag_register( const char *name, debug_flag_t *w );
+#define _debugFlagN( N )   (1 << (N))
+#define _debugFlagEnabled( NAME, BITS )   (!!( (NAME) & (BITS) ) )
+
+int Jim_DebugFlag_Command( Jim_Interp *interp, int argc, Jim_Obj **argv );
+
 #endif	/* LOG_H */
diff --git a/src/openocd.c b/src/openocd.c
index 061cce0..25709d2 100755
--- a/src/openocd.c
+++ b/src/openocd.c
@@ -411,6 +411,15 @@ struct command_context *setup_command_handler(Jim_Interp *interp)
 
 	struct command_context *cmd_ctx = command_init(openocd_startup_tcl, interp);
 
+#define REGISTER_DEBUG_FLAGS( NAME )			\
+	{											\
+		extern debug_flag_t NAME;				\
+		debug_flag_register( #NAME, &NAME );	\
+	}
+	REGISTER_DEBUG_FLAGS( test_debug_flags );
+	REGISTER_DEBUG_FLAGS( dap_debug_flags );
+	REGISTER_DEBUG_FLAGS( armv8_debug_flags );
+	
 	/* register subsystem commands */
 	typedef int (*command_registrant_t)(struct command_context *cmd_ctx_value);
 	static const command_registrant_t command_registrants[] = {
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 2c945e2..1819230 100755
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -79,12 +79,8 @@
 #include <helper/time_support.h>
 
 struct adiv5_dap *global_dap;
-
 jim_wide dap_debug_flags;
-#define _debugflag(N)  (1 <<(N))
-#define debug_flag(N)  (!!(dap_debug_flags & N))
-#define DAP_APDP_IO  _debugflag(0)
-#define DAP_MEM_IO   _debugflag(1)
+
 
 /***************************************************************************
  *                                                                         *
@@ -163,12 +159,12 @@ void dap_ap_select(struct adiv5_dap *dap, int ap )
 
 #if DAP_REG_CACHE	
 	if ( ap == dap->cached_ap_port) {
-		if( debug_flag(DAP_APDP_IO) ){
+		if( dap_debug_flag(DAP_APDP_IO) ){
 			LOG_DEBUG("select-ap = %d cached\n", ap );
 		}
 		return;
 	}
-	if( debug_flag(DAP_APDP_IO) ){
+	if( dap_debug_flag(DAP_APDP_IO) ){
 		LOG_DEBUG("select-ap = %d *new*\n", ap );
 	}
 #endif
@@ -213,7 +209,7 @@ static int dap_setup_accessport_csw(struct adiv5_dap *dap, uint32_t csw, const s
 	
 	if( (!(port->cached_csw_valid)) || (csw != port->cached_csw_reg) ){
 		
-		if( debug_flag(DAP_APDP_IO) ){
+		if( dap_debug(DAP_APDP_IO) ){
 			LOG_DEBUG("DAP: Set CSW %x",csw);
 		}
 		r = dap_queue_ap_write(dap, AP_MEM_REG_CSW, csw);
@@ -484,7 +480,7 @@ static int coresight_io_chunk_wr(struct coresight_bulk *bulk )
 			struct target_addr tmp;
 			tmp = bulk->addr;
 			tmp.addr ^= ti_addr_xor;
-			if( debug_flag(DAP_MEM_IO) ){
+			if( dap_debug(DAP_MEM_IO) ){
 				LOG_DEBUG("access setup: csw: 0x%08" PRIx32 " addr: 0x%016" PRIx64,
 						  csw, tmp.addr );
 			}
@@ -549,7 +545,7 @@ static int coresight_io_chunk_wr(struct coresight_bulk *bulk )
 			break;
 		}
 
-		if( debug_flag(DAP_MEM_IO) ){
+		if( dap_debug(DAP_MEM_IO) ){
 			LOG_DEBUG("wr addr: 0x%016" PRIx64 " <= 0x%016" PRIx64,
 					  bulk->addr.addr, outvalue );
 		}
@@ -666,7 +662,7 @@ int coresight_io_bulk( struct coresight_bulk *bulk )
 			}
 		}
 
-		if( debug_flag(DAP_MEM_IO) ){
+		if( dap_debug(DAP_MEM_IO) ){
 			LOG_DEBUG("bulk: %c @0x%016" PRIx64 " count: 0x%08" PRIx32 " size: %d, total: %d",
 					  bulk->rw,
 					  /* bulk->target can be null! */
@@ -2751,15 +2747,6 @@ static int jim_dap_force_cfg( Jim_Interp *_interp, int _argc, Jim_Obj * const *_
 	return JIM_OK;
 }
 
-static int jim_dap_debug_flags( Jim_Interp *interp, int argc, Jim_Obj * const *argv )
-{
-	Jim_GetOptInfo goi;
-
-	Jim_GetOpt_Setup( &goi, interp, argc, argv );
-	
-	return Jim_LogFlags( &goi, &dap_debug_flags, NULL );
-}
-
 static const struct command_registration dap_commands[] = {
 	{
 		.name = "info",
@@ -2770,13 +2757,6 @@ static const struct command_registration dap_commands[] = {
 		.usage = "[ap_num]",
 	},
 	{
-		.name = "debugflags",
-		.jim_handler = jim_dap_debug_flags,
-		.mode = COMMAND_EXEC,
-		.help = "set/display dap debug log flags",
-		.usage = "[number]"
-	},
-	{
 		.name = "force_port_cfg",
 		.jim_handler = jim_dap_force_cfg,
 		.mode = COMMAND_EXEC,
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 5f7bebd..f27bf30 100755
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -886,5 +886,10 @@ int target_cs_discover_ap( struct target *target,
 						   struct coresight_address *port );
 
 
+extern jim_wide dap_debug_flags;
+#define DAP_APDP_IO  _debugFlagN(0)
+#define DAP_MEM_IO   _debugFlagN(1)
+#define dap_debug( NAME )  _debugFlagEnabled( NAME, dap_debug_flags )
+
 
 #endif
diff --git a/src/target/armv8.c b/src/target/armv8.c
index f3abec3..4a9d01e 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -16,6 +16,8 @@
 
 #include "arm_opcodes.h"
 
+debug_flag_t armv8_debug_flags;
+
 const struct dap_coresight_name armv8_cpu_regs[] = {
 #define CORESIGHT_RW_REG( N, V, D ) { .address = V, .rd_name = #N, .wr_name = #N }
 #define CORESIGHT_RO_REG( N, V, D ) { .address = V, .rd_name = #N, .wr_name = NULL }
diff --git a/src/target/armv8.h b/src/target/armv8.h
index 419d044..1e5af15 100755
--- a/src/target/armv8.h
+++ b/src/target/armv8.h
@@ -12,6 +12,16 @@
 #include "arm_dpm.h"
 #include "armv8_dpm.h"
 
+extern debug_flag_t armv8_debug_flags;
+#define armv8_debug(N)  (_debugFlagEnabled( armv8_debug_ ## N, armv8_debug_flags ))
+#define armv8_debug_OSLAR_EL1     _debugFlagN(0)
+#define armv8_debug_EXEC_OPCODE   _debugFlagN(1)
+#define armv8_debug_DCC_IO        _debugFlagN(2)
+#define armv8_debug_MEM_IO        _debugFlagN(3)
+#define armv8_debug_HW_BP         _debugFlagN(4)
+#define armv8_debug_POLL          _debugFlagN(5)
+#define armv8_debug_EDSCR         _debugFlagN(6)
+
 #if 0
 #define EDESR		0x020
 #define EDECR		0x024
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index c53d5b0..74eafca 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -36,16 +36,7 @@ static int cortex_a53_virt2phys_64(struct target *target,
 static int cortex_a53_read_apb_ab_memory(struct target *target,
 	const struct target_addr *pAddr, uint32_t size, uint32_t count, uint8_t *buffer);
 
-jim_wide cortex_a53_debugflags;
-#define _debugflag(N)  (1 <<(N))
-#define debugflag(N)  (!!(cortex_a53_debugflags & cortex_a53_debugflag_## N))
-#define cortex_a53_debugflag_OSLAR_EL1     _debugflag(0)
-#define cortex_a53_debugflag_EXEC_OPCODE   _debugflag(1)
-#define cortex_a53_debugflag_DCC_IO        _debugflag(2)
-#define cortex_a53_debugflag_MEM_IO        _debugflag(3)
-#define cortex_a53_debugflag_HW_BP         _debugflag(4)
-#define cortex_a53_debugflag_POLL          _debugflag(5)
-#define cortex_a53_debugflag_EDSCR         _debugflag(6)
+
 
 #define _bitof(X,V)       _bitsof( X,X,V )
 #define _bitsof( X,Y,V )  (((V) >> (Y)) & ((1<<((X)-(Y)+1))-1))
@@ -144,7 +135,7 @@ static int armv8_dbg_rd_EDSCR( struct target *target, uint32_t *puthere )
 		if( old_EDSCR != v ){
 			old_EDSCR = v;
 
-			if( debugflag( EDSCR ) ){
+			if( armv8_debug( EDSCR ) ){
 				LOG_DEBUG("rd: edscr: 0x%08" PRIx32 " res0:%d rxful:%d txful:%d ito:%d rxo:%d txo:%d pipe:%d ite:%d",
 						  v,
 						  _bitof( 31, v ),  _bitof( 30, v ),
@@ -183,7 +174,7 @@ static int armv8_rd_OSLAR_EL1( struct target *target, uint32_t *v)
 	if( r != ERROR_OK ){
 		LOG_DEBUG("rd: oslar-el1: error %d",r);
 	} else {
-		if( debugflag(OSLAR_EL1) ){
+		if( armv8_debug(OSLAR_EL1) ){
 			LOG_DEBUG("rd: oslar-el1: 0x%08" PRIx32 " oslk:%d",
 					  *v, _bitof(0,*v) );
 		}
@@ -308,7 +299,7 @@ int armv8_dbg_wr_bpwp_regs( struct armv8 *armv8, struct cortex_a_brp *p )
 		return ERROR_FAIL;
 	}
 
-	if( debugflag( HW_BP ) ){
+	if( armv8_debug( HW_BP ) ){
 		LOG_DEBUG("bpwp enable, cr(0x%08" PRIx32 ")<=%08" PRIx32 " vr(0x%08" PRIx32 ")<= 0x%s",
 				  cr,
 				  p->control,
@@ -556,18 +547,18 @@ static int cortex_a53_exec_opcode(struct target *target,
 	int retval;
 
 	//SQU: why not just read it? dscr = dscr_p ? *dscr_p : 0;
-	if( debugflag(EXEC_OPCODE) ){
+	if( armv8_debug(EXEC_OPCODE) ){
 		LOG_DEBUG("armv8 exec opcode: 0x%08" PRIx32, opcode );
 	}
 	retval = armv8_dbg_rd_EDSCR( target, &dscr );
-	if( debugflag(EXEC_OPCODE) ){
+	if( armv8_debug(EXEC_OPCODE) ){
 		LOG_DEBUG("AArch64=%d (dscr=0x%08X)", isAArch64(dscr), dscr);
 	}
 
 	/* Wait for InstrCompl bit to be set */
 	long long then = timeval_ms();
 	while ((dscr & DSCR_INSTR_COMP) == 0) {
-		if( debugflag(EXEC_OPCODE) ){
+		if( armv8_debug(EXEC_OPCODE) ){
 			LOG_DEBUG("armv8-exec-opcode-poll(1)");
 		}
 		retval = armv8_dbg_rd_EDSCR( target, &dscr );
@@ -668,7 +659,7 @@ static int cortex_a53_exec_opcode(struct target *target,
 
 	then = timeval_ms();
 	do {
-		if( debugflag(EXEC_OPCODE) ){
+		if( armv8_debug(EXEC_OPCODE) ){
 			LOG_DEBUG("armv8-exec-opcode-poll(2)");
 		}
 		retval = armv8_dbg_rd_EDSCR( target, &dscr );
@@ -711,7 +702,7 @@ static int cortex_a53_write_dcc(struct armv8 *armv8, uint64_t data)
 	struct cortex_a_common *cortex_a = armv8_to_cortex_a(armv8);
 	struct target *target = armv8_to_target(armv8);
 
-	if( debugflag( DCC_IO ) ){
+	if( armv8_debug( DCC_IO ) ){
 		LOG_DEBUG("write DCC 0x%" PRIx64, data);
 	}
 	if(isAArch64(cortex_a->cpudbg_dscr))
@@ -735,7 +726,7 @@ static int cortex_a53_read_dcc(struct target *target, uint64_t *data,
 	long long then = timeval_ms();
 
 	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
-		if( debugflag( DCC_IO ) ){
+		if( armv8_debug( DCC_IO ) ){
 			LOG_DEBUG("poll DCC");
 		}
 		retval = armv8_dbg_rd_EDSCR( target, &dscr );
@@ -757,7 +748,7 @@ static int cortex_a53_read_dcc(struct target *target, uint64_t *data,
 	} else
 		*(pdw+1)=0;
 
-	if( debugflag( DCC_IO )){
+	if( armv8_debug( DCC_IO )){
 		LOG_DEBUG("read DCC 0x%08" PRIx64, *data);
 	}
 
@@ -855,7 +846,7 @@ static int cortex_a53_instr_write_data64_r0_mrs(struct arm_dpm *dpm,
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
-	if( debugflag(EXEC_OPCODE) ){
+	if( armv8_debug(EXEC_OPCODE) ){
 		LOG_DEBUG("opcode=0x%08" PRIx32 " data = 0x%016" PRIx64, opcode, data );
 	}
 	retval = cortex_a53_write_dcc(armv8, data);
@@ -889,7 +880,7 @@ static int cortex_a53_instr_write_data64_r0(struct arm_dpm *dpm,
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
-	if( debugflag(EXEC_OPCODE) ){
+	if( armv8_debug(EXEC_OPCODE) ){
 		LOG_DEBUG("opcode=0x%08" PRIx32 " data = 0x%016" PRIx64, opcode, data );
 	}
 
@@ -947,7 +938,7 @@ static int cortex_a53_instr_read_data64_dcc(struct arm_dpm *dpm,
 		return retval;
 
 	retval = cortex_a53_read_dcc(target, data, &dscr);
-	if( debugflag(EXEC_OPCODE) ){
+	if( armv8_debug(EXEC_OPCODE) ){
 		LOG_DEBUG("opcode=0x%08" PRIx32 " data = 0x%016" PRIx64, opcode, *data );
 	}
 	return retval;
@@ -1168,7 +1159,7 @@ static int cortex_a53_poll(struct target *target)
 	
 	enum target_state prev_target_state = target->state;
 
-	if( debugflag( POLL ) ){
+	if( armv8_debug( POLL ) ){
 		LOG_DEBUG("armv8-poll target");
 	}
 	/*  toggle to another core is done by gdb as follow */
@@ -2319,7 +2310,7 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 	uint8_t *tmp_buff = NULL;
 	struct target_addr tmp_addr;
 	
-	if( debugflag( MEM_IO ) ){
+	if( armv8_debug( MEM_IO ) ){
 		LOG_DEBUG("Writing APB-AP memory address %s size %d"  PRIu32 " count%"  PRIu32,
 				  target_addr2str1(target,pAddr), (int)size, count);
 	}
@@ -2476,7 +2467,7 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 	uint8_t buf[8];
 	uint8_t *u8buf_ptr;
 
-	if( debugflag( MEM_IO ) ){
+	if( armv8_debug( MEM_IO ) ){
 		LOG_DEBUG("Reading APB-AP memory address %s size %d"  PRIu32 " count%"  PRIu32,
 				  target_addr2str1(target,pAddr), size, count);
 	}
@@ -2628,7 +2619,7 @@ static int cortex_a53_read_memory_64(struct target *target, const struct target_
 	}
 
 	/* cortex_a53 handles unaligned memory access */
-	if( debugflag( MEM_IO ) ){
+	if( armv8_debug( MEM_IO ) ){
 		LOG_DEBUG("Reading memory at address %s; size %d; count %" PRId64,
 				  target_addr2str1(target,pAddr), (int)size, count);
 	}
@@ -2715,7 +2706,7 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 		
 	int retval = ERROR_COMMAND_SYNTAX_ERROR;
 	
-	if( debugflag( MEM_IO ) ){
+	if( armv8_debug( MEM_IO ) ){
 		LOG_DEBUG("Writing memory to real address %s; size %d; count %" PRId64,
 				  target_addr2str1(target,pAddr),
 				  size, count);
@@ -2763,7 +2754,7 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 		 */
 
 		/* invalidate I-Cache */
-		if( debugflag( MEM_IO ) ){
+		if( armv8_debug( MEM_IO ) ){
 			LOG_DEBUG("I-cache flush");
 		}
 		if (armv7a->armv7a_mmu.armv7a_cache.i_cache_enabled) {
@@ -2784,7 +2775,7 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 		}
 
 		/* invalidate D-Cache */
-		if( debugflag( MEM_IO ) ){
+		if( armv8_debug( MEM_IO ) ){
 			LOG_DEBUG("d-cache flush");
 		}
 		if (armv7a->armv7a_mmu.armv7a_cache.d_u_cache_enabled) {
@@ -2830,7 +2821,7 @@ static int cortex_a53_write_memory_64(struct target *target, const struct target
 
 	/* cortex_a53 handles unaligned memory access */
 
-	if( debugflag( MEM_IO ) ){
+	if( armv8_debug( MEM_IO ) ){
 		LOG_DEBUG("Writing memory at address %s; size %d; count %" PRId64,
 				  target_addr2str1(target,pAddr), (int)size, count);
 		
@@ -3236,15 +3227,6 @@ COMMAND_HANDLER(cortex_a53_handle_smp_gdb_command)
 	return ERROR_OK;
 }
 
-static int jim_cortex_a53_debugflags( Jim_Interp *interp, int argc, Jim_Obj * const *argv )
-{
-	Jim_GetOptInfo goi;
-
-	Jim_GetOpt_Setup( &goi, interp, argc, argv );
-	
-	return Jim_LogFlags( &goi, &cortex_a53_debugflags, NULL );
-}
-
 
 static const struct command_registration cortex_a53_exec_command_handlers[] = {
 	{
@@ -3275,13 +3257,6 @@ static const struct command_registration cortex_a53_exec_command_handlers[] = {
 		.usage = "",
 	},
 	{
-		.name = "debugflags",
-		.jim_handler = jim_cortex_a53_debugflags,
-		.mode = COMMAND_EXEC,
-		.help = "set/display debug log flags",
-		.usage = "[number]"
-	},
-	{
 		.name = "smp_gdb",
 		.handler = cortex_a53_handle_smp_gdb_command,
 		.mode = COMMAND_EXEC,
-- 
1.9.1


From b42f9df9438e695947334ca9eb30c30832e0f539 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 54/94] Warning removal, missing const

---
 src/target/target.c | 2 +-
 src/target/target.h | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/target/target.c b/src/target/target.c
index 8ec67c4..6d452b9 100755
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -1940,7 +1940,7 @@ int target64_write_buffer(struct target *target, const struct target_addr *pAddr
 	return target->type->pIo64_api->write_buffer(target, pAddr, size, buffer);
 }
 
-int target64_write_buffer_default(struct target *target, struct target_addr *pAddr, uint64_t count, const uint8_t *buffer)
+int target64_write_buffer_default(struct target *target, const struct target_addr *pAddr, uint64_t count, const uint8_t *buffer)
 {
 	uint64_t size;
 	struct target_addr tmp_addr;
diff --git a/src/target/target.h b/src/target/target.h
index e2a1183..cbd0bf8 100755
--- a/src/target/target.h
+++ b/src/target/target.h
@@ -633,7 +633,7 @@ int target32_write_phys_memory(struct target *target,
  */
 int target64_write_buffer(struct target *target,
 		const struct target_addr *pAddr, uint64_t size, const uint8_t *buffer);
-int target64_write_buffer_default(struct target *target, struct target_addr *pAddr, uint64_t count, const uint8_t *buffer);
+int target64_write_buffer_default(struct target *target, const struct target_addr *pAddr, uint64_t count, const uint8_t *buffer);
 
 #define target_write_buffer target32_write_buffer
 int target32_write_buffer(struct target *target,
-- 
1.9.1


From 7b5fa9916c0ad09b26c3c400a5dfeac7b92d3a38 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 55/94] Warning removal

---
 src/helper/log.h       | 2 +-
 src/helper/log_flags.c | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/helper/log.h b/src/helper/log.h
index 7194198..d93fe21 100755
--- a/src/helper/log.h
+++ b/src/helper/log.h
@@ -155,6 +155,6 @@ void debug_flag_register( const char *name, debug_flag_t *w );
 #define _debugFlagN( N )   (1 << (N))
 #define _debugFlagEnabled( NAME, BITS )   (!!( (NAME) & (BITS) ) )
 
-int Jim_DebugFlag_Command( Jim_Interp *interp, int argc, Jim_Obj **argv );
+int Jim_DebugFlag_Command( Jim_Interp *interp, int argc, Jim_Obj *const *argv );
 
 #endif	/* LOG_H */
diff --git a/src/helper/log_flags.c b/src/helper/log_flags.c
index 2a67143..0c06a34 100644
--- a/src/helper/log_flags.c
+++ b/src/helper/log_flags.c
@@ -114,7 +114,7 @@ static const Jim_Getopt_SubCmd jim_logflag_cmds[] = {
 };
 
 
-int Jim_DebugFlag_Command( Jim_Interp *interp, int argc, Jim_Obj **argv )
+int Jim_DebugFlag_Command( Jim_Interp *interp, int argc, Jim_Obj *const *argv )
 {
 	Jim_GetOptInfo goi;
 
-- 
1.9.1


From 89ce439b2c744c6d500e8df8dd149ee59f7bccec Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 56/94] Complete set of jtag callbacks

---
 src/jtag/drivers/driver.c            | 86 ++++++++++++++++++++++++++++++------
 src/jtag/drivers/minidriver_imp.h    | 40 ++++++++++++++---
 src/jtag/drivers/mpsse.c             | 15 +++++++
 src/jtag/jtag.h                      | 15 +++++--
 src/jtag/minidriver.h                |  4 +-
 src/jtag/minidriver/minidriver_imp.h |  2 +-
 src/jtag/minidummy/jtag_minidriver.h |  2 +-
 src/jtag/zy1000/jtag_minidriver.h    |  6 +--
 src/jtag/zy1000/zy1000.c             |  2 +-
 src/pld/virtex2.c                    |  5 ++-
 src/target/adi_v5_jtag.c             |  2 +-
 src/target/arm720t.c                 |  2 +-
 src/target/arm7tdmi.c                |  2 +-
 src/target/arm920t.c                 |  2 +-
 src/target/arm926ejs.c               |  2 +-
 src/target/arm946e.c                 |  2 +-
 src/target/arm966e.c                 |  2 +-
 src/target/arm9tdmi.c                |  4 +-
 src/target/arm_jtag.h                |  6 ++-
 src/target/embeddedice.c             |  2 +-
 src/target/etb.c                     |  5 ++-
 src/target/mips_ejtag.c              |  2 +-
 src/target/mips_ejtag.h              |  3 +-
 src/target/xscale.c                  |  5 ++-
 24 files changed, 166 insertions(+), 52 deletions(-)

diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index 75ec115..3ce876c 100755
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -41,7 +41,9 @@
 struct jtag_callback_entry {
 	struct jtag_callback_entry *next;
 
-	jtag_callback_t callback;
+	int n_params;
+	/* Note: callback might be a 1,2,3 or 4 param */
+	jtag_callback4_t callback;
 	jtag_callback_data_t data0;
 	jtag_callback_data_t data1;
 	jtag_callback_data_t data2;
@@ -351,12 +353,15 @@ int interface_jtag_add_sleep(uint32_t us)
 }
 
 /* add callback to end of queue */
-void interface_jtag_add_callback4(jtag_callback_t callback,
-		jtag_callback_data_t data0, jtag_callback_data_t data1,
-		jtag_callback_data_t data2, jtag_callback_data_t data3)
+static void	interface_jtag_add_callbackX(int n,
+										 jtag_callback4_t callback,
+										 jtag_callback_data_t data0,
+										 jtag_callback_data_t data1,
+										 jtag_callback_data_t data2, jtag_callback_data_t data3)
 {
 	struct jtag_callback_entry *entry = cmd_queue_alloc(sizeof(struct jtag_callback_entry));
 
+	entry->n_params = n;
 	entry->next = NULL;
 	entry->callback = callback;
 	entry->data0 = data0;
@@ -373,6 +378,60 @@ void interface_jtag_add_callback4(jtag_callback_t callback,
 	}
 }
 
+void interface_jtag_add_callback4(jtag_callback4_t callback,
+		jtag_callback_data_t data0, jtag_callback_data_t data1,
+		jtag_callback_data_t data2, jtag_callback_data_t data3)
+{
+	interface_jtag_add_callbackX(4, callback, data0, data1, data2, data3 );
+}
+
+void interface_jtag_add_callback3(jtag_callback3_t callback,
+		jtag_callback_data_t data0, jtag_callback_data_t data1,
+		jtag_callback_data_t data2)
+{
+	jtag_callback4_t cb4 = (jtag_callback4_t)callback;
+	interface_jtag_add_callbackX(3, cb4, data0, data1, data2, 0 );
+}
+
+void interface_jtag_add_callback2(jtag_callback2_t callback,
+		jtag_callback_data_t data0, jtag_callback_data_t data1)
+{
+	jtag_callback4_t cb4 = (jtag_callback4_t)callback;
+	interface_jtag_add_callbackX(2, cb4, data0, data1, 0, 0);
+}
+
+void interface_jtag_add_callback1(jtag_callback1_t callback,
+								  jtag_callback_data_t data0)
+{
+	jtag_callback4_t cb4 = (jtag_callback4_t)callback;
+	interface_jtag_add_callbackX(1, cb4, data0, 0, 0, 0 );
+}
+
+static int do_callback(struct jtag_callback_entry *e)
+{
+	int retval;
+	retval = ERROR_FAIL;
+	
+	switch( e->n_params ){
+	default:
+		/* should never happen */
+		break;
+	case 1:
+		retval = ((jtag_callback1_t)(e->callback))(e->data0);
+		break;
+	case 2:
+		retval = ((jtag_callback2_t)(e->callback))(e->data0,e->data1);
+		break;
+	case 3:
+		retval = ((jtag_callback3_t)(e->callback))(e->data0,e->data1,e->data2);
+		break;
+	case 4:
+		retval = ((jtag_callback4_t)(e->callback))(e->data0,e->data1,e->data2,e->data3);
+		break;
+	}
+	return retval;
+}
+
 int interface_jtag_execute_queue(void)
 {
 	static int reentry;
@@ -384,7 +443,7 @@ int interface_jtag_execute_queue(void)
 	if (retval == ERROR_OK) {
 		struct jtag_callback_entry *entry;
 		for (entry = jtag_callback_queue_head; entry != NULL; entry = entry->next) {
-			retval = entry->callback(entry->data0, entry->data1, entry->data2, entry->data3);
+			retval = do_callback( entry );
 			if (retval != ERROR_OK)
 				break;
 		}
@@ -398,24 +457,23 @@ int interface_jtag_execute_queue(void)
 	return retval;
 }
 
-static int jtag_convert_to_callback4(jtag_callback_data_t data0,
-		jtag_callback_data_t data1, jtag_callback_data_t data2, jtag_callback_data_t data3)
+
+void jtag_add_callback1(jtag_callback1_t f, jtag_callback_data_t data0)
 {
-	((jtag_callback1_t)data1)(data0);
-	return ERROR_OK;
+	interface_jtag_add_callback1(f, data0);
 }
 
-void interface_jtag_add_callback(jtag_callback1_t callback, jtag_callback_data_t data0)
+void jtag_add_callback2(jtag_callback2_t f, jtag_callback_data_t data0,jtag_callback_data_t data1)
 {
-	jtag_add_callback4(jtag_convert_to_callback4, data0, (jtag_callback_data_t)callback, 0, 0);
+	interface_jtag_add_callback2(f, data0,data1);
 }
 
-void jtag_add_callback(jtag_callback1_t f, jtag_callback_data_t data0)
+void jtag_add_callback3(jtag_callback3_t f, jtag_callback_data_t data0,jtag_callback_data_t data1,jtag_callback_data_t data2)
 {
-	interface_jtag_add_callback(f, data0);
+	interface_jtag_add_callback3(f, data0,data1,data2);
 }
 
-void jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
+void jtag_add_callback4(jtag_callback4_t f, jtag_callback_data_t data0,
 		jtag_callback_data_t data1, jtag_callback_data_t data2,
 		jtag_callback_data_t data3)
 {
diff --git a/src/jtag/drivers/minidriver_imp.h b/src/jtag/drivers/minidriver_imp.h
index b81368b..cc8c397 100755
--- a/src/jtag/drivers/minidriver_imp.h
+++ b/src/jtag/drivers/minidriver_imp.h
@@ -29,14 +29,40 @@ static inline void interface_jtag_add_scan_check_alloc(struct scan_field *field)
 	field->in_value = cmd_queue_alloc(num_bytes);
 }
 
-void interface_jtag_add_callback(jtag_callback1_t f, jtag_callback_data_t data0);
+void interface_jtag_add_callback1(jtag_callback1_t f,
+								  jtag_callback_data_t data0);
 
-void interface_jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
-				  jtag_callback_data_t data1, jtag_callback_data_t data2,
-				  jtag_callback_data_t data3);
+void interface_jtag_add_callback2(jtag_callback2_t f,
+								  jtag_callback_data_t data0,
+								  jtag_callback_data_t data1);
 
-void jtag_add_callback4(jtag_callback_t f, jtag_callback_data_t data0,
-			jtag_callback_data_t data1, jtag_callback_data_t data2,
-			jtag_callback_data_t data3);
+void interface_jtag_add_callback3(jtag_callback3_t f,
+								  jtag_callback_data_t data0,
+								  jtag_callback_data_t data1,
+								  jtag_callback_data_t data2);
+
+void interface_jtag_add_callback4(jtag_callback4_t f,
+								  jtag_callback_data_t data0,
+								  jtag_callback_data_t data1,
+								  jtag_callback_data_t data2,
+								  jtag_callback_data_t data3);
+
+void jtag_add_callback4(jtag_callback4_t f,
+						jtag_callback_data_t data0,
+						jtag_callback_data_t data1,
+						jtag_callback_data_t data2,
+						jtag_callback_data_t data3);
+
+void jtag_add_callback3(jtag_callback3_t f,
+						jtag_callback_data_t data0,
+						jtag_callback_data_t data1,
+						jtag_callback_data_t data2);
+
+void jtag_add_callback2(jtag_callback2_t f,
+						jtag_callback_data_t data0,
+						jtag_callback_data_t data1);
+
+void jtag_add_callback1(jtag_callback1_t f,
+						jtag_callback_data_t data0);
 
 #endif	/* MINIDRIVER_IMP_H */
diff --git a/src/jtag/drivers/mpsse.c b/src/jtag/drivers/mpsse.c
index 3b0ac5e..4a508f8 100755
--- a/src/jtag/drivers/mpsse.c
+++ b/src/jtag/drivers/mpsse.c
@@ -784,6 +784,8 @@ static LIBUSB_CALL void write_cb(struct libusb_transfer *transfer)
 int mpsse_flush(struct mpsse_ctx *ctx)
 {
 	int retval = ctx->retval;
+	int n;
+	struct timeval tstart, tnow;
 
 	if (retval != ERROR_OK) {
 		DEBUG_IO("Ignoring flush due to previous error");
@@ -822,10 +824,23 @@ int mpsse_flush(struct mpsse_ctx *ctx)
 		retval = libusb_submit_transfer(read_transfer);
 	}
 
+	gettimeofday( &tstart, NULL );
+	n = 0;
 	/* Polling loop, more or less taken from libftdi */
 	while (!write_result.done || !read_result.done) {
+		n++;
 		retval = libusb_handle_events(ctx->usb_ctx);
 		keep_alive();
+		if( n > 10 ){
+			gettimeofday( &tnow, NULL );
+			n = tnow.tv_sec - tstart.tv_sec;
+			if( n >= 3 ){
+				/* something is wrong */
+				retval = LIBUSB_ERROR_TIMEOUT;
+				LOG_ERROR("LIBUSB timeout!\n");
+			}
+			n = 0;
+		}
 		if (retval != LIBUSB_SUCCESS && retval != LIBUSB_ERROR_INTERRUPTED) {
 			libusb_cancel_transfer(write_transfer);
 			if (read_transfer)
diff --git a/src/jtag/jtag.h b/src/jtag/jtag.h
index 5216689..e3e814a 100755
--- a/src/jtag/jtag.h
+++ b/src/jtag/jtag.h
@@ -391,10 +391,11 @@ typedef intptr_t jtag_callback_data_t;
  * For conversion types or checks that can fail, use the more complete
  * variant: jtag_callback_t.
  */
-typedef void (*jtag_callback1_t)(jtag_callback_data_t data0);
+typedef int (*jtag_callback1_t)(jtag_callback_data_t data0);
+typedef int (*jtag_callback2_t)(jtag_callback_data_t data0,jtag_callback_data_t data1);
+typedef int (*jtag_callback3_t)(jtag_callback_data_t data0,jtag_callback_data_t data1,jtag_callback_data_t data2);
+typedef int (*jtag_callback4_t)(jtag_callback_data_t data0,jtag_callback_data_t data1,jtag_callback_data_t data2,jtag_callback_data_t data3);
 
-/** A simpler version of jtag_add_callback4(). */
-void jtag_add_callback(jtag_callback1_t, jtag_callback_data_t data0);
 
 
 /**
@@ -424,7 +425,13 @@ void jtag_add_callback(jtag_callback1_t, jtag_callback_data_t data0);
  * @param data3 An integer big enough to use as an @c int or a pointer.
  * @returns an error code
  */
-typedef int (*jtag_callback_t)(jtag_callback_data_t data0,
+typedef int (*jtag_callback1_t)(jtag_callback_data_t data0);
+typedef int (*jtag_callback2_t)(jtag_callback_data_t data0,
+				jtag_callback_data_t data1);
+typedef int (*jtag_callback3_t)(jtag_callback_data_t data0,
+				jtag_callback_data_t data1,
+				jtag_callback_data_t data2);
+typedef int (*jtag_callback4_t)(jtag_callback_data_t data0,
 				jtag_callback_data_t data1,
 				jtag_callback_data_t data2,
 				jtag_callback_data_t data3);
diff --git a/src/jtag/minidriver.h b/src/jtag/minidriver.h
index 0de8709..362ac02 100755
--- a/src/jtag/minidriver.h
+++ b/src/jtag/minidriver.h
@@ -37,7 +37,9 @@
  * In addtion to the functions defined in the @c minidriver.h file, the
  * @c jtag_minidriver.h file must declare the following functions (or
  * define static inline versions of them):
- * - jtag_add_callback
+ * - jtag_add_callback1
+ * - jtag_add_callback2
+ * - jtag_add_callback3
  * - jtag_add_callback4
  *
  * The following core functions are declared in this file for use by
diff --git a/src/jtag/minidriver/minidriver_imp.h b/src/jtag/minidriver/minidriver_imp.h
index 8ad992c..d3d36e7 100755
--- a/src/jtag/minidriver/minidriver_imp.h
+++ b/src/jtag/minidriver/minidriver_imp.h
@@ -24,7 +24,7 @@
 
 #include <jtag/jtag_minidriver.h>
 
-#define jtag_add_callback(callback, in) interface_jtag_add_callback(callback, in)
+#define jtag_add_callback1(callback, in) interface_jtag_add_callback1(callback, in)
 
 #define jtag_add_callback4(callback, in, data1, data2, data3) \
 	interface_jtag_add_callback4(callback, in, data1, data2, data3)
diff --git a/src/jtag/minidummy/jtag_minidriver.h b/src/jtag/minidummy/jtag_minidriver.h
index 452fbc8..0bccf9a 100755
--- a/src/jtag/minidummy/jtag_minidriver.h
+++ b/src/jtag/minidummy/jtag_minidriver.h
@@ -17,7 +17,7 @@
  *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.           *
  ***************************************************************************/
 
-#define interface_jtag_add_callback(callback, in) callback(in)
+#define interface_jtag_add_callback1(callback, in) callback(in)
 
 #define interface_jtag_add_callback4(callback, in, data1, data2, data3) \
 	jtag_set_error(callback(in, data1, data2, data3))
diff --git a/src/jtag/zy1000/jtag_minidriver.h b/src/jtag/zy1000/jtag_minidriver.h
index d7fa437..959f54e 100755
--- a/src/jtag/zy1000/jtag_minidriver.h
+++ b/src/jtag/zy1000/jtag_minidriver.h
@@ -66,7 +66,7 @@ void zy1000_jtag_add_callback4(jtag_callback_t callback,
 		jtag_callback_data_t data1,
 		jtag_callback_data_t data2,
 		jtag_callback_data_t data3);
-void zy1000_jtag_add_callback(jtag_callback1_t callback, jtag_callback_data_t data0);
+void zy1000_jtag_add_callback1(jtag_callback1_t callback, jtag_callback_data_t data0);
 #endif
 
 static inline void waitQueue(void)
@@ -170,11 +170,11 @@ static inline void shiftValueInner(const enum tap_state state,
 }
 
 #if BUILD_ZY1000_MASTER
-#define interface_jtag_add_callback(callback, in) callback(in)
+#define interface_jtag_add_callback1(callback, in) callback(in)
 #define interface_jtag_add_callback4(callback, in, data1, data2, \
 		data3) jtag_set_error(callback(in, data1, data2, data3))
 #else
-#define interface_jtag_add_callback(callback, in) zy1000_jtag_add_callback(callback, in)
+#define interface_jtag_add_callback1(callback, in) zy1000_jtag_add_callback1(callback, in)
 #define interface_jtag_add_callback4(callback, in, data1, data2, data3) zy1000_jtag_add_callback4( \
 	callback, \
 	in, \
diff --git a/src/jtag/zy1000/zy1000.c b/src/jtag/zy1000/zy1000.c
index 16c3e5d..7bca69a 100755
--- a/src/jtag/zy1000/zy1000.c
+++ b/src/jtag/zy1000/zy1000.c
@@ -1048,7 +1048,7 @@ static int zy1000_jtag_convert_to_callback4(jtag_callback_data_t data0,
 	return ERROR_OK;
 }
 
-void zy1000_jtag_add_callback(jtag_callback1_t callback, jtag_callback_data_t data0)
+void zy1000_jtag_add_callback1(jtag_callback1_t callback, jtag_callback_data_t data0)
 {
 	zy1000_jtag_add_callback4(zy1000_jtag_convert_to_callback4,
 		data0,
diff --git a/src/pld/virtex2.c b/src/pld/virtex2.c
index b600561..0c02213 100755
--- a/src/pld/virtex2.c
+++ b/src/pld/virtex2.c
@@ -74,10 +74,11 @@ static int virtex2_send_32(struct pld_device *pld_device,
 	return ERROR_OK;
 }
 
-static inline void virtexflip32(jtag_callback_data_t arg)
+static inline int virtexflip32(jtag_callback_data_t arg)
 {
 	uint8_t *in = (uint8_t *)arg;
 	*((uint32_t *)arg) = flip_u32(le_to_h_u32(in), 32);
+	return ERROR_OK;
 }
 
 static int virtex2_receive_32(struct pld_device *pld_device,
@@ -97,7 +98,7 @@ static int virtex2_receive_32(struct pld_device *pld_device,
 
 		jtag_add_dr_scan(virtex2_info->tap, 1, &scan_field, TAP_DRPAUSE);
 
-		jtag_add_callback(virtexflip32, (jtag_callback_data_t)words);
+		jtag_add_callback1(virtexflip32, (jtag_callback_data_t)words);
 
 		words++;
 	}
diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 2025522..df05907 100755
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -219,7 +219,7 @@ static int adi_jtag_dp_scan_u32(struct adiv5_dap *dap,
 		return retval;
 
 	if (invalue)
-		jtag_add_callback(arm_le_to_h_u32,
+		jtag_add_callback1(arm_le_to_h_u32,
 				(jtag_callback_data_t) invalue);
 
 	return retval;
diff --git a/src/target/arm720t.c b/src/target/arm720t.c
index facdae9..33865ac 100755
--- a/src/target/arm720t.c
+++ b/src/target/arm720t.c
@@ -73,7 +73,7 @@ static int arm720t_scan_cp15(struct target *target,
 	if (in) {
 		fields[1].in_value = (uint8_t *)in;
 		jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_DRPAUSE);
-		jtag_add_callback(arm7flip32, (jtag_callback_data_t)in);
+		jtag_add_callback1(arm7flip32, (jtag_callback_data_t)in);
 	} else
 		jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_DRPAUSE);
 
diff --git a/src/target/arm7tdmi.c b/src/target/arm7tdmi.c
index 5c58805..466162d 100755
--- a/src/target/arm7tdmi.c
+++ b/src/target/arm7tdmi.c
@@ -156,7 +156,7 @@ static int arm7tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 
 	jtag_add_dr_scan(jtag_info->tap, 2, fields, TAP_DRPAUSE);
 
-	jtag_add_callback(arm7flip32, (jtag_callback_data_t)in);
+	jtag_add_callback1(arm7flip32, (jtag_callback_data_t)in);
 
 	jtag_add_runtest(0, TAP_DRPAUSE);
 
diff --git a/src/target/arm920t.c b/src/target/arm920t.c
index acdaa11..8e0edaa 100755
--- a/src/target/arm920t.c
+++ b/src/target/arm920t.c
@@ -122,7 +122,7 @@ static int arm920t_read_cp15_physical(struct target *target,
 
 	jtag_add_dr_scan(jtag_info->tap, 4, fields, TAP_IDLE);
 
-	jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)value);
+	jtag_add_callback1(arm_le_to_h_u32, (jtag_callback_data_t)value);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	jtag_execute_queue();
diff --git a/src/target/arm926ejs.c b/src/target/arm926ejs.c
index daad5b7..c34fefd 100755
--- a/src/target/arm926ejs.c
+++ b/src/target/arm926ejs.c
@@ -97,7 +97,7 @@ static int arm926ejs_cp15_read(struct target *target, uint32_t op1, uint32_t op2
 		nr_w_buf = 0;
 		jtag_add_dr_scan(jtag_info->tap, 4, fields, TAP_IDLE);
 
-		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)value);
+		jtag_add_callback1(arm_le_to_h_u32, (jtag_callback_data_t)value);
 
 		retval = jtag_execute_queue();
 		if (retval != ERROR_OK)
diff --git a/src/target/arm946e.c b/src/target/arm946e.c
index e387732..2f0f543 100755
--- a/src/target/arm946e.c
+++ b/src/target/arm946e.c
@@ -163,7 +163,7 @@ static int arm946e_read_cp15(struct target *target, int reg_addr, uint32_t *valu
 	fields[0].in_value = (uint8_t *)value;
 	jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
 
-	jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)value);
+	jtag_add_callback1(arm_le_to_h_u32, (jtag_callback_data_t)value);
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
 	LOG_DEBUG("addr: 0x%x value: %8.8x", reg_addr, *value);
diff --git a/src/target/arm966e.c b/src/target/arm966e.c
index cbee69b..aac699d 100755
--- a/src/target/arm966e.c
+++ b/src/target/arm966e.c
@@ -112,7 +112,7 @@ static int arm966e_read_cp15(struct target *target, int reg_addr, uint32_t *valu
 
 	jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
 
-	jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)value);
+	jtag_add_callback1(arm_le_to_h_u32, (jtag_callback_data_t)value);
 
 
 #ifdef _DEBUG_INSTRUCTION_EXECUTION_
diff --git a/src/target/arm9tdmi.c b/src/target/arm9tdmi.c
index 9d0d7f3..8ff6323 100755
--- a/src/target/arm9tdmi.c
+++ b/src/target/arm9tdmi.c
@@ -174,7 +174,7 @@ int arm9tdmi_clock_out(struct arm_jtag *jtag_info, uint32_t instr,
 		fields[0].in_value = (uint8_t *)in;
 		jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_DRPAUSE);
 
-		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)in);
+		jtag_add_callback1(arm_le_to_h_u32, (jtag_callback_data_t)in);
 	} else
 		jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_DRPAUSE);
 
@@ -224,7 +224,7 @@ int arm9tdmi_clock_data_in(struct arm_jtag *jtag_info, uint32_t *in)
 
 	jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_DRPAUSE);
 
-	jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)in);
+	jtag_add_callback1(arm_le_to_h_u32, (jtag_callback_data_t)in);
 
 	jtag_add_runtest(0, TAP_DRPAUSE);
 
diff --git a/src/target/arm_jtag.h b/src/target/arm_jtag.h
index 13b701f..85d212e 100755
--- a/src/target/arm_jtag.h
+++ b/src/target/arm_jtag.h
@@ -69,16 +69,18 @@ static inline int arm_jtag_scann(struct arm_jtag *jtag_info, uint32_t new_scan_c
 int arm_jtag_setup_connection(struct arm_jtag *jtag_info);
 
 /* use this as a static so we can inline it in -O3 and refer to it via a pointer  */
-static inline void arm7flip32(jtag_callback_data_t arg)
+static inline int arm7flip32(jtag_callback_data_t arg)
 {
 	uint8_t *in = (uint8_t *)arg;
 	*((uint32_t *)arg) = flip_u32(le_to_h_u32(in), 32);
+	return ERROR_OK;
 }
 
-static inline void arm_le_to_h_u32(jtag_callback_data_t arg)
+static inline int arm_le_to_h_u32(jtag_callback_data_t arg)
 {
 	uint8_t *in = (uint8_t *)arg;
 	*((uint32_t *)arg) = le_to_h_u32(in);
+	return ERROR_OK;
 }
 
 #endif /* ARM_JTAG */
diff --git a/src/target/embeddedice.c b/src/target/embeddedice.c
index 2d32c83..1174686 100755
--- a/src/target/embeddedice.c
+++ b/src/target/embeddedice.c
@@ -444,7 +444,7 @@ int embeddedice_receive(struct arm_jtag *jtag_info, uint32_t *data, uint32_t siz
 
 		fields[0].in_value = (uint8_t *)data;
 		jtag_add_dr_scan(jtag_info->tap, 3, fields, TAP_IDLE);
-		jtag_add_callback(arm_le_to_h_u32, (jtag_callback_data_t)data);
+		jtag_add_callback1(arm_le_to_h_u32, (jtag_callback_data_t)data);
 
 		data++;
 		size--;
diff --git a/src/target/etb.c b/src/target/etb.c
index 370c181..f6fd83a 100755
--- a/src/target/etb.c
+++ b/src/target/etb.c
@@ -158,11 +158,12 @@ struct reg_cache *etb_build_reg_cache(struct etb *etb)
 	return reg_cache;
 }
 
-static void etb_getbuf(jtag_callback_data_t arg)
+static int etb_getbuf(jtag_callback_data_t arg)
 {
 	uint8_t *in = (uint8_t *)arg;
 
 	*((uint32_t *)arg) = buf_get_u32(in, 0, 32);
+	return ERROR_OK;
 }
 
 static int etb_read_ram(struct etb *etb, uint32_t *data, int num_frames)
@@ -204,7 +205,7 @@ static int etb_read_ram(struct etb *etb, uint32_t *data, int num_frames)
 		fields[0].in_value = (uint8_t *)(data + i);
 		jtag_add_dr_scan(etb->tap, 3, fields, TAP_IDLE);
 
-		jtag_add_callback(etb_getbuf, (jtag_callback_data_t)(data + i));
+		jtag_add_callback1(etb_getbuf, (jtag_callback_data_t)(data + i));
 	}
 
 	jtag_execute_queue();
diff --git a/src/target/mips_ejtag.c b/src/target/mips_ejtag.c
index f6cd451..ad44397 100755
--- a/src/target/mips_ejtag.c
+++ b/src/target/mips_ejtag.c
@@ -473,7 +473,7 @@ int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write_t, uint32_
 	jtag_add_dr_scan(tap, 2, fields, TAP_IDLE);
 
 	if (!write_t && data)
-		jtag_add_callback(mips_le_to_h_u32,
+		jtag_add_callback1(mips_le_to_h_u32,
 			(jtag_callback_data_t) data);
 
 	keep_alive();
diff --git a/src/target/mips_ejtag.h b/src/target/mips_ejtag.h
index 3e0d831..e6adbd4 100755
--- a/src/target/mips_ejtag.h
+++ b/src/target/mips_ejtag.h
@@ -228,10 +228,11 @@ int mips_ejtag_fastdata_scan(struct mips_ejtag *ejtag_info, int write_t, uint32_
 int mips_ejtag_init(struct mips_ejtag *ejtag_info);
 int mips_ejtag_config_step(struct mips_ejtag *ejtag_info, int enable_step);
 
-static inline void mips_le_to_h_u32(jtag_callback_data_t arg)
+static inline int mips_le_to_h_u32(jtag_callback_data_t arg)
 {
 	uint8_t *in = (uint8_t *)arg;
 	*((uint32_t *)arg) = le_to_h_u32(in);
+	return ERROR_OK;
 }
 
 #endif /* MIPS_EJTAG */
diff --git a/src/target/xscale.c b/src/target/xscale.c
index 604b411..f6383da 100755
--- a/src/target/xscale.c
+++ b/src/target/xscale.c
@@ -232,10 +232,11 @@ static int xscale_read_dcsr(struct target *target)
 }
 
 
-static void xscale_getbuf(jtag_callback_data_t arg)
+static int xscale_getbuf(jtag_callback_data_t arg)
 {
 	uint8_t *in = (uint8_t *)arg;
 	*((uint32_t *)arg) = buf_get_u32(in, 0, 32);
+	return ERROR_OK;
 }
 
 static int xscale_receive(struct target *target, uint32_t *buffer, int num_words)
@@ -297,7 +298,7 @@ static int xscale_receive(struct target *target, uint32_t *buffer, int num_words
 
 			jtag_add_dr_scan_check(target->tap, 3, fields, TAP_IDLE);
 
-			jtag_add_callback(xscale_getbuf, (jtag_callback_data_t)(field1 + i));
+			jtag_add_callback1(xscale_getbuf, (jtag_callback_data_t)(field1 + i));
 
 			words_scheduled++;
 		}
-- 
1.9.1


From 934ea6badc1cce34224724eee2eea21a9bafe023 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 57/94] Make dap-io functions non-inline

---
 src/target/arm_adi_v5.c       |  41 +++++++++++++
 src/target/arm_adi_v5.h       | 130 +++---------------------------------------
 src/target/arm_adi_v5_debug.c |  85 +++++++++++++++++++++++++++
 3 files changed, 134 insertions(+), 122 deletions(-)

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 1819230..aec3e1c 100755
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -1326,6 +1326,47 @@ static int dap_ap_class_mem( struct adiv5_dap *dap, struct adiv5_dap_port *port
 	return r;
 }
 
+int dap_dp_poll_register(struct adiv5_dap *dap, unsigned reg,
+				       uint32_t mask, uint32_t value, int timeout)
+{
+	assert(timeout > 0);
+	assert((value & mask) == value);
+
+	int ret;
+	uint32_t regval;
+	LOG_DEBUG("DAP: poll %x, mask 0x08%" PRIx32 ", value 0x%08" PRIx32,
+		  reg, mask, value);
+	do {
+		ret = dap_dp_read_atomic(dap, reg, &regval);
+		if (ret != ERROR_OK)
+			return ret;
+
+		if ((regval & mask) == value)
+			break;
+
+		alive_sleep(10);
+	} while (--timeout);
+
+	if (!timeout) {
+		LOG_DEBUG("DAP: poll %x timeout", reg);
+		return ERROR_FAIL;
+	} else {
+		return ERROR_OK;
+	}
+}
+
+
+int dap_dp_read_atomic(struct adiv5_dap *dap, unsigned reg, uint32_t *value)
+{
+	int retval;
+
+	retval = dap_queue_dp_read(dap, reg, value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dap_run(dap);
+}
+
 
 /**
  * Initialize a DAP.  This sets up the power domains, prepares the DP
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index f27bf30..aad343f 100755
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -409,21 +409,7 @@ enum ap_type {
  *
  * @return ERROR_OK for success, else a fault code.
  */
-static inline int dap_queue_dp_read(struct adiv5_dap *dap,
-		unsigned reg, uint32_t *data)
-{
-	assert(dap->ops != NULL);
-	if( dap_dbg_lowlevel ){
-		struct dap_access_log *p;
-		p = dap_dbg_log_entry(dap);
-		if( p ){
-			p->access_type = DAP_DP_RD;
-			p->reg = reg;
-			p->pointer = data;
-		}
-	}
-	return dap->ops->queue_dp_read(dap, reg, data);
-}
+int dap_queue_dp_read(struct adiv5_dap *dap, unsigned reg, uint32_t *data);
 
 /**
  * Queue a DP register write.
@@ -436,21 +422,7 @@ static inline int dap_queue_dp_read(struct adiv5_dap *dap,
  *
  * @return ERROR_OK for success, else a fault code.
  */
-static inline int dap_queue_dp_write(struct adiv5_dap *dap,
-		unsigned reg, uint32_t data)
-{
-	assert(dap->ops != NULL);
-	if( dap_dbg_lowlevel ){
-		struct dap_access_log *p;
-		p = dap_dbg_log_entry(dap);
-		if( p ){
-			p->access_type = DAP_DP_WR;
-			p->reg = reg;
-			p->dataval = data;
-		}
-	}
-	return dap->ops->queue_dp_write(dap, reg, data);
-}
+int dap_queue_dp_write(struct adiv5_dap *dap, unsigned reg, uint32_t data);
 
 /**
  * Queue an AP register read.
@@ -462,21 +434,7 @@ static inline int dap_queue_dp_write(struct adiv5_dap *dap,
  *
  * @return ERROR_OK for success, else a fault code.
  */
-static inline int dap_queue_ap_read(struct adiv5_dap *dap,
-		unsigned reg, uint32_t *data)
-{
-	assert(dap->ops != NULL);
-	if( dap_dbg_lowlevel ){
-		struct dap_access_log *p;
-		p = dap_dbg_log_entry(dap);
-		if( p ){
-			p->access_type = DAP_DP_RD;
-			p->reg = reg;
-			p->pointer = data;
-		}
-	}
-	return dap->ops->queue_ap_read(dap, reg, data);
-}
+int dap_queue_ap_read(struct adiv5_dap *dap, unsigned reg, uint32_t *data);
 
 /**
  * Queue an AP register write.
@@ -487,21 +445,7 @@ static inline int dap_queue_ap_read(struct adiv5_dap *dap,
  *
  * @return ERROR_OK for success, else a fault code.
  */
-static inline int dap_queue_ap_write(struct adiv5_dap *dap,
-		unsigned reg, uint32_t data)
-{
-	assert(dap->ops != NULL);
-	if( dap_dbg_lowlevel ){
-		struct dap_access_log *p;
-		p = dap_dbg_log_entry(dap);
-		if( p ){
-			p->access_type = DAP_DP_RD;
-			p->reg = reg;
-			p->dataval = data;
-		}
-	}
-	return dap->ops->queue_ap_write(dap, reg, data);
-}
+int dap_queue_ap_write(struct adiv5_dap *dap, unsigned reg, uint32_t data);
 
 /**
  * Queue an AP abort operation.  The current AP transaction is aborted,
@@ -514,20 +458,7 @@ static inline int dap_queue_ap_write(struct adiv5_dap *dap,
  *
  * @return ERROR_OK for success, else a fault code.
  */
-static inline int dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
-{
-	assert(dap->ops != NULL);
-	if( dap_dbg_lowlevel ){
-		struct dap_access_log *p;
-		p = dap_dbg_log_entry(dap);
-		if( p ){
-			p->access_type = DAP_AP_ABORT;
-			p->reg = 0;
-			p->pointer = ack;
-		}
-	}
-	return dap->ops->queue_ap_abort(dap, ack);
-}
+int dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack);
 
 /**
  * Perform all queued DAP operations, and clear any errors posted in the
@@ -539,56 +470,11 @@ static inline int dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
  *
  * @return ERROR_OK for success, else a fault code.
  */
-static inline int dap_run(struct adiv5_dap *dap)
-{
-	int r;
-	assert(dap->ops != NULL);
-	r = dap->ops->run(dap);
-	dap_dbg_log_dump( dap );
-	return r;
-}
-
-static inline int dap_dp_read_atomic(struct adiv5_dap *dap, unsigned reg,
-				     uint32_t *value)
-{
-	int retval;
-
-	retval = dap_queue_dp_read(dap, reg, value);
-	if (retval != ERROR_OK)
-		return retval;
+int dap_run(struct adiv5_dap *dap);
 
-	return dap_run(dap);
-}
-
-static inline int dap_dp_poll_register(struct adiv5_dap *dap, unsigned reg,
-				       uint32_t mask, uint32_t value, int timeout)
-{
-	assert(timeout > 0);
-	assert((value & mask) == value);
-
-	int ret;
-	uint32_t regval;
-	LOG_DEBUG("DAP: poll %x, mask 0x08%" PRIx32 ", value 0x%08" PRIx32,
-		  reg, mask, value);
-	do {
-		ret = dap_dp_read_atomic(dap, reg, &regval);
-		if (ret != ERROR_OK)
-			return ret;
-
-		if ((regval & mask) == value)
-			break;
-
-		alive_sleep(10);
-	} while (--timeout);
-
-	if (!timeout) {
-		LOG_DEBUG("DAP: poll %x timeout", reg);
-		return ERROR_FAIL;
-	} else {
-		return ERROR_OK;
-	}
-}
+int dap_dp_read_atomic(struct adiv5_dap *dap, unsigned reg, uint32_t *value);
 
+int dap_dp_poll_register(struct adiv5_dap *dap, unsigned reg, uint32_t mask, uint32_t value, int timeout);
 
 struct target_addr;
 
diff --git a/src/target/arm_adi_v5_debug.c b/src/target/arm_adi_v5_debug.c
index be790ab..dffa193 100644
--- a/src/target/arm_adi_v5_debug.c
+++ b/src/target/arm_adi_v5_debug.c
@@ -401,3 +401,88 @@ void dap_dbg_log_dump( struct adiv5_dap *dap )
 		0,
 		sizeof(dap->dbg.log[0]) * dap->dbg.n_log_avail );
 }
+
+int dap_queue_dp_read(struct adiv5_dap *dap, unsigned reg, uint32_t *data)
+{
+	assert(dap->ops != NULL);
+	if( dap_dbg_lowlevel ){
+		struct dap_access_log *p;
+		p = dap_dbg_log_entry(dap);
+		if( p ){
+			p->access_type = DAP_DP_RD;
+			p->reg = reg;
+			p->pointer = data;
+		}
+	}
+	return dap->ops->queue_dp_read(dap, reg, data);
+}
+
+
+int dap_queue_dp_write(struct adiv5_dap *dap, unsigned reg, uint32_t data)
+{
+	assert(dap->ops != NULL);
+	if( dap_dbg_lowlevel ){
+		struct dap_access_log *p;
+		p = dap_dbg_log_entry(dap);
+		if( p ){
+			p->access_type = DAP_DP_WR;
+			p->reg = reg;
+			p->dataval = data;
+		}
+	}
+	return dap->ops->queue_dp_write(dap, reg, data);
+}
+
+int dap_queue_ap_read(struct adiv5_dap *dap, unsigned reg, uint32_t *data)
+{
+	assert(dap->ops != NULL);
+	if( dap_dbg_lowlevel ){
+		struct dap_access_log *p;
+		p = dap_dbg_log_entry(dap);
+		if( p ){
+			p->access_type = DAP_DP_RD;
+			p->reg = reg;
+			p->pointer = data;
+		}
+	}
+	return dap->ops->queue_ap_read(dap, reg, data);
+}
+
+int dap_queue_ap_write(struct adiv5_dap *dap, unsigned reg, uint32_t data)
+{
+	assert(dap->ops != NULL);
+	if( dap_dbg_lowlevel ){
+		struct dap_access_log *p;
+		p = dap_dbg_log_entry(dap);
+		if( p ){
+			p->access_type = DAP_DP_RD;
+			p->reg = reg;
+			p->dataval = data;
+		}
+	}
+	return dap->ops->queue_ap_write(dap, reg, data);
+}
+
+int dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
+{
+	assert(dap->ops != NULL);
+	if( dap_dbg_lowlevel ){
+		struct dap_access_log *p;
+		p = dap_dbg_log_entry(dap);
+		if( p ){
+			p->access_type = DAP_AP_ABORT;
+			p->reg = 0;
+			p->pointer = ack;
+		}
+	}
+	return dap->ops->queue_ap_abort(dap, ack);
+}
+
+int dap_run(struct adiv5_dap *dap)
+{
+	int r;
+	assert(dap->ops != NULL);
+	r = dap->ops->run(dap);
+	dap_dbg_log_dump( dap );
+	return r;
+}
-- 
1.9.1


From d274920b48c795141da5c9026fa188a0104d3169 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 58/94] Improve debug flag for DAP_MEM_AP_IO

---
 src/target/arm_adi_v5.c | 6 +++---
 src/target/arm_adi_v5.h | 4 ++--
 2 files changed, 5 insertions(+), 5 deletions(-)

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index aec3e1c..40135b0 100755
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -480,7 +480,7 @@ static int coresight_io_chunk_wr(struct coresight_bulk *bulk )
 			struct target_addr tmp;
 			tmp = bulk->addr;
 			tmp.addr ^= ti_addr_xor;
-			if( dap_debug(DAP_MEM_IO) ){
+			if( dap_debug(DAP_MEM_AP_IO) ){
 				LOG_DEBUG("access setup: csw: 0x%08" PRIx32 " addr: 0x%016" PRIx64,
 						  csw, tmp.addr );
 			}
@@ -545,7 +545,7 @@ static int coresight_io_chunk_wr(struct coresight_bulk *bulk )
 			break;
 		}
 
-		if( dap_debug(DAP_MEM_IO) ){
+		if( dap_debug(DAP_MEM_AP_IO) ){
 			LOG_DEBUG("wr addr: 0x%016" PRIx64 " <= 0x%016" PRIx64,
 					  bulk->addr.addr, outvalue );
 		}
@@ -662,7 +662,7 @@ int coresight_io_bulk( struct coresight_bulk *bulk )
 			}
 		}
 
-		if( dap_debug(DAP_MEM_IO) ){
+		if( dap_debug(DAP_MEM_AP_IO) ){
 			LOG_DEBUG("bulk: %c @0x%016" PRIx64 " count: 0x%08" PRIx32 " size: %d, total: %d",
 					  bulk->rw,
 					  /* bulk->target can be null! */
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index aad343f..c2d2313 100755
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -773,9 +773,9 @@ int target_cs_discover_ap( struct target *target,
 
 
 extern jim_wide dap_debug_flags;
-#define DAP_APDP_IO  _debugFlagN(0)
-#define DAP_MEM_IO   _debugFlagN(1)
 #define dap_debug( NAME )  _debugFlagEnabled( NAME, dap_debug_flags )
+#define DAP_APDP_IO    _debugFlagN(0)
+#define DAP_MEM_AP_IO  _debugFlagN(1)
 
 
 #endif
-- 
1.9.1


From e3eb2749e54ec18e0c26bd5e69895e405032acec Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 59/94] Fix image/taret-addr issues

---
 src/jtag/drivers/usb_blaster/ublast2_access_libusb.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/jtag/drivers/usb_blaster/ublast2_access_libusb.c b/src/jtag/drivers/usb_blaster/ublast2_access_libusb.c
index 70dab20..779839d 100755
--- a/src/jtag/drivers/usb_blaster/ublast2_access_libusb.c
+++ b/src/jtag/drivers/usb_blaster/ublast2_access_libusb.c
@@ -124,7 +124,7 @@ static int load_usb_blaster_firmware(struct jtag_libusb_device_handle *libusb_de
 		return ERROR_FAIL;
 	}
 
-	ublast2_firmware_image.base_address = 0;
+	TARGET_ADDR_INIT(&ublast2_firmware_image.base_address,0);
 	ublast2_firmware_image.base_address_set = 0;
 
 	int ret = image_open(&ublast2_firmware_image, low->firmware_path, "ihex");
-- 
1.9.1


From 51c109aa2a394da2230e933c8eb54559f9f77581 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 60/94] Fix image/taret-addr issues

---
 src/jtag/drivers/ulink.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/jtag/drivers/ulink.c b/src/jtag/drivers/ulink.c
index 8c2b9db..77890e3 100755
--- a/src/jtag/drivers/ulink.c
+++ b/src/jtag/drivers/ulink.c
@@ -408,7 +408,7 @@ int ulink_load_firmware(struct ulink *device, const char *filename)
 		return ret;
 	}
 
-	ulink_firmware_image.base_address = 0;
+	TARGET_ADDR_INIT( &(ulink_firmware_image.base_address), 0 );
 	ulink_firmware_image.base_address_set = 0;
 
 	ret = image_open(&ulink_firmware_image, filename, "ihex");
-- 
1.9.1


From 2668f2e5509eb5f405d6991a70a2cbba5d2f671d Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 61/94] Fix jtag callback typename change

---
 src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h
index fa53062..b986f4b 100755
--- a/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h
+++ b/src/jtag/drivers/versaloon/usbtoxxx/usbtoxxx.h
@@ -104,8 +104,8 @@ RESULT usbtojtaghl_dr(uint8_t interface_index, uint8_t *dr, uint16_t bitlen,
 		      uint8_t idle, uint8_t want_ret);
 RESULT usbtojtaghl_tms(uint8_t interface_index, uint8_t *tms, uint16_t bitlen);
 RESULT usbtojtaghl_runtest(uint8_t interface_index, uint32_t cycles);
-RESULT usbtojtaghl_register_callback(uint8_t index, jtag_callback_t send_callback,
-				     jtag_callback_t receive_callback);
+RESULT usbtojtaghl_register_callback(uint8_t index, jtag_callback4_t send_callback,
+				     jtag_callback4_t receive_callback);
 
 /* USB_TO_JTAG_RAW */
 RESULT usbtojtagraw_init(uint8_t interface_index);
-- 
1.9.1


From a1b82c0f04948dff79795ff97f6df162a77b311b Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 62/94] Refactor out dap_current_port(), to cleanup
 memaccess_tck access

---
 src/jtag/drivers/ftdi.c  | 14 +++++++++++---
 src/jtag/drivers/jlink.c | 24 +++++++++++++++++++++---
 src/target/adi_v5_jtag.c | 23 +++++++++++++++++++----
 src/target/arm_adi_v5.c  | 26 +++++++++++++++++++++-----
 src/target/arm_adi_v5.h  |  3 +++
 5 files changed, 75 insertions(+), 15 deletions(-)

diff --git a/src/jtag/drivers/ftdi.c b/src/jtag/drivers/ftdi.c
index 9960c5d..396b652 100755
--- a/src/jtag/drivers/ftdi.c
+++ b/src/jtag/drivers/ftdi.c
@@ -1059,9 +1059,17 @@ static void ftdi_swd_queue_cmd(struct adiv5_dap *dap, uint8_t cmd, uint32_t *dst
 	}
 
 	/* Insert idle cycles after AP accesses to avoid WAIT */
-	if (cmd & SWD_CMD_APnDP)
-		mpsse_clock_data_out(mpsse_ctx, NULL, 0, dap->port[ dap->cached_ap_port].memaccess_tck, SWD_MODE);
-
+	if (cmd & SWD_CMD_APnDP){
+		struct adiv5_dap_port *p;
+		uint32_t n;
+		p = dap_current_port(dap);
+		if( p ){
+			n = p->memaccess_tck;
+		} else {
+			n = 8;
+		}
+		mpsse_clock_data_out(mpsse_ctx, NULL, 0, n, SWD_MODE);
+	}
 }
 
 static void ftdi_swd_read_reg(struct adiv5_dap *dap, uint8_t cmd, uint32_t *value)
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index 57eea64..cba4fcc 100755
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -1650,7 +1650,16 @@ skip:
 static void jlink_swd_queue_cmd(struct adiv5_dap *dap, uint8_t cmd, uint32_t *dst, uint32_t data)
 {
 	uint8_t data_parity_trn[DIV_ROUND_UP(32 + 1, 8)];
-	if (tap_length + 46 + 8 + dap->memaccess_tck >= sizeof(tdi_buffer) * 8 ||
+	uint32_t n;
+	struct adiv5_dap_port *p;
+
+	p = dap_current_port(dap);
+	if( p == NULL ){
+	  n = 8;
+	} else {
+	  n = p->memaccess_tck;
+	}
+	if (tap_length + 46 + 8 + n >= sizeof(tdi_buffer) * 8 ||
 	    pending_scan_results_length == MAX_PENDING_SCAN_RESULTS) {
 		/* Not enough room in the queue. Run the queue. */
 		queued_retval = jlink_swd_run_queue(dap);
@@ -1685,8 +1694,17 @@ static void jlink_swd_queue_cmd(struct adiv5_dap *dap, uint8_t cmd, uint32_t *ds
 	pending_scan_results_length++;
 
 	/* Insert idle cycles after AP accesses to avoid WAIT */
-	if (cmd & SWD_CMD_APnDP)
-		jlink_queue_data_out(NULL, dap->memaccess_tck);
+	if (cmd & SWD_CMD_APnDP){
+		struct adiv5_dap_port *p;
+		uint32_t n;
+		p = dap_current_port(dap);
+		if( p == NULL ){
+			n = 8;
+		} else {
+			n = p->memaccess_tck;
+		}
+		jlink_queue_data_out(NULL, n );
+	}
 }
 
 /*****************************************************************************/
diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index df05907..4d00359 100755
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -143,7 +143,16 @@ static int adi_jtag_dp_scan(struct adiv5_dap *dap,
 	}
 
 	int n;
-	n = dap->port[ dap->cached_ap_port].memaccess_tck;
+	{
+	  /* Get current port access delay */
+	  struct adiv5_dap_port *p;
+	  p = dap_current_port(dap);
+	  if( p ){
+	    n = p->memaccess_tck;
+	  }else {
+	    n = 8;
+	  }
+	}
 	if( n < 8 ){
 		n = 8;
 	}
@@ -393,9 +402,15 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 					AP_MEM_REG_TAR_lo, &mem_ap_tar_l);
 			if (retval != ERROR_OK)
 				return retval;
-			if( dap->port[ dap->cached_ap_port ].addr_64bit ){
-				retval = dap_queue_ap_read(dap,
-										   AP_MEM_REG_TAR_lo, &mem_ap_tar_h);
+			
+			{
+				/* is this a 64bit port? */
+				struct adiv5_dap_port *p;
+				p = dap_current_port(dap);
+				if( p->addr_64bit ){
+					retval = dap_queue_ap_read(dap,
+											   AP_MEM_REG_TAR_lo, &mem_ap_tar_h);
+				}
 			}
 
 			retval = jtag_execute_queue();
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 40135b0..5613149 100755
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -91,14 +91,14 @@ jim_wide dap_debug_flags;
 void dap_invalidate_port_cache( struct adiv5_dap *dap )
 {
 	struct adiv5_dap_port *p;
-	if( (dap->cached_ap_port < 0) || (dap->cached_ap_port > 255) ){
+
+	p = dap_current_port( dap );
+	if( p == NULL ){
 		/* maybe the AP CURRENT is invalid */
 		/* like set to -1? to make it invalid */
 		return;
 	}
 
-	p = &(dap->port[ dap->cached_ap_port ]);
-
 	p->cached_tar_valid = false;
 	p->cached_tar_reg   = (uint64_t)(-1);
 	p->cached_csw_reg   = (uint32_t)(-1);
@@ -140,6 +140,15 @@ static int dap_ap_read( struct adiv5_dap *dap, int reg, uint32_t *val )
 	return r;
 }
 
+/* Returns pointer to current dap port, or null if not valid */
+struct adiv5_dap_port *dap_current_port( struct adiv5_dap *dap )
+{
+  if( (dap->cached_ap_port < 0) || (dap->cached_ap_port > 255) ){
+    return NULL;
+  }
+
+  return &(dap->port[ dap->cached_ap_port ]);
+}
 
 /**
  * Select one of the APs connected to the specified DAP.  The
@@ -226,7 +235,11 @@ static int dap_setup_accessport_tar(struct adiv5_dap *dap, uint64_t address )
 	int r;
 	struct adiv5_dap_port *port;
 	
-	port = &(dap->port[ dap->cached_ap_port ]);
+	port = dap_current_port( dap );
+	if( !port ){
+		LOG_ERROR("Something is wrong, no current port?\n");
+		return;
+	}
 
 	/* this is easier to read then a multi-step IF statement */
 	if ( !(port->cached_tar_valid) ){
@@ -867,11 +880,14 @@ static int dap_mem_ap_read_tar( struct adiv5_dap *dap, uint64_t *tar )
 	uint32_t l,h;
 	uint64_t tmp;
 	int r;
+	struct adiv5_dap_port *p;
 
 	h = 0;
 	l = 0;
+
+	p = dap_current_port( dap );
 	
-	if( dap->port[ dap->cached_ap_port ].addr_64bit ){
+	if( p->addr_64bit ){
 		r = dap_queue_ap_read(dap, AP_MEM_REG_TAR_hi, &h);
 		if( r != ERROR_OK ){
 			return r;
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index c2d2313..ba113fd 100755
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -772,6 +772,9 @@ int target_cs_discover_ap( struct target *target,
 						   struct coresight_address *port );
 
 
+/* Returns pointer to current dap port, or null if not valid */
+struct adiv5_dap_port *dap_current_port( struct adiv5_dap *dap );
+
 extern jim_wide dap_debug_flags;
 #define dap_debug( NAME )  _debugFlagEnabled( NAME, dap_debug_flags )
 #define DAP_APDP_IO    _debugFlagN(0)
-- 
1.9.1


From 35df8568feadc5870b3a2978eed9db224d843bf4 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 63/94] Improve command error reporting

---
 src/helper/command.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/helper/command.c b/src/helper/command.c
index b097d6b..96c38ba 100755
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -630,9 +630,13 @@ static int run_command(struct command_context *context,
 		/* just fall through for a shutdown request */
 	} else if (retval != ERROR_OK) {
 		/* we do not print out an error message because the command *should*
-		 * have printed out an error
+		 * have printed out an error (Truth: some commands don't do that)
 		 */
-		LOG_DEBUG("Command failed with error code %d", retval);
+		LOG_DEBUG("Command %s failed with error code %d", c->name, retval);
+		unsigned x;
+		for( x = 0 ; x < num_words ; x++ ){
+			LOG_DEBUG("Param: (%d) %s", x, words[x] );
+		}
 	}
 
 	return retval;
-- 
1.9.1


From 2cafb81e823a5b75721591f7ed62b77a2c175650 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 64/94] log timestamp with secs and msecs (more readable)

---
 src/helper/log.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/helper/log.c b/src/helper/log.c
index 0d222ca..648f2c4 100755
--- a/src/helper/log.c
+++ b/src/helper/log.c
@@ -141,11 +141,11 @@ static void log_puts(enum log_levels level,
 			struct mallinfo info;
 			info = mallinfo();
 #endif
-			fprintf(log_output, "%s%d %d %s:%d %s()"
+			fprintf(log_output, "%s%d %2d.%03d %s:%d %s()"
 #ifdef _DEBUG_FREE_SPACE_
 				" %d"
 #endif
-				": %s", log_strings[level + 1], count, t, file, line, function,
+				": %s", log_strings[level + 1], count, t/1000, t%1000, file, line, function,
 #ifdef _DEBUG_FREE_SPACE_
 				info.fordblks,
 #endif
-- 
1.9.1


From de4644e12424609265e3d430e87cf9119a9beb47 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 65/94] Refactor memacess tck from other branch, and cleanup
 debug logging

---
 src/jtag/drivers/ftdi.c         |  10 +-
 src/jtag/drivers/jlink.c        |  19 +-
 src/target/adi_v5_jtag.c        |  11 +-
 src/target/arm_adi_v5.c         | 162 +++++++---------
 src/target/arm_adi_v5.h         |  13 +-
 src/target/arm_adi_v5_debug.c   | 416 ++++++++++++++++++++++++++--------------
 src/target/arm_adi_v5_debug.h   |  48 +++--
 src/target/armv7m.c             |   8 +
 src/target/armv7m.h             |  12 ++
 src/target/armv7m_cpudbg_regs.h | 109 +++++++++++
 src/target/armv8_cpudbg_regs.h  | 134 ++++++-------
 src/target/cortex_a53.c         |   4 +
 src/target/cortex_m.c           |  14 ++
 src/target/cortex_m.h           |  55 ------
 src/target/target.c             |   7 +-
 15 files changed, 616 insertions(+), 406 deletions(-)
 create mode 100644 src/target/armv7m_cpudbg_regs.h

diff --git a/src/jtag/drivers/ftdi.c b/src/jtag/drivers/ftdi.c
index 396b652..300494d 100755
--- a/src/jtag/drivers/ftdi.c
+++ b/src/jtag/drivers/ftdi.c
@@ -1060,15 +1060,7 @@ static void ftdi_swd_queue_cmd(struct adiv5_dap *dap, uint8_t cmd, uint32_t *dst
 
 	/* Insert idle cycles after AP accesses to avoid WAIT */
 	if (cmd & SWD_CMD_APnDP){
-		struct adiv5_dap_port *p;
-		uint32_t n;
-		p = dap_current_port(dap);
-		if( p ){
-			n = p->memaccess_tck;
-		} else {
-			n = 8;
-		}
-		mpsse_clock_data_out(mpsse_ctx, NULL, 0, n, SWD_MODE);
+		mpsse_clock_data_out(mpsse_ctx, NULL, 0, dap_get_memacces_tck(dap), SWD_MODE);
 	}
 }
 
diff --git a/src/jtag/drivers/jlink.c b/src/jtag/drivers/jlink.c
index cba4fcc..4a5bc66 100755
--- a/src/jtag/drivers/jlink.c
+++ b/src/jtag/drivers/jlink.c
@@ -1651,14 +1651,9 @@ static void jlink_swd_queue_cmd(struct adiv5_dap *dap, uint8_t cmd, uint32_t *ds
 {
 	uint8_t data_parity_trn[DIV_ROUND_UP(32 + 1, 8)];
 	uint32_t n;
-	struct adiv5_dap_port *p;
 
-	p = dap_current_port(dap);
-	if( p == NULL ){
-	  n = 8;
-	} else {
-	  n = p->memaccess_tck;
-	}
+	n = dap_get_memacces_tck( dap );
+	
 	if (tap_length + 46 + 8 + n >= sizeof(tdi_buffer) * 8 ||
 	    pending_scan_results_length == MAX_PENDING_SCAN_RESULTS) {
 		/* Not enough room in the queue. Run the queue. */
@@ -1695,15 +1690,7 @@ static void jlink_swd_queue_cmd(struct adiv5_dap *dap, uint8_t cmd, uint32_t *ds
 
 	/* Insert idle cycles after AP accesses to avoid WAIT */
 	if (cmd & SWD_CMD_APnDP){
-		struct adiv5_dap_port *p;
-		uint32_t n;
-		p = dap_current_port(dap);
-		if( p == NULL ){
-			n = 8;
-		} else {
-			n = p->memaccess_tck;
-		}
-		jlink_queue_data_out(NULL, n );
+		jlink_queue_data_out(NULL, dap_get_memacces_tck( dap ) );
 	}
 }
 
diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 4d00359..cc0c27d 100755
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -143,16 +143,7 @@ static int adi_jtag_dp_scan(struct adiv5_dap *dap,
 	}
 
 	int n;
-	{
-	  /* Get current port access delay */
-	  struct adiv5_dap_port *p;
-	  p = dap_current_port(dap);
-	  if( p ){
-	    n = p->memaccess_tck;
-	  }else {
-	    n = 8;
-	  }
-	}
+	n = dap_get_memacces_tck(dap);
 	if( n < 8 ){
 		n = 8;
 	}
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 5613149..b3343f9 100755
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -168,12 +168,12 @@ void dap_ap_select(struct adiv5_dap *dap, int ap )
 
 #if DAP_REG_CACHE	
 	if ( ap == dap->cached_ap_port) {
-		if( dap_debug_flag(DAP_APDP_IO) ){
+		if( dap_debug_flag(DAP_DBG_AP_IO) ){
 			LOG_DEBUG("select-ap = %d cached\n", ap );
 		}
 		return;
 	}
-	if( dap_debug_flag(DAP_APDP_IO) ){
+	if( dap_debug_flag(DAP_DBG_AP_IO) ){
 		LOG_DEBUG("select-ap = %d *new*\n", ap );
 	}
 #endif
@@ -218,9 +218,6 @@ static int dap_setup_accessport_csw(struct adiv5_dap *dap, uint32_t csw, const s
 	
 	if( (!(port->cached_csw_valid)) || (csw != port->cached_csw_reg) ){
 		
-		if( dap_debug(DAP_APDP_IO) ){
-			LOG_DEBUG("DAP: Set CSW %x",csw);
-		}
 		r = dap_queue_ap_write(dap, AP_MEM_REG_CSW, csw);
 		if( r == ERROR_OK ){
 			port->cached_csw_valid = true;
@@ -238,7 +235,7 @@ static int dap_setup_accessport_tar(struct adiv5_dap *dap, uint64_t address )
 	port = dap_current_port( dap );
 	if( !port ){
 		LOG_ERROR("Something is wrong, no current port?\n");
-		return;
+		return ERROR_FAIL;
 	}
 
 	/* this is easier to read then a multi-step IF statement */
@@ -493,10 +490,6 @@ static int coresight_io_chunk_wr(struct coresight_bulk *bulk )
 			struct target_addr tmp;
 			tmp = bulk->addr;
 			tmp.addr ^= ti_addr_xor;
-			if( dap_debug(DAP_MEM_AP_IO) ){
-				LOG_DEBUG("access setup: csw: 0x%08" PRIx32 " addr: 0x%016" PRIx64,
-						  csw, tmp.addr );
-			}
 			r = dap_setup_accessport( bulk->dap, csw, &tmp );
 			if( r != ERROR_OK ){
 				goto fail;
@@ -558,9 +551,10 @@ static int coresight_io_chunk_wr(struct coresight_bulk *bulk )
 			break;
 		}
 
-		if( dap_debug(DAP_MEM_AP_IO) ){
-			LOG_DEBUG("wr addr: 0x%016" PRIx64 " <= 0x%016" PRIx64,
-					  bulk->addr.addr, outvalue );
+		if( dap_debug(DAP_DBG_MEM_AP_IO) ){
+			/* log this here due to TI quirks */
+			LOG_DEBUG("wr addr: 0x%016" PRIx64 " <= 0x%0*" PRIx64,
+					  bulk->addr.addr, this_size * 2, outvalue );
 		}
 
 		r = ERROR_OK;
@@ -675,22 +669,16 @@ int coresight_io_bulk( struct coresight_bulk *bulk )
 			}
 		}
 
-		if( dap_debug(DAP_MEM_AP_IO) ){
-			LOG_DEBUG("bulk: %c @0x%016" PRIx64 " count: 0x%08" PRIx32 " size: %d, total: %d",
-					  bulk->rw,
-					  /* bulk->target can be null! */
-					  /* do not use "target_addr2tr() */
-					  bulk->addr.addr,
-					  bulk->wip_count,
-					  (int)(bulk->size),
-					  (int)(bulk->wip_count * bulk->size));
-			{
-				int n;
-				n = bulk->wip_count;
-				if( n > 32 ){
-					n = 32;
-				}
-				log_hexdump( bulk->addr.addr, (void *)(bulk->buffer), n );
+		if( dap_debug( DAP_DBG_MEM_AP_IO ) ){
+			struct dap_access_log *p;
+			p = dap_dbg_log_entry(bulk->dap);
+			if( p ){
+				p->access_type = (bulk->rw == 'w') ? MEM_AP_WRBULK : MEM_AP_RDBULK;
+				p->address     = bulk->addr.addr;
+				p->pointer     = bulk->buffer;
+				p->bytelen     = bulk->size * bulk->wip_count;
+				p->tar_inc     = bulk->addrinc;
+				dap_dbg_set_regname( bulk->dap, p );
 			}
 		}
 		
@@ -729,20 +717,23 @@ int mem_ap_read_u32(struct adiv5_dap *dap, const struct target_addr *pAddr,
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when reading several consecutive addresses.
 	 */
-	if( dap_dbg_highlevel ){
+	  
+	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF,	pAddr);
+	if (retval != ERROR_OK)
+		return retval;
+
+	if( dap_debug(DAP_DBG_MEM_AP_IO) ){
 		struct dap_access_log *p;
 		p = dap_dbg_log_entry(dap);
 		if( p ){
 			p->access_type = MEM_AP_RD32;
 			p->address     = pAddr->addr;
 			p->pointer     = value;
+			p->bytelen     = 4;
+			dap_dbg_set_regname( dap, p );
 		}
 	}
-	  
-	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF,	pAddr);
-	if (retval != ERROR_OK)
-		return retval;
-
+	
 	r = dap_queue_ap_read(dap, AP_MEM_REG_BD0 | (pAddr->addr & 0xC), value);
 	
 	return r;
@@ -758,22 +749,25 @@ int mem_ap_read_u64(struct adiv5_dap *dap, const struct target_addr *pAddr,
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when reading several consecutive addresses.
 	 */
-	if( dap_dbg_highlevel ){
+	  
+	retval = dap_setup_accessport(dap, CSW_64BIT | CSW_ADDRINC_OFF, pAddr );
+	if (retval != ERROR_OK)
+		return retval;
+
+	uint64_t a;
+	a = pAddr->addr;
+
+	if( dap_debug(DAP_DBG_MEM_AP_IO) ){
 		struct dap_access_log *p;
 		p = dap_dbg_log_entry(dap);
 		if( p ){
 			p->access_type = MEM_AP_RD64;
 			p->address     = pAddr->addr;
 			p->pointer     = value;
+			p->bytelen     = 8;
+			dap_dbg_set_regname( dap, p );
 		}
 	}
-	  
-	retval = dap_setup_accessport(dap, CSW_64BIT | CSW_ADDRINC_OFF, pAddr );
-	if (retval != ERROR_OK)
-		return retval;
-
-	uint64_t a;
-	a = pAddr->addr;
 	
 	r = dap_queue_ap_read(dap, AP_MEM_REG_BD0 | (a & 0xC), &l);
 	if( r != ERROR_OK ){
@@ -813,19 +807,22 @@ int mem_ap_write_u32(struct adiv5_dap *dap, const struct target_addr *pAddr, uin
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when writing several consecutive addresses.
 	 */
-	if( dap_dbg_highlevel ){
+	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF, pAddr );
+	if (retval != ERROR_OK)
+		return retval;
+
+	if( dap_debug(DAP_DBG_MEM_AP_IO) ){
 		struct dap_access_log *p;
 		p = dap_dbg_log_entry(dap);
 		if( p ){
 			p->access_type = MEM_AP_WR32;
 			p->address     = pAddr->addr;
 			p->dataval     = value;
+			p->bytelen     = 4;
+			dap_dbg_set_regname( dap, p );
 		}
 	}
-	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF, pAddr );
-	if (retval != ERROR_OK)
-		return retval;
-
+	
 	return dap_queue_ap_write(dap, AP_MEM_REG_BD0 | (pAddr->addr & 0xC),
 			value);
 }
@@ -853,19 +850,22 @@ int mem_ap_write_u64(struct adiv5_dap *dap, const struct target_addr *pAddr, uin
 	/* Use banked addressing (REG_BDx) to avoid some link traffic
 	 * (updating TAR) when writing several consecutive addresses.
 	 */
-	if( dap_dbg_highlevel ){
+	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF, pAddr );
+	if (retval != ERROR_OK)
+		return retval;
+
+	if( dap_debug(DAP_DBG_MEM_AP_IO) ){
 		struct dap_access_log *p;
 		p = dap_dbg_log_entry(dap);
 		if( p ){
 			p->access_type = MEM_AP_WR64;
 			p->address     = pAddr->addr;
 			p->dataval     = value;
+			p->bytelen     = 8;
+			dap_dbg_set_regname( dap, p );
 		}
 	}
-	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF, pAddr );
-	if (retval != ERROR_OK)
-		return retval;
-
+	
 	uint64_t a;
 	a = pAddr->addr;
 	dap_queue_ap_write(dap, AP_MEM_REG_BD0 | (a & 0xC), value);
@@ -1501,7 +1501,8 @@ int dap_debugport_init(struct adiv5_dap *dap)
 		
 		port->idr_reg  = i_reg;
 		if( i_reg == 0 ){
-			continue;
+			/* STOP at the first zero */
+			break;
 		}
 
 		switch( i_reg & AP_CLASS_MASK ){
@@ -1509,6 +1510,7 @@ int dap_debugport_init(struct adiv5_dap *dap)
 			/* we don't care about this */
 			break;
 		case AP_CLASS_MEM:
+			port->is_mem_ap = 1;
 			dap_ap_class_mem( dap, port );
 			break;
 		case AP_CLASS_NONE:
@@ -1590,6 +1592,19 @@ int target_cs_find_ap(struct target *target, enum ap_type type_to_find, uint8_t
 	return ERROR_FAIL;
 }
 
+int dap_get_memacces_tck( struct adiv5_dap *dap )
+{
+	struct adiv5_dap_port *p;
+	uint32_t n;
+	p = dap_current_port(dap);
+	if( p ){
+		n = p->memaccess_tck;
+	} else {
+		n = 8;
+	}
+	return n;
+}
+
 int target_cs_get_debugbase2( struct target *target, const struct target_addr *p, uint32_t *dbgbase, uint32_t *apid )
 {
 	int ap;
@@ -1602,7 +1617,8 @@ int target_cs_get_debugbase2( struct target *target, const struct target_addr *p
 
 	return target_cs_get_debugbase( target, ap, dbgbase, apid );
 }
-		
+
+
 
 int target_cs_get_debugbase( struct target *target, int ap,
 			uint32_t *dbgbase, uint32_t *apid)
@@ -2205,35 +2221,6 @@ static int dap_info_command(struct command_context *cmd_ctx, struct adiv5_dap *d
 	return ERROR_OK;
 }
 
-COMMAND_HANDLER(handle_dap_log_command)
-{
-	int v;
-	int r;
-	switch(CMD_ARGC){
-	default:
-		r = ERROR_COMMAND_SYNTAX_ERROR;
-		break;
-	case 0:
-		command_print(CMD_CTX, "low: %d, high: %d\n", dap_dbg_lowlevel, dap_dbg_highlevel );
-		r = ERROR_OK;
-		break;
-	case 2:
-		COMMAND_PARSE_NUMBER(int, CMD_ARGV[1], v );
-		if( 0 == strcmp( CMD_ARGV[0], "low" )){
-			dap_dbg_lowlevel = v;
-			r = ERROR_OK;
-			break;
-		}
-		if( 0 == strcmp( CMD_ARGV[0], "high" )){
-			dap_dbg_highlevel = v;
-			r = ERROR_OK;
-			break;
-		}
-		r = ERROR_COMMAND_SYNTAX_ERROR;
-		break;
-	}
-	return r;
-}
 
 COMMAND_HANDLER(handle_dap_info_command)
 {
@@ -2821,13 +2808,6 @@ static const struct command_registration dap_commands[] = {
 		.usage = "PORTNUM cfg|idr VALUE",
 	},
 	{
-		.name = "log",
-		.handler = handle_dap_log_command,
-		.mode = COMMAND_EXEC,
-		.help = "enable/disable dap logging",
-		.usage = "[[low|high] VALUE]",
-	},
-	{
 		.name = "baseaddr",
 		.handler = dap_baseaddr_command,
 		.mode = COMMAND_EXEC,
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index ba113fd..bd480a4 100755
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -63,7 +63,7 @@ struct coresight_settings;
  */
 #define DP_IDCODE		BANK_REG(0x0, 0x0)	/* SWD: read */
 #define DP_ABORT		BANK_REG(0x0, 0x0)	/* SWD: write */
-#define DP_CTRL_STAT		BANK_REG(0x0, 0x4)	/* r/w */
+#define DP_CTRL_STAT	BANK_REG(0x0, 0x4)	/* r/w */
 #define DP_RESEND		BANK_REG(0x0, 0x8)	/* SWD: read */
 #define DP_SELECT		BANK_REG(0x0, 0x8)	/* JTAG: r/w; SWD: write */
 #define DP_RDBUFF		BANK_REG(0x0, 0xC)	/* read-only */
@@ -164,6 +164,7 @@ struct adiv5_dap {
 	bool     port_types_done;
 	struct adiv5_dap_port {
 		int      port_num;
+		int      is_mem_ap;
 
 		/* Identification register */
 		bool     idr_reg_forced;
@@ -348,8 +349,6 @@ struct coresight_bulk {
 int coresight_io_bulk( struct coresight_bulk *pBulk );
 
 
-extern int dap_dbg_lowlevel;
-extern int dap_dbg_highlevel;
 void dap_dbg_add_names( struct adiv5_dap *dap,
 			/* what port number is this on */
 			int portnum,
@@ -771,14 +770,18 @@ int target_cs_discover_ap( struct target *target,
 						   enum ap_type findme,
 						   struct coresight_address *port );
 
+int dap_get_memacces_tck( struct adiv5_dap *dap );
 
 /* Returns pointer to current dap port, or null if not valid */
 struct adiv5_dap_port *dap_current_port( struct adiv5_dap *dap );
 
 extern jim_wide dap_debug_flags;
 #define dap_debug( NAME )  _debugFlagEnabled( NAME, dap_debug_flags )
-#define DAP_APDP_IO    _debugFlagN(0)
-#define DAP_MEM_AP_IO  _debugFlagN(1)
+#define DAP_DBG_AP_IO         _debugFlagN(0)
+#define DAP_DBG_DP_IO         _debugFlagN(1)
+#define DAP_DBG_MEM_AP_IO     _debugFlagN(3)
+#define DAP_DBG_CORESIGHT_IO  _debugFlagN(4)
+#define DAP_DBG_any_IO   (DAP_DBG_AP_IO|DAP_DBG_DP_IO|DAP_DBG_MEM_AP_IO)
 
 
 #endif
diff --git a/src/target/arm_adi_v5_debug.c b/src/target/arm_adi_v5_debug.c
index dffa193..09fe3be 100644
--- a/src/target/arm_adi_v5_debug.c
+++ b/src/target/arm_adi_v5_debug.c
@@ -1,4 +1,4 @@
- #ifdef HAVE_CONFIG_H
+#ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
@@ -7,20 +7,30 @@
 #include "arm_adi_v5.h"
 #include <helper/time_support.h>
 
-int dap_dbg_lowlevel = 0;
-int dap_dbg_highlevel = 0;
-
 static int dap_log_overflow_once;
 
-#define dap_has_coresight_names(DAP)				\
-	(dap_find_namelist((DAP), (DAP)->cached_ap_port) != NULL)
+static void dap_dbg_log_clear( struct adiv5_dap *dap )
+{
+	/* clear log array */
+	dap->dbg.n_log_entries = 0;
+	memset( (void *)(dap->dbg.log),
+		0,
+		sizeof(dap->dbg.log[0]) * dap->dbg.n_log_avail );
+	dap_log_overflow_once = 0;	
+}
 
 /* find the name list for this port */
 static const struct dap_coresight_namelist *
-dap_find_namelist( struct adiv5_dap *dap, uint32_t portnum )
+dap_find_namelist( struct adiv5_dap *dap )
 {
+	int portnum;
 	const struct dap_coresight_namelist *nl;
 
+	portnum = dap->cached_ap_port;
+	if( (portnum < 0) || (portnum >255) ){
+		return NULL;
+	}
+	
 	nl = dap->dbg.namelist;
 	/* MOST chips have a *SINGLE* dap debug port 
 	 * SOME chips (qualcomm) have two, or three...
@@ -28,10 +38,10 @@ dap_find_namelist( struct adiv5_dap *dap, uint32_t portnum )
 	 */
 	while( nl ){
 		/* find the port number */
-		if( nl->portnum == portnum ){
+		if( nl->portnum == ((unsigned)portnum) ){
 			return nl;
 		}
-		nl = nl->next_port;
+		nl = nl->next;
 	}
 	return nl;
 }
@@ -57,7 +67,7 @@ dap_find_reg_block( const struct dap_coresight_namelist *nl, uint64_t a )
 			break;
 		}
 
-		b = b->next_block;
+		b = b->next;
 	}
 	return b;
 }
@@ -81,46 +91,43 @@ dap_reg_name( const struct dap_coresight_block *blk, uint64_t a )
 
 
 
-static const char *
-dap_coresight_regname( struct adiv5_dap *dap, uint32_t portnum, int is_wr, uint64_t addr )
+void
+dap_dbg_set_regname( struct adiv5_dap *dap, struct dap_access_log *p )
 {
 	const struct dap_coresight_namelist *nl;
 	const struct dap_coresight_block *blk;
 	const struct dap_coresight_name *n;
-	const char *cp1;
-	const char *cp2;
+
+ 	nl = dap_find_namelist( dap );
+	if( nl == NULL ){
+		return;
+	}
+
+	blk = dap_find_reg_block( nl, p->address );
 	
-	cp1 = "(unknown)";
-	cp2 = "(unknown)";
-	nl = dap_find_namelist( dap,portnum );
-	if( !nl ){
-		goto done;
-	}
-
-	cp1 = dap->name;
-	blk = dap_find_reg_block( nl, addr );
-	if( !blk ){
-		goto done;
-	}
-	cp1 = blk->name;
-
-	n = dap_reg_name( blk, addr );
-	if( n ){
-		if( is_wr ){
-			cp2 = n->wr_name;
-			if( !cp2 ){
-				cp2 = n->rd_name;
-			}
-		} else {
-			cp2 = n->rd_name;
-			if(!cp2){
-				cp2 = n->wr_name;
-			}
-		}
+	if( blk == NULL ){
+		return;
+	}
+
+	n = dap_reg_name( blk, p->address );
+	if( n == NULL ){
+		return;
+	}
+
+	switch( p->access_type ){
+	default:
+		break;
+	case  MEM_AP_RD32:
+	case  MEM_AP_RD64:
+	case  MEM_AP_RDBULK:
+		p->reg_name =n->rd_name;
+		break;
+	case  MEM_AP_WR32:
+	case  MEM_AP_WR64:
+	case  MEM_AP_WRBULK:
+		p->reg_name =n->wr_name;
+		break;
 	}
- done:
-	snprintf( dap->dbg.coresight_namebuf, sizeof(dap->dbg.coresight_namebuf), "%s.%s", cp1, cp2 );
-	return dap->dbg.coresight_namebuf;
 }
 
 
@@ -130,39 +137,66 @@ void dap_dbg_init(struct adiv5_dap *dap )
 	if( dap->name == NULL ){
 		dap->name = strdup("dap");
 	}
-	memset( &(dap->dbg), 0, sizeof(dap->dbg) );
+
 	
 	dap->dbg.n_log_entries = 0;
-	dap->dbg.n_log_avail   = 20;
+	dap->dbg.n_log_avail   = 50;
 	dap->dbg.log = calloc( dap->dbg.n_log_avail, sizeof( dap->dbg.log[0] ) );
 	if(dap->dbg.log==NULL){
 		dap->dbg.n_log_avail = 0;
 		LOG_ERROR("no memory for dap log?");
 	}
+	dap_dbg_log_clear(dap);
 }
 
 struct dap_access_log * dap_dbg_log_entry(struct adiv5_dap *dap )
 {
+	unsigned n;
 	struct dap_access_log *p;
-	if( dap->dbg.n_log_entries >= dap->dbg.n_log_avail ){
-		if( (dap->dbg.n_log_avail) && (dap_log_overflow_once == 0) ){
+
+	n = dap->dbg.n_log_entries;
+	if( n >= dap->dbg.n_log_avail ){
+		if( !dap_log_overflow_once ){
 			dap_log_overflow_once = 1;
-			LOG_ERROR("DAP LOG overflow\n");
+			LOG_ERROR("DAP LOG overflow");
 		}
 		return NULL;
 	}
-	dap->dbg.n_log_entries += 1;
-	p = &(dap->dbg.log[ dap->dbg.n_log_entries ]);
+	dap->dbg.n_log_entries = n+1;
+	
+	p = &(dap->dbg.log[n]);
+	memset( p, 0, sizeof(*p) );
+	
 	return p;
 }
 
-static const char *dap_ap_regname( unsigned reg, bool is_write )
+static const char *dap_ap_reg_name( struct adiv5_dap *dap, unsigned reg, bool is_write )
 {
-	(void)(is_write);
 	const char *cp;
+	struct adiv5_dap_port *port;
+
+	(void)(is_write);
+	
+	cp = NULL;
+
+	port = dap_current_port( dap );
+	if( port == NULL ){
+		return NULL;
+	}
+
+	if( reg == AP_REG_IDR ){
+		return "ap-idr";
+	}
+
+	if( !port->is_mem_ap ){
+		/* FUTURE: add JTAG AP names here */
+		return NULL;
+	}
+	
+	/* Generic regs */
 	switch( reg ){
 	default:
-		cp = "ap-unknown";
+		cp = NULL;
 		break;
 	case AP_MEM_REG_CSW:
 		cp = "ap-csw";
@@ -198,7 +232,7 @@ static const char *dap_ap_regname( unsigned reg, bool is_write )
 	return cp;
 }
 
-static const char *dap_dp_regname( unsigned reg, bool is_write, bool is_swd )
+static const char *dap_dp_reg_name( unsigned reg, bool is_write, bool is_swd )
 {
 #if DP_IDCODE != DP_ABORT
 #error fix me
@@ -240,57 +274,6 @@ static const char *dap_dp_regname( unsigned reg, bool is_write, bool is_swd )
 }
 
 
-void dap_dbg_highlevel_xx( struct adiv5_dap *dap, uint32_t address, bool is_wr, char *value )
-{
-	const char *cp;
-
-	if( !dap_dbg_highlevel ){
-		return;
-	}
-	
-	if( !dap_has_coresight_names( dap ) ){
-		return;
-	}
-	
-	cp = dap_coresight_regname( dap, dap->cached_ap_port, is_wr, address );
-	LOG_OUTPUT("dap-%s: 0x%08" PRIx32 " (%8s) %s\n",
-		   (is_wr ? "wr" : "rd"),
-		   address,
-		   cp,
-		   value );
-}
-
-
-
-void dap_dbg_highlevel_wr32( struct adiv5_dap *dap, uint32_t address, uint32_t value)
-{
-	char buf[20];
-
-	if( !dap_dbg_highlevel ){
-		return;
-	}
-	snprintf( buf, sizeof(buf),"0x%08" PRIx32 , value );
-
-	dap_dbg_highlevel_xx( dap, 1, address, buf );
-}
-
-
-void dap_dbg_highlevel_rd32( struct adiv5_dap *dap, uint32_t address, uint32_t *value)
-{
-	char *cp;
-	char buf[20];
-	if( !dap_dbg_highlevel ){
-		return;
-	}
-	if( value ){
-		snprintf( buf,sizeof(buf), "0x%08" PRIx32, *value );
-		cp = buf;
-	} else {
-		cp = "dummy";
-	}
-
-	dap_dbg_highlevel_xx(dap, 0, address,cp);
-}
 
 #define PRINTBUFSIZE 30
 static void print_num( char *buf, int width, uint64_t val )
@@ -299,35 +282,39 @@ static void print_num( char *buf, int width, uint64_t val )
 }
 
 
+
 void dap_dbg_log_dump( struct adiv5_dap *dap )
 {
 	unsigned x;
-	const char *regname;
+	const char *reg_name;
 	const char *val;
 	struct dap_access_log *p;
 	int is_wr;
 	char buf[PRINTBUFSIZE];
 
-	if( dap_dbg_lowlevel <= 0 ){
+	if( dap->dbg.n_log_entries == 0 ){
 		return;
 	}
 
 	for( x = 0 ; x < dap->dbg.n_log_entries ; x++ ){
 		p = &(dap->dbg.log[x]);
-		
+
+		reg_name = p->reg_name;
+		if( reg_name == NULL ){
+			reg_name = "(unknown)";
+		}
 		is_wr = 0;
 		val = buf;
 		switch( p->access_type ){
 		case DAP_AP_ABORT:
 			/* data is uint8 */
 			p->dataval = * ((uint8_t *)(p->pointer));
-			LOG_OUTPUT( "dap: abort result: 0x%02" PRIx64 "\n", p->dataval );
+			LOG_DEBUG( "dap: abort result: 0x%02" PRIx64 , p->dataval );
 			break;
 		case DAP_DP_WR:
 			is_wr++;
 			/* fall through */
 		case DAP_DP_RD:
-			regname = dap_dp_regname( p->reg, is_wr, dap->ops->is_swd );
 			if( !is_wr ){
 				if( p->pointer ){
 					p->dataval = *((uint32_t *)(p->pointer));
@@ -336,13 +323,12 @@ void dap_dbg_log_dump( struct adiv5_dap *dap )
 				}
 			}
 			print_num( buf, 8, p->dataval );
-			LOG_OUTPUT( "dap-%s: %-8s: %s\n", is_wr ? "wr" : "rd", regname, val );
+			LOG_DEBUG( "dap-%s: %-8s: %s", is_wr ? "wr" : "rd", reg_name, val );
 			break;
 		case DAP_AP_WR:
 			is_wr++;
 			/* fallthrough */
 		case DAP_AP_RD:
-			regname = dap_ap_regname( p->reg, is_wr );
 			if( !is_wr ){
 				if( p->pointer ){
 					p->dataval = *((uint32_t *)(p->pointer));
@@ -351,7 +337,7 @@ void dap_dbg_log_dump( struct adiv5_dap *dap )
 				}
 			}
 			print_num( buf, 8, p->dataval );
-			LOG_OUTPUT( "dap-%s: %-8s: %s\n", is_wr ? "wr" : "rd", regname, val );
+			LOG_DEBUG( "dap-%s: %-8s: %s", is_wr ? "wr" : "rd", reg_name, val );
 			break;
 		case MEM_AP_WR32:
 		case MEM_AP_WR64:
@@ -361,7 +347,6 @@ void dap_dbg_log_dump( struct adiv5_dap *dap )
 		case MEM_AP_RD64:
 			/* REG = dap port number */
 			/* ADR = register address */
-			regname = dap_coresight_regname( dap, p->reg, is_wr, p->address );
 			if( !is_wr ){
 				if( p->pointer ){
 					if( p->access_type == MEM_AP_RD64 ){
@@ -379,39 +364,38 @@ void dap_dbg_log_dump( struct adiv5_dap *dap )
 				/* 32bit */
 				print_num( buf,  8, p->dataval );
 			}
-			LOG_OUTPUT( "dap-%s: %20s: %s\n", is_wr ? "wr" : "rd", regname, val );
+			LOG_DEBUG( "dap-%s: %20s: %s", is_wr ? "wr" : "rd", reg_name, val );
 			break;
 		case MEM_AP_WRBULK:
 			is_wr++;
 			/* fallthrough */
 		case MEM_AP_RDBULK:
 			/* this has no names */
-			regname = dap_coresight_regname( dap, p->reg, is_wr, p->address );
-			LOG_OUTPUT("dap-bulk-%s: @ 0x%08" PRIx64 " inc:%d len: 0x%08" PRIx64 "\n",
-				   is_wr ? "wr" : "rd",
-				   p->address,
-				   p->reg ? 1 : 0,
-				   p->dataval );
+			LOG_DEBUG("dap-bulk-%s: (%s) @ 0x%08" PRIx64 " inc:%d len: 0x%08" PRIx64,
+					   is_wr ? "wr" : "rd",
+					   reg_name,
+					   p->address,
+					   p->tar_inc,
+					   p->dataval );
 			break;
 		}
 	}
-	/* clear log array */
-	dap->dbg.n_log_entries = 0;
-	memset( (void *)(dap->dbg.log),
-		0,
-		sizeof(dap->dbg.log[0]) * dap->dbg.n_log_avail );
+
+	dap_dbg_log_clear(dap);
 }
 
+
 int dap_queue_dp_read(struct adiv5_dap *dap, unsigned reg, uint32_t *data)
 {
 	assert(dap->ops != NULL);
-	if( dap_dbg_lowlevel ){
+	if( dap_debug(DAP_DBG_DP_IO) ){
 		struct dap_access_log *p;
 		p = dap_dbg_log_entry(dap);
 		if( p ){
 			p->access_type = DAP_DP_RD;
-			p->reg = reg;
+			p->reg_name = dap_dp_reg_name( reg, 0, dap->ops->is_swd );
 			p->pointer = data;
+			p->bytelen = 4;
 		}
 	}
 	return dap->ops->queue_dp_read(dap, reg, data);
@@ -421,13 +405,14 @@ int dap_queue_dp_read(struct adiv5_dap *dap, unsigned reg, uint32_t *data)
 int dap_queue_dp_write(struct adiv5_dap *dap, unsigned reg, uint32_t data)
 {
 	assert(dap->ops != NULL);
-	if( dap_dbg_lowlevel ){
+	if( dap_debug(DAP_DBG_DP_IO) ){
 		struct dap_access_log *p;
 		p = dap_dbg_log_entry(dap);
 		if( p ){
 			p->access_type = DAP_DP_WR;
-			p->reg = reg;
+			p->reg_name = dap_dp_reg_name( reg, 1, dap->ops->is_swd );
 			p->dataval = data;
+			p->bytelen = 4;
 		}
 	}
 	return dap->ops->queue_dp_write(dap, reg, data);
@@ -436,13 +421,14 @@ int dap_queue_dp_write(struct adiv5_dap *dap, unsigned reg, uint32_t data)
 int dap_queue_ap_read(struct adiv5_dap *dap, unsigned reg, uint32_t *data)
 {
 	assert(dap->ops != NULL);
-	if( dap_dbg_lowlevel ){
+	if( dap_debug(DAP_DBG_AP_IO) ){
 		struct dap_access_log *p;
 		p = dap_dbg_log_entry(dap);
 		if( p ){
-			p->access_type = DAP_DP_RD;
-			p->reg = reg;
+			p->access_type = DAP_AP_RD;
+			p->reg_name = dap_ap_reg_name( dap, reg, 0 );
 			p->pointer = data;
+			p->bytelen = 4;
 		}
 	}
 	return dap->ops->queue_ap_read(dap, reg, data);
@@ -451,13 +437,14 @@ int dap_queue_ap_read(struct adiv5_dap *dap, unsigned reg, uint32_t *data)
 int dap_queue_ap_write(struct adiv5_dap *dap, unsigned reg, uint32_t data)
 {
 	assert(dap->ops != NULL);
-	if( dap_dbg_lowlevel ){
+	if( dap_debug(DAP_DBG_AP_IO) ){
 		struct dap_access_log *p;
 		p = dap_dbg_log_entry(dap);
 		if( p ){
-			p->access_type = DAP_DP_RD;
-			p->reg = reg;
+			p->access_type = DAP_AP_WR;
+			p->reg_name = dap_ap_reg_name( dap, reg, 1 );
 			p->dataval = data;
+			p->bytelen = 4;
 		}
 	}
 	return dap->ops->queue_ap_write(dap, reg, data);
@@ -466,13 +453,14 @@ int dap_queue_ap_write(struct adiv5_dap *dap, unsigned reg, uint32_t data)
 int dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
 {
 	assert(dap->ops != NULL);
-	if( dap_dbg_lowlevel ){
+	if( dap_debug( DAP_DBG_any_IO ) ){
 		struct dap_access_log *p;
 		p = dap_dbg_log_entry(dap);
 		if( p ){
 			p->access_type = DAP_AP_ABORT;
-			p->reg = 0;
+			p->reg_name = "abort";
 			p->pointer = ack;
+			p->bytelen = 1;
 		}
 	}
 	return dap->ops->queue_ap_abort(dap, ack);
@@ -486,3 +474,153 @@ int dap_run(struct adiv5_dap *dap)
 	dap_dbg_log_dump( dap );
 	return r;
 }
+
+
+static void delete_nameblock( struct dap_coresight_block *b )
+{
+	int done;
+	int x;
+
+	/* release prefixnames */
+	if( b->n1 ){
+		free((void *)(b->n1));
+	}
+	b->n1 = NULL;
+	if( b->n2 ){
+		free((void *)(b->n2));
+	}
+	b->n2 = NULL;
+
+	done = 1;
+	/* release all rdwr names */
+	for( x = 0 ; !done ; x++ ){
+		/* assume done */
+		done = 1;
+
+		/* list is terminated with two nulls */
+		if( b->names[x].rd_name ){
+			free((void *)(b->names[x].rd_name));
+			/* not done yet */
+			done = 0;
+		}
+		if( b->names[x].wr_name ){
+			free((void *)(b->names[x].wr_name));
+			/* not done yet */
+			done = 0;
+		}
+	}
+	/* release name vector */
+	free((void *)(b->names));
+	/* and finally the block */
+	free((void *)(b));
+}
+
+
+void dap_dbg_add_regs( struct adiv5_dap *dap,
+					   uint64_t mask,
+					   const struct target_addr *pBase,
+					   const char *n1,
+					   const char *n2,
+					   const struct dap_coresight_name *regs )
+{
+	struct dap_coresight_namelist **nl;
+	struct dap_coresight_namelist *new_nl;
+	struct dap_coresight_block *block;
+	uint32_t pn;
+	int x;
+	int n_names;
+	char buf[100];
+
+	/* get port number */
+	pn = pBase->route - TA_ROUTE_arm_dap0;
+
+	/* Does this port already exist? */
+	nl = &(dap->dbg.namelist);
+	while( *nl ){
+		if( (*nl)->portnum == pn ){
+			break;
+		}
+		nl = &((*nl)->next);
+	}
+
+	/* create if needed */
+	if( *nl == NULL ){
+		new_nl = calloc( 1, sizeof(*nl) );
+		if( new_nl == NULL ){
+			LOG_DEBUG("no memory :-(");
+			return;
+		}
+		new_nl->portnum = pn;
+		new_nl->next    = dap->dbg.namelist;
+		dap->dbg.namelist = new_nl;
+	}
+
+	/* create the new block */
+	block = calloc( 1, sizeof(*block) );
+	if( !block ){
+		/* we can leave the namelist... 
+		 * it might have existed from before 
+		 */
+		return;
+	}
+	
+	block->base_address = pBase->addr;
+	block->address_mask = mask;
+
+	/* remember n1 & n2 for later */
+	if( n1 == NULL ){
+		n1 = "";
+	}
+	if( n2 == NULL ){
+		n2 = "";
+	}
+	block->n1 = strdup(n1);
+	block->n2 = strdup(n2);
+	if( (block->n1 == NULL) || (block->n2 == NULL) ){
+	fail:
+		delete_nameblock(block);
+		return;
+	}
+
+	/* count names, list ends in double null */
+	for( x = 0 ; (regs[x].rd_name != NULL) || (regs[x].wr_name != NULL) ; x++ ){
+		/* counting... */
+	}
+	n_names = x;
+	block->names = calloc( n_names, sizeof(block->names[0]) );
+	if( block->names == NULL ){
+		goto fail;
+	}
+
+	/* create names and dup each of them */
+	for( x = 0 ; x < n_names ; x++, regs++ ){
+		if( regs->wr_name ){
+			if( n2[0] ){
+				snprintf( buf, sizeof(buf), "%s.%s.%s", n1, n2, regs->wr_name );
+			} else {
+				snprintf( buf, sizeof(buf), "%s.%s", n1, regs->wr_name );
+			}
+			block->names[x].address = block->base_address + regs->address;
+			block->names[x].wr_name = strdup( buf );
+			if( NULL == block->names[x].wr_name ){
+				goto fail;
+			}
+		}			
+		if( regs->rd_name ){
+			if( n2[0] ){
+				snprintf( buf, sizeof(buf), "%s.%s.%s", n1, n2, regs->rd_name );
+			} else {
+				snprintf( buf, sizeof(buf), "%s.%s", n1, regs->rd_name );
+			}
+			block->names[x].address = block->base_address + regs->address;
+			block->names[x].rd_name = strdup( buf );
+			if( NULL == block->names[x].rd_name ){
+				goto fail;
+			}
+		}			
+	}
+	/* if we get here - we have a valid block */
+	block->next = (*nl)->blocks;
+	new_nl->blocks = block;
+}
+
diff --git a/src/target/arm_adi_v5_debug.h b/src/target/arm_adi_v5_debug.h
index 071ff9c..0384671 100644
--- a/src/target/arm_adi_v5_debug.h
+++ b/src/target/arm_adi_v5_debug.h
@@ -16,10 +16,12 @@ struct dap_access_log {
 #define MEM_AP_RDBULK ( ('m' << 24) | ('r'<<16) | ('b'<<8) | ('l'<<0))
 #define MEM_AP_WRBULK ( ('m' << 24) | ('w'<<16) | ('b'<<8) | ('l'<<0))
 	
-	unsigned reg;
-	uint64_t dataval;
-	uint64_t address;
-	void     *pointer;
+	const char *reg_name; /* name of register or null */
+	uint64_t dataval;    /* io value */
+	uint64_t address;    /* what address is being rd/wr */
+	uint64_t bytelen;    /* if applicable how many bytes */
+	void     *pointer;   /* memory pointer rd/wr bulk and all reads */
+	int      tar_inc;    /* applicable to bulk IO */
 };
 
 
@@ -36,34 +38,56 @@ struct dap_coresight_name {
 struct dap_coresight_block {
 	/* Example:  The CPU vrs ETM vrs STM */
 	/* base of this block */
-	const char *name;
+	const char *n1;
+	const char *n2;
 	uint64_t base_address;
 	/* typically mask = 0xFFF (size=4k)*/
 	uint64_t address_mask;
-	const struct dap_coresight_name *names;
-	const struct dap_coresight_block *next_block;
+	struct dap_coresight_name *names;
+	struct dap_coresight_block *next;
 } ;
 
 struct dap_coresight_namelist {
 	/* Example the DEBUG AP vrs the MEM AP */
 	uint32_t portnum;
 	/* list of blocks on this port */
-	const struct dap_coresight_block  *blocks;
+	struct dap_coresight_block  *blocks;
 	/* next port */
-	const struct dap_coresight_namelist *next_port;
+	struct dap_coresight_namelist *next;
 };
 
 struct dap_debug_info {
 	struct dap_access_log *log;
 	size_t n_log_avail;
 	size_t n_log_entries;
-	char   coresight_namebuf[30];
 	
 	/* list of names on this dap port */
-	const struct dap_coresight_namelist *namelist;
-} ;
+	struct dap_coresight_namelist *namelist;
+};
 
 struct dap_access_log * dap_dbg_log_entry(struct adiv5_dap *dap );
 
+/* Is there a defined register name at this address? If so give me the name */
+void dap_dbg_set_regname( struct adiv5_dap *dap, struct dap_access_log *p );
+
 void dap_dbg_log_dump( struct adiv5_dap *dap );
 void dap_dbg_init(struct adiv5_dap *dap );
+
+/** on this dap - register debug names
+ * \param dap - the dap it belongs to
+ * \param pBase - dap port and base address
+ *    Specifies both port number and base address
+ * \param mask  - address mask to use
+ *    For cortex M3 - maks is always 0xffffffff
+ *    For typically use mask = (~4K-1)
+ * \param n1    - primary name, ie: apps0
+ * \param n2    - secondary name, ie: "dbg" or "cti" or null
+ * \param regs  - array of names.
+ */
+
+void dap_dbg_add_regs( struct adiv5_dap *dap,
+					   uint64_t mask,
+					   const struct target_addr *pBase,
+					   const char *n1,
+					   const char *n2,
+					   const struct dap_coresight_name *regs );
diff --git a/src/target/armv7m.c b/src/target/armv7m.c
index 9d92916..43d5fa8 100755
--- a/src/target/armv7m.c
+++ b/src/target/armv7m.c
@@ -44,6 +44,14 @@
 #define _DEBUG_INSTRUCTION_EXECUTION_
 #endif
 
+const struct dap_coresight_name armv7m_cpu_regs[] = {
+#define ARMV7M_DBG_REG( N, V )  { .address = (V), .rd_name =#N, .wr_name = #N }
+#include "armv7m_cpudbg_regs.h"
+#undef ARMV7M_DBG_REG
+	/* terminate list */
+	DAP_CORESIGHT_NAME_TERMINATE()	
+};
+
 static const char * const armv7m_exception_strings[] = {
 	"", "Reset", "NMI", "HardFault",
 	"MemManage", "BusFault", "UsageFault", "RESERVED",
diff --git a/src/target/armv7m.h b/src/target/armv7m.h
index 13bf25f..16c65a1 100755
--- a/src/target/armv7m.h
+++ b/src/target/armv7m.h
@@ -35,6 +35,18 @@ extern const int armv7m_msp_reg_map[];
 
 const char *armv7m_exception_string(int number);
 
+extern const struct dap_coresight_name armv7m_cpu_regs[];
+
+enum armv7m_cpu_regs {
+#define ARMV7M_DBG_REG( N, V )  N = (V)
+#include "armv7m_cpudbg_regs.h"
+#undef ARMV7M_DBG_REG
+
+	/* force a 32bit enum */
+	armv7m_cpu_reg32bit  = 0x7fffffff
+};
+
+
 /* offsets into armv7m core register cache */
 enum {
 	/* for convenience, the first set of indices match
diff --git a/src/target/armv7m_cpudbg_regs.h b/src/target/armv7m_cpudbg_regs.h
new file mode 100644
index 0000000..6b70757
--- /dev/null
+++ b/src/target/armv7m_cpudbg_regs.h
@@ -0,0 +1,109 @@
+/* -*- mode: c -*- */
+/* this file is included to create two tables */
+
+/*FIXME: Not all of these are RW regs */
+    ARMV7M_DBG_REG( ITM_STIM0       , 0xE0000000   ),
+    ARMV7M_DBG_REG( ITM_STIM1       , 0xE0000004   ),
+    ARMV7M_DBG_REG( ITM_STIM2       , 0xE0000008   ),
+    ARMV7M_DBG_REG( ITM_STIM3       , 0xE000000c   ),
+    ARMV7M_DBG_REG( ITM_STIM4       , 0xE0000010   ),
+    ARMV7M_DBG_REG( ITM_STIM5       , 0xE0000014   ),
+    ARMV7M_DBG_REG( ITM_STIM6       , 0xE0000018   ),
+    ARMV7M_DBG_REG( ITM_STIM7       , 0xE000001c   ),
+    ARMV7M_DBG_REG( ITM_STIM8       , 0xE0000020   ),
+    ARMV7M_DBG_REG( ITM_STIM9       , 0xE0000024   ),
+    ARMV7M_DBG_REG( ITM_STIM10      , 0xE0000028   ),
+    ARMV7M_DBG_REG( ITM_STIM11      , 0xE000002c   ),
+    ARMV7M_DBG_REG( ITM_STIM12      , 0xE0000030   ),
+    ARMV7M_DBG_REG( ITM_STIM13      , 0xE0000034   ),
+    ARMV7M_DBG_REG( ITM_STIM14      , 0xE0000038   ),
+    ARMV7M_DBG_REG( ITM_STIM15      , 0xE000003c   ),
+    ARMV7M_DBG_REG( ITM_STIM16      , 0xE0000040   ),
+    ARMV7M_DBG_REG( ITM_STIM17      , 0xE0000044   ),
+    ARMV7M_DBG_REG( ITM_STIM18      , 0xE0000048   ),
+    ARMV7M_DBG_REG( ITM_STIM19      , 0xE000004c   ),
+    ARMV7M_DBG_REG( ITM_STIM20      , 0xE0000050   ),
+    ARMV7M_DBG_REG( ITM_STIM21      , 0xE0000054   ),
+    ARMV7M_DBG_REG( ITM_STIM22      , 0xE0000058   ),
+    ARMV7M_DBG_REG( ITM_STIM23      , 0xE000005c   ),
+    ARMV7M_DBG_REG( ITM_STIM24      , 0xE0000060   ),
+    ARMV7M_DBG_REG( ITM_STIM25      , 0xE0000064   ),
+    ARMV7M_DBG_REG( ITM_STIM26      , 0xE0000068   ),
+    ARMV7M_DBG_REG( ITM_STIM27      , 0xE000006c   ),
+    ARMV7M_DBG_REG( ITM_STIM28      , 0xE0000070   ),
+    ARMV7M_DBG_REG( ITM_STIM29      , 0xE0000074   ),
+    ARMV7M_DBG_REG( ITM_STIM30      , 0xE0000078   ),
+    ARMV7M_DBG_REG( ITM_STIM31      , 0xE000007c   ),
+    ARMV7M_DBG_REG( ITM_TER         , 0xE0000E00   ),
+    ARMV7M_DBG_REG( ITM_TPR         , 0xE0000E40   ),
+    ARMV7M_DBG_REG( ITM_TCR         , 0xE0000E80   ),
+    ARMV7M_DBG_REG( ITM_ITATRDY     , 0xE0000EF0   ),
+    ARMV7M_DBG_REG( ITM_ITATVAL     , 0xE0000EF8   ),
+    ARMV7M_DBG_REG( ITM_TCTRL       , 0xE0000F00   ),
+    ARMV7M_DBG_REG( ITM_LAR         , 0xE0000FB0   ),
+    ARMV7M_DBG_REG( ITM_LSR         , 0xE0000FB4   ),
+    ARMV7M_DBG_REG( DWT_CTRL        , 0xE0001000   ),
+    ARMV7M_DBG_REG( DWT_CYCCNT      , 0xE0001004   ),
+	ARMV7M_DBG_REG( DWT_CPICNT		, 0xE0001008   ),
+	ARMV7M_DBG_REG( DWT_EXCCNT		, 0xE000100C   ),
+	ARMV7M_DBG_REG( DWT_SLEEPCNT	, 0xE0001010 	),
+	ARMV7M_DBG_REG( DWT_LSUCNT		, 0xE0001014 ),
+	ARMV7M_DBG_REG( DWT_FOLDCNT		, 0xE0001018 ),
+	ARMV7M_DBG_REG( DWT_PCSR		, 0xE000101C ),
+	ARMV7M_DBG_REG( DWT_COMP0       , 0xE0001020   ),
+    ARMV7M_DBG_REG( DWT_MASK0       , 0xE0001024   ),
+    ARMV7M_DBG_REG( DWT_FUNCTION0   , 0xE0001028   ),
+
+    ARMV7M_DBG_REG( DWT_COMP1       , 0xE0001030   ),
+    ARMV7M_DBG_REG( DWT_MASK1       , 0xE0001034   ),
+    ARMV7M_DBG_REG( DWT_FUNCTION1   , 0xE0001038   ),
+
+    ARMV7M_DBG_REG( DWT_COMP2       , 0xE0001040   ),
+    ARMV7M_DBG_REG( DWT_MASK2       , 0xE0001044   ),
+    ARMV7M_DBG_REG( DWT_FUNCTION2   , 0xE0001048   ),
+
+    ARMV7M_DBG_REG( DWT_COMP3       , 0xE0001050   ),
+    ARMV7M_DBG_REG( DWT_MASK3       , 0xE0001054   ),
+    ARMV7M_DBG_REG( DWT_FUNCTION3   , 0xE0001058   ),
+		
+    ARMV7M_DBG_REG( FP_CTRL         , 0xE0002000   ),
+    ARMV7M_DBG_REG( FP_REMAP        , 0xE0002004   ),
+    ARMV7M_DBG_REG( FP_COMP0        , 0xE0002008   ),
+    ARMV7M_DBG_REG( FP_COMP1        , 0xE000200C   ),
+    ARMV7M_DBG_REG( FP_COMP2        , 0xE0002010   ),
+    ARMV7M_DBG_REG( FP_COMP3        , 0xE0002014   ),
+    ARMV7M_DBG_REG( FP_COMP4        , 0xE0002018   ),
+    ARMV7M_DBG_REG( FP_COMP5        , 0xE000201C   ),
+    ARMV7M_DBG_REG( FP_COMP6        , 0xE0002020   ),
+    ARMV7M_DBG_REG( FP_COMP7        , 0xE0002024   ),
+		
+    ARMV7M_DBG_REG( NVIC_ICTR       , 0xE000E004   ),
+    ARMV7M_DBG_REG( NVIC_ISE0       , 0xE000E100   ),
+		
+    ARMV7M_DBG_REG( CPUID           , 0xE000ED00   ),
+    ARMV7M_DBG_REG( NVIC_ICSR       , 0xE000ED04   ),
+    ARMV7M_DBG_REG( NVIC_AIRCR      , 0xE000ED0C   ),
+    ARMV7M_DBG_REG( NVIC_SHCSR      , 0xE000ED24   ),
+    ARMV7M_DBG_REG( NVIC_CFSR       , 0xE000ED28   ),
+    ARMV7M_DBG_REG( NVIC_MMFSRb     , 0xE000ED28   ),
+    ARMV7M_DBG_REG( NVIC_BFSRb      , 0xE000ED29   ),
+    ARMV7M_DBG_REG( NVIC_USFSRh     , 0xE000ED2A   ),
+    ARMV7M_DBG_REG( NVIC_HFSR       , 0xE000ED2C   ),
+    ARMV7M_DBG_REG( NVIC_DFSR       , 0xE000ED30   ),
+    ARMV7M_DBG_REG( NVIC_MMFAR      , 0xE000ED34   ),
+    ARMV7M_DBG_REG( NVIC_BFAR       , 0xE000ED38   ),
+    ARMV7M_DBG_REG( FPU_CPACR       , 0xE000ED88   ),
+    ARMV7M_DBG_REG( DCB_DHCSR       , 0xE000EDF0   ),
+    ARMV7M_DBG_REG( DCB_DCRSR       , 0xE000EDF4   ),
+    ARMV7M_DBG_REG( DCB_DCRDR       , 0xE000EDF8   ),
+    ARMV7M_DBG_REG( DCB_DEMCR       , 0xE000EDFC   ),
+    ARMV7M_DBG_REG( FPU_FPCCR       , 0xE000EF34   ),
+    ARMV7M_DBG_REG( FPU_FPCAR       , 0xE000EF38   ),
+    ARMV7M_DBG_REG( FPU_FPDSCR      , 0xE000EF3C   ),
+    ARMV7M_DBG_REG( TPI_SSPSR       , 0xE0040000   ),
+    ARMV7M_DBG_REG( TPI_CSPSR       , 0xE0040004   ),
+    ARMV7M_DBG_REG( TPI_ACPR        , 0xE0040010   ),
+    ARMV7M_DBG_REG( TPI_SPPR        , 0xE00400F0   ),
+    ARMV7M_DBG_REG( TPI_FFSR        , 0xE0040300   ),
+    ARMV7M_DBG_REG( TPI_FFCR        , 0xE0040304   ),
+    ARMV7M_DBG_REG( TPI_FSCR        , 0xE0040308   ),
diff --git a/src/target/armv8_cpudbg_regs.h b/src/target/armv8_cpudbg_regs.h
index 4a162b9..9f1958a 100644
--- a/src/target/armv8_cpudbg_regs.h
+++ b/src/target/armv8_cpudbg_regs.h
@@ -1,36 +1,36 @@
 
 
-  CORESIGHT_RW_REG( EDESR		, 0x020, "External Debug Event Status Reg" ),
-  CORESIGHT_RW_REG( EDECR		, 0x024, "External Debug Execution Control Reg" ),
-  CORESIGHT_RW_REG( EDWAR		, 0x030, "External Debug Watchpoint Address Reg"	),
+  CORESIGHT_RW_REG( EDESR				, 0x020, "External Debug Event Status Reg" ),
+  CORESIGHT_RW_REG( EDECR				, 0x024, "External Debug Execution Control Reg" ),
+  CORESIGHT_RW_REG( EDWAR				, 0x030, "External Debug Watchpoint Address Reg"	),
 		   
-  CORESIGHT_RW_REG( DBGDTRRX_EL0	, 0x080 , "Debug Communications Channel RX"		),
-  CORESIGHT_RW_REG( EDITR		, 0x084, "External Debug Instruction Transfer Reg"	),
-  CORESIGHT_RW_REG( EDSCR		, 0x088, "External Debug Status and Control Reg"	),
-  CORESIGHT_RW_REG( DBGDTRTX_EL0	, 0x08C, "The Debug Communications Channel TX"		),
-  CORESIGHT_RW_REG( EDRCR		, 0x090, "External Debug Reserve Control Reg"		),
-  CORESIGHT_RW_REG( EDACR		, 0x094, "External Debug Auxiliary Control Reg"		),
-  CORESIGHT_RW_REG( EDECCR		, 0x098, "External Debug Exception Catch Control Reg"	),
-  CORESIGHT_RW_REG( EDPCSRlo		, 0x0A0, "External Debug Program Counter Sample Regs"	),
-  CORESIGHT_RW_REG( EDCIDSR		, 0x0A4, "External Debug Context ID Sample Reg"		),
-  CORESIGHT_RW_REG( EDVIDSR		, 0x0A8, "External Debug Virtual Context Sample Reg"	),
-  CORESIGHT_RW_REG( EDPCSRhi		, 0x0AC, "External Debug Program Counter Sample Regs"	),
-  CORESIGHT_RW_REG( OSLAR_EL1		, 0x300, "OS Lock Access Reg"				),
-  CORESIGHT_RW_REG( EDPRCR		, 0x310, "External Debug Power/Reset Control Reg"	),
-  CORESIGHT_RW_REG( EDPRSR		, 0x314, "External Debug Processor Status Reg"		),
-  CORESIGHT_RW_REG( DBGBVR0_EL1		, 0x400, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGDTRRX_EL0		, 0x080 , "Debug Communications Channel RX"		),
+  CORESIGHT_RW_REG( EDITR				, 0x084, "External Debug Instruction Transfer Reg"	),
+  CORESIGHT_RW_REG( EDSCR				, 0x088, "External Debug Status and Control Reg"	),
+  CORESIGHT_RW_REG( DBGDTRTX_EL0		, 0x08C, "The Debug Communications Channel TX"		),
+  CORESIGHT_RW_REG( EDRCR				, 0x090, "External Debug Reserve Control Reg"		),
+  CORESIGHT_RW_REG( EDACR				, 0x094, "External Debug Auxiliary Control Reg"		),
+  CORESIGHT_RW_REG( EDECCR				, 0x098, "External Debug Exception Catch Control Reg"	),
+  CORESIGHT_RW_REG( EDPCSRlo			, 0x0A0, "External Debug Program Counter Sample Regs"	),
+  CORESIGHT_RW_REG( EDCIDSR				, 0x0A4, "External Debug Context ID Sample Reg"		),
+  CORESIGHT_RW_REG( EDVIDSR				, 0x0A8, "External Debug Virtual Context Sample Reg"	),
+  CORESIGHT_RW_REG( EDPCSRhi			, 0x0AC, "External Debug Program Counter Sample Regs"	),
+  CORESIGHT_RW_REG( OSLAR_EL1			, 0x300, "OS Lock Access Reg"				),
+  CORESIGHT_RW_REG( EDPRCR				, 0x310, "External Debug Power/Reset Control Reg"	),
+  CORESIGHT_RW_REG( EDPRSR				, 0x314, "External Debug Processor Status Reg"		),
+  CORESIGHT_RW_REG( DBGBVR0_EL1			, 0x400, "Breakpoint Value Regs"			),
 #if !defined( DBGBVRn_EL1 )
 #define DBGBVRn_EL1(n)  (DBGBVR0_EL1 + ((n)*16))
 #endif
-  CORESIGHT_RW_REG( DBGBVR1_EL1		, 0x410, "Breakpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGBVR2_EL1		, 0x420, "Breakpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGBVR3_EL1		, 0x430, "Breakpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGBVR4_EL1		, 0x440, "Breakpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGBVR5_EL1		, 0x450, "Breakpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGBVR6_EL1		, 0x460, "Breakpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGBVR7_EL1		, 0x470, "Breakpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGBVR8_EL1		, 0x480, "Breakpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGBVR9_EL1		, 0x490, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR1_EL1			, 0x410, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR2_EL1			, 0x420, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR3_EL1			, 0x430, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR4_EL1			, 0x440, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR5_EL1			, 0x450, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR6_EL1			, 0x460, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR7_EL1			, 0x470, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR8_EL1			, 0x480, "Breakpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGBVR9_EL1			, 0x490, "Breakpoint Value Regs"			),
   CORESIGHT_RW_REG( DBGBVR10_EL1		, 0x4a0, "Breakpoint Value Regs"			),
   CORESIGHT_RW_REG( DBGBVR11_EL1		, 0x4b0, "Breakpoint Value Regs"			),
   CORESIGHT_RW_REG( DBGBVR12_EL1		, 0x4c0, "Breakpoint Value Regs"			),
@@ -38,19 +38,19 @@
   CORESIGHT_RW_REG( DBGBVR14_EL1		, 0x4e0, "Breakpoint Value Regs"			),
   CORESIGHT_RW_REG( DBGBVR15_EL1		, 0x4f0, "Breakpoint Value Regs"			),
   
-  CORESIGHT_RW_REG( DBGBCR0_EL1		, 0x408, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR0_EL1			, 0x408, "Breakpoint Control Regs"			),
 #if !defined( DBGCBRn_EL1 )
 #define DBGBCRn_EL1(n)  (DBGBCR0_EL1 + ((n)*16))
 #endif
-  CORESIGHT_RW_REG( DBGBCR1_EL1		, 0x418, "Breakpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGBCR2_EL1		, 0x428, "Breakpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGBCR3_EL1		, 0x438, "Breakpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGBCR4_EL1		, 0x448, "Breakpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGBCR5_EL1		, 0x458, "Breakpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGBCR6_EL1		, 0x468, "Breakpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGBCR7_EL1		, 0x478, "Breakpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGBCR8_EL1		, 0x488, "Breakpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGBCR9_EL1		, 0x498, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR1_EL1			, 0x418, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR2_EL1			, 0x428, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR3_EL1			, 0x438, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR4_EL1			, 0x448, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR5_EL1			, 0x458, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR6_EL1			, 0x468, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR7_EL1			, 0x478, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR8_EL1			, 0x488, "Breakpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGBCR9_EL1			, 0x498, "Breakpoint Control Regs"			),
   CORESIGHT_RW_REG( DBGBCR10_EL1		, 0x4a8, "Breakpoint Control Regs"			),
   CORESIGHT_RW_REG( DBGBCR11_EL1		, 0x4b8, "Breakpoint Control Regs"			),
   CORESIGHT_RW_REG( DBGBCR12_EL1		, 0x4c8, "Breakpoint Control Regs"			),
@@ -60,19 +60,19 @@
 
 
 
-  CORESIGHT_RW_REG( DBGWVR0_EL1		, 0x800, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR0_EL1			, 0x800, "Watchpoint Value Regs"			),
 #if !defined(DBGWVRn_EL1)
 #define DBGWVRn_EL1(n) (DBGWVR0_EL1 + ((n)*16))
 #endif
-  CORESIGHT_RW_REG( DBGWVR1_EL1		, 0x810, "Watchpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGWVR2_EL1		, 0x820, "Watchpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGWVR3_EL1		, 0x830, "Watchpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGWVR4_EL1		, 0x840, "Watchpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGWVR5_EL1		, 0x850, "Watchpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGWVR6_EL1		, 0x860, "Watchpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGWVR7_EL1		, 0x870, "Watchpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGWVR8_EL1		, 0x880, "Watchpoint Value Regs"			),
-  CORESIGHT_RW_REG( DBGWVR9_EL1		, 0x890, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR1_EL1			, 0x810, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR2_EL1			, 0x820, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR3_EL1			, 0x830, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR4_EL1			, 0x840, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR5_EL1			, 0x850, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR6_EL1			, 0x860, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR7_EL1			, 0x870, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR8_EL1			, 0x880, "Watchpoint Value Regs"			),
+  CORESIGHT_RW_REG( DBGWVR9_EL1			, 0x890, "Watchpoint Value Regs"			),
   CORESIGHT_RW_REG( DBGWVR10_EL1		, 0x8a0, "Watchpoint Value Regs"			),
   CORESIGHT_RW_REG( DBGWVR11_EL1		, 0x8b0, "Watchpoint Value Regs"			),
   CORESIGHT_RW_REG( DBGWVR12_EL1		, 0x8c0, "Watchpoint Value Regs"			),
@@ -80,19 +80,19 @@
   CORESIGHT_RW_REG( DBGWVR14_EL1		, 0x8e0, "Watchpoint Value Regs"			),
   CORESIGHT_RW_REG( DBGWVR15_EL1		, 0x8f0, "Watchpoint Value Regs"			),
 
-  CORESIGHT_RW_REG( DBGWCR0_EL1		, 0x804, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR0_EL1			, 0x804, "Watchpoint Control Regs"			),
 #if !defined(DBGWCRn_EL1)
 #define DBGWCRn_EL1(n) (DBGWCR0_EL1 + ((n)*16))
 #endif
-  CORESIGHT_RW_REG( DBGWCR1_EL1		, 0x814, "Watchpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGWCR2_EL1		, 0x824, "Watchpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGWCR3_EL1		, 0x834, "Watchpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGWCR4_EL1		, 0x844, "Watchpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGWCR5_EL1		, 0x854, "Watchpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGWCR6_EL1		, 0x864, "Watchpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGWCR7_EL1		, 0x874, "Watchpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGWCR8_EL1		, 0x884, "Watchpoint Control Regs"			),
-  CORESIGHT_RW_REG( DBGWCR9_EL1		, 0x894, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR1_EL1			, 0x814, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR2_EL1			, 0x824, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR3_EL1			, 0x834, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR4_EL1			, 0x844, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR5_EL1			, 0x854, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR6_EL1			, 0x864, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR7_EL1			, 0x874, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR8_EL1			, 0x884, "Watchpoint Control Regs"			),
+  CORESIGHT_RW_REG( DBGWCR9_EL1			, 0x894, "Watchpoint Control Regs"			),
   CORESIGHT_RW_REG( DBGWCR10_EL1		, 0x8a4, "Watchpoint Control Regs"			),
   CORESIGHT_RW_REG( DBGWCR11_EL1		, 0x8b4, "Watchpoint Control Regs"			),
   CORESIGHT_RW_REG( DBGWCR12_EL1		, 0x8c4, "Watchpoint Control Regs"			),
@@ -100,18 +100,18 @@
   CORESIGHT_RW_REG( DBGWCR14_EL1		, 0x8e4, "Watchpoint Control Regs"			),
   CORESIGHT_RW_REG( DBGWCR15_EL1		, 0x8f4, "Watchpoint Control Regs"			),
 
-  CORESIGHT_RW_REG( IMP_DEF_An		, 0xc00, "IMPLEMENTATION DEFINED"			),
-  CORESIGHT_RW_REG( MIDR_EL1		, 0xD00, "Main ID Reg"					),
-  CORESIGHT_RW_REG( EDPFR			, 0xD20, "External Debug Processor Feature Reg"		),
-  CORESIGHT_RW_REG( EDDFR			, 0xD28, "External Debug Feature Reg"			),
+  CORESIGHT_RW_REG( IMP_DEF_An			, 0xc00, "IMPLEMENTATION DEFINED"			),
+  CORESIGHT_RW_REG( MIDR_EL1			, 0xD00, "Main ID Reg"					),
+  CORESIGHT_RW_REG( EDPFR				, 0xD20, "External Debug Processor Feature Reg"		),
+  CORESIGHT_RW_REG( EDDFR				, 0xD28, "External Debug Feature Reg"			),
 /* Reserved 0xD30 UNKNOWN */
 /* Reserved 0xD38 UNKNOWN */
-  CORESIGHT_RW_REG( IMP_DEF_Bn		, 0xe80, "IMPLEMENTATION DEFINED"			),
-/*   xxxx				, 0xF00-F8C Management regs Management regs and CoreSight compliance */
-  CORESIGHT_RW_REG( DBGCLAIMSET_EL1	, 0xFA0, "Claim Tag Set Reg"				),
-  CORESIGHT_RW_REG( DBGCLAIMCLR_EL1	, 0xFA4, "Claim Tag Clr Reg"				),
-  CORESIGHT_RW_REG( EDDEVAFFn		, 0xFA8, "Device Affinity regs"				),
+  CORESIGHT_RW_REG( IMP_DEF_Bn			, 0xe80, "IMPLEMENTATION DEFINED"			),
+/*   xxxx								, 0xF00-F8C Management regs Management regs and CoreSight compliance */
+  CORESIGHT_RW_REG( DBGCLAIMSET_EL1		, 0xFA0, "Claim Tag Set Reg"				),
+  CORESIGHT_RW_REG( DBGCLAIMCLR_EL1		, 0xFA4, "Claim Tag Clr Reg"				),
+  CORESIGHT_RW_REG( EDDEVAFFn			, 0xFA8, "Device Affinity regs"				),
 /* 0xFB0-FB4 Management regs Management regs and CoreSight compliance  */
   CORESIGHT_RW_REG( DBGAUTHSTATUS_EL1	, 0xFB8, "Authentication Status reg"			),
-  CORESIGHT_RW_REG( EDDEVIDn		, 0xFC0, "Device ID regs"				),
+  CORESIGHT_RW_REG( EDDEVIDn			, 0xFC0, "Device ID regs"				),
 /* 0xFD0-FFC Management regs Management regs and CoreSight compliance */
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 74eafca..d237b9d 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -2902,6 +2902,7 @@ static int cortex_a53_examine_first(struct target *target)
 	struct arm             *arm      = armv8_to_arm(armv8);
 	struct cortex_a_common *cortex_a = armv8_to_cortex_a( armv8 );
 	struct coresight_settings *coresight = target_to_coresight(target);
+	struct adiv5_dap       *dap      = coresight_to_dap(coresight);	
 
 	int i;
 	int retval = ERROR_OK;
@@ -2973,6 +2974,9 @@ static int cortex_a53_examine_first(struct target *target)
 	LOG_DEBUG("cortex_a53[%d] cpuid: 0x%08" PRIx32, target->coreid, cpuid );
 	armv8->midr_el1_reg = cpuid;
 
+	dap_dbg_add_regs( dap, ~(4096-1), &(coresight->dbgbus.addr), target_name(target),"cpu", armv8_cpu_regs );
+	dap_dbg_add_regs( dap, ~(4096-1), &(coresight->cti.addr)   , target_name(target),"cti", armv8_cti_regs );
+
 	{
 		/* read the EDDFR as two seperate 32bit values lsb first */
 		/* table H8-2, page H8-4769, ARM DDI0478a */
diff --git a/src/target/cortex_m.c b/src/target/cortex_m.c
index df34286..072f3fc 100755
--- a/src/target/cortex_m.c
+++ b/src/target/cortex_m.c
@@ -1871,6 +1871,20 @@ int cortex_m_examine(struct target *target)
 			cortex_m->dwt_num_comp);
 	}
 
+	{
+		struct coresight_settings *coresight = target_to_coresight(target);
+		struct adiv5_dap       *dap      = coresight_to_dap(coresight);	
+
+		/* the cortex M3 uses the entire 32bit adress space for registers */
+		/* hence it often has a private APB (not ahb, not AXI) port on the DAP bus */
+		dap_dbg_add_regs( dap,
+						  (((uint64_t)(1))<<32)-1,
+						   &(coresight->dbgbus.addr),
+						   target_name(target),
+						   "cpu",
+						   armv7m_cpu_regs );
+	}
+
 	return ERROR_OK;
 }
 
diff --git a/src/target/cortex_m.h b/src/target/cortex_m.h
index 8b873bc..129ad30 100755
--- a/src/target/cortex_m.h
+++ b/src/target/cortex_m.h
@@ -31,52 +31,10 @@
 
 #define CORTEX_M_COMMON_MAGIC 0x1A451A45
 
-#define SYSTEM_CONTROL_BASE 0x400FE000
 
-#define ITM_TER		0xE0000E00
-#define ITM_TPR		0xE0000E40
-#define ITM_TCR		0xE0000E80
-#define ITM_LAR		0xE0000FB0
-
-#define CPUID		0xE000ED00
-/* Debug Control Block */
-#define DCB_DHCSR	0xE000EDF0
-#define DCB_DCRSR	0xE000EDF4
-#define DCB_DCRDR	0xE000EDF8
-#define DCB_DEMCR	0xE000EDFC
 
 #define DCRSR_WnR	(1 << 16)
 
-#define DWT_CTRL	0xE0001000
-#define DWT_CYCCNT	0xE0001004
-#define DWT_COMP0	0xE0001020
-#define DWT_MASK0	0xE0001024
-#define DWT_FUNCTION0	0xE0001028
-
-#define FP_CTRL		0xE0002000
-#define FP_REMAP	0xE0002004
-#define FP_COMP0	0xE0002008
-#define FP_COMP1	0xE000200C
-#define FP_COMP2	0xE0002010
-#define FP_COMP3	0xE0002014
-#define FP_COMP4	0xE0002018
-#define FP_COMP5	0xE000201C
-#define FP_COMP6	0xE0002020
-#define FP_COMP7	0xE0002024
-
-#define FPU_CPACR	0xE000ED88
-#define FPU_FPCCR	0xE000EF34
-#define FPU_FPCAR	0xE000EF38
-#define FPU_FPDSCR	0xE000EF3C
-
-#define TPI_SSPSR	0xE0040000
-#define TPI_CSPSR	0xE0040004
-#define TPI_ACPR	0xE0040010
-#define TPI_SPPR	0xE00400F0
-#define TPI_FFSR	0xE0040300
-#define TPI_FFCR	0xE0040304
-#define TPI_FSCR	0xE0040308
-
 /* DCB_DHCSR bit and field definitions */
 #define DBGKEY		(0xA05F << 16)
 #define C_DEBUGEN	(1 << 0)
@@ -101,19 +59,6 @@
 #define VC_MMERR		(1 << 4)
 #define VC_CORERESET	(1 << 0)
 
-#define NVIC_ICTR		0xE000E004
-#define NVIC_ISE0		0xE000E100
-#define NVIC_ICSR		0xE000ED04
-#define NVIC_AIRCR		0xE000ED0C
-#define NVIC_SHCSR		0xE000ED24
-#define NVIC_CFSR		0xE000ED28
-#define NVIC_MMFSRb		0xE000ED28
-#define NVIC_BFSRb		0xE000ED29
-#define NVIC_USFSRh		0xE000ED2A
-#define NVIC_HFSR		0xE000ED2C
-#define NVIC_DFSR		0xE000ED30
-#define NVIC_MMFAR		0xE000ED34
-#define NVIC_BFAR		0xE000ED38
 
 /* NVIC_AIRCR bits */
 #define AIRCR_VECTKEY		(0x5FA << 16)
diff --git a/src/target/target.c b/src/target/target.c
index 6d452b9..fec1624 100755
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -3263,9 +3263,12 @@ COMMAND_HANDLER(handle_dump_image_command)
 		uint32_t this_run_size = (size > buf_size) ? buf_size : size;
 		/* underlying code needs to understand possible: route=phys */
 		retval = target64_read_buffer(target, &addr, this_run_size, buffer);
-		if (retval != ERROR_OK)
+		if (retval != ERROR_OK){
+			LOG_DEBUG("target read error(%d) @ address %s for %d bytes\n",
+					  retval, target_addr2str1( target, &addr ), (int)this_run_size );
 			break;
-
+		}
+		
 		retval = fileio_write(&fileio, this_run_size, buffer, &size_written);
 		if (retval != ERROR_OK)
 			break;
-- 
1.9.1


From 56621ca84089bac88e30bb840d6d9f1ae64482da Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 66/94] Add Jim_GetOpt_Bool()

---
 src/helper/jim-nvp.c | 62 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/helper/jim-nvp.h |  7 ++++++
 2 files changed, 69 insertions(+)

diff --git a/src/helper/jim-nvp.c b/src/helper/jim-nvp.c
index 94a340c..c7db57c 100755
--- a/src/helper/jim-nvp.c
+++ b/src/helper/jim-nvp.c
@@ -262,6 +262,68 @@ int Jim_GetOpt_Double(Jim_GetOptInfo *goi, double *puthere)
 	return r;
 }
 
+static const char * const t_words[] = {
+	"y", "yes", "t", "true", 0
+};
+static const char * const f_words[] = {
+	"n", "no", "f", "false", 0
+};
+	
+
+int Jim_GetOpt_Bool(Jim_GetOptInfo *goi, int *puthere)
+{
+	int e;
+	Jim_Obj *o;
+	int tmp;
+	const char *cp;
+	char *ep;
+	int x;
+
+	/* unknown */
+	tmp = -1;
+	e = Jim_GetOpt_Obj(goi, &o);
+	if( e != JIM_OK ){
+		return e;
+	}
+
+	cp = Jim_GetString( o, NULL );
+	if( !cp ){
+		return JIM_ERR;
+	}
+
+	/* is this a number */
+	tmp = strtol( cp, &ep, 0 );
+	if( (*ep == 0) && (ep != cp) ){
+		/* We have a number! */
+		/* normalize to bool */
+		tmp = !!tmp;
+		goto done;
+	}
+
+	/* or any true or false word? */
+	for( x = 0 ; t_words[x] ; x++ ){
+		if( 0 == strcasecmp( t_words[x], cp ) ){
+			tmp = 1;
+			goto done;
+		}
+	}
+	for( x = 0 ; f_words[x] ; x++ ){
+		if( 0 == strcasecmp( t_words[x], cp ) ){
+			tmp = 0;
+			break;
+		}
+	}
+ done:
+	if( tmp < 0 ){
+		Jim_SetResultFormatted(goi->interp, "not a bool: %#s", o);
+		return JIM_ERR;
+	}
+	if( puthere ){
+		*puthere = tmp;
+	}
+	return JIM_OK;
+}
+
 int Jim_GetOpt_Wide(Jim_GetOptInfo *goi, jim_wide *puthere)
 {
 	int r;
diff --git a/src/helper/jim-nvp.h b/src/helper/jim-nvp.h
index 562bc2e..9eb88da 100755
--- a/src/helper/jim-nvp.h
+++ b/src/helper/jim-nvp.h
@@ -268,6 +268,13 @@ int Jim_GetOpt_Double(Jim_GetOptInfo *goi, double *puthere);
  */
 int Jim_GetOpt_Wide(Jim_GetOptInfo *goi, jim_wide *puthere);
 
+/** Remove argv[0] as wide.
+ *
+ * \param goi     - get opt info
+ * \param puthere - where param is put.
+ */
+int Jim_GetOpt_Bool(Jim_GetOptInfo *goi, int *puthere );
+
 /** Remove argv[0] as NVP.
  *
  * \param goi     - get opt info
-- 
1.9.1


From 60df93be414e2b2a66168437f7cd76742228b0b7 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 67/94] Add HYP as an arm mode

---
 src/target/arm.h | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/target/arm.h b/src/target/arm.h
index b4ec57c..d705922 100755
--- a/src/target/arm.h
+++ b/src/target/arm.h
@@ -54,14 +54,21 @@
  * they support.
  */
 enum arm_mode {
+	/* In the past the CPSR mode bits where bits [4:0]
+	 * This changed, now bit[4] = Res1 (reserved always 1)
+	 * The mode bit is now Bits[3:0]
+	 *
+	 * However, this set of numbers includes bit[4]
+	 */
 	ARM_MODE_USR = 16,
 	ARM_MODE_FIQ = 17,
 	ARM_MODE_IRQ = 18,
 	ARM_MODE_SVC = 19,
-	ARM_MODE_MON = 22,
+	ARM_MODE_MON = 22, /* example: trust zone */
 	ARM_MODE_ABT = 23,
+	ARM_MODE_HYP = 26, /* hypervisor */
 	ARM_MODE_UND = 27,
-	ARM_MODE_SYS = 31,
+	ARM_MODE_SYS = 31, /* example: Linux Kernel */
 
 	ARM_MODE_THREAD = 0,
 	ARM_MODE_USER_THREAD = 1,
-- 
1.9.1


From ecbf66a6175d4aa191f43fccd08172a28818dc00 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 68/94] Work In process: DAP caching speed up, and DAP Error
 Resolution (more hardcoding issues)

---
 src/target/adi_v5_cmsis_dap.c |  44 ++++---
 src/target/adi_v5_jtag.c      | 142 ++++++++++++----------
 src/target/adi_v5_swd.c       | 145 ++++++++++------------
 src/target/arm_adi_v5.c       | 276 +++++++++++++++++++++++++++++++++++-------
 src/target/arm_adi_v5.h       |  80 +++++++-----
 src/target/arm_adi_v5_debug.c |  34 +++---
 src/target/coresight_io.c     |  26 ++--
 src/target/cortex_a.c         |   6 +-
 src/target/cortex_a53.c       |  81 +++++++++----
 src/target/cortex_m.c         |   6 +-
 10 files changed, 530 insertions(+), 310 deletions(-)

diff --git a/src/target/adi_v5_cmsis_dap.c b/src/target/adi_v5_cmsis_dap.c
index 4ac72d9..8e45595 100755
--- a/src/target/adi_v5_cmsis_dap.c
+++ b/src/target/adi_v5_cmsis_dap.c
@@ -52,13 +52,12 @@
 #define CMSIS_CMD_MATCH_MSK     (1   << 5)    /* Match Mask */
 
 /* YUK! - but this is currently a global.... */
-extern struct jtag_interface *jtag_interface;
 
 static int cmsis_dap_clear_sticky_errors(struct adiv5_dap *dap)
 {
 	LOG_DEBUG(" ");
 
-	const struct swd_driver *swd = jtag_interface->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 	assert(swd);
 
 	swd->write_reg(dap, (CMSIS_CMD_DP | CMSIS_CMD_WRITE | CMSIS_CMD_A32(DP_ABORT)),
@@ -70,7 +69,7 @@ static int cmsis_dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
 {
 	LOG_DEBUG(" ");
 
-	const struct swd_driver *swd = jtag_interface->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 	assert(swd);
 
 	swd->write_reg(dap, (CMSIS_CMD_DP | CMSIS_CMD_WRITE | CMSIS_CMD_A32(DP_ABORT)),
@@ -82,7 +81,7 @@ static int cmsis_dap_queue_dp_read(struct adiv5_dap *dap, unsigned reg, uint32_t
 {
 	LOG_DEBUG("reg = %d", reg);
 
-	const struct swd_driver *swd = jtag_interface->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 	assert(swd);
 
 	swd->read_reg(dap, (CMSIS_CMD_DP | CMSIS_CMD_READ | CMSIS_CMD_A32(reg)), data);
@@ -100,7 +99,7 @@ static int (cmsis_dap_queue_dp_write)(struct adiv5_dap *dap, unsigned reg, uint3
 		data &= ~CORUNDETECT;
 	}
 
-	const struct swd_driver *swd = jtag_interface->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 	assert(swd);
 
 	swd->write_reg(dap, (CMSIS_CMD_DP | CMSIS_CMD_WRITE | CMSIS_CMD_A32(reg)), data);
@@ -110,15 +109,18 @@ static int (cmsis_dap_queue_dp_write)(struct adiv5_dap *dap, unsigned reg, uint3
 /** Select the AP register bank matching bits 7:4 of reg. */
 static int cmsis_dap_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
 {
-	uint32_t select_ap_bank = reg & 0x000000F0;
+	/* AP reg is [7:4] */
+	reg = reg >> 4;
+	reg = reg & 0x0f;
 
-	if (select_ap_bank == dap->cached_ap_bank_value)
-		return ERROR_OK;
-
-	dap->cached_ap_bank_value = select_ap_bank;
-	select_ap_bank |= dap->cached_ap_port<<24;
-
-	cmsis_dap_queue_dp_write(dap, DP_SELECT, select_ap_bank);
+	dap_update_select_reg_cache( dap, -1, reg, -1 );
+	
+	if( dap->cached_select_reg_valid ){
+		/* CACHE HIT */
+	} else {
+		cmsis_dap_queue_dp_write(dap, DP_SELECT, dap->cached_select_reg_value );
+		dap->cached_select_reg_valid = true;
+	}
 	return ERROR_OK;
 }
 
@@ -128,7 +130,7 @@ static int (cmsis_dap_queue_ap_read)(struct adiv5_dap *dap, unsigned reg, uint32
 
 	LOG_DEBUG("reg = %d", reg);
 
-	const struct swd_driver *swd = jtag_interface->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 	assert(swd);
 
 	swd->read_reg(dap, (CMSIS_CMD_AP | CMSIS_CMD_READ | CMSIS_CMD_A32(reg)), data);
@@ -150,7 +152,7 @@ static int (cmsis_dap_queue_ap_write)(struct adiv5_dap *dap, unsigned reg, uint3
 
 	LOG_DEBUG("reg = %d, data = 0x%08" PRIx32, reg, data);
 
-	const struct swd_driver *swd = jtag_interface->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 	assert(swd);
 
 	swd->write_reg(dap, (CMSIS_CMD_AP | CMSIS_CMD_WRITE | CMSIS_CMD_A32(reg)), data);
@@ -191,7 +193,7 @@ static int cmsis_dap_run(struct adiv5_dap *dap)
 }
 
 const struct dap_ops cmsis_dap_ops = {
-	.is_swd = true,
+	.transport_type      = ARM_DAP_TRANSPORT_SWD,
 	.queue_dp_read       = cmsis_dap_queue_dp_read,
 	.queue_dp_write      = cmsis_dap_queue_dp_write,
 	.queue_ap_read       = cmsis_dap_queue_ap_read,
@@ -229,8 +231,10 @@ static const struct command_registration cmsis_dap_handlers[] = {
 
 static int cmsis_dap_select(struct command_context *ctx)
 {
+	struct target *target = get_current_target(ctx);
+	struct adiv5_dap *dap = target_cs_to_dap(target);
+	
 	LOG_DEBUG("CMSIS-ADI: cmsis_dap_select");
-
 	int retval = register_commands(ctx, NULL, cmsis_dap_handlers);
 
 	if (retval != ERROR_OK)
@@ -241,7 +245,7 @@ static int cmsis_dap_select(struct command_context *ctx)
 	 * with hardware default TRN (1), it can be changed later
 	 * we use a bogus 'swd' driver to implement cmsis-dap as it is quite similar */
 
-	const struct swd_driver *swd = jtag_interface->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 	if (!swd || !swd->read_reg || !swd->write_reg || !swd->init) {
 		LOG_ERROR("no SWD driver?");
 		return ERROR_FAIL;
@@ -268,7 +272,7 @@ static int cmsis_dap_init(struct command_context *ctx)
 
 	/* Force the DAP's ops vector for CMSIS-DAP mode.
 	 * messy - is there a better way? */
-	dap->ops = &cmsis_dap_ops;
+	dap->driver.ops = &cmsis_dap_ops;
 
 	/* FIXME validate transport config ... is the
 	 * configured DAP present (check IDCODE)?
@@ -280,7 +284,7 @@ static int cmsis_dap_init(struct command_context *ctx)
 	/* Note, debugport_init() does setup too */
 
 #if 0
-	const struct swd_driver *swd = jtag_interface->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 	if (!swd || !swd->read_reg || !swd->write_reg || !swd->init) {
 		LOG_ERROR("no SWD driver?");
 		return ERROR_FAIL;
diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index cc0c27d..aeced14 100755
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -52,13 +52,13 @@
 
 int dap_jtag_debug = 0;
 
-struct adiv5_jtag_dap {
-	struct adiv5_dap dap;
-	struct jtag_tap *tap;
-};
-
 static int jtag_ap_q_abort(struct adiv5_dap *dap, uint8_t *ack);
 
+struct jtag_tap *arm_dap2tap( struct adiv5_dap *dap )
+{
+	return dap->driver.jtag_tap;
+}
+
 /***************************************************************************
  *
  * DPACC and APACC scanchain access through JTAG-DP (or SWJ-DP)
@@ -88,13 +88,13 @@ static int adi_jtag_dp_scan(struct adiv5_dap *dap,
 		uint8_t instr, uint8_t reg_addr, uint8_t RnW,
 		uint8_t *outvalue, uint8_t *invalue, uint8_t *ack)
 {
-	struct adiv5_jtag_dap *jtag_dap = container_of(dap, struct adiv5_jtag_dap, dap);
+	struct jtag_tap *tap = arm_dap2tap(dap);
 	struct scan_field fields[2];
 	uint8_t out_addr_buf;
 
-	if (buf_get_u32(jtag_dap->tap->cur_instr, 0, jtag_dap->tap->ir_length) != instr) {
+	if (buf_get_u32(tap->cur_instr, 0, tap->ir_length) != instr) {
 		struct scan_field field;
-		field.num_bits = jtag_dap->tap->ir_length;
+		field.num_bits = tap->ir_length;
 
 		uint8_t t[DIV_ROUND_UP(field.num_bits, 8)];
 		buf_set_u32(t, 0, field.num_bits, instr);
@@ -102,7 +102,7 @@ static int adi_jtag_dp_scan(struct adiv5_dap *dap,
 		field.out_value = t;
 		field.in_value = NULL;
 
-		jtag_add_ir_scan(jtag_dap->tap, &field, TAP_IDLE);
+		jtag_add_ir_scan(tap, &field, TAP_IDLE);
 	}
 
 	/* Scan out a read or write operation using some DP or AP register.
@@ -122,7 +122,7 @@ static int adi_jtag_dp_scan(struct adiv5_dap *dap,
 	fields[1].out_value = outvalue;
 	fields[1].in_value = invalue;
 
-	jtag_add_dr_scan(jtag_dap->tap, 2, fields, TAP_IDLE);
+	jtag_add_dr_scan(tap, 2, fields, TAP_IDLE);
 
 	/* Add specified number of tck clocks after starting memory bus
 	 * access, giving the hardware time to complete the access.
@@ -257,6 +257,31 @@ static int adi_jtag_scan_inout_check_u32(struct adiv5_dap *dap,
 	return retval;
 }
 
+static int jtag_dp_wr_ctrlstat( struct adiv5_dap *dap, uint32_t newvalue )
+{
+	int retval;
+	/* dap->dp_ctrl_stat | SSTICKYORUN | SSTICKYERR */
+	retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC, DP_CTRL_STAT, DPAP_WRITE, newvalue , NULL);
+	if( retval != ERROR_OK ){
+		return retval;
+	}
+	retval = jtag_execute_queue();
+	return retval;
+}
+
+static int jtag_dp_rd_ctrlstat( struct adiv5_dap *dap, uint32_t *result )
+{
+	int retval;
+
+	retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC, DP_CTRL_STAT, DPAP_READ, 0, result);
+	if (retval != ERROR_OK)
+		return retval;
+	retval = jtag_execute_queue();
+	return retval;
+}
+	
+	
+
 static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 {
 	int retval;
@@ -292,21 +317,18 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 	/* Post CTRL/STAT read; discard any previous posted read value
 	 * but collect its ACK status.
 	 */
-	retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-			DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = jtag_execute_queue();
-	if (retval != ERROR_OK)
-		return retval;
+	retval = jtag_dp_rd_ctrlstat( dap, &ctrlstat );
 
 	dap->ack = dap->ack & 0x7;
 
 	/* common code path avoids calling timeval_ms() */
-	if (dap->ack != JTAG_ACK_OK_FAULT) {
+	if (dap->ack == JTAG_ACK_OK_FAULT) {
+		/* ok */
+	} else {
 		long long then = timeval_ms();
 
 		while (dap->ack != JTAG_ACK_OK_FAULT) {
+			
 			if (dap->ack == JTAG_ACK_WAIT) {
 				if ((timeval_ms()-then) > 1000) {
 					LOG_WARNING("Timeout (1000ms) waiting "
@@ -328,11 +350,7 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 				return ERROR_JTAG_DEVICE_ERROR;
 			}
 
-			retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
-			if (retval != ERROR_OK)
-				return retval;
-			retval = jtag_execute_queue();
+			retval = jtag_dp_rd_ctrlstat( dap, &ctrlstat);
 			if (retval != ERROR_OK)
 				return retval;
 			dap->ack = dap->ack & 0x7;
@@ -343,10 +361,16 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 
 	/* Check for STICKYERR and STICKYORUN */
 	if (ctrlstat & (SSTICKYORUN | SSTICKYERR)) {
-		LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32, ctrlstat);
+		LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32" (sticky:%d, overrun:%d)",
+				  ctrlstat, !!(SSTICKYERR & ctrlstat), !!(SSTICKYORUN & ctrlstat));
 		/* Check power to debug regions */
-		if ((ctrlstat & 0xf0000000) != 0xf0000000) {
-
+		uint32_t maskcheck;
+		if( dap->ignore_csyspwrupreq ){
+			maskcheck = 0x70000000;
+		} else {
+			maskcheck = 0xf0000000;
+		}
+		if ((ctrlstat & maskcheck) != maskcheck) {
 			retval = dap_debugport_init(dap);
 			if (retval != ERROR_OK)
 				return retval;
@@ -368,29 +392,19 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 				LOG_ERROR("JTAG-DP STICKY ERROR");
 
 			/* Clear Sticky Error Bits */
-			retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_WRITE,
-					dap->dp_ctrl_stat | SSTICKYORUN
-						| SSTICKYERR, NULL);
-			if (retval != ERROR_OK)
-				return retval;
-			retval = adi_jtag_scan_inout_check_u32(dap, JTAG_DP_DPACC,
-					DP_CTRL_STAT, DPAP_READ, 0, &ctrlstat);
+			retval = jtag_dp_wr_ctrlstat( dap, dap->dp_ctrl_stat | SSTICKYORUN | SSTICKYERR);
 			if (retval != ERROR_OK)
 				return retval;
-			retval = jtag_execute_queue();
+
+			retval = jtag_dp_rd_ctrlstat( dap, &ctrlstat);
 			if (retval != ERROR_OK)
 				return retval;
-
 			LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
-
-			retval = dap_queue_ap_read(dap,
-					AP_MEM_REG_CSW, &mem_ap_csw);
+			retval = dap_queue_ap_read(dap, AP_MEM_REG_CSW, &mem_ap_csw);
 			if (retval != ERROR_OK)
 				return retval;
 
-			retval = dap_queue_ap_read(dap,
-					AP_MEM_REG_TAR_lo, &mem_ap_tar_l);
+			retval = dap_queue_ap_read(dap, AP_MEM_REG_TAR_lo, &mem_ap_tar_l);
 			if (retval != ERROR_OK)
 				return retval;
 			
@@ -442,20 +456,20 @@ static int jtag_dp_q_write(struct adiv5_dap *dap, unsigned reg,
 /** Select the AP register bank matching bits 7:4 of reg. */
 static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
 {
-	uint32_t select_ap_bank = reg & 0x000000F0;
-#if DAP_REG_CACHE
-	if (select_ap_bank == dap->cached_ap_bank_value){
-		LOG_DEBUG("ap-q-bank: 0x%02" PRIx32 " (cached)", (uint32_t)(reg));
+	int r;
+
+	dap_update_select_reg_cache( dap, -1, reg >> 4, -1 );
+	
+	if( dap->cached_select_reg_valid ){
+		/* CACHE HIT */
 		return ERROR_OK;
-	} else {
-		LOG_DEBUG("ap-q-bank: 0x%02" PRIx32 " *new*", (uint32_t)(reg));
 	}
-#endif
-	dap->cached_ap_bank_value = select_ap_bank;
-
-	select_ap_bank |= dap->cached_ap_port<<24;
-
-	return jtag_dp_q_write(dap, DP_SELECT, select_ap_bank);
+	
+	r = jtag_dp_q_write(dap, DP_SELECT, dap->cached_select_reg_value );
+	if( r == ERROR_OK ){
+		dap->cached_select_reg_valid = true;
+	}
+	return r;
 }
 
 static int jtag_ap_q_read(struct adiv5_dap *dap, unsigned reg,
@@ -500,6 +514,7 @@ static int jtag_dp_run(struct adiv5_dap *dap)
  * part of DAP setup
 */
 const struct dap_ops jtag_dp_ops = {
+	.transport_type      = ARM_DAP_TRANSPORT_JTAG,
 	.queue_dp_read       = jtag_dp_q_read,
 	.queue_dp_write      = jtag_dp_q_write,
 	.queue_ap_read       = jtag_ap_q_read,
@@ -557,20 +572,15 @@ int dap_to_jtag(struct target *target)
 	return retval;
 }
 
-void adiv5_jtag_dap_create(struct adiv5_jtag_dap *jtag_dap, struct jtag_tap *tap)
-{
-	/* TODO: Maybe create the super class, i.e. adiv5_dap_create(&swd_dap->dap); */
-	jtag_dap->dap.ops = &jtag_dp_ops;
-	jtag_dap->tap = tap;
-}
 
-struct adiv5_dap *adiv5_jtag_dap_new(struct jtag_tap *tap)
+
+int arm_dap_transport_change_JTAG( struct adiv5_dap *dap, int is_set )
 {
-	struct adiv5_jtag_dap *jtag_dap = calloc(1, sizeof(*jtag_dap));
-	if (jtag_dap == NULL)
-		return NULL;
+	/* we don't care */
+	if( !is_set ){
+		return ERROR_OK;
+	}
 
-	adiv5_jtag_dap_create(jtag_dap, tap);
-	adiv5_dap_init_common( &(jtag_dap->dap) );
-	return &jtag_dap->dap;
+	dap->driver.ops = &jtag_dp_ops;
+	return ERROR_OK;
 }
diff --git a/src/target/adi_v5_swd.c b/src/target/adi_v5_swd.c
index d4206e2..58e584e 100755
--- a/src/target/adi_v5_swd.c
+++ b/src/target/adi_v5_swd.c
@@ -56,16 +56,16 @@
 #include <jtag/swd.h>
 
 /* YUK! - but this is currently a global.... */
-extern struct jtag_interface *jtag_interface;
 static bool do_sync;
-struct adiv5_swd_dap {
-	struct adiv5_dap dap;
-	const struct swd_driver *swd;
-};
+
+const struct swd_driver *arm_dap2swd_driver( struct adiv5_dap *dap )
+{
+	return dap->driver.swd_driver;
+}
 
 static void swd_finish_read(struct adiv5_dap *dap)
 {
-	const struct swd_driver *swd = jtag_interface->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 	if (dap->last_read != NULL) {
 		swd->read_reg(dap, swd_cmd(true, false, DP_RDBUFF), dap->last_read);
 		dap->last_read = NULL;
@@ -77,7 +77,7 @@ static int swd_queue_dp_write(struct adiv5_dap *dap, unsigned reg,
 
 static void swd_clear_sticky_errors(struct adiv5_dap *dap)
 {
-	const struct swd_driver *swd = jtag_interface->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 	assert(swd);
 
 	swd->write_reg(dap, swd_cmd(false,  false, DP_ABORT),
@@ -86,7 +86,7 @@ static void swd_clear_sticky_errors(struct adiv5_dap *dap)
 
 static int swd_run_inner(struct adiv5_dap *dap)
 {
-	const struct swd_driver *swd = jtag_interface->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 
 	int retval = swd->run(dap);
 
@@ -105,7 +105,7 @@ static inline int check_sync(struct adiv5_dap *dap)
 
 static int swd_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
 {
-	const struct swd_driver *swd = jtag_interface->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 	assert(swd);
 
 	swd->write_reg(dap, swd_cmd(false,  false, DP_ABORT),
@@ -113,31 +113,28 @@ static int swd_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
 	return check_sync(dap);
 }
 
-/** Select the DP register bank matching bits 7:4 of reg. */
+/** Select the DP register bank matching bits 3:0 of reg. */
 static void swd_queue_dp_bankselect(struct adiv5_dap *dap, unsigned reg)
 {
-	uint32_t select_dp_bank = (reg & 0x000000F0) >> 4;
-
-	if (reg == DP_SELECT)
-		return;
+	/* DP bank is [3:0] */
+	reg = reg >> 0;
+	reg = reg & 0x0f;
+	dap_update_select_reg_cache( dap, -1, -1, reg );
 
-#if DAP_REG_CACHE
-	if (select_dp_bank == dap->cached_dp_bank_value)
+	if( dap->cached_select_reg_valid ){
 		return;
-#endif
+	}
+		
+	swd_queue_dp_write(dap, DP_SELECT, dap->cached_select_reg_value );
+	dap->cached_select_reg_valid = true;
 	
-	dap->cached_dp_bank_value = select_dp_bank;
-	select_dp_bank |= dap->cached_ap_port | dap->cached_ap_bank_value;
-
-	swd_queue_dp_write(dap, DP_SELECT, select_dp_bank);
 }
 
 static int swd_queue_dp_read(struct adiv5_dap *dap, unsigned reg,
 		uint32_t *data)
 {
-	struct adiv5_swd_dap *swd_dap = container_of(dap, struct adiv5_swd_dap, dap);
-	const struct swd_driver *swd = swd_dap->swd;
-	assert(swd);
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
+	assert(swd != NULL);
 
 	swd_queue_dp_bankselect(dap, reg);
 	swd->read_reg(dap, swd_cmd(true,  false, reg), data);
@@ -149,8 +146,7 @@ static int swd_queue_dp_read(struct adiv5_dap *dap, unsigned reg,
 static int swd_queue_dp_write(struct adiv5_dap *dap, unsigned reg,
 		uint32_t data)
 {
-	struct adiv5_swd_dap *swd_dap = container_of(dap, struct adiv5_swd_dap, dap);
-	const struct swd_driver *swd = swd_dap->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 	assert(swd);
 
 	swd_finish_read(dap);
@@ -163,22 +159,18 @@ static int swd_queue_dp_write(struct adiv5_dap *dap, unsigned reg,
 /** Select the AP register bank matching bits 7:4 of reg. */
 static void swd_queue_ap_bankselect(struct adiv5_dap *dap, unsigned reg)
 {
-	uint32_t select_ap_bank = reg & 0x000000F0;
-
-	if (select_ap_bank == dap->cached_ap_bank_value)
-		return;
-
-	dap->cached_ap_bank_value = select_ap_bank;
-	select_ap_bank |= dap->cached_ap_port | dap->cached_dp_bank_value;
-
-	swd_queue_dp_write(dap, DP_SELECT, select_ap_bank);
+	/* AP bank is [7:4] */
+	reg = reg >> 4;
+	reg = reg & 0x0f;
+	dap_update_select_reg_cache( dap, -1, reg, -1 );
+	
+	swd_queue_dp_write(dap, DP_SELECT, dap->cached_select_reg_value );
 }
 
 static int swd_queue_ap_read(struct adiv5_dap *dap, unsigned reg,
 		uint32_t *data)
 {
-	struct adiv5_swd_dap *swd_dap = container_of(dap, struct adiv5_swd_dap, dap);
-	const struct swd_driver *swd = swd_dap->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 	assert(swd);
 
 	swd_queue_ap_bankselect(dap, reg);
@@ -191,8 +183,7 @@ static int swd_queue_ap_read(struct adiv5_dap *dap, unsigned reg,
 static int swd_queue_ap_write(struct adiv5_dap *dap, unsigned reg,
 		uint32_t data)
 {
-	struct adiv5_swd_dap *swd_dap = container_of(dap, struct adiv5_swd_dap, dap);
-	const struct swd_driver *swd = swd_dap->swd;
+	const struct swd_driver *swd = arm_dap2swd_driver(dap);
 	assert(swd);
 
 	swd_finish_read(dap);
@@ -210,7 +201,7 @@ static int swd_run(struct adiv5_dap *dap)
 }
 
 const struct dap_ops swd_dap_ops = {
-	.is_swd = true,
+	.transport_type = ARM_DAP_TRANSPORT_SWD,
 
 	.queue_dp_read = swd_queue_dp_read,
 	.queue_dp_write = swd_queue_dp_write,
@@ -297,7 +288,7 @@ COMMAND_HANDLER(handle_swd_wcr)
 		/*retval = swd_queue_dp_read(dap, DP_WCR, &wcr); */
 		retval = dap_queue_dp_read(dap, DP_WCR, &wcr);
 		if (retval == ERROR_OK)
-			dap->ops->run(dap);
+			dap->driver.ops->run(dap);
 		if (retval != ERROR_OK) {
 			LOG_ERROR("can't read WCR?");
 			return retval;
@@ -377,40 +368,53 @@ static int swd_select(struct command_context *ctx)
 {
 	int retval;
 
+	struct target *target = get_current_target(ctx);
+	struct adiv5_dap *dap = target_cs_to_dap(target);
+	
 	retval = register_commands(ctx, NULL, swd_handlers);
 
 	if (retval != ERROR_OK)
 		return retval;
 
-	struct target *target = get_current_target(ctx);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm_to_dap(arm);
-	struct adiv5_swd_dap *swd_dap = container_of(dap, struct adiv5_swd_dap, dap);
-	const struct swd_driver *swd = swd_dap->swd;
+	retval = arm_dap_change_transport( dap, ARM_DAP_TRANSPORT_SWD );
+	return retval;
+}
+
+/* this is called by the upper level management code in different ways
+ * First: (is_set!=0) Is when we are moving *FROM* swd to something else
+ * Second: Occurs when SWD is choosen.
+ * 
+ * 
+ */
+int arm_dap_transport_change_SWD( struct adiv5_dap *dap, int is_set )
+{
+	int retval;
+	const struct swd_driver *swd;
+
+	if( !is_set ){
+		/* we do not care about the "go-away" or unset condition */
+		return ERROR_OK;
+	} else {
+		/* we only have work to do when SWD is selected */
+	}
+	
+	/* QUESTION: Does jtag interface support swd? */
+	swd = jtag_interface->swd;
 
 	 /* be sure driver is in SWD mode; start
 	  * with hardware default TRN (1), it can be changed later
 	  */
 	if (!swd || !swd->read_reg || !swd->write_reg || !swd->init) {
-		LOG_DEBUG("no SWD driver?");
+		LOG_DEBUG("selected Interface does not support SWD!");
 		return ERROR_FAIL;
 	}
 
+	dap->driver.swd_driver = swd;
+
+	/* tell the swd engine to go */
 	retval = swd->init();
 	if (retval != ERROR_OK) {
 		LOG_DEBUG("can't init SWD driver");
-		return retval;
-	}
-
-	global_dap = adiv5_swd_dap_new(swd);
-
-	/* force DAP into SWD mode (not JTAG) */
-	/*retval = dap_to_swd(target);*/
-
-	if (ctx->current_target) {
-		/* force DAP into SWD mode (not JTAG) */
-		target = get_current_target(ctx);
-		retval = dap_to_swd(target);
 	}
 
 	return retval;
@@ -419,8 +423,7 @@ static int swd_select(struct command_context *ctx)
 static int swd_init(struct command_context *ctx)
 {
 	struct target *target = get_current_target(ctx);
-	struct arm *arm = target_to_arm(target);
-	struct adiv5_dap *dap = arm_to_dap(arm);
+	struct adiv5_dap *dap = target_cs_to_dap(target);
 	uint32_t idcode;
 	int status;
 
@@ -458,28 +461,8 @@ static void swd_constructor(void)
 	transport_register(&swd_transport);
 }
 
-/** Returns true if the current debug session
- * is using SWD as its transport.
- */
 bool transport_is_swd(void)
 {
 	return get_current_transport() == &swd_transport;
 }
 
-void adiv5_swd_dap_create(struct adiv5_swd_dap *swd_dap, const struct swd_driver *swd)
-{
-	/* TODO: Maybe create the super class, i.e. adiv5_dap_create(&swd_dap->dap); */
-	swd_dap->dap.ops = &swd_dap_ops;
-	swd_dap->swd = swd;
-}
-
-struct adiv5_dap *adiv5_swd_dap_new(const struct swd_driver *swd)
-{
-	struct adiv5_swd_dap *swd_dap = calloc(1, sizeof(*swd_dap));
-	if (swd_dap == NULL)
-		return NULL;
-
-	adiv5_swd_dap_create(swd_dap, swd);
-	adiv5_dap_init_common( &(swd_dap->dap) );
-	return &swd_dap->dap;
-}
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index b3343f9..9f859fd 100755
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -78,34 +78,120 @@
 #include "arm_adi_v5.h"
 #include <helper/time_support.h>
 
-struct adiv5_dap *global_dap;
+struct adiv5_dap *all_daps;
 jim_wide dap_debug_flags;
 
+	
 
-/***************************************************************************
- *                                                                         *
- * DP and MEM-AP  register access  through APACC and DPACC                 *
- *                                                                         *
-***************************************************************************/
 
-void dap_invalidate_port_cache( struct adiv5_dap *dap )
+void dap_update_select_reg_cache( struct adiv5_dap *dap, int apsel, int apbanksel, int dpbanksel )
 {
-	struct adiv5_dap_port *p;
+	uint32_t v;
+	
+	if( (apsel < 0) || (apsel > 255) ){
+		v = dap->cached_select_reg_value;
+		v = v >> 24;
+		apsel = ((int)v);
+	}
 
-	p = dap_current_port( dap );
-	if( p == NULL ){
-		/* maybe the AP CURRENT is invalid */
-		/* like set to -1? to make it invalid */
-		return;
+	if( (apbanksel < 0) || (apbanksel > 15) ){
+		v = dap->cached_select_reg_value;
+		v = v >> 4;
+		v = v & 0x0f;
+		apbanksel = ((int)v);
+	}
+
+	if( (dpbanksel < 0) || (dpbanksel > 15) ){
+		v = dap->cached_select_reg_value;
+		v = v >> 0;
+		v = v & 0x0f;
+		dpbanksel = ((int)(v));
+	}
+
+	/* build the new value */
+	v = apsel;
+	v = v << 24;
+	v = v | (apbanksel << 4);
+	v = v | (dpbanksel << 0);
+
+	/* did the value change? */
+	if( dap->cached_select_reg_value != v ){
+		/* then mark for update */
+		dap->cached_select_reg_valid = 0;
+	}
+	dap->cached_select_reg_value = v;
+}	
+
+int arm_dap_is_swd( struct adiv5_dap *dap )
+{
+	if( dap->driver.ops == NULL ){
+		return 0;
+	}
+
+	if( dap->driver.ops->transport_type == ARM_DAP_TRANSPORT_SWD ){
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+int arm_dap_change_transport( struct adiv5_dap *dap, int new_id )
+{
+	int old_id;
+	int e;
+
+	old_id = ARM_DAP_TRANSPORT_unknown;
+	if( dap->driver.ops ){
+		old_id = dap->driver.ops->transport_type;
+		if( old_id == new_id ){
+			return ERROR_OK;
+		}
 	}
 
-	p->cached_tar_valid = false;
-	p->cached_tar_reg   = (uint64_t)(-1);
-	p->cached_csw_reg   = (uint32_t)(-1);
-	p->cached_csw_valid = false;
+	e = ERROR_OK;
+	switch(old_id){
+	default:
+	case ARM_DAP_TRANSPORT_unknown:
+		/* Nothing to do */
+		break;
+	case ARM_DAP_TRANSPORT_SWD:
+		e = arm_dap_transport_change_SWD(dap, 0 );
+		break;
+		
+	case ARM_DAP_TRANSPORT_JTAG:
+		e = arm_dap_transport_change_JTAG(dap, 0 );
+		break;
+	}
+
+	if( e != ERROR_OK ){
+		return e;
+	}
+	dap->driver.ops = NULL;
+
+	switch(new_id){
+	default:
+		/* should not happen */
+		break;
+	case ARM_DAP_TRANSPORT_SWD:
+		e = arm_dap_transport_change_SWD(dap, 1 );
+		break;
+		
+	case ARM_DAP_TRANSPORT_JTAG:
+		e = arm_dap_transport_change_JTAG(dap, 1 );
+		break;
+	}
+	return e;
 }
 
 
+/***************************************************************************
+ *                                                                         *
+ * DP and MEM-AP  register access  through APACC and DPACC                 *
+ *                                                                         *
+ **************************************************************************/
+
+
+
 int target_addr_to_dap_port( const struct target_addr *pAddr )
 {
 	int r;
@@ -143,11 +229,12 @@ static int dap_ap_read( struct adiv5_dap *dap, int reg, uint32_t *val )
 /* Returns pointer to current dap port, or null if not valid */
 struct adiv5_dap_port *dap_current_port( struct adiv5_dap *dap )
 {
-  if( (dap->cached_ap_port < 0) || (dap->cached_ap_port > 255) ){
-    return NULL;
-  }
+	uint32_t v;
+	v = dap->cached_select_reg_valid;
+	v = v >> 24;
+	v = v & 0x0ff;
 
-  return &(dap->port[ dap->cached_ap_port ]);
+	return &(dap->port[ v ]);
 }
 
 /**
@@ -161,25 +248,16 @@ struct adiv5_dap_port *dap_current_port( struct adiv5_dap *dap )
  */
 void dap_ap_select(struct adiv5_dap *dap, int ap )
 {
-	if( (ap < 0) || (ap > 255) ){
-		LOG_ERROR("dap: invalid PORT %d", ap );
-		return;
-	}
+	struct adiv5_dap_port *p;
+	dap_update_select_reg_cache( dap, ap, -1, -1 );
 
-#if DAP_REG_CACHE	
-	if ( ap == dap->cached_ap_port) {
-		if( dap_debug_flag(DAP_DBG_AP_IO) ){
-			LOG_DEBUG("select-ap = %d cached\n", ap );
-		}
-		return;
-	}
-	if( dap_debug_flag(DAP_DBG_AP_IO) ){
-		LOG_DEBUG("select-ap = %d *new*\n", ap );
+	p = dap_current_port( dap );
+	if( p ){
+		p->cached_tar_valid = false;
+		p->cached_tar_reg   = (uint64_t)(-1);
+		p->cached_csw_reg   = (uint32_t)(-1);
+		p->cached_csw_valid = false;
 	}
-#endif
-	dap->cached_ap_port = ap;
-	/* invalidate where we are now */
-	dap_invalidate_port_cache( dap );
 }
 
 static int dap_setup_accessport_csw(struct adiv5_dap *dap, uint32_t csw, const struct target_addr *pAddr)
@@ -841,8 +919,11 @@ int mem_ap_write_u32(struct adiv5_dap *dap, const struct target_addr *pAddr, uin
 int mem_ap_write_u64(struct adiv5_dap *dap, const struct target_addr *pAddr, uint64_t value)
 {
 	int retval;
+	struct adiv5_dap_port *port;
 
-	if( !dap->port[ dap->cached_ap_port ].data_64bit ){
+	port = dap_current_port( dap );
+
+	if( !(port->data_64bit) ){
 		LOG_ERROR("target port does not support 64bit data transfers");
 		return ERROR_TARGET_UNALIGNED_ACCESS;
 	}
@@ -1405,9 +1486,8 @@ int dap_debugport_init(struct adiv5_dap *dap)
 	LOG_DEBUG(" ");
 
 	dap->port_types_done = false;	
-	/* invalidate what we know about the dap */
-	dap->cached_ap_port       = -1;
-	dap->cached_dp_bank_value = -1;
+	dap->cached_select_reg_value = 0;
+	dap->cached_select_reg_valid = false;
 	
 	
 	/* Default MEM-AP setup.
@@ -2465,12 +2545,113 @@ COMMAND_HANDLER(dap_ti_be_32_quirks_command)
 }
 
 
+#define DAP_MAGIC_NUMBER (('D' << 24) + ('a' << 16) + ('P'<<8) + ('!'<<0))
+
+
+struct adiv5_dap *arm_dap_find( const char *name )
+{
+	struct adiv5_dap *p;
+
+	p = all_daps;
+	while(p){
+		if( 0 == strcmp(name,p->name) ){
+			break;
+		}
+		p = p->next_dap;
+	}
+	/* return null or a pointer to the dap */
+	return p;
+}
+
+struct adiv5_dap *arm_dap_new( const char *name, int transport )
+{
+	struct adiv5_dap *dap;
+
+	dap = calloc( 1, sizeof(*dap) );
+	/* Just return null on error */
+	if( !dap ){
+		LOG_ERROR("no memory for new dap!");
+		return dap;
+	}
+	/*
+	 * Today: calloc() is mostly sufficent :-)
+	 * This will change in the future!
+	 */
+	dap->name = strdup( name );
+	if( dap->name == NULL ){
+		free((void *)(dap));
+		dap = NULL;
+		LOG_ERROR("no memory for new dap!");
+		return dap;
+	}
+
+	dap->dap_magic_number = DAP_MAGIC_NUMBER;
+	dap->next_dap = all_daps;
+	all_daps = dap;
+	
+	/* DO NOT USE ANYTHING OTEHR THEN 1K here
+	 *
+	 * Per ARM -  There is no standard way to determine 
+	 * the proper size - it is implimentation defined.
+	 *
+	 * The target init script can override this
+	 * Even if the target does support 4K pages
+	 *
+	 * Incrementally we are talking about very simple TAR register writes
+	 * during the overall bulk write process.
+	 * 
+	 */
+	dap->tar_autoincr_block = (1 << 10);
+	
+	dap_dbg_init(dap);
+	arm_dap_change_transport( dap, transport );
+	return dap;
+}
 
-void adiv5_dap_init_common( struct adiv5_dap *dap )
+void arm_dap_magic_check( struct adiv5_dap *dap )
 {
-	dap_dbg_init(dap );
+	if( dap->dap_magic_number == DAP_MAGIC_NUMBER ){
+		return;
+	}
+	/* FIXME: We need a LOG_FATAL() */
+	LOG_ERROR("BAD ARM DAP MAGIC!");
 }
 
+static int jim_dap_csyspwrupreq(Jim_Interp *_interp, int _argc, Jim_Obj * const *_argv )
+{
+	int e;
+	Jim_GetOptInfo goi;
+	int b;
+	struct adiv5_dap *dap;
+
+	Jim_GetOpt_Setup( &goi, _interp, _argc-1, _argv+1 );
+
+	if( goi.argc > 1 ){
+		Jim_WrongNumArgs( goi.interp, 1, _argv, "[boolean]");
+		return JIM_ERR;
+	}
+
+	/* FIXME: We could have more then 1 dap! */
+	/* Meanwhile, we take the *current* target dap */
+	{
+		struct command_context *context;
+		struct target *target;
+		context = current_command_context(goi.interp);	
+		target = get_current_target(context);
+		dap = target_cs_to_dap(target);
+	}
+	
+	if( goi.argc == 1 ){
+		e = Jim_GetOpt_Bool( &goi, &b );
+		if( e != JIM_OK ){
+			return e;
+		}
+		dap->ignore_csyspwrupreq = b;		
+	}
+	Jim_SetResultBool( goi.interp, dap->ignore_csyspwrupreq );
+	return JIM_OK;
+}
+	
 struct dap_rdwr {
 	Jim_GetOptInfo goi;
 	int      is_wr;
@@ -2801,6 +2982,13 @@ static const struct command_registration dap_commands[] = {
 		.usage = "[ap_num]",
 	},
 	{
+		.name = "ignore_csyspwrupreq",
+		.jim_handler = jim_dap_csyspwrupreq,
+		.mode = COMMAND_EXEC,
+		.help = "ignore dap csyspwrup timeout errors",
+		.usage = "[true|false]"
+	},
+	{
 		.name = "force_port_cfg",
 		.jim_handler = jim_dap_force_cfg,
 		.mode = COMMAND_EXEC,
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index bd480a4..5158984 100755
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -147,7 +147,11 @@ struct coresight_settings;
  * signals are available).
  */
 struct adiv5_dap {
-	const struct dap_ops *ops;
+	const char *dap_name;
+	struct adiv5_dap  *next_dap;
+	/* set by arm_adi_new_dap */
+	uint32_t dap_magic_number;
+
 	int ops_dirty;
 	int ops_last_result;
 	/* there may be more then one dap, each dap has a name */
@@ -156,6 +160,7 @@ struct adiv5_dap {
 	struct dap_debug_info dbg;
 	/* Control config */
 	uint32_t dp_ctrl_stat;
+	bool     ignore_csyspwrupreq;
 
 
 	/* this is the ap port the user has selected */
@@ -248,28 +253,14 @@ struct adiv5_dap {
 		
 	} port[ 256 ];
 	
-	/**
-	 * Cache for DP_SELECT bits identifying the current AP.  A DAP may
-	 * connect to multiple APs, such as one MEM-AP for general access,
-	 * another reserved for accessing debug modules, and a JTAG-DP.
-	 * "-1" indicates no cached value.
-	 */
-	int cached_ap_port;
-	/**
-	 * Cache for DP_SELECT bits identifying the current four-word AP
-	 * register bank.  This caches AP register addresss bits 7:4; JTAG
-	 * and SWD access primitves pass address bits 3:2; bits 1:0 are zero.
-	 * "-1" indicates no cached value.
-	 */
-	uint32_t cached_ap_bank_value;
-
-	/**
-	 * Cache for DP_SELECT bits identifying the current four-word DP
-	 * register bank.  This caches DP register addresss bits 7:4; JTAG
-	 * and SWD access primitves pass address bits 3:2; bits 1:0 are zero.
+	
+	/** This represents the current content of the DAP select register.
+	 * See: ARM IHI0031B - Page 67 of 256
+	 * Section: 3.3.9 ELECT, AP Select Register
 	 */
-	uint32_t cached_dp_bank_value;
-
+	uint32_t cached_select_reg_value;
+	int      cached_select_reg_valid;
+	
 
 	/* information about current pending SWjDP-AHBAP transaction */
 	uint8_t  ack;
@@ -292,8 +283,16 @@ struct adiv5_dap {
 	 * swizzle appropriately. */
 	/* FIXME: This is not a feature of the DAP, it's specific to the MEM-AP used. */
 	bool ti_be_32_quirks;
+
+	/* for use by the underlying driver */
+	struct adiv5_dap_driver {
+		const struct swd_driver *swd_driver;
+		struct jtag_tap   *jtag_tap;
+		const struct dap_ops *ops;
+	} driver;
 };
 
+
 /**
  * Transport-neutral representation of queued DAP transactions, supporting
  * both JTAG and SWD transports.  All submitted transactions are logically
@@ -302,10 +301,8 @@ struct adiv5_dap {
  * available until run().
  */
 struct dap_ops {
-	/** If the DAP transport isn't SWD, it must be JTAG.  Upper level
-	 * code may need to care about the difference in some cases.
-	 */
-	bool	is_swd;
+	/** there can be other transports other then swd and jtag */
+	int transport_type;
 
 	/** DP register read. */
 	int (*queue_dp_read)(struct adiv5_dap *dap, unsigned reg,
@@ -525,12 +522,18 @@ int dap_to_swd(struct target *target);
 /* Put debug link into JTAG mode */
 int dap_to_jtag(struct target *target);
 
-extern struct adiv5_dap *global_dap;
-
 struct swd_driver;
-struct adiv5_dap *adiv5_jtag_dap_new(struct jtag_tap *tap);
-struct adiv5_dap *adiv5_swd_dap_new(const struct swd_driver *swd);
-void adiv5_dap_init_common( struct adiv5_dap *dap );
+/** Allocate and initialize a new DAP, add it to the chain of all daps */
+struct adiv5_dap *arm_dap_find( const char *jtag_tap_name );
+struct adiv5_dap *arm_dap_new( const char *name, int transport );
+void              arm_dap_magic_check( struct adiv5_dap *dap );
+#define ARM_DAP_TRANSPORT_unknown 0
+#define ARM_DAP_TRANSPORT_SWD     'S'
+#define ARM_DAP_TRANSPORT_JTAG    'J'
+int arm_dap_change_transport( struct adiv5_dap *dap, int newtransport );
+int arm_dap_transport_change_JTAG( struct adiv5_dap *dap, int is_set );
+int arm_dap_transport_change_SWD( struct adiv5_dap *dap, int is_set );
+
 
 extern const struct command_registration dap_command_handlers[];
 
@@ -760,7 +763,7 @@ int target_cs_dbg_wr_bulk_noinc( struct target *target,
 			   size_t item_count,
 			   const void   *buffer );
 
-void target_cs_connect_dap( struct target *target, struct adiv5_dap *dap);
+int target_cs_connect_dap( struct target *target);
 
 
 int target_cs_dap_run(struct target *target);
@@ -783,5 +786,18 @@ extern jim_wide dap_debug_flags;
 #define DAP_DBG_CORESIGHT_IO  _debugFlagN(4)
 #define DAP_DBG_any_IO   (DAP_DBG_AP_IO|DAP_DBG_DP_IO|DAP_DBG_MEM_AP_IO)
 
+/* update the DAP select register cache
+ * To change a specific field pass >= 0
+ * To ignore (skip) a field pass -1
+ *
+ * Example:
+ *   To change the APSEL port number
+ * \code
+ *   dap_update_select_cache( dap, newvalue, -1, -1 );
+ * \endcode
+ */
+void dap_update_select_reg_cache( struct adiv5_dap *dap, int apsel, int apbanksel, int dpbanksel );
+
+int arm_dap_is_swd( struct adiv5_dap *dap );
 
 #endif
diff --git a/src/target/arm_adi_v5_debug.c b/src/target/arm_adi_v5_debug.c
index 09fe3be..5624797 100644
--- a/src/target/arm_adi_v5_debug.c
+++ b/src/target/arm_adi_v5_debug.c
@@ -24,12 +24,14 @@ static const struct dap_coresight_namelist *
 dap_find_namelist( struct adiv5_dap *dap )
 {
 	int portnum;
+	struct adiv5_dap_port *port;
 	const struct dap_coresight_namelist *nl;
 
-	portnum = dap->cached_ap_port;
-	if( (portnum < 0) || (portnum >255) ){
+	port = dap_current_port( dap );
+	if( port == NULL ){
 		return NULL;
 	}
+	portnum = port->port_num;
 	
 	nl = dap->dbg.namelist;
 	/* MOST chips have a *SINGLE* dap debug port 
@@ -387,40 +389,40 @@ void dap_dbg_log_dump( struct adiv5_dap *dap )
 
 int dap_queue_dp_read(struct adiv5_dap *dap, unsigned reg, uint32_t *data)
 {
-	assert(dap->ops != NULL);
+	assert(dap->driver.ops != NULL);
 	if( dap_debug(DAP_DBG_DP_IO) ){
 		struct dap_access_log *p;
 		p = dap_dbg_log_entry(dap);
 		if( p ){
 			p->access_type = DAP_DP_RD;
-			p->reg_name = dap_dp_reg_name( reg, 0, dap->ops->is_swd );
+			p->reg_name = dap_dp_reg_name( reg, 0, arm_dap_is_swd(dap) );
 			p->pointer = data;
 			p->bytelen = 4;
 		}
 	}
-	return dap->ops->queue_dp_read(dap, reg, data);
+	return dap->driver.ops->queue_dp_read(dap, reg, data);
 }
 
 
 int dap_queue_dp_write(struct adiv5_dap *dap, unsigned reg, uint32_t data)
 {
-	assert(dap->ops != NULL);
+	assert(dap->driver.ops != NULL);
 	if( dap_debug(DAP_DBG_DP_IO) ){
 		struct dap_access_log *p;
 		p = dap_dbg_log_entry(dap);
 		if( p ){
 			p->access_type = DAP_DP_WR;
-			p->reg_name = dap_dp_reg_name( reg, 1, dap->ops->is_swd );
+			p->reg_name = dap_dp_reg_name( reg, 1, arm_dap_is_swd(dap) );
 			p->dataval = data;
 			p->bytelen = 4;
 		}
 	}
-	return dap->ops->queue_dp_write(dap, reg, data);
+	return dap->driver.ops->queue_dp_write(dap, reg, data);
 }
 
 int dap_queue_ap_read(struct adiv5_dap *dap, unsigned reg, uint32_t *data)
 {
-	assert(dap->ops != NULL);
+	assert(dap->driver.ops != NULL);
 	if( dap_debug(DAP_DBG_AP_IO) ){
 		struct dap_access_log *p;
 		p = dap_dbg_log_entry(dap);
@@ -431,12 +433,12 @@ int dap_queue_ap_read(struct adiv5_dap *dap, unsigned reg, uint32_t *data)
 			p->bytelen = 4;
 		}
 	}
-	return dap->ops->queue_ap_read(dap, reg, data);
+	return dap->driver.ops->queue_ap_read(dap, reg, data);
 }
 
 int dap_queue_ap_write(struct adiv5_dap *dap, unsigned reg, uint32_t data)
 {
-	assert(dap->ops != NULL);
+	assert(dap->driver.ops != NULL);
 	if( dap_debug(DAP_DBG_AP_IO) ){
 		struct dap_access_log *p;
 		p = dap_dbg_log_entry(dap);
@@ -447,12 +449,12 @@ int dap_queue_ap_write(struct adiv5_dap *dap, unsigned reg, uint32_t data)
 			p->bytelen = 4;
 		}
 	}
-	return dap->ops->queue_ap_write(dap, reg, data);
+	return dap->driver.ops->queue_ap_write(dap, reg, data);
 }
 
 int dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
 {
-	assert(dap->ops != NULL);
+	assert(dap->driver.ops != NULL);
 	if( dap_debug( DAP_DBG_any_IO ) ){
 		struct dap_access_log *p;
 		p = dap_dbg_log_entry(dap);
@@ -463,14 +465,14 @@ int dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
 			p->bytelen = 1;
 		}
 	}
-	return dap->ops->queue_ap_abort(dap, ack);
+	return dap->driver.ops->queue_ap_abort(dap, ack);
 }
 
 int dap_run(struct adiv5_dap *dap)
 {
 	int r;
-	assert(dap->ops != NULL);
-	r = dap->ops->run(dap);
+	assert(dap->driver.ops != NULL);
+	r = dap->driver.ops->run(dap);
 	dap_dbg_log_dump( dap );
 	return r;
 }
diff --git a/src/target/coresight_io.c b/src/target/coresight_io.c
index 73ff686..14311a3 100644
--- a/src/target/coresight_io.c
+++ b/src/target/coresight_io.c
@@ -131,26 +131,22 @@ struct coresight_settings *target_to_coresight( struct target *t )
 	return t->HIDE_coresight;
 }
 
-void target_cs_connect_dap( struct target *target, struct adiv5_dap *dap)
+int target_cs_connect_dap( struct target *target)
 {
 	struct coresight_settings *cs;
-	/* DO NOT USE ANYTHING OTEHR THEN 1K here
-	 *
-	 * Per ARM -  There is no standard way to determine 
-	 * the proper size - it is implimentation defined.
-	 *
-	 * The target init script can override this
-	 * Even if the target does support 4K pages
-	 *
-	 * Incrementally we are talking about very simple TAR register writes
-	 * during the overall bulk write process.
-	 * 
-	 */
-	dap->tar_autoincr_block = (1 << 10);
-
+	struct adiv5_dap *dap;
+	
+	/* does this dap exist? */
+	dap = arm_dap_find( target->tap->tapname );
+	if( dap == NULL ){
+		dap = arm_dap_new( target->tap->tapname, ARM_DAP_TRANSPORT_JTAG );
+		dap->driver.jtag_tap = target->tap;
+	}
+	
 	cs = target_to_coresight( target );
 	
 	cs->HIDE_dap = dap;
+	return ERROR_OK;
 }
 
 int target_cs_dap_run(struct target *target)
diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index 5f5fd3f..cfc6cde 100755
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -2454,11 +2454,7 @@ static int cortex_a_target_create(struct target *target, Jim_Interp *interp)
 	cortex_a->HIDE_armv7a_common.is_armv7r = false;
 	cortex_a_init_arch_info(target, cortex_a);
 
-	/* If it's not set, assume transport select is not swd. Nothing sets up the JTAG DAP so we have to. */
-	if (!global_dap)
-		global_dap = adiv5_jtag_dap_new(target->tap);
-
-	target_cs_connect_dap(target, global_dap);
+	target_cs_connect_dap(target);
  
 	return ERROR_OK;
 }
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index d237b9d..cf44512 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -573,40 +573,73 @@ static int cortex_a53_exec_opcode(struct target *target,
 	}
 
     //override opcode. SQU TODO: instead of hack here, might need to change to caller to use right opcode for right state
-	if(opcode==0xE12FF000)
-	{//in case of ARMV4_5_MSR(0, 0) for setting CPSR
+	if(opcode==0xE12FF000){
+		/* Move CPSR to R0.
+		**
+		** ARM DDI 0100I - Section A3.1
+		** Figure A3-1 ARM instruction set summary
+		** 
+		** 0xE12F => [1110][0001][0010][1111]
+		** 0xF000 => [1111][0000][0000][0000] 
+		**
+		** Bits[31:28] = 1110 => Always
+		** Bits[27:25] =  000 = Misc Instruction
+		** Bits[24:23] =   10 = Misc Instruction
+		** Bits[   20] =    0 = "S" = 0, Misc Instruction 
+		** Bits[    4] =    0 = Misc Instruction
+		**--------------------------------------
+		** Now, look at: Figure A3-4 Miscellaneous instructions
+		**--------------------------------------
+		** Bits [   22] = (R) = 0
+		** Bits [21:20] = 10
+		** Bits [19:16] = Mask(0xf)
+		** Bits [15:12] = SBO (should be 1), 0x0f
+		** Bits [11:00] = 0
+		** Bits [03:00] = Destination Register.
+		** 
+		**/
+		//in case of ARMV4_5_MSR(0, 0) for setting CPSR
 		//LOG_DEBUG("SQU: ARMv8: set CPSR");
-		if(isAArch64(dscr)) opcode=ARMV8_A64_MSR(3, 3, 4, 5, 0, 0); //MSR DSPSR_EL0, R0
-        else opcode=ARMV8_T32_MCR(15, 3, 0, 4, 5, 0);
+		if(isAArch64(dscr))
+			opcode=ARMV8_A64_MSR(3, 3, 4, 5, 0, 0); //MSR DSPSR_EL0, R0
+        else
+			opcode=ARMV8_T32_MCR(15, 3, 0, 4, 5, 0);
 	}
-	else if(opcode==0xE1A0F000)
-	{//in case of MOV pc, r0
+	else if(opcode==0xE1A0F000){
+		//in case of MOV pc, r0
 		//LOG_DEBUG("SQU: ARMv8: set pc ");
-        if(isAArch64(dscr)) opcode=ARMV8_A64_MSR(3, 3, 4, 5, 1, 0); //MSR DLR_EL0, R0
-        else opcode=ARMV8_T32_MCR(15, 3, 0, 4, 5, 1);
+        if(isAArch64(dscr))
+			opcode=ARMV8_A64_MSR(3, 3, 4, 5, 1, 0); //MSR DLR_EL0, R0
+        else
+			opcode=ARMV8_T32_MCR(15, 3, 0, 4, 5, 1);
 	}
-	else if(opcode==0xE10F0000)
-	{//in case of ARMV4_5_MRS(0, 0) for reading CPSR
+	else if(opcode==0xE10F0000){
+		//in case of ARMV4_5_MRS(0, 0) for reading CPSR
 		//LOG_DEBUG("SQU: ARMv8: read CPSR");
-		if(isAArch64(dscr)) opcode=ARMV8_A64_MRS(3, 3, 4, 5, 0, 0); //MRS R0, DSPSR_EL0
-        else opcode=ARMV8_T32_MRC(15, 3, 0, 4, 5, 0); //change to read DSPSR
+		if(isAArch64(dscr))
+			opcode=ARMV8_A64_MRS(3, 3, 4, 5, 0, 0); //MRS R0, DSPSR_EL0
+        else
+			opcode=ARMV8_T32_MRC(15, 3, 0, 4, 5, 0); //change to read DSPSR
 	}
-	else if(opcode==0xF3F28030)
-	{//in case of MRS r0, spsr
+	else if(opcode==0xF3F28030){
+		//in case of MRS r0, spsr
 		LOG_DEBUG("ARMv8: read spsr");
         opcode = (opcode>>16) | (opcode<<16);
  	}
-	else if(opcode==0xE1A0000F)
-	{//in case of MOV r0, pc
+	else if(opcode==0xE1A0000F){
+		//in case of MOV r0, pc
 		//LOG_DEBUG("SQU: ARMv8: read pc");
-        if(isAArch64(dscr)) opcode=ARMV8_A64_MRS(3, 3, 4, 5, 1, 0); //MRS R0, DLR_EL0
-        else opcode=ARMV8_T32_MRC(15, 3, 0, 4, 5, 1); //change to read DLR
+        if(isAArch64(dscr))
+			opcode=ARMV8_A64_MRS(3, 3, 4, 5, 1, 0); //MRS R0, DLR_EL0
+        else
+			opcode=ARMV8_T32_MRC(15, 3, 0, 4, 5, 1); //change to read DLR
  	}
     else if((opcode&0xFF000000)==0xEE000000) //MRC/MCR
     {
-        //LOG_DEBUG("SQU: MCR/MRC L=%d cp=%d op1=%d CRn=%d CRm=%d op2=%d Rt=%d", (opcode&0x100000)>>20, (opcode&0xF00)>>8, (opcode&0xE00000)>>21, (opcode&0xF0000)>>16, opcode&0xF,(opcode&0xE0)>>5,(opcode&0xF000)>>12);
+        //LOG_DEBUG("SQU: MCR/MRC L=%d cp=%d op1=%d CRn=%d CRm=%d op2=%d Rt=%d",
+		// (opcode&0x100000)>>20, (opcode&0xF00)>>8, (opcode&0xE00000)>>21,
+		// (opcode&0xF0000)>>16, opcode&0xF,(opcode&0xE0)>>5,(opcode&0xF000)>>12);
         if(isAArch64(dscr)) //convert MCR/MRC to MSR/MRS
-//    	if(target->is_64b)
         {
             switch (opcode & 0xEF0FFF)
         	{
@@ -2335,7 +2368,7 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 		return retval;
 
 	/* This algorithm comes from either :
-	 * Cortex-A8 TRM Example 12-25
+	 * Cortex-A8 TRM (DDI0344K) Example 12-25
 	 * Cortex-R4 TRM Example 11-26
 	 * (slight differences)
 	 */
@@ -3102,11 +3135,7 @@ static int cortex_a53_target_create(struct target *target, Jim_Interp *interp)
 
 	cortex_a53_init_arch_info(target, cortex_a);
 
-    /* If it's not set, assume transport select is not swd. Nothing sets up the JTAG DAP so we have to. */
-	if (!global_dap)
-		global_dap = adiv5_jtag_dap_new(target->tap);
-
-	target_cs_connect_dap(target, global_dap);
+	target_cs_connect_dap(target);
 
     return ERROR_OK;
 }
diff --git a/src/target/cortex_m.c b/src/target/cortex_m.c
index 072f3fc..7fe6fde 100755
--- a/src/target/cortex_m.c
+++ b/src/target/cortex_m.c
@@ -2003,11 +2003,7 @@ static int cortex_m_target_create(struct target *target, Jim_Interp *interp)
 	cortex_m->common_cortex_m_magic = CORTEX_M_COMMON_MAGIC;
 	cortex_m_init_arch_info(target, cortex_m);
 
-	/* If it's not set, assume transport select is not swd. Nothing sets up the JTAG DAP so we have to. */
-	if (!global_dap)
-		global_dap = adiv5_jtag_dap_new(target->tap);
-
-	target_cs_connect_dap(target, global_dap);
+	target_cs_connect_dap(target);
 
 	return ERROR_OK;
 }
-- 
1.9.1


From b3b91a27a4911a74794b696494d4b1bc8388d1ec Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 69/94] Add ackptr to debug struct for later use

---
 src/target/arm_adi_v5_debug.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/target/arm_adi_v5_debug.h b/src/target/arm_adi_v5_debug.h
index 0384671..9239af3 100644
--- a/src/target/arm_adi_v5_debug.h
+++ b/src/target/arm_adi_v5_debug.h
@@ -21,6 +21,7 @@ struct dap_access_log {
 	uint64_t address;    /* what address is being rd/wr */
 	uint64_t bytelen;    /* if applicable how many bytes */
 	void     *pointer;   /* memory pointer rd/wr bulk and all reads */
+	uint8_t  *ackptr;
 	int      tar_inc;    /* applicable to bulk IO */
 };
 
-- 
1.9.1


From 2334338bd5cc892c7ef3b87e1739aaa407c11ddc Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 70/94] fix log message for bulk io

---
 src/target/arm_adi_v5_debug.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/src/target/arm_adi_v5_debug.c b/src/target/arm_adi_v5_debug.c
index 5624797..8fb6898 100644
--- a/src/target/arm_adi_v5_debug.c
+++ b/src/target/arm_adi_v5_debug.c
@@ -378,7 +378,7 @@ void dap_dbg_log_dump( struct adiv5_dap *dap )
 					   reg_name,
 					   p->address,
 					   p->tar_inc,
-					   p->dataval );
+					   p->bytelen );
 			break;
 		}
 	}
@@ -463,6 +463,7 @@ int dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack)
 			p->reg_name = "abort";
 			p->pointer = ack;
 			p->bytelen = 1;
+			p->ackptr  = ack;
 		}
 	}
 	return dap->driver.ops->queue_ap_abort(dap, ack);
-- 
1.9.1


From c1171be49d2df3f0b706f26ce96e6670c24e8a89 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 71/94] Add swd response and another debug flag

---
 src/target/arm_adi_v5.h | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 5158984..8c553d2 100755
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -50,6 +50,7 @@ struct coresight_settings;
 #define SWD_ACK_OK    0x1
 #define SWD_ACK_WAIT  0x2
 #define SWD_ACK_FAULT 0x4
+#define SWD_ACK_NORESPONSE 0x07
 
 #define DPAP_WRITE		0
 #define DPAP_READ		1
@@ -784,7 +785,8 @@ extern jim_wide dap_debug_flags;
 #define DAP_DBG_DP_IO         _debugFlagN(1)
 #define DAP_DBG_MEM_AP_IO     _debugFlagN(3)
 #define DAP_DBG_CORESIGHT_IO  _debugFlagN(4)
-#define DAP_DBG_any_IO   (DAP_DBG_AP_IO|DAP_DBG_DP_IO|DAP_DBG_MEM_AP_IO)
+#define DAP_DBG_JTAG_IO       _debugFlagN(5)
+#define DAP_DBG_any_IO   (DAP_DBG_AP_IO|DAP_DBG_DP_IO|DAP_DBG_MEM_AP_IO|DAP_DBG_JTAG_IO)
 
 /* update the DAP select register cache
  * To change a specific field pass >= 0
-- 
1.9.1


From 470b6f6834af6e70313f1d14caa99ed6f862fe9f Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 72/94] Make columns lineup in log output

---
 src/helper/log.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/helper/log.c b/src/helper/log.c
index 648f2c4..992a825 100755
--- a/src/helper/log.c
+++ b/src/helper/log.c
@@ -141,7 +141,7 @@ static void log_puts(enum log_levels level,
 			struct mallinfo info;
 			info = mallinfo();
 #endif
-			fprintf(log_output, "%s%d %2d.%03d %s:%d %s()"
+			fprintf(log_output, "%s%6d %2d.%03d %s:%d %s()"
 #ifdef _DEBUG_FREE_SPACE_
 				" %d"
 #endif
-- 
1.9.1


From 25a8f7d5e5ebbb4366710b5d49d59ef918cca626 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 73/94] Add public 64bit wrappers

---
 src/target/coresight_io.c | 66 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 66 insertions(+)

diff --git a/src/target/coresight_io.c b/src/target/coresight_io.c
index 14311a3..0ca2e3f 100644
--- a/src/target/coresight_io.c
+++ b/src/target/coresight_io.c
@@ -6,6 +6,7 @@
 #include "arm.h"
 #include "arm_adi_v5.h"
 #include "target.h"
+#include "target_type.h"
 #include <helper/time_support.h>
 
 
@@ -654,3 +655,68 @@ int target_cs_mem_rd_bulk( struct target *target,  uint64_t addr,
 	return target_cs_rd_bulk( target, &a, size, count, buffer );
 }
 
+
+int target_cs_read_memory_wrapper( struct target *target, const struct target_addr *pAddr,
+							  uint64_t size, uint64_t count, uint8_t *buffer)
+{
+	struct target_addr a;
+	int r;
+	r = target_addr_resolve_route( target, pAddr, &a );
+	if( r < 0 ){
+		/* it is a CPU based address */
+		r = target->type->pIo32_legacy_api->read_memory( target, pAddr->addr, size, count, buffer );
+	} else {
+		r = target_cs_rd_bulk( target, &a, size, count, buffer );
+	}
+	return r;
+}
+
+int target_cs_write_memory_wrapper(struct target *target, const struct target_addr *pAddr,
+							   uint64_t size, uint64_t count, const uint8_t *buffer)
+{
+	struct target_addr a;
+	int r;
+	r = target_addr_resolve_route( target, pAddr, &a );
+	if( r < 0 ){
+		/* it is CPU based address */
+		r = target->type->pIo32_legacy_api->write_memory( target, pAddr->addr, size, count, buffer );
+	} else {
+		r = target_cs_wr_bulk( target, &a, size, count, buffer );
+	}
+	return r;
+}
+
+int target_cs_read_buffer_wrapper(struct target *target, const struct target_addr *pAddr,
+			uint64_t count, uint8_t *buffer)
+{
+	struct target_addr a;
+	int r;
+	r = target_addr_resolve_route( target, pAddr, &a );
+	if( r < 0 ){
+		/* it is CPU based address */
+		r = target->type->pIo32_legacy_api->read_buffer( target, pAddr->addr, count, buffer );
+	} else {
+		/* use the default read buffer code */
+		/* it will use the 'read_memory' api */
+		r = target64_read_buffer_default( target, &a, count, buffer );
+	}
+	return r;
+}
+
+int target_cs_write_buffer_wrapper(struct target *target, const struct target_addr *pAddr,
+			uint64_t count, const uint8_t *buffer)
+{
+	struct target_addr a;
+	int r;
+	r = target_addr_resolve_route( target, pAddr, &a );
+	if( r < 0 ){
+		/* it is CPU based address */
+		r = target->type->pIo32_legacy_api->write_buffer( target, pAddr->addr, count, buffer );
+	} else {
+		/* use the default read buffer code */
+		/* it will use the 'read_memory' api */
+		r = target64_write_buffer_default( target, &a, count, buffer );
+	}
+	return r;
+}
+
-- 
1.9.1


From 258758bc0d7750a089e7963cba42f9990596386c Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 74/94] Add public 64bit wrappers

---
 src/target/target_type.h | 25 +++++++++++++++++++++++++
 1 file changed, 25 insertions(+)

diff --git a/src/target/target_type.h b/src/target/target_type.h
index 7a2b82e..748c215 100755
--- a/src/target/target_type.h
+++ b/src/target/target_type.h
@@ -111,6 +111,31 @@ struct target_io32 {
 
 extern const struct target_io64 target_64_wrapper;
 
+/* these are 64 to 32 bit wrappers in the target_64_wrapper */
+/* some targets may choose to use some, and override others */
+int target64_resume_wrapper(struct target *target, int current, const struct target_addr *pAddr, int handle_breakpoints, int debug_execution);
+int target64_step_wrapper( struct target *target, int current, const struct target_addr *pAddr, int handle_breakpoints);
+int target64_read_memory_wrapper( struct target *target, const struct target_addr *pAddr, uint64_t size, uint64_t count, uint8_t *buffer);
+int target64_write_memory_wrapper(struct target *target, const struct target_addr *pAddr, uint64_t size, uint64_t count, const uint8_t *buffer);
+int target64_read_buffer_wrapper(struct target *target, const struct target_addr *pAddr, uint64_t count, uint8_t *buffer);
+int target64_write_buffer_wrapper(struct target *target, const struct target_addr *pAddr, uint64_t count, const uint8_t *buffer);
+int target64_checksum_wrapper(struct target *target, const struct target_addr *pAddr, uint64_t count, uint32_t *checksum);
+int target64_blank_check_wrapper(struct target *target, const struct target_addr *pAddr, uint64_t count, uint32_t *checksum);
+int target64_run_algo_wrapper(struct target *target, int num_mem_params, struct mem_param *mem_params, int num_reg_params, 
+						   struct reg_param *reg_param, const struct target_addr *pEntryPoint,
+						   const struct target_addr *pExitPoint, int timeout_ms, void *arch_info);
+int target64_start_algo_wrapper(struct target *target, int num_mem_params,
+			struct mem_param *mem_params, int num_reg_params,
+			struct reg_param *reg_param, const struct target_addr *pEntryPoint,
+			const struct target_addr *pExitPoint, void *arch_info);
+int target64_wait_algo_wrapper(struct target *target, int num_mem_params,
+			struct mem_param *mem_params, int num_reg_params,
+			struct reg_param *reg_param, 
+			const struct target_addr *pExitPoint, int timeout_ms, void *arch_info);
+int target64_virt2phys_wrapper( struct target *target,
+			 const struct target_addr *in_pVirt,
+			 struct target_addr *out_pPhys );
+
 struct target_io64 {
 
 	int (*resume)(struct target *target, int current, const struct target_addr *pAddr,
-- 
1.9.1


From f13cc9f2f291a813c32fe7fa5945957429155260 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 75/94] Add public 64bit wrappers AND solve issue with image
 load

---
 src/target/target.c | 67 +++++++++++++++++++++++++++--------------------------
 1 file changed, 34 insertions(+), 33 deletions(-)

diff --git a/src/target/target.c b/src/target/target.c
index fec1624..d2b2952 100755
--- a/src/target/target.c
+++ b/src/target/target.c
@@ -1919,8 +1919,8 @@ static int target_profiling_default(struct target *target, uint32_t *samples,
  */
 int target64_write_buffer(struct target *target, const struct target_addr *pAddr, uint64_t size, const uint8_t *buffer)
 {
-	LOG_DEBUG("writing buffer of %" PRIu64 " byte at 0x%" PRIx64,
-			size, pAddr->addr);
+	LOG_DEBUG("writing buffer of %" PRIu64 " byte at %s",
+			  size, target_addr2str1( target, pAddr ));
 
 	if (!target_was_examined(target)) {
 		LOG_ERROR("Target not examined yet");
@@ -3103,7 +3103,6 @@ static COMMAND_HELPER(parse_load_image_command_CMD_ARGV, struct image *image,
 	} else
 		image->base_address_set = 0;
 
-	image->start_address_set = 0;
 
 	if (CMD_ARGC >= (*argn_out+4))
 		COMMAND_PARSE_NUMBER(u64, CMD_ARGV[*argn_out+3], pMinAddr->addr);
@@ -3182,8 +3181,9 @@ COMMAND_HANDLER(handle_load_image_command)
 				length -= (image.sections[i].base_address + buf_cnt)-max_addr.addr;
 
 			struct target_addr tmp_addr;
-			TARGET_ADDR_INIT( &tmp_addr , image.sections[i].base_address + offset );
-
+			/* a route may have been specified */
+			tmp_addr = image.base_address;
+			tmp_addr.addr = image.sections[i].base_address + offset;
 			retval = target64_write_buffer(target, &tmp_addr, length, buffer + offset);
 			if (retval != ERROR_OK) {
 				free(buffer);
@@ -6475,57 +6475,58 @@ int target64_virt2phys( struct target *target, const struct target_addr *in_pVir
 	return target->type->pIo64_api->virt2phys( target, in_pVirt, out_pPhys );
 }
 
-static int t64_resume_wrap(struct target *target, int current, const struct target_addr *pAddr,
+int target64_resume_wrapper(struct target *target, int current, const struct target_addr *pAddr,
 			int handle_breakpoints, int debug_execution)
 {
 	return target->type->pIo32_legacy_api->resume( target, current, pAddr->addr, handle_breakpoints, debug_execution );
 }
-static int t64_step_wrap( struct target *target, int current, const struct target_addr *pAddr,
+
+int target64_step_wrapper( struct target *target, int current, const struct target_addr *pAddr,
 			int handle_breakpoints)
 {
 	return target->type->pIo32_legacy_api->step( target, current, pAddr->addr, handle_breakpoints );
 }
 
-static int t64_rm_wrap( struct target *target, const struct target_addr *pAddr,
+int target64_read_memory_wrapper( struct target *target, const struct target_addr *pAddr,
 			uint64_t size, uint64_t count, uint8_t *buffer)
 {
 	return target->type->pIo32_legacy_api->read_memory( target, pAddr->addr, size, count, buffer );
 }
 
-static int t64_wm_wrap (struct target *target, const struct target_addr *pAddr,
+int target64_write_memory_wrapper(struct target *target, const struct target_addr *pAddr,
 			uint64_t size, uint64_t count, const uint8_t *buffer)
 {
 	return target->type->pIo32_legacy_api->write_memory( target, pAddr->addr, size, count, buffer );
 }
 
-static int t64_rb_wrap(struct target *target, const struct target_addr *pAddr,
+int target64_read_buffer_wrapper(struct target *target, const struct target_addr *pAddr,
 			uint64_t size, uint8_t *buffer)
 {
 	return target->type->pIo32_legacy_api->read_buffer( target, pAddr->addr, size, buffer );
 }
 
-static int t64_wb_wrap(struct target *target, const struct target_addr *pAddr,
+int target64_write_buffer_wrapper(struct target *target, const struct target_addr *pAddr,
 			uint64_t size, const uint8_t *buffer)
 {
 	return target->type->pIo32_legacy_api->write_buffer( target, pAddr->addr, size, buffer );
 }
 
-static int t64_cs_wrap(struct target *target, const struct target_addr *pAddr,
+int target64_checksum_wrapper(struct target *target, const struct target_addr *pAddr,
 			uint64_t count, uint32_t *checksum)
 {
 	return target->type->pIo32_legacy_api->checksum_memory( target, pAddr->addr, count, checksum );
 }
 
-static int t64_bc_wrap(struct target *target, const struct target_addr *pAddr,
+int target64_blank_check_wrapper(struct target *target, const struct target_addr *pAddr,
 			uint64_t count, uint32_t *checksum)
 {
 	return target->type->pIo32_legacy_api->blank_check_memory( target, pAddr->addr, count, checksum );
 }
 
-static int t64_ra_wrap(struct target *target, int num_mem_params,
-			struct mem_param *mem_params, int num_reg_params,
-			struct reg_param *reg_param, const struct target_addr *pEntryPoint,
-			const struct target_addr *pExitPoint, int timeout_ms, void *arch_info)
+int target64_run_algo_wrapper(struct target *target, int num_mem_params,
+						   struct mem_param *mem_params, int num_reg_params,
+						   struct reg_param *reg_param, const struct target_addr *pEntryPoint,
+						   const struct target_addr *pExitPoint, int timeout_ms, void *arch_info)
 {
 	return target->type->pIo32_legacy_api->run_algorithm( target,
 							      num_mem_params,
@@ -6538,7 +6539,7 @@ static int t64_ra_wrap(struct target *target, int num_mem_params,
 							      arch_info );
 }
 
-static int t64_sa_wrap(struct target *target, int num_mem_params,
+int target64_start_algo_wrapper(struct target *target, int num_mem_params,
 			struct mem_param *mem_params, int num_reg_params,
 			struct reg_param *reg_param, const struct target_addr *pEntryPoint,
 			const struct target_addr *pExitPoint, void *arch_info)
@@ -6553,7 +6554,7 @@ static int t64_sa_wrap(struct target *target, int num_mem_params,
 							      arch_info );
 }
 
-static int t64_wa_wrap(struct target *target, int num_mem_params,
+int target64_wait_algo_wrapper(struct target *target, int num_mem_params,
 			struct mem_param *mem_params, int num_reg_params,
 			struct reg_param *reg_param, 
 			const struct target_addr *pExitPoint, int timeout_ms, void *arch_info)
@@ -6568,7 +6569,7 @@ static int t64_wa_wrap(struct target *target, int num_mem_params,
 							      arch_info );
 }
 
-static int t64_v2p_wrap( struct target *target,
+int target64_virt2phys_wrapper( struct target *target,
 			 const struct target_addr *in_pVirt,
 			 struct target_addr *out_pPhys )
 {
@@ -6576,24 +6577,24 @@ static int t64_v2p_wrap( struct target *target,
 	int r;
 
 	r = target->type->pIo32_legacy_api->virt2phys( target, in_pVirt->addr, &pa );
-	out_pPhys->addr = pa;
+	TARGET_ADDR_INIT( out_pPhys, pa );
 	return r;
 }
 
 
 const struct target_io64 target_64_wrapper = {
-	.resume			= t64_resume_wrap,
-	.step			= t64_step_wrap,
-	.read_memory		= t64_rm_wrap,
-	.write_memory		= t64_wm_wrap,
-	.read_buffer		= t64_rb_wrap,
-	.write_buffer		= t64_wb_wrap,
-	.checksum_memory	= t64_cs_wrap,
-	.blank_check_memory	= t64_bc_wrap,
-	.run_algorithm		= t64_ra_wrap,
-	.start_algorithm	= t64_sa_wrap,
-	.wait_algorithm		= t64_wa_wrap,
-	.virt2phys		= t64_v2p_wrap
+	.resume			= target64_resume_wrapper,
+	.step			= target64_step_wrapper,
+	.read_memory		= target64_read_memory_wrapper,
+	.write_memory		= target64_write_memory_wrapper,
+	.read_buffer		= target64_read_buffer_wrapper,
+	.write_buffer		= target64_write_buffer_wrapper,
+	.checksum_memory	= target64_checksum_wrapper,
+	.blank_check_memory	= target64_blank_check_wrapper,
+	.run_algorithm		= target64_run_algo_wrapper,
+	.start_algorithm	= target64_start_algo_wrapper,
+	.wait_algorithm		= target64_wait_algo_wrapper,
+	.virt2phys		= target64_virt2phys_wrapper
 };
 
 bool target_addr_is64bit( const struct target_addr *pAddr )
-- 
1.9.1


From ae3a39917510447f660742e2fb42b70b92ee8a80 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 76/94] Resolve addresses in cases of aliases

---
 src/target/mematts.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/target/mematts.c b/src/target/mematts.c
index f390dd2..3a1bc83 100644
--- a/src/target/mematts.c
+++ b/src/target/mematts.c
@@ -730,6 +730,12 @@ int parse_memory_address( struct target_addr *pAddr, const char *str1, const cha
 			/* not an att */
 			return -1;
 		}
+
+		/* resolve aliases */
+		while( atts->alias_of ){
+			atts = atts->alias_of;
+		}
+		
 		if( atts != NULL ){
 			*pAddr = atts->tmplate;
 		}
-- 
1.9.1


From c1944bedfb57146c8c1d18f3383fc20af00b9468 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 77/94] Add MEMATT type access to the cortex M target

---
 src/target/cortex_m.c | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/src/target/cortex_m.c b/src/target/cortex_m.c
index 7fe6fde..89d74f3 100755
--- a/src/target/cortex_m.c
+++ b/src/target/cortex_m.c
@@ -2285,11 +2285,31 @@ static struct target_io32 cortexm_target32 = {
 	.resume = cortex_m_resume,
 };
 
+
+
+
+const struct target_io64 cortexm_target64 = {
+	.resume			= target64_resume_wrapper,
+	.step			= target64_step_wrapper,
+	.read_memory		= target_cs_read_memory_wrapper,
+	.write_memory		= target_cs_write_memory_wrapper,
+	.read_buffer		= target_cs_read_buffer_wrapper,
+	.write_buffer		= target_cs_write_buffer_wrapper,
+	.checksum_memory	= target64_checksum_wrapper,
+	.blank_check_memory	= target64_blank_check_wrapper,
+	.run_algorithm		= target64_run_algo_wrapper,
+	.start_algorithm	= target64_start_algo_wrapper,
+	.wait_algorithm		= target64_wait_algo_wrapper,
+	.virt2phys		= target64_virt2phys_wrapper
+};
+
+
 struct target_type cortexm_target = {
 	.name = "cortex_m",
 	.deprecated_name = "cortex_m3",
 
 	.pIo32_legacy_api = &cortexm_target32,
+	.pIo64_api        = &cortexm_target64,
 	
 	.poll = cortex_m_poll,
 	.arch_state = armv7m_arch_state,
-- 
1.9.1


From f3ccfdf59d3b15d7a6b5d73467185ad10b6c0380 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 78/94] Handle case where abort is given a NULL ack pointer

---
 src/target/arm_adi_v5_debug.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/src/target/arm_adi_v5_debug.c b/src/target/arm_adi_v5_debug.c
index 8fb6898..458ee92 100644
--- a/src/target/arm_adi_v5_debug.c
+++ b/src/target/arm_adi_v5_debug.c
@@ -288,6 +288,7 @@ static void print_num( char *buf, int width, uint64_t val )
 void dap_dbg_log_dump( struct adiv5_dap *dap )
 {
 	unsigned x;
+	int v;
 	const char *reg_name;
 	const char *val;
 	struct dap_access_log *p;
@@ -310,8 +311,14 @@ void dap_dbg_log_dump( struct adiv5_dap *dap )
 		switch( p->access_type ){
 		case DAP_AP_ABORT:
 			/* data is uint8 */
-			p->dataval = * ((uint8_t *)(p->pointer));
-			LOG_DEBUG( "dap: abort result: 0x%02" PRIx64 , p->dataval );
+			if( p->pointer ){
+				v = * ((uint8_t *)(p->pointer));
+				LOG_DEBUG( "dap: abort result: %d",v);
+			} else {
+				/* put here */
+				v = -1;
+				LOG_DEBUG( "dap: abort result: no pointer" );
+			}
 			break;
 		case DAP_DP_WR:
 			is_wr++;
-- 
1.9.1


From edf770b826a8bc4a33bbefa29dec3c9d4189a12c Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 79/94] Add jtag scan in/out data to debug log

---
 src/jtag/drivers/ftdi.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/jtag/drivers/ftdi.c b/src/jtag/drivers/ftdi.c
index 300494d..af02762 100755
--- a/src/jtag/drivers/ftdi.c
+++ b/src/jtag/drivers/ftdi.c
@@ -430,9 +430,9 @@ static void ftdi_execute_scan(struct jtag_command *cmd)
 
 	for (int i = 0; i < cmd->cmd.scan->num_fields; i++, field++) {
 		scan_size += field->num_bits;
-		DEBUG_JTAG_IO("%s%s field %d/%d %d bits",
-			field->in_value ? "in" : "",
-			field->out_value ? "out" : "",
+		DEBUG_JTAG_IO("%s/%s field %d/%d %d",
+			field->in_value ? "in" : "--",
+			field->out_value ? "out" : "---",
 			i,
 			cmd->cmd.scan->num_fields,
 			field->num_bits);
-- 
1.9.1


From f63090f8d7b18cc83e8830d02144389acbfe3462 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 80/94] Add (conditionally) some debug logs for jtag io

---
 src/jtag/drivers/driver.c | 21 ++++++++++++++++++++-
 1 file changed, 20 insertions(+), 1 deletion(-)

diff --git a/src/jtag/drivers/driver.c b/src/jtag/drivers/driver.c
index 3ce876c..ee63763 100755
--- a/src/jtag/drivers/driver.c
+++ b/src/jtag/drivers/driver.c
@@ -118,6 +118,15 @@ int interface_jtag_add_ir_scan(struct jtag_tap *active,
 
 		/* update device information */
 		buf_cpy(field->out_value, tap->cur_instr, tap->ir_length);
+#if _DEBUG_JTAG_IO_
+		{
+			uint32_t ir;
+			ir = buf_get_u32( tap->cur_instr, 0, tap->ir_length );
+			LOG_DEBUG("tap: %s (len:%d) value=%d/0x%x",
+					  tap->tapname,
+					  tap->ir_length,ir,ir);
+		}
+#endif
 
 		field++;
 	}
@@ -172,6 +181,14 @@ int interface_jtag_add_dr_scan(struct jtag_tap *active, int in_num_fields,
 #endif /* NDEBUG */
 
 			for (int j = 0; j < in_num_fields; j++) {
+#if _DEBUG_JTAG_IO_
+				long long v;
+				v = buf_get_u64( (in_fields+j)->out_value, 0, (in_fields+j)->num_bits );
+				LOG_DEBUG("drscan(%s): len:%d, %lld/%llx",
+						  tap->tapname,
+						  (in_fields+j)->num_bits,
+						  v,v);
+#endif		  
 				cmd_queue_scan_field_clone(field, in_fields + j);
 
 				field++;
@@ -185,7 +202,9 @@ int interface_jtag_add_dr_scan(struct jtag_tap *active, int in_num_fields,
 			field->num_bits = 1;
 			field->out_value = NULL;
 			field->in_value = NULL;
-
+#if _DEBUG_JTAG_IO_
+			LOG_DEBUG("drscan(%s): bypass", tap->tapname );
+#endif
 			field++;
 		}
 	}
-- 
1.9.1


From 1351d83598ae8f609a35a34e5de93a02051ba94e Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 81/94] Shorten reset periods and add ignore for cpwrup

---
 tcl/qualcomm/common/jtag_dap_cfg1.cfg | 12 +++++++-----
 tcl/qualcomm/msm8994/apps_coreX.cfg   |  3 +++
 tcl/qualcomm/msm8994/rpm_core.cfg     |  3 +++
 3 files changed, 13 insertions(+), 5 deletions(-)

diff --git a/tcl/qualcomm/common/jtag_dap_cfg1.cfg b/tcl/qualcomm/common/jtag_dap_cfg1.cfg
index 088065c..6f3e36a 100644
--- a/tcl/qualcomm/common/jtag_dap_cfg1.cfg
+++ b/tcl/qualcomm/common/jtag_dap_cfg1.cfg
@@ -15,11 +15,13 @@ foreach tapid $_MSM_TAPID {
 eval jtag newtap $_CHIPNAME msm -irlen 11  -ignore-version $taplist
 
 
-jtag_ntrst_assert_width    10
-jtag_ntrst_delay           10
-adapter_nsrst_assert_width 1000
-adapter_nsrst_delay        10
+jtag_ntrst_assert_width    5
+jtag_ntrst_delay           5
+adapter_nsrst_assert_width 5
+adapter_nsrst_delay        5
 reset_config trst_and_srst
 
-adapter_khz 10000
+adapter_khz 3000
+
+debug_flags set  dap_debug_flags -1
 
diff --git a/tcl/qualcomm/msm8994/apps_coreX.cfg b/tcl/qualcomm/msm8994/apps_coreX.cfg
index 4d75c0e..c98b338 100644
--- a/tcl/qualcomm/msm8994/apps_coreX.cfg
+++ b/tcl/qualcomm/msm8994/apps_coreX.cfg
@@ -10,3 +10,6 @@ $_appsNAME configure -dbg-base    [format "${_dbg_port}:0x%x" [expr 0x80810000 +
 $_appsNAME configure -cti-base    [format "${_dbg_port}:0x%x" [expr 0x80820000 + ($_appsX * 0x100000)]]
 $_appsNAME configure -mem-ap      ${_mem_port}:0
 $_appsNAME configure -sys-ap      ${_axi_port}:0
+
+# Required for qualcom daps
+dap ignore_csyspwrupreq 1
diff --git a/tcl/qualcomm/msm8994/rpm_core.cfg b/tcl/qualcomm/msm8994/rpm_core.cfg
index d14c672..1f8b457 100644
--- a/tcl/qualcomm/msm8994/rpm_core.cfg
+++ b/tcl/qualcomm/msm8994/rpm_core.cfg
@@ -12,6 +12,9 @@ rpm configure -cti-base $_dbg_port:0
 rpm configure -sys-ap   $_axi_port:0
 rpm configure -mem-ap   $_axi_port:0
 
+# Required for qualcom daps
+dap ignore_csyspwrupreq 1
+
 proc edl_mode {} {
 	targets rpm
 	halt
-- 
1.9.1


From 429b086021375d7c573624e52513f2746d445559 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 82/94] move extern to header file instead of c file

---
 src/jtag/adapter.c   | 1 -
 src/jtag/interface.h | 1 +
 2 files changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/jtag/adapter.c b/src/jtag/adapter.c
index 2f5f6b4..6fc7a89 100755
--- a/src/jtag/adapter.c
+++ b/src/jtag/adapter.c
@@ -47,7 +47,6 @@
  * Holds support for configuring debug adapters from TCl scripts.
  */
 
-extern struct jtag_interface *jtag_interface;
 const char * const jtag_only[] = { "jtag", NULL };
 
 static int jim_adapter_name(Jim_Interp *interp, int argc, Jim_Obj * const *argv)
diff --git a/src/jtag/interface.h b/src/jtag/interface.h
index c7130cc..90e99df 100755
--- a/src/jtag/interface.h
+++ b/src/jtag/interface.h
@@ -300,6 +300,7 @@ struct jtag_interface {
 	int (*srst_asserted)(int *srst_asserted);
 };
 
+extern struct jtag_interface *jtag_interface;
 extern const char * const jtag_only[];
 
 void adapter_assert_reset(void);
-- 
1.9.1


From 5f99b179c37dc7314d3ba167002118afbc0806dd Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 83/94] Add prototype for dap swd driver

---
 src/jtag/swd.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/jtag/swd.h b/src/jtag/swd.h
index d6746dd..d49857f 100755
--- a/src/jtag/swd.h
+++ b/src/jtag/swd.h
@@ -211,6 +211,8 @@ struct swd_driver {
 	int *(*trace)(struct adiv5_dap *dap, bool swo);
 };
 
+const struct swd_driver *arm_dap2swd_driver( struct adiv5_dap *dap );
+
 int swd_init_reset(struct command_context *cmd_ctx);
 void swd_add_reset(int req_srst);
 
-- 
1.9.1


From 73747e0cdb2ace281fd6ba0ee56cc944f0b56129 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 84/94] Create public atomic functions, re-enable dap cache of
 SELECT register

---
 src/target/adi_v5_jtag.c | 219 ++++++++++++++++++++++++++++++-----------------
 src/target/adi_v5_swd.c  |   4 +-
 src/target/arm_adi_v5.c  | 154 +++++++++++++++++++++------------
 src/target/arm_adi_v5.h  |  20 +++++
 4 files changed, 261 insertions(+), 136 deletions(-)

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index aeced14..d2521a6 100755
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -47,10 +47,10 @@
 #define JTAG_DP_IDCODE		0xE
 
 /* three-bit ACK values for DPACC and APACC reads */
+#define JTAG_ACK_NO_RESPONSE 0x03
 #define JTAG_ACK_OK_FAULT	0x2
 #define JTAG_ACK_WAIT		0x1
 
-int dap_jtag_debug = 0;
 
 static int jtag_ap_q_abort(struct adiv5_dap *dap, uint8_t *ack);
 
@@ -130,25 +130,36 @@ static int adi_jtag_dp_scan(struct adiv5_dap *dap,
 	 * See "Minimum Response Time" for JTAG-DP, in the ADIv5 spec.
 	 */
 
+	int n;
+	n = dap_get_memacces_tck(dap);
+
 	/* if not a memory transaction */
 	if( instr != JTAG_DP_APACC ){
-		/* we are done */
-		return ERROR_OK;
+		/* no delay required for DP or ABORT */
+		n = 0;
 	}
 
-	/* not a memory register */
-	if( ! ((reg_addr == AP_MEM_REG_DRW) || ((reg_addr & 0xF0) == AP_MEM_REG_BD0)) ){
-		/* we are done */
-		return ERROR_OK;
+	/* Delays involve these registers */
+	/* note: All BD0/1/2/3 are in the same bank, ie: 0x010 to 0x1F */
+	if( instr == JTAG_DP_APACC ){
+		switch( reg_addr ){
+		default:
+			n = 0;
+			break;
+		case AP_MEM_REG_DRW:
+		case AP_MEM_REG_BD0:
+		case AP_MEM_REG_BD1:
+		case AP_MEM_REG_BD2:
+		case AP_MEM_REG_BD3:
+		case AP_MEM_REG_TAR_lo:
+		case AP_MEM_REG_TAR_hi:
+			/* We do the delay */
+			break;
+		}
 	}
 
-	int n;
-	n = dap_get_memacces_tck(dap);
-	if( n < 8 ){
-		n = 8;
-	}
 	if( n ){
-		/* only add idle if specified */
+		// LOG_DEBUG("dap delay: %d clocks", n );
 		jtag_add_runtest(n, TAP_IDLE);
 	}
 	return ERROR_OK;
@@ -173,7 +184,7 @@ static int adi_jtag_dp_scan_u32(struct adiv5_dap *dap,
 
 
 
-	if( dap_jtag_debug ){
+	if( dap_debug(DAP_DBG_JTAG_IO) ){
 		if( RnW ){
 			rw = "rd";
 		} else {
@@ -285,7 +296,11 @@ static int jtag_dp_rd_ctrlstat( struct adiv5_dap *dap, uint32_t *result )
 static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 {
 	int retval;
+	uint32_t v;
 	uint32_t ctrlstat;
+	uint32_t mem_ap_csw;
+	uint64_t mem_ap_tar;
+	uint32_t mem_ap_tar_l,mem_ap_tar_h;
 
 	/* too expensive to call keep_alive() here */
 
@@ -360,81 +375,108 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 	/* REVISIT also STICKYCMP, for pushed comparisons (nyet used) */
 
 	/* Check for STICKYERR and STICKYORUN */
-	if (ctrlstat & (SSTICKYORUN | SSTICKYERR)) {
-		LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32" (sticky:%d, overrun:%d)",
-				  ctrlstat, !!(SSTICKYERR & ctrlstat), !!(SSTICKYORUN & ctrlstat));
-		/* Check power to debug regions */
-		uint32_t maskcheck;
-		if( dap->ignore_csyspwrupreq ){
-			maskcheck = 0x70000000;
-		} else {
-			maskcheck = 0xf0000000;
-		}
-		if ((ctrlstat & maskcheck) != maskcheck) {
-			retval = dap_debugport_init(dap);
-			if (retval != ERROR_OK)
-				return retval;
-		} else {
-			uint32_t mem_ap_csw;
-			uint64_t mem_ap_tar;
-			uint32_t mem_ap_tar_l,mem_ap_tar_h;
+	if (0 == (ctrlstat & (SSTICKYORUN | SSTICKYERR)) ) {
+		/* NO ERRORS - we are done */
+		return ERROR_OK;
+	}
 
-			/* Maybe print information about last intended
-			 * MEM-AP access; but not if autoincrementing.
-			 * *Real* CSW and TAR values are always shown.
-			 */
+	/* because someting is wrong, we invalidate
+	 * the CSW and TAR cache values.
+	 */
+	{
+		struct adiv5_dap_port *port;
+		port = dap_current_port( dap );
+		port->cached_csw_valid = false;
+		port->cached_tar_valid = false;
+	}
+		
+	LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32" (sticky:%d, overrun:%d)",
+			  ctrlstat, !!(SSTICKYERR & ctrlstat), !!(SSTICKYORUN & ctrlstat));
 
-			if (ctrlstat & SSTICKYORUN)
-				LOG_ERROR("JTAG-DP OVERRUN - check clock, "
-					"memaccess, or reduce jtag speed");
+	/* Check power to debug regions */
+	/* maybe the device disconnected ?*/
+	
 
-			if (ctrlstat & SSTICKYERR)
-				LOG_ERROR("JTAG-DP STICKY ERROR");
+	if( dap->ignore_csyspwrupreq ){
+		v = 0x70000000;
+	} else {
+		v = 0xf0000000;
+	}
+	
+	if ((ctrlstat & v) != v) {
+		LOG_DEBUG("reinitializing debug port");
+		retval = dap_debugport_init(dap);
+		LOG_DEBUG("result: %d\n", retval );
+		/* must still fail the transfer */
+		return ERROR_FAIL;
+	}
 
-			/* Clear Sticky Error Bits */
-			retval = jtag_dp_wr_ctrlstat( dap, dap->dp_ctrl_stat | SSTICKYORUN | SSTICKYERR);
-			if (retval != ERROR_OK)
-				return retval;
 
-			retval = jtag_dp_rd_ctrlstat( dap, &ctrlstat);
-			if (retval != ERROR_OK)
-				return retval;
-			LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
-			retval = dap_queue_ap_read(dap, AP_MEM_REG_CSW, &mem_ap_csw);
-			if (retval != ERROR_OK)
-				return retval;
+	/* read the CSW, and TAR 
+	 * that might help explain where 
+	 * things went wrong
+	 */
+	
+	/* Maybe print information about last intended
+	 * MEM-AP access; but not if autoincrementing.
+	 * *Real* CSW and TAR values are always shown.
+	 */
+	
+	if (ctrlstat & SSTICKYORUN)
+		LOG_ERROR("JTAG-DP OVERRUN - check clock, memaccess, or reduce jtag speed");
 
-			retval = dap_queue_ap_read(dap, AP_MEM_REG_TAR_lo, &mem_ap_tar_l);
-			if (retval != ERROR_OK)
-				return retval;
-			
-			{
-				/* is this a 64bit port? */
-				struct adiv5_dap_port *p;
-				p = dap_current_port(dap);
-				if( p->addr_64bit ){
-					retval = dap_queue_ap_read(dap,
-											   AP_MEM_REG_TAR_lo, &mem_ap_tar_h);
-				}
-			}
+	if (ctrlstat & SSTICKYERR)
+		LOG_ERROR("JTAG-DP STICKY ERROR");
 
-			retval = jtag_execute_queue();
-			if (retval != ERROR_OK)
-				return retval;
-			mem_ap_tar = mem_ap_tar_h;
-			mem_ap_tar = mem_ap_tar << 32;
-			mem_ap_tar += mem_ap_tar_l;
-			LOG_ERROR("MEM_AP_CSW 0x%" PRIx32 ", MEM_AP_TAR 0x%"
-					PRIx64, mem_ap_csw, mem_ap_tar);
+	LOG_ERROR("Clearing STICKYERR & STYCKYORUN");
 
+	v = dap->dp_ctrl_stat;
+	/*
+	 * Note: Per ARM IHI 0031B, page 3-56
+	 * Section: 3.3.2 CTRL/STAT, Control/Status register
+	 * for JTAG, these bits are: "W1C" [write 1 to clear]
+	 */
+	v = v | SSTICKYORUN | SSTICKYERR;
+	retval = jtag_dp_wr_ctrlstat( dap, v );
+	if (retval != ERROR_OK)
+		return retval;
+
+	retval = jtag_dp_rd_ctrlstat( dap, &ctrlstat);
+	if (retval != ERROR_OK)
+		return retval;
+
+	LOG_DEBUG("jtag-dp: CTRL/STAT 0x%" PRIx32, ctrlstat);
+	retval = dap_queue_ap_read(dap, AP_MEM_REG_CSW, &mem_ap_csw);
+	if (retval != ERROR_OK)
+		return retval;
+			
+	retval = dap_queue_ap_read(dap, AP_MEM_REG_TAR_lo, &mem_ap_tar_l);
+	if (retval != ERROR_OK)
+		return retval;
+
+	{
+		/* is this a 64bit port? */
+		struct adiv5_dap_port *p;
+		p = dap_current_port(dap);
+		if( p->addr_64bit ){
+			LOG_DEBUG("port: %d 64bit port!", p->port_num);
+			retval = dap_queue_ap_read(dap,
+									   AP_MEM_REG_TAR_lo, &mem_ap_tar_h);
+		} else {
+			mem_ap_tar_h = 0;
 		}
-		retval = jtag_execute_queue();
-		if (retval != ERROR_OK)
-			return retval;
-		return ERROR_JTAG_DEVICE_ERROR;
 	}
-
-	return ERROR_OK;
+	
+	retval = jtag_execute_queue();
+	if (retval != ERROR_OK)
+		return retval;
+	mem_ap_tar = mem_ap_tar_h;
+	mem_ap_tar = mem_ap_tar << 32;
+	mem_ap_tar += mem_ap_tar_l;
+	LOG_ERROR("MEM_AP_CSW 0x%" PRIx32 ", MEM_AP_TAR 0x%"
+			  PRIx64, mem_ap_csw, mem_ap_tar);
+	
+	return ERROR_JTAG_DEVICE_ERROR;
 }
 
 /*--------------------------------------------------------------------------*/
@@ -462,10 +504,12 @@ static int jtag_ap_q_bankselect(struct adiv5_dap *dap, unsigned reg)
 	
 	if( dap->cached_select_reg_valid ){
 		/* CACHE HIT */
+		//LOG_DEBUG("dap bankselect CACHE HIT");
 		return ERROR_OK;
 	}
 	
 	r = jtag_dp_q_write(dap, DP_SELECT, dap->cached_select_reg_value );
+	//LOG_DEBUG("write DP_SELECT=0x%08x", dap->cached_select_reg_value);
 	if( r == ERROR_OK ){
 		dap->cached_select_reg_valid = true;
 	}
@@ -501,6 +545,23 @@ static int jtag_ap_q_write(struct adiv5_dap *dap, unsigned reg,
 static int jtag_ap_q_abort(struct adiv5_dap *dap, uint8_t *ack)
 {
 	/* for JTAG, this is the only valid ABORT register operation */
+	/* SPECIFICALLY see
+	 *  ARM: IHI-0031B - Section 4.4.4 
+	 *  Title: Abort, The JTAG-DP Abort Register 
+	 * 
+	 * The text reads:
+	 *
+	 * In DPv0, the effect of writing a value other than 0x00000001 to
+	 * the ABORT register is UNPREDICTABLE. For more information, see
+	 * ABORT, AP Abort register on page 3-54. This means that, in
+	 * DPv0, the debugger must scan the value 0x000000008 into this
+	 * scan chain.
+	 *
+	 * note: the 8, translates into <32bits><3bits>
+	 *       Where the 32bit value = 1
+	 *       The 3 zero bits are the stuff values for the ACK
+	 */
+	
 	return adi_jtag_dp_scan_u32(dap, JTAG_DP_ABORT,
 			0, DPAP_WRITE, 1, NULL, ack);
 }
diff --git a/src/target/adi_v5_swd.c b/src/target/adi_v5_swd.c
index 58e584e..9b4f036 100755
--- a/src/target/adi_v5_swd.c
+++ b/src/target/adi_v5_swd.c
@@ -286,9 +286,7 @@ COMMAND_HANDLER(handle_swd_wcr)
 	/* no-args: just dump state */
 	case 0:
 		/*retval = swd_queue_dp_read(dap, DP_WCR, &wcr); */
-		retval = dap_queue_dp_read(dap, DP_WCR, &wcr);
-		if (retval == ERROR_OK)
-			dap->driver.ops->run(dap);
+		retval = dap_dp_read_atomic(dap, DP_WCR, &wcr );
 		if (retval != ERROR_OK) {
 			LOG_ERROR("can't read WCR?");
 			return retval;
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 9f859fd..38a53d1 100755
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -81,13 +81,14 @@
 struct adiv5_dap *all_daps;
 jim_wide dap_debug_flags;
 
-	
+static uint32_t dummy_u32[10];
 
 
 void dap_update_select_reg_cache( struct adiv5_dap *dap, int apsel, int apbanksel, int dpbanksel )
 {
 	uint32_t v;
-	
+
+	/* pick up old values if we are not changing them */
 	if( (apsel < 0) || (apsel > 255) ){
 		v = dap->cached_select_reg_value;
 		v = v >> 24;
@@ -114,9 +115,14 @@ void dap_update_select_reg_cache( struct adiv5_dap *dap, int apsel, int apbankse
 	v = v | (apbanksel << 4);
 	v = v | (dpbanksel << 0);
 
+
 	/* did the value change? */
-	if( dap->cached_select_reg_value != v ){
-		/* then mark for update */
+	if( dap->cached_select_reg_value == v ){
+		LOG_DEBUG("DAP-select (old=0x%08x, v=0x%08x) match",
+				  dap->cached_select_reg_value,v);
+	} else {
+		LOG_DEBUG("DAP-select (old=0x%08x, v=0x%08x) invalidating",
+				  dap->cached_select_reg_value,v);
 		dap->cached_select_reg_valid = 0;
 	}
 	dap->cached_select_reg_value = v;
@@ -204,7 +210,7 @@ int target_addr_to_dap_port( const struct target_addr *pAddr )
 }
 
 /* write (now) this dap register */
-static int dap_ap_write( struct adiv5_dap *dap, int reg, uint32_t val )
+int dap_ap_write_atomic( struct adiv5_dap *dap, int reg, uint32_t val )
 {
 	int r;
 	
@@ -215,7 +221,7 @@ static int dap_ap_write( struct adiv5_dap *dap, int reg, uint32_t val )
 	return r;
 }
 
-static int dap_ap_read( struct adiv5_dap *dap, int reg, uint32_t *val )
+int dap_ap_read_atomic( struct adiv5_dap *dap, int reg, uint32_t *val )
 {
 	int r;
 	
@@ -230,7 +236,7 @@ static int dap_ap_read( struct adiv5_dap *dap, int reg, uint32_t *val )
 struct adiv5_dap_port *dap_current_port( struct adiv5_dap *dap )
 {
 	uint32_t v;
-	v = dap->cached_select_reg_valid;
+	v = dap->cached_select_reg_value;
 	v = v >> 24;
 	v = v & 0x0ff;
 
@@ -265,13 +271,7 @@ static int dap_setup_accessport_csw(struct adiv5_dap *dap, uint32_t csw, const s
 	struct adiv5_dap_port *port;
 	int r;
 
-	r = target_addr_to_dap_port(pAddr);
-	if( r < 0 ){
-		LOG_ERROR("dap-ap[ERROR] id =%d", r );
-		return ERROR_FAIL;
-	}
-
-	port = &(dap->port[r]);
+	port = dap_current_port( dap );
 
 	/* clear away all sbzp bits */
 	csw &= ~(port->csw_reg_sbzp_mask);
@@ -338,10 +338,23 @@ static int dap_setup_accessport_tar(struct adiv5_dap *dap, uint64_t address )
 	if( port->addr_64bit ){
 		uint64_t a2;
 		a2 = address >> 32;
-		r = dap_queue_ap_write(dap, AP_MEM_REG_TAR_hi, a2 );
-	}
 
-	if( r == ERROR_OK ){
+		r = dap_run(dap);
+		if( r != ERROR_OK ){
+			return;
+		}
+		
+		LOG_DEBUG("port: %d is 64bit - writing TAR hi", port->port_num );
+#if 0	  
+		r = dap_ap_write_atomic(dap, AP_MEM_REG_TAR_hi, a2 );
+		/* write LOW */
+		r = dap_ap_write_atomic(dap, AP_MEM_REG_TAR_lo, address );
+#else
+		r = dap_queue_ap_write(dap, AP_MEM_REG_TAR_hi, a2 );
+		/* write LOW */
+		r = dap_ap_write_atomic(dap, AP_MEM_REG_TAR_lo, address );
+#endif
+	} else {
 		/* write LOW */
 		r = dap_queue_ap_write(dap, AP_MEM_REG_TAR_lo, address );
 	}
@@ -381,7 +394,7 @@ static int dap_setup_accessport(struct adiv5_dap *dap, uint32_t csw, const struc
 		return ERROR_FAIL;
 	}
 	dap_ap_select(dap, retval );
-	
+
 	retval = dap_setup_accessport_csw(dap, csw, pAddr);
 	if (retval != ERROR_OK)
 		return retval;
@@ -760,7 +773,7 @@ int coresight_io_bulk( struct coresight_bulk *bulk )
 			}
 		}
 		
-		
+
 		/* transfer a chunk */
 		if( bulk->rw == 'w' ){
 			r = coresight_io_chunk_wr( bulk );
@@ -969,6 +982,7 @@ static int dap_mem_ap_read_tar( struct adiv5_dap *dap, uint64_t *tar )
 	p = dap_current_port( dap );
 	
 	if( p->addr_64bit ){
+		LOG_DEBUG("port: %d is 64bit - reading TAR hi\n", p->port_num );
 		r = dap_queue_ap_read(dap, AP_MEM_REG_TAR_hi, &h);
 		if( r != ERROR_OK ){
 			return r;
@@ -1035,7 +1049,7 @@ static int dap_idr_0x14770004( struct adiv5_dap *dap, struct adiv5_dap_port *por
 	/* PER: ARM DDI 0480F, page: 3-182 */
 	LOG_DEBUG( "dap-port[%d] axi with ace", port->port_num );
 
-	r = dap_ap_read( dap, AP_MEM_REG_CSW, &reg );
+	r = dap_ap_read_atomic( dap, AP_MEM_REG_CFG, &reg );
 	if( r != ERROR_OK ){
 		return r;
 	}
@@ -1050,7 +1064,7 @@ static int dap_idr_0x14770004( struct adiv5_dap *dap, struct adiv5_dap_port *por
 
 
 	/* read and capture the SBZP csw registers */
-	r = dap_ap_read(dap, AP_MEM_REG_CSW, &reg );
+	r = dap_ap_read_atomic(dap, AP_MEM_REG_CSW, &reg );
 	if( r != ERROR_OK ){
 		return r;
 	}
@@ -1090,6 +1104,11 @@ static int dap_idr_0x14770004( struct adiv5_dap *dap, struct adiv5_dap_port *por
 	/* AXI ports vary, use cfg register */
 	port->addr_64bit = !!(port->cfg_reg & 0x02);
 	port->data_64bit = !!(port->cfg_reg & 0x04);
+	LOG_DEBUG("Port: %d: Data64=%d, Address64=%d, BigEndian: %d",
+			  port->port_num,
+			  port->data_64bit,
+			  port->addr_64bit,
+			  port->big_endian);
 	
 	/* this is a full featured port */
 	port->word_only_transfers = false;
@@ -1115,14 +1134,14 @@ static int dap_idr_0x14770002( struct adiv5_dap *dap, struct adiv5_dap_port *por
 	port->cfg_reg = 0;
 
 	/* read and capture the SBZP csw registers */
-	r = dap_ap_read(dap, AP_MEM_REG_CSW, &reg );
+	r = dap_ap_read_atomic(dap, AP_MEM_REG_CSW, &reg );
 	if( r != ERROR_OK ){
 		return r;
 	}
 	/* Table 2-14, page 2-35 ddi-316D dap lite trm */
 	/* the DBGSW ENABLE bit must forced on */
 	reg |= 0x80000000;
-	r = dap_ap_write(dap, AP_MEM_REG_CSW, reg );
+	r = dap_ap_write_atomic(dap, AP_MEM_REG_CSW, reg );
 	port->csw_reg_orig = reg;
 
 	/* from figure 2-13, ddi-0316d, page 2-34 */
@@ -1164,7 +1183,7 @@ static int dap_idr_0x447700001( struct adiv5_dap *dap, struct adiv5_dap_port *po
 	/* the CFG register does not exist in the M1 dap */
 	port->cfg_reg = 0;
 
-	r = dap_ap_read(dap, AP_MEM_REG_CSW, &reg );
+	r = dap_ap_read_atomic(dap, AP_MEM_REG_CSW, &reg );
 	if( r != ERROR_OK ){
 		return r;
 	}
@@ -1224,13 +1243,13 @@ static int dap_idr_0x44770002( struct adiv5_dap *dap, struct adiv5_dap_port *por
 
 	/* the CFG register does not exist */
 	port->cfg_reg = 0;
-	r = dap_ap_read(dap, AP_MEM_REG_CSW, &csw_reg );
+	r = dap_ap_read_atomic(dap, AP_MEM_REG_CSW, &csw_reg );
 	if( r != ERROR_OK ){
 		return r;
 	}
 	/* we *MUST* enable the debug port */
 	csw_reg |= 0x80000000;
-	r = dap_ap_write(dap, AP_MEM_REG_CSW, csw_reg );
+	r = dap_ap_write_atomic(dap, AP_MEM_REG_CSW, csw_reg );
 	if( r != ERROR_OK ){
 		return r;
 	}
@@ -1281,7 +1300,7 @@ static int dap_idr_0x24770011( struct adiv5_dap *dap, struct adiv5_dap_port *por
 
 	/* 7.2.2 AHB-AP programmers model  */
 
-	r = dap_ap_read( dap, AP_MEM_REG_CSW, &csw_reg );
+	r = dap_ap_read_atomic( dap, AP_MEM_REG_CSW, &csw_reg );
 	if( r != ERROR_OK ){
 		return r;
 	}
@@ -1327,7 +1346,7 @@ static int dap_idr_UNKNOWN( struct adiv5_dap *dap, struct adiv5_dap_port *port )
 	/* assume no CFG reg */
 	port->cfg_reg = 0;
 
-	r = dap_ap_read( dap, AP_MEM_REG_CSW, &csw);
+	r = dap_ap_read_atomic( dap, AP_MEM_REG_CSW, &csw);
 	if( r != ERROR_OK ){
 		return r;
 	}
@@ -1365,7 +1384,7 @@ static int dap_ap_class_mem( struct adiv5_dap *dap, struct adiv5_dap_port *port
 	
 	dap_ap_select( dap, port->port_num );
 		
-	r = dap_ap_read(dap, AP_MEM_REG_BASE, &rombase_reg );
+	r = dap_ap_read_atomic(dap, AP_MEM_REG_BASE, &rombase_reg );
 	if( r != ERROR_OK ){
 		return r;
 	}
@@ -1464,6 +1483,17 @@ int dap_dp_read_atomic(struct adiv5_dap *dap, unsigned reg, uint32_t *value)
 	return dap_run(dap);
 }
 
+int dap_dp_write_atomic(struct adiv5_dap *dap, unsigned reg, uint32_t value)
+{
+	int retval;
+
+	retval = dap_queue_dp_write(dap, reg, value);
+	if (retval != ERROR_OK)
+		return retval;
+
+	return dap_run(dap);
+}
+
 
 /**
  * Initialize a DAP.  This sets up the power domains, prepares the DP
@@ -1496,20 +1526,36 @@ int dap_debugport_init(struct adiv5_dap *dap)
 	dap->last_read = NULL;
 
 
-	r = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
+	r = dap_dp_read_atomic(dap, DP_CTRL_STAT, NULL);
 	if (r != ERROR_OK)
 		return r;
 
-	r = dap_queue_dp_write(dap, DP_CTRL_STAT, SSTICKYERR);
+	/* clear *BOTH* sticky and ORUN */
+	if( arm_dap_is_swd(dap) ){
+		/* see: ARM IHI 0031B */
+		/* see 3.3.1 ABORT, AP Abort register */
+		/* these are cleared via the ABORT register */
+		r = dap_queue_dp_write(dap, DP_ABORT,
+							   DAPABORT  | 
+							   STKCMPCLR |
+							   STKERRCLR |
+							   WDERRCLR  |
+							   ORUNERRCLR );
+	} else {
+		/* these are W1C on the JTAG dap */
+		r = dap_queue_ap_abort( dap, NULL );
+	}
 	if (r != ERROR_OK)
 		return r;
 
-	r = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
+	r = dap_run(dap);
+
+	r = dap_dp_read_atomic(dap, DP_CTRL_STAT, NULL);
 	if (r != ERROR_OK)
 		return r;
 
 	dap->dp_ctrl_stat = CDBGPWRUPREQ | CSYSPWRUPREQ;
-	r = dap_queue_dp_write(dap, DP_CTRL_STAT, dap->dp_ctrl_stat);
+	r = dap_dp_write_atomic(dap, DP_CTRL_STAT, dap->dp_ctrl_stat);
 	if (r != ERROR_OK)
 		return r;
 
@@ -1521,14 +1567,18 @@ int dap_debugport_init(struct adiv5_dap *dap)
 	if (r != ERROR_OK)
 		return r;
 
-	/*LOG_DEBUG("DAP: wait CSYSPWRUPACK");
-	r = dap_dp_poll_register(dap, DP_CTRL_STAT,
-				      CSYSPWRUPACK, CSYSPWRUPACK,
-				      DAP_POWER_DOMAIN_TIMEOUT);
-	if (r != ERROR_OK)
-		//return r; SQU: for QCOM chip, ignore this as without bootloader, this bit might be not set
-        LOG_USER("DAP: Timeout for waiting CSYSPWRUPACK");*/
 
+	if( dap->ignore_csyspwrupreq ){
+		// For QCOM chips without working RPM
+		// firmware this bit will never be set
+	} else {
+		r = dap_dp_poll_register(dap, DP_CTRL_STAT,
+								 CSYSPWRUPACK, CSYSPWRUPACK,
+				      DAP_POWER_DOMAIN_TIMEOUT);
+		if (r != ERROR_OK){
+			LOG_USER("DAP: Timeout for waiting CSYSPWRUPACK");
+		}
+	}
 	r = dap_queue_dp_read(dap, DP_CTRL_STAT, NULL);
 	if (r != ERROR_OK)
 		return r;
@@ -1541,6 +1591,9 @@ int dap_debugport_init(struct adiv5_dap *dap)
 	if (r != ERROR_OK)
 		return r;
 
+	/* run the above */
+	dap_run(dap);
+	
 	/*
 	 * Need to find the AHB port, with a DAP ROM
 	 * We assume that all ports act like that port 
@@ -1557,9 +1610,9 @@ int dap_debugport_init(struct adiv5_dap *dap)
 		port = &(dap->port[ x ]);
 		
 		dap_ap_select( dap, port->port_num );
-		dap_queue_ap_read( dap, AP_REG_IDR , &i_reg );
-		r = dap_run( dap );
+		r = dap_ap_read_atomic( dap, AP_REG_IDR , &i_reg );
 		if( r != ERROR_OK ){
+			LOG_ERROR("dap port: %d - Error reading IDR register",x);
 			continue;
 		}
 
@@ -1581,6 +1634,7 @@ int dap_debugport_init(struct adiv5_dap *dap)
 		
 		port->idr_reg  = i_reg;
 		if( i_reg == 0 ){
+			LOG_DEBUG("dap-port[%d]: *last*port*", x );
 			/* STOP at the first zero */
 			break;
 		}
@@ -2360,10 +2414,7 @@ COMMAND_HANDLER(dap_baseaddr_command)
 	 * though they're not common for now.  This should
 	 * use the ID register to verify it's a MEM-AP.
 	 */
-	retval = dap_queue_ap_read(dap, AP_MEM_REG_BASE, &baseaddr);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = dap_run(dap);
+	retval = dap_ap_read_atomic(dap, AP_MEM_REG_BASE, &baseaddr);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -2430,10 +2481,7 @@ COMMAND_HANDLER(dap_apsel_command)
 	dap->ap_cmd_sel = ap_cmd_sel;
 	dap_ap_select(dap, ap_cmd_sel );
 
-	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = dap_run(dap);
+	retval = dap_ap_read_atomic(dap, AP_REG_IDR, &apid);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -2507,10 +2555,7 @@ COMMAND_HANDLER(dap_apid_command)
 
 	dap_ap_select(dap, ap_cmd_sel );
 
-	retval = dap_queue_ap_read(dap, AP_REG_IDR, &apid);
-	if (retval != ERROR_OK)
-		return retval;
-	retval = dap_run(dap);
+	retval = dap_ap_read_atomic(dap, AP_REG_IDR, &apid);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -2617,6 +2662,7 @@ void arm_dap_magic_check( struct adiv5_dap *dap )
 	LOG_ERROR("BAD ARM DAP MAGIC!");
 }
 
+
 static int jim_dap_csyspwrupreq(Jim_Interp *_interp, int _argc, Jim_Obj * const *_argv )
 {
 	int e;
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 8c553d2..db97a2c 100755
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -162,6 +162,8 @@ struct adiv5_dap {
 	/* Control config */
 	uint32_t dp_ctrl_stat;
 	bool     ignore_csyspwrupreq;
+	/* What standard (DPv0, DPv1, DPv2) is this? */
+	int      dap_DPv_number;
 
 
 	/* this is the ap port the user has selected */
@@ -470,6 +472,7 @@ int dap_queue_ap_abort(struct adiv5_dap *dap, uint8_t *ack);
 int dap_run(struct adiv5_dap *dap);
 
 int dap_dp_read_atomic(struct adiv5_dap *dap, unsigned reg, uint32_t *value);
+int dap_dp_write_atomic(struct adiv5_dap *dap, unsigned reg, uint32_t value);
 
 int dap_dp_poll_register(struct adiv5_dap *dap, unsigned reg, uint32_t mask, uint32_t value, int timeout);
 
@@ -764,6 +767,23 @@ int target_cs_dbg_wr_bulk_noinc( struct target *target,
 			   size_t item_count,
 			   const void   *buffer );
 
+/* for use in target64 io wrappers: If address == DAPBUS based, use the dap route instead */
+int target_cs_read_memory_wrapper( struct target *target, const struct target_addr *pAddr,
+								uint64_t size, uint64_t count, uint8_t *buffer);
+
+/* for use in target64 io wrappers: If address == DAPBUS based, use the dap route instead */
+int target_cs_write_memory_wrapper(struct target *target, const struct target_addr *pAddr,
+								 uint64_t size, uint64_t count, const uint8_t *buffer);
+
+/* for use in target64 io wrappers: If address == DAPBUS based, use the dap route instead */
+int target_cs_read_buffer_wrapper(struct target *target, const struct target_addr *pAddr,
+							   uint64_t size, uint8_t *buffer);
+
+/* for use in target64 io wrappers: If address == DAPBUS based, use the dap route instead */
+int target_cs_write_buffer_wrapper(struct target *target, const struct target_addr *pAddr,
+								uint64_t size, const uint8_t *buffer);
+
+
 int target_cs_connect_dap( struct target *target);
 
 
-- 
1.9.1


From 99f5137ee790d6919b1d91116ed4099eb7c9ce60 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 85/94] Always insert a delay for DAP transactions

---
 src/target/adi_v5_jtag.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index d2521a6..5798bc9 100755
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -132,13 +132,14 @@ static int adi_jtag_dp_scan(struct adiv5_dap *dap,
 
 	int n;
 	n = dap_get_memacces_tck(dap);
-
+#if 0
 	/* if not a memory transaction */
 	if( instr != JTAG_DP_APACC ){
 		/* no delay required for DP or ABORT */
 		n = 0;
 	}
 
+	/* ALWAYS insert a delay */
 	/* Delays involve these registers */
 	/* note: All BD0/1/2/3 are in the same bank, ie: 0x010 to 0x1F */
 	if( instr == JTAG_DP_APACC ){
@@ -157,7 +158,7 @@ static int adi_jtag_dp_scan(struct adiv5_dap *dap,
 			break;
 		}
 	}
-
+#endif
 	if( n ){
 		// LOG_DEBUG("dap delay: %d clocks", n );
 		jtag_add_runtest(n, TAP_IDLE);
-- 
1.9.1


From 4a96a1d7f7d56ca98598202e5c003dc072c0ace1 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 86/94] Clean up Queued vrs Atomic DAP IO

---
 src/target/arm_adi_v5.c               | 273 ++++++++++++-----------------
 src/target/arm_adi_v5.h               |  57 +++---
 src/target/arm_adi_v5_debug.c         |  13 +-
 src/target/arm_adi_v5_mem_ap.c        |   5 +-
 src/target/coresight_io.c             | 301 +++++++++++++-------------------
 src/target/cortex_a.c                 | 127 +++++++-------
 src/target/cortex_a53.c               | 319 ++++++++++++++++++----------------
 src/target/cortex_m.c                 | 146 ++++++++++------
 tcl/qualcomm/common/jtag_dap_cfg1.cfg |   2 +-
 9 files changed, 594 insertions(+), 649 deletions(-)
 mode change 100644 => 100755 src/target/arm_adi_v5_debug.c
 mode change 100644 => 100755 src/target/arm_adi_v5_mem_ap.c
 mode change 100644 => 100755 src/target/coresight_io.c
 mode change 100644 => 100755 tcl/qualcomm/common/jtag_dap_cfg1.cfg

diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 38a53d1..73a90e6 100755
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -81,7 +81,6 @@
 struct adiv5_dap *all_daps;
 jim_wide dap_debug_flags;
 
-static uint32_t dummy_u32[10];
 
 
 void dap_update_select_reg_cache( struct adiv5_dap *dap, int apsel, int apbanksel, int dpbanksel )
@@ -118,11 +117,15 @@ void dap_update_select_reg_cache( struct adiv5_dap *dap, int apsel, int apbankse
 
 	/* did the value change? */
 	if( dap->cached_select_reg_value == v ){
+#if 0
 		LOG_DEBUG("DAP-select (old=0x%08x, v=0x%08x) match",
 				  dap->cached_select_reg_value,v);
+#endif
 	} else {
+#if 0
 		LOG_DEBUG("DAP-select (old=0x%08x, v=0x%08x) invalidating",
 				  dap->cached_select_reg_value,v);
+#endif
 		dap->cached_select_reg_valid = 0;
 	}
 	dap->cached_select_reg_value = v;
@@ -331,6 +334,7 @@ static int dap_setup_accessport_tar(struct adiv5_dap *dap, uint64_t address )
 		return ERROR_OK;
 	}
  doit:
+	port->cached_tar_valid = false;
 	r = ERROR_OK;
 
 	/* Some SOCs have mixed port sizes */
@@ -339,21 +343,11 @@ static int dap_setup_accessport_tar(struct adiv5_dap *dap, uint64_t address )
 		uint64_t a2;
 		a2 = address >> 32;
 
-		r = dap_run(dap);
-		if( r != ERROR_OK ){
-			return;
-		}
-		
 		LOG_DEBUG("port: %d is 64bit - writing TAR hi", port->port_num );
-#if 0	  
-		r = dap_ap_write_atomic(dap, AP_MEM_REG_TAR_hi, a2 );
-		/* write LOW */
-		r = dap_ap_write_atomic(dap, AP_MEM_REG_TAR_lo, address );
-#else
 		r = dap_queue_ap_write(dap, AP_MEM_REG_TAR_hi, a2 );
-		/* write LOW */
-		r = dap_ap_write_atomic(dap, AP_MEM_REG_TAR_lo, address );
-#endif
+		if( r == ERROR_OK ){
+		  r = dap_queue_ap_write(dap, AP_MEM_REG_TAR_lo, address );
+		}
 	} else {
 		/* write LOW */
 		r = dap_queue_ap_write(dap, AP_MEM_REG_TAR_lo, address );
@@ -787,188 +781,146 @@ int coresight_io_bulk( struct coresight_bulk *bulk )
 	return r;
 }
 
-
-/**
- * Asynchronous (queued) read of a word from memory or a system register.
+/* Setup a RD/WR operation for some memory location
  *
- * @param dap The DAP connected to the MEM-AP performing the read.
- * @param address Address of the 32-bit word to read; it must be
- *	readable by the currently selected MEM-AP.
- * @param value points to where the word will be stored when the
- *	transaction queue is flushed (assuming no errors).
+ * This is *OPTIMIZED* to read specific small memory ranges.
+ * You will notice that the ARM CPU control registers are:
+ *  (1) always on a 16byte boundary.
+ *  (2) and are *nicely* grouped together in groups of 4
  *
- * @return ERROR_OK for success.  Otherwise a fault code.
+ * These 4 register - being next to each other and aligned
+ * make it very adventagous to use the BANKED BD0/1/2/3
+ * registers to read and write memory locations
  */
-int mem_ap_read_u32(struct adiv5_dap *dap, const struct target_addr *pAddr,
-		uint32_t *value)
+
+static int coresight_queued_xxXX( struct adiv5_dap *dap, const struct target_addr *pAddr, uint64_t ofset, int *bdnum, uint32_t csw )
 {
-	int retval;
 	int r;
+	struct target_addr tmp;
 
-	/* Use banked addressing (REG_BDx) to avoid some link traffic
-	 * (updating TAR) when reading several consecutive addresses.
-	 */
-	  
-	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF,	pAddr);
-	if (retval != ERROR_OK)
-		return retval;
-
-	if( dap_debug(DAP_DBG_MEM_AP_IO) ){
-		struct dap_access_log *p;
-		p = dap_dbg_log_entry(dap);
-		if( p ){
-			p->access_type = MEM_AP_RD32;
-			p->address     = pAddr->addr;
-			p->pointer     = value;
-			p->bytelen     = 4;
-			dap_dbg_set_regname( dap, p );
-		}
-	}
-	
-	r = dap_queue_ap_read(dap, AP_MEM_REG_BD0 | (pAddr->addr & 0xC), value);
+	tmp = *pAddr;
+	tmp.addr += ofset;
+	/* determine which "BD0/1/2/3" we will use */
+	r = (tmp.addr & 0x0c);
+	r = r + AP_MEM_REG_BD0;
+	*bdnum = r;
+	/* align the address *DOWN* to the BDx base address */
+	tmp.addr &= (~(0x0f));
 	
+	/* Create the CSW bits we care about */
+	csw += CSW_ADDRINC_OFF;
+
+	r = dap_setup_accessport( dap, csw, &tmp );
 	return r;
 }
 
-int mem_ap_read_u64(struct adiv5_dap *dap, const struct target_addr *pAddr,
-		uint64_t *value)
+int coresight_atomic_rd32( struct adiv5_dap *dap, const struct target_addr *pAddr, uint64_t ofset, uint32_t *p32 )
 {
-	uint32_t l,h;
-	int retval;
 	int r;
+	r = coresight_queued_rd32( dap, pAddr, ofset, p32 );
+	if( r == ERROR_OK ){
+		r = dap_run( dap );
+	}
+	return r;
+}
 
-	/* Use banked addressing (REG_BDx) to avoid some link traffic
-	 * (updating TAR) when reading several consecutive addresses.
-	 */
-	  
-	retval = dap_setup_accessport(dap, CSW_64BIT | CSW_ADDRINC_OFF, pAddr );
-	if (retval != ERROR_OK)
-		return retval;
 
-	uint64_t a;
-	a = pAddr->addr;
-
-	if( dap_debug(DAP_DBG_MEM_AP_IO) ){
-		struct dap_access_log *p;
-		p = dap_dbg_log_entry(dap);
-		if( p ){
-			p->access_type = MEM_AP_RD64;
-			p->address     = pAddr->addr;
-			p->pointer     = value;
-			p->bytelen     = 8;
-			dap_dbg_set_regname( dap, p );
-		}
-	}
-	
-	r = dap_queue_ap_read(dap, AP_MEM_REG_BD0 | (a & 0xC), &l);
+int coresight_queued_rd32( struct adiv5_dap *dap, const struct target_addr *pAddr, uint64_t ofset, uint32_t *p32 )
+{
+	int bdnum;
+	int r;
+	r = coresight_queued_xxXX( dap, pAddr, ofset, &bdnum, CSW_32BIT );
 	if( r != ERROR_OK ){
 		return r;
 	}
-	a += 4;
-	r = dap_queue_ap_read(dap, AP_MEM_REG_BD0 | (a & 0xC), &h);
+	r = dap_queue_ap_read( dap, bdnum, p32 );
+	return r;
+}
+
+
+int coresight_atomic_rd64( struct adiv5_dap *dap, const struct target_addr *pAddr, uint64_t ofset, uint64_t *p64 )
+{
+	int r;
+	r = coresight_queued_rd64( dap, pAddr, ofset, p64 );
+	if( r == ERROR_OK ){
+		r = dap_run(dap);
+	}
+	return r;
+}
+
+int coresight_queued_rd64( struct adiv5_dap *dap, const struct target_addr *pAddr, uint64_t ofset, uint64_t *p64 )
+{
+	int bdnum;
+	int r;
+	uint64_t l64,h64;
+	uint32_t l32,h32;
+	r = coresight_queued_xxXX( dap, pAddr, ofset, &bdnum, CSW_64BIT );
 	if( r != ERROR_OK ){
 		return r;
 	}
-
-	r = dap_run(dap);
+	r = dap_queue_ap_read( dap, bdnum+0, &l32);
+	r = dap_ap_read_atomic(dap, bdnum+1, &h32);
 	
-	*value = h;
-	*value = *value << 32;
-	*value = *value + l;
+	l64 = l32;
+	h64 = h32;
+	h64 = h64 << 32;
 	
+	h64 |= l64;
+	*p64 = h64;
 	return r;
 }
 
 
-/**
- * Asynchronous (queued) write of a word to memory or a system register.
- *
- * @param dap The DAP connected to the MEM-AP.
- * @param address Address to be written; it must be writable by
- *	the currently selected MEM-AP.
- * @param value Word that will be written to the address when transaction
- *	queue is flushed (assuming no errors).
- *
- * @return ERROR_OK for success.  Otherwise a fault code.
- */
-int mem_ap_write_u32(struct adiv5_dap *dap, const struct target_addr *pAddr, uint32_t value)
+int coresight_atomic_wr32( struct adiv5_dap *dap, const struct target_addr *pAddr, uint64_t ofset, uint32_t v32 )
 {
-	int retval;
-
-	/* Use banked addressing (REG_BDx) to avoid some link traffic
-	 * (updating TAR) when writing several consecutive addresses.
-	 */
-	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF, pAddr );
-	if (retval != ERROR_OK)
-		return retval;
-
-	if( dap_debug(DAP_DBG_MEM_AP_IO) ){
-		struct dap_access_log *p;
-		p = dap_dbg_log_entry(dap);
-		if( p ){
-			p->access_type = MEM_AP_WR32;
-			p->address     = pAddr->addr;
-			p->dataval     = value;
-			p->bytelen     = 4;
-			dap_dbg_set_regname( dap, p );
-		}
+	int r;
+	r = coresight_queued_wr32( dap, pAddr, ofset, v32 );
+	if( r == ERROR_OK ){
+		r = dap_run( dap );
 	}
-	
-	return dap_queue_ap_write(dap, AP_MEM_REG_BD0 | (pAddr->addr & 0xC),
-			value);
+	return r;
 }
 
-/**
- * Asynchronous (queued) write of a word to memory or a system register.
- *
- * @param dap The DAP connected to the MEM-AP.
- * @param address Address to be written; it must be writable by
- *	the currently selected MEM-AP.
- * @param value Word that will be written to the address when transaction
- *	queue is flushed (assuming no errors).
- *
- * @return ERROR_OK for success.  Otherwise a fault code.
- */
-int mem_ap_write_u64(struct adiv5_dap *dap, const struct target_addr *pAddr, uint64_t value)
+
+int coresight_queued_wr32( struct adiv5_dap *dap, const struct target_addr *pAddr, uint64_t ofset, uint32_t v32 )
 {
-	int retval;
-	struct adiv5_dap_port *port;
+	int bdnum;
+	int r;
+	r = coresight_queued_xxXX( dap, pAddr, ofset, &bdnum, CSW_32BIT );
+	if( r != ERROR_OK ){
+		return r;
+	}
+	r = dap_queue_ap_write( dap, bdnum, v32 );
+	return r;
+}
 
-	port = dap_current_port( dap );
 
-	if( !(port->data_64bit) ){
-		LOG_ERROR("target port does not support 64bit data transfers");
-		return ERROR_TARGET_UNALIGNED_ACCESS;
+int coresight_atomic_wr64( struct adiv5_dap *dap, const struct target_addr *pAddr, uint64_t ofset, uint64_t v64 )
+{
+	int r;
+	r = coresight_queued_wr64( dap, pAddr, ofset, v64 );
+	if( r == ERROR_OK ){
+		r = dap_run( dap );
 	}
+	return r;
+}
 
-	/* Use banked addressing (REG_BDx) to avoid some link traffic
-	 * (updating TAR) when writing several consecutive addresses.
-	 */
-	retval = dap_setup_accessport(dap, CSW_32BIT | CSW_ADDRINC_OFF, pAddr );
-	if (retval != ERROR_OK)
-		return retval;
 
-	if( dap_debug(DAP_DBG_MEM_AP_IO) ){
-		struct dap_access_log *p;
-		p = dap_dbg_log_entry(dap);
-		if( p ){
-			p->access_type = MEM_AP_WR64;
-			p->address     = pAddr->addr;
-			p->dataval     = value;
-			p->bytelen     = 8;
-			dap_dbg_set_regname( dap, p );
-		}
+int coresight_queued_wr64( struct adiv5_dap *dap, const struct target_addr *pAddr, uint64_t ofset, uint64_t v64 )
+{
+	int bdnum;
+	int r;
+	r = coresight_queued_xxXX( dap, pAddr, ofset, &bdnum, CSW_64BIT );
+	if( r != ERROR_OK ){
+		return r;
 	}
-	
-	uint64_t a;
-	a = pAddr->addr;
-	dap_queue_ap_write(dap, AP_MEM_REG_BD0 | (a & 0xC), value);
-	/* FIX ME handle endianess */
-	value = value >> 32;
-	a += 4;
-	return dap_queue_ap_write(dap, AP_MEM_REG_BD0 | (a & 0xC), value);
+	r = dap_queue_ap_write( dap, bdnum+0, v64 );
+	v64 = v64 >> 32;
+	r = dap_queue_ap_write( dap, bdnum+1, v64 );
+	return r;
 }
 
+
 static int dap_mem_ap_read_tar( struct adiv5_dap *dap, uint64_t *tar )
 {
 	uint32_t l,h;
@@ -1787,13 +1739,8 @@ struct dap_rom_io {
 
 static int dap_rom_read( struct dap_rom_io *p, uint32_t ofset, uint32_t *val )
 {
-	struct target_addr a;
 	int r;
-
-	a = p->base_addr;
-	a.addr += ofset;
-
-	r =  mem_ap_read_atomic_u32( p->dap, &a, val );
+	r =  coresight_atomic_rd32( p->dap, &(p->base_addr), ofset, val );
 	return r;
 }
 
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index db97a2c..83193af 100755
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -348,6 +348,17 @@ struct coresight_bulk {
 
 int coresight_io_bulk( struct coresight_bulk *pBulk );
 
+int coresight_queued_rd32( struct adiv5_dap *dap, const struct target_addr *pA, uint64_t ofset, uint32_t *puthere );
+int coresight_queued_wr32( struct adiv5_dap *dap, const struct target_addr *pA, uint64_t ofset, uint32_t value );
+int coresight_queued_rd64( struct adiv5_dap *dap, const struct target_addr *pA, uint64_t ofset, uint64_t *puthere );
+int coresight_queued_wr64( struct adiv5_dap *dap, const struct target_addr *pA, uint64_t ofset, uint64_t value );
+
+int coresight_atomic_rd32( struct adiv5_dap *dap, const struct target_addr *pA, uint64_t ofset, uint32_t *puthere );
+int coresight_atomic_wr32( struct adiv5_dap *dap, const struct target_addr *pA, uint64_t ofset, uint32_t value );
+int coresight_atomic_rd64( struct adiv5_dap *dap, const struct target_addr *pA, uint64_t ofset, uint64_t *puthere );
+int coresight_atomic_wr64( struct adiv5_dap *dap, const struct target_addr *pA, uint64_t ofset, uint64_t value );
+
+
 
 void dap_dbg_add_names( struct adiv5_dap *dap,
 			/* what port number is this on */
@@ -486,17 +497,6 @@ void dap_ap_select(struct adiv5_dap *dap, int ap );
 void dap_invalidate_port_cache( struct adiv5_dap *dap );
 /* Queued AP transactions */
 
-/* Queued MEM-AP memory mapped single word transfers */
-int mem_ap_read_u32(struct adiv5_dap *swjdp, const struct target_addr *pAddr, uint32_t *value);
-int mem_ap_write_u32(struct adiv5_dap *swjdp, const struct target_addr *pAddr, uint32_t value);
-
-int mem_ap_read_u64(struct adiv5_dap *swjdp, const struct target_addr *pAddr, uint64_t *value);
-int mem_ap_write_u64(struct adiv5_dap *swjdp, const struct target_addr *pAddr, uint64_t value);
-
-/* Synchronous MEM-AP memory mapped single word transfers */
-int mem_ap_read_atomic_u32(struct adiv5_dap *swjdp, const struct target_addr *pAddr, uint32_t *value);
-int mem_ap_write_atomic_u32(struct adiv5_dap *swjdp, const struct target_addr *pAddr, uint32_t value);
-
 struct target;
 
 /* Initialisation of the debug system, power domains and registers */
@@ -672,22 +672,11 @@ int target_addr_resolve_route( struct target *target,
 
 struct adiv5_dap *target_cs_to_dap( struct target *target );
 
-int target_cs_rd32( struct target *target, const struct target_addr *addr, uint32_t *value );
-int target_cs_rd64( struct target *target, const struct target_addr *addr, uint64_t *value );
-int target_cs_wr32( struct target *target, const struct target_addr *addr, uint32_t value );
-int target_cs_wr64( struct target *target, const struct target_addr *addr, uint64_t value );
-
-int target_cs_addr_queued_rd32( struct target *target, const struct target_addr *addr, uint32_t *value );
-int target_cs_addr_queued_rd64( struct target *target, const struct target_addr *addr, uint64_t *value );
-int target_cs_addr_queued_wr32( struct target *target, const struct target_addr *addr, uint32_t value );
-int target_cs_addr_queued_wr64( struct target *target, const struct target_addr *addr, uint64_t value );
 
-int target_cs_dbg_rd32( struct target *target, uint64_t ofset, uint32_t *value );
-/* THINK TWICE about using this  - most DBG registers are 'pairs' of 32bit registers */
-int target_cs_dbg_rd64( struct target *target, uint64_t ofset, uint64_t *value );
-int target_cs_dbg_wr32( struct target *target, uint64_t ofset, uint32_t value );
-/* THINK TWICE about using this  - most DBG registers are 'pairs' of 32bit registers */
-int target_cs_dbg_wr64( struct target *target, uint64_t ofset, uint64_t value );
+int target_cs_dbg_atomic_rd32( struct target *target, uint64_t ofset, uint32_t *value );
+int target_cs_dbg_atomic_rd64( struct target *target, uint64_t ofset, uint64_t *value );
+int target_cs_dbg_atomic_wr32( struct target *target, uint64_t ofset, uint32_t value );
+int target_cs_dbg_atomic_wr64( struct target *target, uint64_t ofset, uint64_t value );
 
 
 int target_cs_dbg_queued_rd32( struct target *target, uint64_t ofset, uint32_t *value );
@@ -696,16 +685,16 @@ int target_cs_dbg_queued_wr32( struct target *target, uint64_t ofset, uint32_t v
 int target_cs_dbg_queued_wr64( struct target *target, uint64_t ofset, uint64_t value );
 
 /* And some [armv8] always have a CTI interface */
-int target_cs_cti_rd32( struct target *target, uint64_t ofset, uint32_t *value );
-int target_cs_cti_rd64( struct target *target, uint64_t ofset, uint64_t *value );
-int target_cs_cti_wr32( struct target *target, uint64_t ofset, uint32_t value );
-int target_cs_cti_wr64( struct target *target, uint64_t ofset, uint64_t value );
+int target_cs_cti_atomic_rd32( struct target *target, uint64_t ofset, uint32_t *value );
+
+int target_cs_cti_atomic_wr32( struct target *target, uint64_t ofset, uint32_t value );
+
 
 /* And some [armv8] always have a MEM interface */
-int target_cs_mem_rd32( struct target *target, uint64_t ofset, uint32_t *value );
-int target_cs_mem_rd64( struct target *target, uint64_t ofset, uint64_t *value );
-int target_cs_mem_wr32( struct target *target, uint64_t ofset, uint32_t value );
-int target_cs_mem_wr64( struct target *target, uint64_t ofset, uint64_t value );
+int target_cs_mem_atomic_rd32( struct target *target, uint64_t ofset, uint32_t *value );
+int target_cs_mem_atomic_rd64( struct target *target, uint64_t ofset, uint64_t *value );
+int target_cs_mem_atomic_wr32( struct target *target, uint64_t ofset, uint32_t value );
+int target_cs_mem_atomic_wr64( struct target *target, uint64_t ofset, uint64_t value );
 
 
 int target_cs_rd_bulk( struct target *target,
diff --git a/src/target/arm_adi_v5_debug.c b/src/target/arm_adi_v5_debug.c
old mode 100644
new mode 100755
index 458ee92..09702ee
--- a/src/target/arm_adi_v5_debug.c
+++ b/src/target/arm_adi_v5_debug.c
@@ -480,6 +480,7 @@ int dap_run(struct adiv5_dap *dap)
 {
 	int r;
 	assert(dap->driver.ops != NULL);
+	LOG_DEBUG("DAP FLUSH");
 	r = dap->driver.ops->run(dap);
 	dap_dbg_log_dump( dap );
 	return r;
@@ -534,7 +535,6 @@ void dap_dbg_add_regs( struct adiv5_dap *dap,
 					   const struct dap_coresight_name *regs )
 {
 	struct dap_coresight_namelist **nl;
-	struct dap_coresight_namelist *new_nl;
 	struct dap_coresight_block *block;
 	uint32_t pn;
 	int x;
@@ -555,15 +555,15 @@ void dap_dbg_add_regs( struct adiv5_dap *dap,
 
 	/* create if needed */
 	if( *nl == NULL ){
-		new_nl = calloc( 1, sizeof(*nl) );
+		struct dap_coresight_namelist *new_nl;
+		new_nl = calloc( 1, sizeof(*new_nl) );
 		if( new_nl == NULL ){
 			LOG_DEBUG("no memory :-(");
 			return;
 		}
 		new_nl->portnum = pn;
-		new_nl->next    = dap->dbg.namelist;
-		dap->dbg.namelist = new_nl;
-	}
+		*nl = new_nl;
+	} 
 
 	/* create the new block */
 	block = calloc( 1, sizeof(*block) );
@@ -630,7 +630,8 @@ void dap_dbg_add_regs( struct adiv5_dap *dap,
 		}			
 	}
 	/* if we get here - we have a valid block */
+	/* insert at front of block list */
 	block->next = (*nl)->blocks;
-	new_nl->blocks = block;
+	(*nl)->blocks = block;
 }
 
diff --git a/src/target/arm_adi_v5_mem_ap.c b/src/target/arm_adi_v5_mem_ap.c
old mode 100644
new mode 100755
index 6f1ec08..c50941f
--- a/src/target/arm_adi_v5_mem_ap.c
+++ b/src/target/arm_adi_v5_mem_ap.c
@@ -13,6 +13,7 @@
 
 
 
+#if 0
 
 /**
  * Synchronous read of a word from memory or a system register.
@@ -51,7 +52,9 @@ int mem_ap_read_atomic_u64(struct adiv5_dap *dap, const struct target_addr *pAdd
 	return retval;
 }
 
+#endif
 
+#if 0
 /**
  * Synchronous write of a word to memory or a system register.
  * As a side effect, this flushes any queued transactions.
@@ -81,5 +84,5 @@ int mem_ap_write_atomic_u64(struct adiv5_dap *dap, const struct target_addr *pAd
 
 	return retval;
 }
-
+#endif
 
diff --git a/src/target/coresight_io.c b/src/target/coresight_io.c
old mode 100644
new mode 100755
index 0ca2e3f..ecb10f2
--- a/src/target/coresight_io.c
+++ b/src/target/coresight_io.c
@@ -184,33 +184,7 @@ int target_cs_discover_ap( struct target *target, enum ap_type findme, struct co
 
 
 
-int target_cs_queued_rd32( struct target *target,
-						   const struct target_addr *p,
-						   uint32_t *value )
-{
-	return mem_ap_read_u32( target_cs_to_dap(target),
-				    p,
-				    value );
-}
-
-
-
-int target_cs_queued_wr32( struct target *target, const struct target_addr *p, uint32_t value )
-{
-	return mem_ap_write_u32( target_cs_to_dap(target), p, value );
-}
 
-int target_cs_queued_rd64( struct target *target, const struct target_addr *p, uint64_t *value )
-{
-	return mem_ap_read_u64( target_cs_to_dap(target), p, value );
-}
-
-
-
-int target_cs_queued_wr64( struct target *target, const struct target_addr *p, uint64_t value )
-{
-	return mem_ap_write_u64( target_cs_to_dap(target), p, value );
-}
 
 static struct target_addr *target_cs_dbg_addr( struct target *target )
 {
@@ -231,10 +205,10 @@ static struct target_addr *target_cs_mem_addr( struct target *target )
 
 int target_cs_dbg_queued_rd32( struct target *target, uint64_t addr, uint32_t *value )
 {
-	struct target_addr a = *target_cs_dbg_addr(target);
-	a.addr += addr;
-  
-	return mem_ap_read_u32( target_cs_to_dap(target), &a, value );
+	return coresight_queued_rd32( target_cs_to_dap(target), 
+								  target_cs_dbg_addr(target), 
+								  addr, 
+								  value );
 }
 
 
@@ -347,77 +321,32 @@ int target_cs_wr_bulk( struct target *target,  const struct target_addr *addr,
 }
 
 
-
-int target_cs_wr64( struct target *target, const struct target_addr *p, uint64_t value )
-{
-	int r;
-	r = target_cs_queued_wr64( target, p, value );
-	if(r == ERROR_OK ){
-		r = target_cs_dap_run( target );
-	}
-	return r;
-}
-
-
-
-
-int target_cs_wr32( struct target *target, const struct target_addr *p, uint32_t value )
-{
-	int r;
-	r = target_cs_queued_wr32( target, p, value );
-	if(r == ERROR_OK ){
-		r = target_cs_dap_run(target);
-	}
-	return r;
-}
-
-int target_cs_rd32( struct target *target, const struct target_addr *p, uint32_t *value )
-{
-	int r;
-	r = target_cs_queued_rd32( target, p, value );
-	if( r == ERROR_OK ){
-		r = target_cs_dap_run(target);
-	}
-	return r;
-}
-
-int target_cs_dbg_rd32( struct target *target, uint64_t addr, uint32_t *value )
+int target_cs_dbg_atomic_rd32( struct target *target, uint64_t addr, uint32_t *value )
 {
-	struct target_addr a = *target_cs_dbg_addr(target);
-	a.addr += addr;
-
-	return target_cs_rd32( target, &a, value );
+	return coresight_atomic_rd32( target_cs_to_dap(target), 
+								  target_cs_dbg_addr(target), 
+								  addr,
+								  value );
 }
 
-int target_cs_dbg_wr32( struct target *target,uint64_t addr, uint32_t value )
+int target_cs_dbg_atomic_wr32( struct target *target,uint64_t addr, uint32_t value )
 {
-	struct target_addr a = *target_cs_dbg_addr(target);
-	a.addr += addr;
-
-	return target_cs_wr32( target, &a, value );
+	return coresight_atomic_wr32( target_cs_to_dap(target), 
+								  target_cs_dbg_addr(target), 
+								  addr,
+								  value );
 }
 
 
 int target_cs_dbg_queued_wr32( struct target *target, uint64_t addr, uint32_t value )
 {
-	struct target_addr a = *target_cs_dbg_addr(target);
-	a.addr += addr;
-
-	return target_cs_queued_wr32( target, &a, value );
+	return coresight_queued_wr32( target_cs_to_dap(target),
+								  target_cs_dbg_addr(target), 
+								  addr, value );
 }
 
 
-int target_cs_rd64( struct target *target, const struct target_addr *p, uint64_t *value )
-{
-	int r;
-	r = target_cs_queued_rd64( target, p, value );
-	if( r == ERROR_OK ){
-		r = target_cs_dap_run(target);
-	}
-	return r;
-}
 
-/* does this targets DEBUG port support 64bit data transfers? */
 static struct adiv5_dap_port *target_cs_dbgport( struct target *target )
 {
 	int x;
@@ -435,68 +364,88 @@ static struct adiv5_dap_port *target_cs_dbgport( struct target *target )
 }
 	
 
-int target_cs_dbg_rd64( struct target *target,uint64_t addr, uint64_t *value )
+int target_cs_dbg_atomic_rd64( struct target *target,uint64_t addr, uint64_t *value )
 {
-	uint64_t a64,b64;
-	uint32_t a32,b32;
 	int r;
-	struct target_addr a = *target_cs_dbg_addr(target);
-	struct adiv5_dap_port *port;	
-	a.addr += addr;
+	struct adiv5_dap *dap;
+	struct adiv5_dap_port *port;
+	const struct target_addr *pAddr;
+	uint64_t l64,h64;
+	uint32_t l32,h32;
 
-	/* get the debug port */
-	port = target_cs_dbgport( target );
-	if( port == NULL ){
-		LOG_ERROR("TARGET: %s no dbg port!", target_name(target));
-		return ERROR_FAIL;
-	}
+	dap   = target_cs_to_dap(target);
+	port  = target_cs_dbgport(target);
+	pAddr = target_cs_dbg_addr(target);
 
-	/* if it supports 64bit - just use it */
 	if( port->data_64bit ){
-		return target_cs_rd64( target, &a, value );
+		return coresight_atomic_rd64( dap, 
+									  pAddr,
+									  addr,
+									  value );
 	}
 
-	/* otherwise fake it */
-	/* always read in increasing order */
-	r = target_cs_rd32( target, &a, &a32 );
-	if( r == ERROR_OK ){
-		a.addr += 4;
-		r = target_cs_rd32( target, &a, &b32 );
+	if( port->big_endian ){
+		r = coresight_queued_rd32( dap,
+								   pAddr,
+								   addr,
+								   &h32 );
+	} else {
+		r = coresight_queued_rd32( dap,
+								   pAddr,
+								   addr,
+								   &l32 );
+	}
+
+	if( r != ERROR_OK ){
+		return r;
 	}
-	/* reassemble the value */
-	a64 = a32;
-	b64 = b32;
+
+	addr += 4;
+
 	if( port->big_endian ){
-		a64 = a64 << 32;
+		r = coresight_atomic_rd32( dap,
+								   pAddr,
+								   addr,
+								   &l32 );
 	} else {
-		b64 = b64 << 32;
+		r = coresight_atomic_rd32( dap,
+								   pAddr,
+								   addr,
+								   &h32 );
 	}
-	a64 = a64 | b64;
-	if( value ){
-		*value = a64;
+
+	if( r != ERROR_OK ){
+		return r;
 	}
+
+	l64 = l32;
+	h64 = h32;
+	
+	h64 = h64 << 32;
+	h64 = h64 | l64;
+
+	*value = h64;
 	return r;
 }
 
 
-int target_cs_dbg_wr64( struct target *target,uint64_t addr, uint64_t value )
+int target_cs_dbg_atomic_wr64( struct target *target,uint64_t addr, uint64_t value )
 {
-	uint64_t a64,b64;
 	int r;
-	struct target_addr a = *target_cs_dbg_addr(target);
+	struct adiv5_dap *dap;
 	struct adiv5_dap_port *port;
-	a.addr += addr;
+	const struct target_addr *pAddr;
+	uint64_t a64,b64;
 
-	/* get the debug port */
-	port = target_cs_dbgport( target );
-	if( port == NULL ){
-		LOG_ERROR("TARGET: %s no dbg port!", target_name(target));
-		return ERROR_FAIL;
-	}
+	dap   = target_cs_to_dap(target);
+	port  = target_cs_dbgport(target);
+	pAddr = target_cs_dbg_addr(target);
 
-	/* if it supports 64bit - just use */
 	if( port->data_64bit ){
-		return target_cs_wr64( target, &a, value );
+		return coresight_atomic_wr64( dap, 
+									  pAddr,
+									  addr,
+									  value );
 	}
 
 	a64 = value;
@@ -506,86 +455,73 @@ int target_cs_dbg_wr64( struct target *target,uint64_t addr, uint64_t value )
 	} else {
 		b64 = b64 >> 32;
 	}
-	
-	/* always read in increasing order */
-	r = target_cs_wr32( target, &a, a64 );
-	a.addr += 4;
+
+	r = coresight_queued_wr32( dap, 
+							   pAddr,
+							   addr + 0,
+							   a64 );
 	if( r == ERROR_OK ){
-		r = target_cs_wr32( target, &a, b64 );
+		r = coresight_atomic_wr32( dap,
+								   pAddr,
+								   addr + 4,
+								   b64 );
 	}
-	
-	return r;
-}
-
 
-int target_cs_cti_rd32( struct target *target, uint64_t addr, uint32_t *value )
-{
-	struct target_addr a = *target_cs_cti_addr(target);
-	a.addr += addr;
-
-	return target_cs_rd32( target, &a, value );
+	return r;
 }
 
 
-int target_cs_cti_wr32( struct target *target,uint64_t addr, uint32_t value )
+int target_cs_cti_atomic_rd32( struct target *target, uint64_t addr, uint32_t *value )
 {
-	struct target_addr a = *target_cs_cti_addr(target);
-	a.addr += addr;
-
-	return target_cs_wr32( target, &a, value );
+	return coresight_atomic_rd32( target_cs_to_dap(target), 
+								  target_cs_cti_addr(target), 
+								  addr, 
+								  value );
 }
 
 
-int target_cs_cti_rd64( struct target *target,uint64_t addr, uint64_t *value )
+int target_cs_cti_atomic_wr32( struct target *target,uint64_t addr, uint32_t value )
 {
-	struct target_addr a = *target_cs_cti_addr(target);
-	a.addr += addr;
-
-	return target_cs_rd64( target, &a, value );
+	return coresight_atomic_wr32( target_cs_to_dap(target), 
+								  target_cs_cti_addr(target), 
+								  addr, 
+								  value );
 }
 
 
-int target_cs_cti_wr64( struct target *target,uint64_t addr, uint64_t value )
-{
-	struct target_addr a = *target_cs_cti_addr(target);
-	a.addr += addr;
-
-	return target_cs_wr64( target, &a, value );
-}
-
-int target_cs_mem_rd32( struct target *target, uint64_t addr, uint32_t *value )
+int target_cs_mem_atomic_rd32( struct target *target, uint64_t addr, uint32_t *value )
 {
-	struct target_addr a = *target_cs_mem_addr(target);
-	a.addr += addr;
-
-	return target_cs_rd32( target, &a, value );
+	return coresight_atomic_rd32( target_cs_to_dap(target), 
+								  target_cs_mem_addr(target), 
+								  addr, 
+								  value );
 }
 
 
-int target_cs_mem_wr32( struct target *target,uint64_t addr, uint32_t value )
+int target_cs_mem_atomic_wr32( struct target *target,uint64_t addr, uint32_t value )
 {
-	struct target_addr a = *target_cs_mem_addr(target);
-	a.addr += addr;
-
-	return target_cs_wr32( target, &a, value );
+	return coresight_atomic_wr32( target_cs_to_dap(target), 
+								  target_cs_mem_addr(target), 
+								  addr, 
+								  value );
 }
 
 
-int target_cs_mem_rd64( struct target *target,uint64_t addr, uint64_t *value )
+int target_cs_mem_atomic_rd64( struct target *target,uint64_t addr, uint64_t *value )
 {
-	struct target_addr a = *target_cs_mem_addr(target);
-	a.addr += addr;
-
-	return target_cs_rd64( target, &a, value );
+	return coresight_atomic_rd64( target_cs_to_dap(target), 
+								  target_cs_mem_addr(target), 
+								  addr, 
+								  value );
 }
 
 
-int target_cs_mem_wr64( struct target *target,uint64_t addr, uint64_t value )
+int target_cs_mem_atomic_wr64( struct target *target,uint64_t addr, uint64_t value )
 {
-	struct target_addr a = *target_cs_mem_addr(target);
-	a.addr += addr;
-
-	return target_cs_wr64( target, &a, value );
+	return coresight_atomic_wr64( target_cs_to_dap(target), 
+								  target_cs_mem_addr(target), 
+								  addr, 
+								  value );
 }
 
 
@@ -633,6 +569,7 @@ int target_cs_dbg_rd_bulk( struct target *target,  uint64_t addr,
 	return target_cs_rd_bulk( target, &a, size, count, buffer );
 }
 
+
 int target_cs_mem_wr_bulk( struct target *target,  uint64_t addr, 
 						   size_t size, size_t count, const void *buffer )
 {
@@ -656,6 +593,8 @@ int target_cs_mem_rd_bulk( struct target *target,  uint64_t addr,
 }
 
 
+
+
 int target_cs_read_memory_wrapper( struct target *target, const struct target_addr *pAddr,
 							  uint64_t size, uint64_t count, uint8_t *buffer)
 {
diff --git a/src/target/cortex_a.c b/src/target/cortex_a.c
index cfc6cde..559ee0d 100755
--- a/src/target/cortex_a.c
+++ b/src/target/cortex_a.c
@@ -180,7 +180,7 @@ static int cortex_a_init_debug_access(struct target *target)
 
 	/* Strong Qu: Write 0 to DBGOSLAR(OS Lock Access Register, FC33_0300) */
 	LOG_USER("Clear DBGOSLAR.");
-	retval = target_cs_dbg_wr32( target, CPUDBG_OSLAR, 0);
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_OSLAR, 0);
 	if (retval != ERROR_OK){
 		LOG_USER("Failed to clear DBGOSLAR.");
 		return retval;
@@ -188,19 +188,20 @@ static int cortex_a_init_debug_access(struct target *target)
 
 	/* Unlocking the debug registers for modification
 	 * The debugport might be uninitialised so try twice */
-	retval = target_cs_dbg_wr32( target, CPUDBG_LOCKACCESS, 0xC5ACCE55);
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_LOCKACCESS, 0xC5ACCE55);
 	if (retval != ERROR_OK) {
 		/* try again */
-		retval = target_cs_dbg_wr32( target, CPUDBG_LOCKACCESS, 0xC5ACCE55);
+		retval = target_cs_dbg_atomic_wr32( target, CPUDBG_LOCKACCESS, 0xC5ACCE55);
 		if (retval == ERROR_OK)
 			LOG_USER(
 				"Locking debug access failed on first, but succeeded on second try.");
 	}
 	if (retval != ERROR_OK)
 		return retval;
+
 	/* Clear Sticky Power Down status Bit in PRSR to enable access to
 	   the registers in the Core Power Domain */
-	retval = target_cs_dbg_rd32( target, CPUDBG_PRSR, &dummy);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_PRSR, &dummy);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -230,7 +231,7 @@ static int cortex_a_exec_opcode(struct target *target,
 	/* Wait for InstrCompl bit to be set */
 	long long then = timeval_ms();
 	while ((dscr & DSCR_INSTR_COMP) == 0) {
-		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK) {
 			LOG_ERROR("Could not read DSCR register, opcode = 0x%08" PRIx32, opcode);
 			return retval;
@@ -247,7 +248,7 @@ static int cortex_a_exec_opcode(struct target *target,
 
 	then = timeval_ms();
 	do {
-		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK) {
 			LOG_ERROR("Could not read DSCR register");
 			return retval;
@@ -336,7 +337,7 @@ static int cortex_a_dap_read_coreregister_u32(struct target *target,
 	/* Wait for DTRRXfull then read DTRRTX */
 	long long then = timeval_ms();
 	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
-		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			return retval;
 		if (timeval_ms() > then + 1000) {
@@ -345,7 +346,7 @@ static int cortex_a_dap_read_coreregister_u32(struct target *target,
 		}
 	}
 
-	retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, value);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, value);
 	LOG_DEBUG("read DCC 0x%08" PRIx32, *value);
 
 	return retval;
@@ -361,7 +362,7 @@ static int cortex_a_dap_write_coreregister_u32(struct target *target,
 	LOG_DEBUG("register %i, value 0x%08" PRIx32, regnum, value);
 
 	/* Check that DCCRX is not full */
-	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		return retval;
 	if (dscr & DSCR_DTR_RX_FULL) {
@@ -437,7 +438,7 @@ static int cortex_a_dap_write_coreregister_u32(struct target *target,
  * be the places to enable/disable that mode.
  */
 
-static int cortex_a_write_dcc(struct cortex_a_common *cortex_a, uint32_t data)
+static int cortex_a_write_queued_dcc(struct cortex_a_common *cortex_a, uint32_t data)
 {
 	LOG_DEBUG("write DCC 0x%08" PRIx32, data);
 	return target_cs_dbg_queued_wr32( cortex_a_to_target(cortex_a), CPUDBG_DTRRX, data);
@@ -457,7 +458,7 @@ static int cortex_a_read_dcc(struct cortex_a_common *cortex_a, uint32_t *data,
 	/* Wait for DTRRXfull */
 	long long then = timeval_ms();
 	while ((dscr & DSCR_DTR_TX_FULL) == 0) {
-		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR,&dscr);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR,&dscr);
 		if (retval != ERROR_OK)
 			return retval;
 		if (timeval_ms() > then + 1000) {
@@ -466,7 +467,7 @@ static int cortex_a_read_dcc(struct cortex_a_common *cortex_a, uint32_t *data,
 		}
 	}
 
-	retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, data);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, data);
 	if (retval != ERROR_OK)
 		return retval;
 	/* LOG_DEBUG("read DCC 0x%08" PRIx32, *data); */
@@ -486,7 +487,7 @@ static int cortex_a_dpm_prepare(struct arm_dpm *dpm)
 	/* set up invariant:  INSTR_COMP is set after ever DPM operation */
 	long long then = timeval_ms();
 	for (;; ) {
-		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR,	&dscr);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR,	&dscr);
 		if (retval != ERROR_OK)
 			return retval;
 		if ((dscr & DSCR_INSTR_COMP) != 0)
@@ -526,7 +527,7 @@ static int cortex_a_instr_write_data_dcc(struct arm_dpm *dpm,
 	int retval;
 	uint32_t dscr = DSCR_INSTR_COMP;
 
-	retval = cortex_a_write_dcc(cortex_a, data);
+	retval = cortex_a_write_queued_dcc(cortex_a, data);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -544,7 +545,7 @@ static int cortex_a_instr_write_data_r0(struct arm_dpm *dpm,
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 
-	retval = cortex_a_write_dcc(cortex_a, data);
+	retval = cortex_a_write_queued_dcc(cortex_a, data);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -689,7 +690,7 @@ static int cortex_a_poll(struct target *target)
 		target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 		return retval;
 	}
-	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		return retval;
 	cortex_a->cpudbg_dscr = dscr;
@@ -748,24 +749,24 @@ static int cortex_a_halt(struct target *target)
 	 * Tell the core to be halted by writing DRCR with 0x1
 	 * and then wait for the core to be halted.
 	 */
-	retval = target_cs_dbg_wr32( target, CPUDBG_DRCR, DRCR_HALT);
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_DRCR, DRCR_HALT);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/*
 	 * enter halting debug mode
 	 */
-	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr | DSCR_HALT_DBG_MODE);
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_DSCR, dscr | DSCR_HALT_DBG_MODE);
 	if (retval != ERROR_OK)
 		return retval;
 
 	long long then = timeval_ms();
 	for (;; ) {
-		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			return retval;
 		if ((dscr & DSCR_CORE_HALTED) != 0)
@@ -890,25 +891,25 @@ static int cortex_a_internal_restart(struct target *target)
 	 * disable IRQs by default, with optional override...
 	 */
 
-	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
 	if ((dscr & DSCR_INSTR_COMP) == 0)
 		LOG_ERROR("DSCR InstrCompl must be set before leaving debug!");
 
-	retval = target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr & ~DSCR_ITR_EN);
+	retval = target_cs_dbg_queued_wr32( target, CPUDBG_DSCR, dscr & ~DSCR_ITR_EN);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = target_cs_dbg_wr32( target, CPUDBG_DRCR, DRCR_RESTART |
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_DRCR, DRCR_RESTART |
 			DRCR_CLEAR_EXCEPTIONS);
 	if (retval != ERROR_OK)
 		return retval;
 
 	long long then = timeval_ms();
 	for (;; ) {
-		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			return retval;
 		if ((dscr & DSCR_CORE_RESTARTED) != 0)
@@ -999,7 +1000,7 @@ static int cortex_a_debug_entry(struct target *target)
 	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a->cpudbg_dscr);
 
 	/* REVISIT surely we should not re-read DSCR !! */
-	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1010,7 +1011,7 @@ static int cortex_a_debug_entry(struct target *target)
 
 	/* Enable the ITR execution once we are in debug mode */
 	dscr |= DSCR_ITR_EN;
-	retval = target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr);
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_DSCR, dscr);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1021,7 +1022,7 @@ static int cortex_a_debug_entry(struct target *target)
 	if (target->debug_reason == DBG_REASON_WATCHPOINT) {
 		uint32_t wfar;
 
-		retval = target_cs_dbg_rd32( target, CPUDBG_WFAR,	&wfar);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_WFAR,	&wfar);
 		if (retval != ERROR_OK)
 			return retval;
 		arm_dpm_report_wfar(arm_dpm, wfar);
@@ -1233,16 +1234,16 @@ static int cortex_a_wr_bpwp_reg( struct target *target, struct cortex_a_brp *b )
 
 	if( b->control == 0 ){
 		/* we are disabling, write CR first */
-		retval = target_cs_dbg_wr32( target,
-									 CPUDBG_BCR_BASE + (4 * b->BRPn),
-									 b->control);
+		retval = target_cs_dbg_queued_wr32( target,
+											CPUDBG_BCR_BASE + (4 * b->BRPn),
+											b->control);
 		if( retval != ERROR_OK ){
 			return retval;
 		}
 	}
 	
 	/* this core is 32bit not 64bit */
-	retval = target_cs_dbg_wr32( target, CPUDBG_BVR_BASE + (4 * b->BRPn),
+	retval = target_cs_dbg_queued_wr32( target, CPUDBG_BVR_BASE + (4 * b->BRPn),
 				b->value);
 	if( retval != ERROR_OK ){
 		return retval;
@@ -1250,10 +1251,14 @@ static int cortex_a_wr_bpwp_reg( struct target *target, struct cortex_a_brp *b )
 
 	if( b->control != 0 ){
 		/* we are enabling  write CR last */
-		retval = target_cs_dbg_wr32( target,
+		retval = target_cs_dbg_queued_wr32( target,
 									 CPUDBG_BCR_BASE + (4 * b->BRPn),
 									 b->control);
 	}	
+	if( retval == ERROR_OK ){
+		retval = target_cs_dap_run(target);
+	}
+
 	return retval;
 }
 
@@ -1711,7 +1716,7 @@ static int cortex_a_write_apb_ab_memory(struct target *target,
 	reg->dirty = true;
 
 	/*  clear any abort  */
-	retval = target_cs_dbg_wr32( target, CPUDBG_DRCR, 1<<2);
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_DRCR, 1<<2);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1754,30 +1759,30 @@ static int cortex_a_write_apb_ab_memory(struct target *target,
 	/* We now have a 32 bit aligned buffer that can be written */
 
 	/* Read DSCR */
-	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		goto error_free_buff_w;
 
 	/* Set DTR mode to Fast (2) */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_FAST_MODE;
-	retval = target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr);
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_DSCR, dscr);
 	if (retval != ERROR_OK)
 		goto error_free_buff_w;
 
 	/* Copy the destination address into R0 */
 	/*  - pend an instruction  MRC p14, 0, R0, c5, c0 */
-	retval = target_cs_dbg_wr32( target, CPUDBG_ITR, ARMV4_5_MRC(14, 0, 0, 0, 5, 0));
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_ITR, ARMV4_5_MRC(14, 0, 0, 0, 5, 0));
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 	/* Write address into DTRRX, which triggers previous instruction */
-	retval = target_cs_dbg_wr32( target, CPUDBG_DTRRX, address & (~0x3));
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_DTRRX, address & (~0x3));
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
 	/* Write the data transfer instruction into the ITR
 	 * (STC p14, c5, [R0], 4)
 	 */
-	retval = target_cs_dbg_wr32( target, CPUDBG_ITR, ARMV4_5_STC(0, 1, 0, 1, 14, 5, 0, 4));
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_ITR, ARMV4_5_STC(0, 1, 0, 1, 14, 5, 0, 4));
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
@@ -1793,18 +1798,18 @@ static int cortex_a_write_apb_ab_memory(struct target *target,
 
 	/* Switch DTR mode back to non-blocking (0) */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	retval = target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr);
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_DSCR, dscr);
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
     /* Check for sticky abort flags in the DSCR */
-	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		goto error_free_buff_w;
 	if (dscr & (DSCR_STICKY_ABORT_PRECISE | DSCR_STICKY_ABORT_IMPRECISE)) {
 		/* Abort occurred - clear it and exit */
 		LOG_ERROR("abort occurred - dscr = 0x%08" PRIx32, dscr);
-		target_cs_dbg_wr32( target, CPUDBG_DRCR, 1<<2);
+		target_cs_dbg_atomic_wr32( target, CPUDBG_DRCR, 1<<2);
 		goto error_free_buff_w;
 	}
 
@@ -1814,9 +1819,9 @@ static int cortex_a_write_apb_ab_memory(struct target *target,
 
 error_unset_dtr_w:
 	/* Unset DTR mode */
-	target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+	target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr);
+	target_cs_dbg_atomic_wr32( target, CPUDBG_DSCR, dscr);
 error_free_buff_w:
 	LOG_ERROR("error");
 	free(tmp_buff);
@@ -1860,12 +1865,12 @@ static int cortex_a_read_apb_ab_memory(struct target *target,
 
 	/*  clear any abort  */
 	retval =
-		target_cs_dbg_wr32( target, CPUDBG_DRCR, 1<<2);
+		target_cs_dbg_atomic_wr32( target, CPUDBG_DRCR, 1<<2);
 	if (retval != ERROR_OK)
 		goto error_free_buff_r;
 
 	/* Read DSCR */
-	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 
 	/* This algorithm comes from either :
 	 * Cortex-A TRM Example 12-24
@@ -1875,11 +1880,11 @@ static int cortex_a_read_apb_ab_memory(struct target *target,
 
 	/* Set DTR access mode to stall mode b01  */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_STALL_MODE;
-	retval +=  target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr);
+	retval +=  target_cs_dbg_atomic_wr32( target, CPUDBG_DSCR, dscr);
 
 	/* Write R0 with value 'address' using write procedure for stall mode */
 	/*   - Write the address for read access into DTRRX */
-	retval += target_cs_dbg_wr32( target, CPUDBG_DTRRX, address & ~0x3);
+	retval += target_cs_dbg_atomic_wr32( target, CPUDBG_DTRRX, address & ~0x3);
 	/*  - Copy value from DTRRX to R0 using instruction mrc p14, 0, r0, c5, c0 */
 	cortex_a_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dscr);
 
@@ -1929,25 +1934,25 @@ static int cortex_a_read_apb_ab_memory(struct target *target,
 
 	/* set DTR access mode back to non blocking b00  */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	retval =  target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr);
+	retval =  target_cs_dbg_atomic_wr32( target, CPUDBG_DSCR, dscr);
 	if (retval != ERROR_OK)
 		goto error_free_buff_r;
 
 	/* Wait for the final read instruction to finish */
 	do {
-		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 		if (retval != ERROR_OK)
 			goto error_free_buff_r;
 	} while ((dscr & DSCR_INSTR_COMP) == 0);
 
 	/* Check for sticky abort flags in the DSCR */
-	retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 	if (retval != ERROR_OK)
 		goto error_free_buff_r;
 	if (dscr & (DSCR_STICKY_ABORT_PRECISE | DSCR_STICKY_ABORT_IMPRECISE)) {
 		/* Abort occurred - clear it and exit */
 		LOG_ERROR("abort occurred - dscr = 0x%08" PRIx32, dscr);
-		target_cs_dbg_wr32( target, CPUDBG_DRCR, 1<<2);
+		target_cs_dbg_atomic_wr32( target, CPUDBG_DRCR, 1<<2);
 		goto error_free_buff_r;
 	}
 
@@ -1962,9 +1967,9 @@ static int cortex_a_read_apb_ab_memory(struct target *target,
 
 error_unset_dtr_r:
 	/* Unset DTR mode */
-	target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+	target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	target_cs_dbg_wr32( target, CPUDBG_DSCR, dscr);
+	target_cs_dbg_atomic_wr32( target, CPUDBG_DSCR, dscr);
 error_free_buff_r:
 	LOG_ERROR("error");
 	free(tmp_buff);
@@ -2219,14 +2224,14 @@ static int cortex_a_handle_target_request(void *priv)
 	if (target->state == TARGET_RUNNING) {
 		uint32_t request;
 		uint32_t dscr;
-		retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 
 		/* check if we have data */
 		while ((dscr & DSCR_DTR_TX_FULL) && (retval == ERROR_OK)) {
-			retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &request);
+			retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &request);
 			if (retval == ERROR_OK) {
 				target_request(target, request);
-				retval = target_cs_dbg_rd32( target, CPUDBG_DSCR, &dscr);
+				retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DSCR, &dscr);
 			}
 		}
 	}
@@ -2330,29 +2335,29 @@ static int cortex_a_examine_first(struct target *target)
 				  coreidx, target_addr2str1( target, &coresight->dbgbus.addr));
 	}
 
-	retval = target_cs_dbg_rd32( target, CPUDBG_CPUID, &cpuid);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_CPUID, &cpuid);
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = target_cs_dbg_rd32( target, CPUDBG_CPUID, &cpuid);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_CPUID, &cpuid);
 	if (retval != ERROR_OK) {
 		LOG_DEBUG("Examine %s failed", "CPUID");
 		return retval;
 	}
 
-	retval = target_cs_dbg_rd32( target, CPUDBG_CTYPR, &ctypr);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_CTYPR, &ctypr);
 	if (retval != ERROR_OK) {
 		LOG_DEBUG("Examine %s failed", "CTYPR");
 		return retval;
 	}
 
-	retval = target_cs_dbg_rd32( target, CPUDBG_TTYPR, &ttypr);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_TTYPR, &ttypr);
 	if (retval != ERROR_OK) {
 		LOG_DEBUG("Examine %s failed", "TTYPR");
 		return retval;
 	}
 
-	retval = target_cs_dbg_rd32( target, CPUDBG_DIDR, &didr);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DIDR, &didr);
 	if (retval != ERROR_OK) {
 		LOG_DEBUG("Examine %s failed", "DIDR");
 		return retval;
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index cf44512..4937a50 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -61,22 +61,22 @@ static int isAArch64(uint32_t dscr)
 
 	
 
-static int armv8_cti_wr_RESTART( struct target *target )
+static int armv8_cti_wr_atomic_RESTART( struct target *target )
 {
-	return target_cs_cti_wr32( target, CTIAPPPULSE, 1<<CTIDBGCHAN_RESTART);
+	return target_cs_cti_atomic_wr32( target, CTIAPPPULSE, 1<<CTIDBGCHAN_RESTART);
 }
 
-static int armv8_cti_wr_HALT( struct target *target )
+static int armv8_cti_wr_atomic_HALT( struct target *target )
 {
-	return target_cs_cti_wr32( target, CTIAPPPULSE, 1<<CTIDBGCHAN_HALT);
+	return target_cs_cti_atomic_wr32( target, CTIAPPPULSE, 1<<CTIDBGCHAN_HALT);
 }
 
-static int armv8_cti_rd_STATUS( struct target *target, uint32_t *puthere )
+static int armv8_cti_rd_atomic_STATUS( struct target *target, uint32_t *puthere )
 {
-	return target_cs_cti_rd32( target, CTITRIGOUTSTATUS, puthere );
+	return target_cs_cti_atomic_rd32( target, CTITRIGOUTSTATUS, puthere );
 }
 
-static int armv8_dbg_rd_EDPRSR( struct target *target, uint32_t *puthere )
+static int armv8_dbg_rd_atomic_EDPRSR( struct target *target, uint32_t *puthere )
 {
 	int r;
 	uint32_t v;
@@ -84,7 +84,7 @@ static int armv8_dbg_rd_EDPRSR( struct target *target, uint32_t *puthere )
 	static uint32_t old_EDPRSR;
 	
 
-	r = target_cs_dbg_rd32( target, EDPRSR, &v );
+	r = target_cs_dbg_atomic_rd32( target, EDPRSR, &v );
 	if( r != ERROR_OK ){
 		LOG_DEBUG("rd: edprsr: error: %d", r );
 		old_EDPRSR = (uint32_t)(-1);
@@ -109,24 +109,34 @@ static int armv8_dbg_rd_EDPRSR( struct target *target, uint32_t *puthere )
 
 			  
 
-static int armv8_dbg_wr_EDSCR( struct target *target, uint32_t v )
+static int armv8_dbg_queued_wr_EDSCR( struct target *target, uint32_t v )
 {
 	int r;
 	// LOG_DEBUG("wr: edscr: 0x%08" PRIx32 , v );
-	r = target_cs_dbg_wr32( target, EDSCR, v );
+	r = target_cs_dbg_queued_wr32( target, EDSCR, v );
+	return r;
+}
+ 
+static int armv8_dbg_wr_atomic_EDSCR( struct target *target, uint32_t v )
+{
+	int r;
+	r = armv8_dbg_queued_wr_EDSCR( target, v );
+	if( r == ERROR_OK ){
+	  r = target_cs_dap_run( target );
+	}
 	return r;
 }
 
 #define armv8_edscr_get_HDE(V)  _bitof( 14, (V) )
 #define armv8_edscr_set_HDE(V)  ((V) |= (1 << 14))
 
-static int armv8_dbg_rd_EDSCR( struct target *target, uint32_t *puthere )
+static int armv8_dbg_rd_atomic_EDSCR( struct target *target, uint32_t *puthere )
 {
 	int r;
 	uint32_t v;
 	/* fix me: make this per cpu */
 	static uint32_t old_EDSCR;
-	r = target_cs_dbg_rd32( target, EDSCR, &v );
+	r = target_cs_dbg_atomic_rd32( target, EDSCR, &v );
 
 	if( r != ERROR_OK ){
 		LOG_DEBUG("rd edscr: error: %d", r );
@@ -161,16 +171,16 @@ static int armv8_dbg_rd_EDSCR( struct target *target, uint32_t *puthere )
 }
 
 
-static int armv8_dbg_wr_OSLAR_EL1( struct target *target, uint32_t v)
+static int armv8_dbg_wr_atomic_OSLAR_EL1( struct target *target, uint32_t v)
 {
-	return target_cs_dbg_wr32( target, OSLAR_EL1, v );
+	return target_cs_dbg_atomic_wr32( target, OSLAR_EL1, v );
 }
 
-static int armv8_rd_OSLAR_EL1( struct target *target, uint32_t *v)
+static int armv8_rd_atomic_OSLAR_EL1( struct target *target, uint32_t *v)
 {
 	int r;
 
-	r = target_cs_dbg_rd32( target, OSLAR_EL1, v );
+	r = target_cs_dbg_atomic_rd32( target, OSLAR_EL1, v );
 	if( r != ERROR_OK ){
 		LOG_DEBUG("rd: oslar-el1: error %d",r);
 	} else {
@@ -182,7 +192,7 @@ static int armv8_rd_OSLAR_EL1( struct target *target, uint32_t *v)
 	return r;
 }
 
-static int armv8_rd_OSLSR_EL1( struct target *target, uint32_t *v)
+static int armv8_rd_atomic_OSLSR_EL1( struct target *target, uint32_t *v)
 {
 	int r;
 #if 1
@@ -215,7 +225,7 @@ static int armv8_dbg_ClearStickyErrors( struct target *target )
 	/* Clear sticky bit errors
 	 * ARM DDI-0487A rev E, page H9-5154
 	 */
-	return target_cs_dbg_wr32( target, EDRCR, 1 << 2 );
+	return target_cs_dbg_atomic_wr32( target, EDRCR, 1 << 2 );
 }
 
 static void cortex_a53_dbg_dump(struct target *target)
@@ -223,24 +233,24 @@ static void cortex_a53_dbg_dump(struct target *target)
 	int retval;
 	uint32_t dummy;
 
-	retval = armv8_dbg_rd_EDPRSR( target, &dummy);
-	retval = target_cs_dbg_rd32( target, EDECR, &dummy);
+	retval = armv8_dbg_rd_atomic_EDPRSR( target, &dummy);
+	retval = target_cs_dbg_atomic_rd32( target, EDECR, &dummy);
 	LOG_DEBUG("Read %d EDECR 0x%08" PRIx32, retval, dummy);
-	retval = target_cs_dbg_rd32( target, EDESR, &dummy);
+	retval = target_cs_dbg_atomic_rd32( target, EDESR, &dummy);
 	LOG_DEBUG("Read %d EDESR 0x%08" PRIx32, retval, dummy);
-	retval = armv8_dbg_rd_EDSCR( target, &dummy );
-	retval = armv8_rd_OSLAR_EL1( target, &dummy);
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dummy );
+	retval = armv8_rd_atomic_OSLAR_EL1( target, &dummy);
 
 
-	retval = target_cs_dbg_rd32( target, EDRCR, &dummy);
+	retval = target_cs_dbg_atomic_rd32( target, EDRCR, &dummy);
 	LOG_DEBUG("Read %d EDRCR 0x%08" PRIx32, retval, dummy);
-	retval = target_cs_dbg_rd32( target, EDACR, &dummy);
+	retval = target_cs_dbg_atomic_rd32( target, EDACR, &dummy);
 	LOG_DEBUG("Read %d EDACR 0x%08" PRIx32, retval, dummy);
-	retval = target_cs_dbg_rd32( target, EDECCR, &dummy);
+	retval = target_cs_dbg_atomic_rd32( target, EDECCR, &dummy);
 	LOG_DEBUG("Read %d EDECCR 0x%08" PRIx32, retval, dummy);
-	retval = target_cs_dbg_rd32( target, EDPRCR, &dummy);
+	retval = target_cs_dbg_atomic_rd32( target, EDPRCR, &dummy);
 	LOG_DEBUG("Read %d EDPRCR 0x%08" PRIx32, retval, dummy);
-	retval = target_cs_dbg_rd32( target, DBGAUTHSTATUS_EL1, &dummy);
+	retval = target_cs_dbg_atomic_rd32( target, DBGAUTHSTATUS_EL1, &dummy);
 	LOG_DEBUG("Read %d DBGAUTHSTATUS_EL1 0x%08" PRIx32, retval, dummy);
 }
 
@@ -252,26 +262,26 @@ static void cortex_a53_cti_dump(struct target *target)
 	int retval;
 	uint32_t dummy;
 
-	//retval = target_cs_cti_rd32( target, CTIDEVID, &dummy);
+	//retval = target_cs_cti_atomic_rd32( target, CTIDEVID, &dummy);
 	//LOG_DEBUG("Read %d CTIDEVID 0x%08" PRIx32, retval, dummy); //RO, for 8916 it is 0x1040800
-	retval = target_cs_cti_rd32( target, CTICONTROL, &dummy);
+	retval = target_cs_cti_atomic_rd32( target, CTICONTROL, &dummy);
 	LOG_DEBUG("Read %d CTICONTROL 0x%08" PRIx32, retval, dummy);
-	retval = target_cs_cti_rd32( target, CTIGATE, &dummy);
+	retval = target_cs_cti_atomic_rd32( target, CTIGATE, &dummy);
 	LOG_DEBUG("Read %d CTIGATE 0x%08" PRIx32, retval, dummy);
-	retval = target_cs_cti_rd32( target, CTIINENn(0), &dummy);
+	retval = target_cs_cti_atomic_rd32( target, CTIINENn(0), &dummy);
 	LOG_DEBUG("Read %d CTIINEN0 0x%08" PRIx32, retval, dummy);
-	retval = target_cs_cti_rd32( target, CTIOUTENn(0), &dummy);
+	retval = target_cs_cti_atomic_rd32( target, CTIOUTENn(0), &dummy);
 	LOG_DEBUG("Read %d CTIOUTEN0 0x%08" PRIx32, retval, dummy);
 
-	retval = target_cs_cti_rd32( target, CTIINENn(1), &dummy);
+	retval = target_cs_cti_atomic_rd32( target, CTIINENn(1), &dummy);
 	LOG_DEBUG("Read %d CTIINEN0 0x%08" PRIx32, retval, dummy);
-	retval = target_cs_cti_rd32( target, CTIOUTENn(1), &dummy);
+	retval = target_cs_cti_atomic_rd32( target, CTIOUTENn(1), &dummy);
 	LOG_DEBUG("Read %d CTIOUTEN0 0x%08" PRIx32, retval, dummy);
 	
 
-	retval = target_cs_cti_rd32( target, CTITRIGOUTSTATUS, &dummy);
+	retval = target_cs_cti_atomic_rd32( target, CTITRIGOUTSTATUS, &dummy);
 	LOG_DEBUG("Read %d CTITRIGOUTSTATUS 0x%08" PRIx32, retval, dummy);
-	retval = target_cs_cti_rd32( target, CTIAPPPULSE, &dummy);
+	retval = target_cs_cti_atomic_rd32( target, CTIAPPPULSE, &dummy);
 	LOG_DEBUG("Read %d CTIAPPPULSE 0x%08" PRIx32, retval, dummy);
 }
 
@@ -321,7 +331,7 @@ int armv8_dbg_wr_bpwp_regs( struct armv8 *armv8, struct cortex_a_brp *p )
 	
 	if( !(p->control & 1) ){
 		/* we are disabling write control first */
-		retval = target_cs_dbg_wr32( target, cr, p->control );
+		retval = target_cs_dbg_queued_wr32( target, cr, p->control );
 		if( retval != ERROR_OK ){
 			return retval;
 		}
@@ -331,13 +341,13 @@ int armv8_dbg_wr_bpwp_regs( struct armv8 *armv8, struct cortex_a_brp *p )
 	uint64_t v = p->value;
 
 	/* LSB first */
-	retval = target_cs_dbg_wr32( target, vr+0, v );
+	retval = target_cs_dbg_queued_wr32( target, vr+0, v );
 	if( retval != ERROR_OK ){
 		return retval;
 	}
 	/* then MSB */
 	v = v >> 32;
-	retval = target_cs_dbg_wr32( target, vr+4, v );
+	retval = target_cs_dbg_queued_wr32( target, vr+4, v );
 	if( retval != ERROR_OK ){
 		return retval;
 	}
@@ -345,8 +355,14 @@ int armv8_dbg_wr_bpwp_regs( struct armv8 *armv8, struct cortex_a_brp *p )
 	/* if we are enabling write control last */
 	if( p->control & 1 ){
 		/* we are enabling write control last */
-		retval = target_cs_dbg_wr32( target, cr, p->control);
+		retval = target_cs_dbg_queued_wr32( target, cr, p->control);
 	}
+
+	/* Flush the above */
+	if( retval == ERROR_OK ){
+		retval = target_cs_dap_run(target);
+	}
+
 	return retval;
 }
 
@@ -464,45 +480,45 @@ static int cortex_a53_init_debug_access(struct target *target)
 	Later, just set CTIAPPPULSE[chan]=1 to trigger.
 	For restart, it is similar but using CTIINEN1 and CTIOUTEN1.
 	*/
-	retval = target_cs_cti_wr32( target, CTICONTROL, 1);
-	retval = target_cs_cti_rd32( target, CTIGATE, &dummy);
+	retval = target_cs_cti_atomic_wr32( target, CTICONTROL, 1);
+	retval = target_cs_cti_atomic_rd32( target, CTIGATE, &dummy);
 	dummy |= (1<<CTIDBGCHAN_HALT)|(1<<CTIDBGCHAN_RESTART);
-	retval = target_cs_cti_wr32( target, CTIGATE, dummy);
+	retval = target_cs_cti_atomic_wr32( target, CTIGATE, dummy);
 
-	retval = target_cs_cti_rd32( target, CTIINENn(0), &dummy);
+	retval = target_cs_cti_atomic_rd32( target, CTIINENn(0), &dummy);
 	dummy |= 1<<CTIDBGCHAN_HALT;
-	retval = target_cs_cti_wr32( target, CTIINENn(0), dummy);
+	retval = target_cs_cti_atomic_wr32( target, CTIINENn(0), dummy);
 
-	retval = target_cs_cti_rd32( target, CTIOUTENn(0), &dummy);
+	retval = target_cs_cti_atomic_rd32( target, CTIOUTENn(0), &dummy);
 	dummy |= 1<<CTIDBGCHAN_HALT;
-	retval = target_cs_cti_wr32( target, CTIOUTENn(0), dummy);
+	retval = target_cs_cti_atomic_wr32( target, CTIOUTENn(0), dummy);
 
-	retval = target_cs_cti_rd32( target, CTIINENn(1), &dummy);
+	retval = target_cs_cti_atomic_rd32( target, CTIINENn(1), &dummy);
 	dummy |= 1<<CTIDBGCHAN_RESTART;
-	retval = target_cs_cti_wr32( target, CTIINENn(1), dummy);
+	retval = target_cs_cti_atomic_wr32( target, CTIINENn(1), dummy);
 
-	retval = target_cs_cti_rd32( target, CTIOUTENn(1), &dummy);
+	retval = target_cs_cti_atomic_rd32( target, CTIOUTENn(1), &dummy);
 	dummy |= 1<<CTIDBGCHAN_RESTART;
-	retval = target_cs_cti_wr32( target, CTIOUTENn(1), dummy);
+	retval = target_cs_cti_atomic_wr32( target, CTIOUTENn(1), dummy);
 
 	/* read this to determine state */
-	armv8_dbg_rd_EDPRSR( target, &dummy );
+	armv8_dbg_rd_atomic_EDPRSR( target, &dummy );
 	
 	//set EDECCR for catching exception
 	/*dummy = 8; //2;
-	retval = target_cs_dbg_wr32( target, EDECCR, dummy);*/
+	retval = target_cs_dbg_atomic_wr32( target, EDECCR, dummy);*/
 
 	//set HDE(bit14) for enable BP, WP and Halt Instruction
 	LOG_DEBUG("armv8: Enable HDE");
-	retval = armv8_dbg_rd_EDSCR( target, &dummy );
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dummy );
 	dummy |= (1 << 14); //set HDE to enable halt
-	retval = armv8_dbg_wr_EDSCR( target, dummy);
-	retval = armv8_dbg_rd_EDSCR( target, &dummy );
+	retval = armv8_dbg_queued_wr_EDSCR( target, dummy);
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dummy );
 	armv8_dbg_ClearStickyErrors( target );
 
 	/* Strong Qu: Write 0 to DBGOSLAR(OS Lock Access Register, FC33_0300) */
 	LOG_DEBUG("Clear DBGOSLAR.");
-    retval = armv8_dbg_wr_OSLAR_EL1( target, 0);
+    retval = armv8_dbg_wr_atomic_OSLAR_EL1( target, 0);
 	if (retval != ERROR_OK)
     {
 		LOG_ERROR("Failed to clear DBGOSLAR.");
@@ -511,10 +527,10 @@ static int cortex_a53_init_debug_access(struct target *target)
 
 	/* Unlocking the debug registers for modification
 	 * The debugport might be uninitialised so try twice */
-	retval = target_cs_dbg_wr32( target, CPUDBG_LOCKACCESS, 0xC5ACCE55);
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_LOCKACCESS, 0xC5ACCE55);
 	if (retval != ERROR_OK) {
 		/* try again */
-		retval = target_cs_dbg_wr32( target, CPUDBG_LOCKACCESS, 0xC5ACCE55);
+		retval = target_cs_dbg_atomic_wr32( target, CPUDBG_LOCKACCESS, 0xC5ACCE55);
 		if (retval == ERROR_OK)
 			LOG_DEBUG(
 				"Locking debug access failed on first, but succeeded on second try.");
@@ -523,7 +539,7 @@ static int cortex_a53_init_debug_access(struct target *target)
 		return retval;
 	/* Clear Sticky Power Down status Bit in PRSR to enable access to
 	   the registers in the Core Power Domain */
-	retval = armv8_dbg_rd_EDPRSR( target, &dummy);
+	retval = armv8_dbg_rd_atomic_EDPRSR( target, &dummy);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -550,7 +566,7 @@ static int cortex_a53_exec_opcode(struct target *target,
 	if( armv8_debug(EXEC_OPCODE) ){
 		LOG_DEBUG("armv8 exec opcode: 0x%08" PRIx32, opcode );
 	}
-	retval = armv8_dbg_rd_EDSCR( target, &dscr );
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 	if( armv8_debug(EXEC_OPCODE) ){
 		LOG_DEBUG("AArch64=%d (dscr=0x%08X)", isAArch64(dscr), dscr);
 	}
@@ -561,7 +577,7 @@ static int cortex_a53_exec_opcode(struct target *target,
 		if( armv8_debug(EXEC_OPCODE) ){
 			LOG_DEBUG("armv8-exec-opcode-poll(1)");
 		}
-		retval = armv8_dbg_rd_EDSCR( target, &dscr );
+		retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 		if (retval != ERROR_OK) {
 			LOG_ERROR("Could not read DSCR register, opcode = 0x%08" PRIx32, opcode);
 			return retval;
@@ -686,6 +702,7 @@ static int cortex_a53_exec_opcode(struct target *target,
     	if(!target->is_64b) LOG_ERROR("SQU: Exec AArch64 opcode=0x%x for AArch32 state", opcode);
     }
 
+	LOG_DEBUG("execute: 0x%08x", opcode);
 	retval = target_cs_dbg_queued_wr32( target, CPUDBG_ITR, opcode);
 	if (retval != ERROR_OK)
 		return retval;
@@ -695,7 +712,7 @@ static int cortex_a53_exec_opcode(struct target *target,
 		if( armv8_debug(EXEC_OPCODE) ){
 			LOG_DEBUG("armv8-exec-opcode-poll(2)");
 		}
-		retval = armv8_dbg_rd_EDSCR( target, &dscr );
+		retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 		if (retval != ERROR_OK) {
 			LOG_ERROR("Could not read DSCR register");
 			return retval;
@@ -730,7 +747,7 @@ static int cortex_a53_exec_opcode(struct target *target,
  */
 
 
-static int cortex_a53_write_dcc(struct armv8 *armv8, uint64_t data)
+static int cortex_a53_write_queued_dcc(struct armv8 *armv8, uint64_t data)
 {
 	struct cortex_a_common *cortex_a = armv8_to_cortex_a(armv8);
 	struct target *target = armv8_to_target(armv8);
@@ -762,7 +779,7 @@ static int cortex_a53_read_dcc(struct target *target, uint64_t *data,
 		if( armv8_debug( DCC_IO ) ){
 			LOG_DEBUG("poll DCC");
 		}
-		retval = armv8_dbg_rd_EDSCR( target, &dscr );
+		retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 		if (retval != ERROR_OK)
 			return retval;
 		if (timeval_ms() > then + 1000) {
@@ -771,15 +788,19 @@ static int cortex_a53_read_dcc(struct target *target, uint64_t *data,
 		}
 	}
 
-	retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, pdw);
+	retval = target_cs_dbg_queued_rd32( target, CPUDBG_DTRTX, pdw);
 	if (retval != ERROR_OK)
 		return retval;
 	
 	if(isAArch64(dscr))
 	{
-		target_cs_dbg_rd32( target, CPUDBG_DTRRX, pdw+1); //DTRRX holds high dword for 64bit data
+		retval = target_cs_dbg_queued_rd32( target, CPUDBG_DTRRX, pdw+1); //DTRRX holds high dword for 64bit data
 	} else
 		*(pdw+1)=0;
+	
+	if( retval == ERROR_OK ){
+		retval = target_cs_dap_run(target);
+	}
 
 	if( armv8_debug( DCC_IO )){
 		LOG_DEBUG("read DCC 0x%08" PRIx64, *data);
@@ -800,7 +821,7 @@ static int cortex_a53_dpm_prepare(struct arm_dpm *dpm)
 	/* set up invariant:  INSTR_COMP is set after every DPM operation */
 	long long then = timeval_ms();
 	for (;; ) {
-		retval = armv8_dbg_rd_EDSCR( target, &dscr);
+		retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr);
 		if (retval != ERROR_OK)
 			return retval;
 		if ((dscr & DSCR_INSTR_COMP) != 0)
@@ -855,7 +876,7 @@ static int cortex_a53_instr_write_data64_dcc(struct arm_dpm *dpm,
 	int retval;
 	uint32_t dscr = DSCR_INSTR_COMP;
 
-	retval = cortex_a53_write_dcc(armv8, data);
+	retval = cortex_a53_write_queued_dcc(armv8, data);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -882,7 +903,7 @@ static int cortex_a53_instr_write_data64_r0_mrs(struct arm_dpm *dpm,
 	if( armv8_debug(EXEC_OPCODE) ){
 		LOG_DEBUG("opcode=0x%08" PRIx32 " data = 0x%016" PRIx64, opcode, data );
 	}
-	retval = cortex_a53_write_dcc(armv8, data);
+	retval = cortex_a53_write_queued_dcc(armv8, data);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -917,7 +938,7 @@ static int cortex_a53_instr_write_data64_r0(struct arm_dpm *dpm,
 		LOG_DEBUG("opcode=0x%08" PRIx32 " data = 0x%016" PRIx64, opcode, data );
 	}
 
-	retval = cortex_a53_write_dcc(armv8, data);
+	retval = cortex_a53_write_queued_dcc(armv8, data);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1207,7 +1228,7 @@ static int cortex_a53_poll(struct target *target)
 		target_call_event_callbacks(target, TARGET_EVENT_HALTED);
 		return retval;
 	}
-	retval = armv8_dbg_rd_EDSCR( target, &dscr );
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1279,8 +1300,8 @@ static int cortex_a53_halt(struct target *target)
 	uint32_t dummy;
 
 	LOG_DEBUG("armv8-halt");
-	retval = armv8_dbg_rd_EDSCR( target, &dummy);
-	/*retval = target_cs_dbg_rd32( target, EDPRSR, &dummy);
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dummy);
+	/*retval = target_cs_dbg_atomic_rd32( target, EDPRSR, &dummy);
 	LOG_DEBUG("And EDPRSR = 0x%08" PRIx32, dummy);
 	cortex_a53_dbg_dump(target);
 	cortex_a53_cti_dump(target);
@@ -1291,8 +1312,8 @@ static int cortex_a53_halt(struct target *target)
 	 * SS of EDECR and EDESR are for single step.
 	 * For ARMv7 it used to be setting 1 to CPUDBG_DRCR and read CPUDBG_DSCR
 	 */
-	retval = armv8_cti_wr_HALT( target ); //trigger dbg req evt
-	retval = armv8_dbg_rd_EDSCR( target, &dummy);
+	retval = armv8_cti_wr_atomic_HALT( target ); //trigger dbg req evt
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dummy);
 	LOG_DEBUG("After CTI triggered: %d EDSCR 0x%08" PRIx32, retval, dummy);
 	//cortex_a53_cti_dump(target);
 
@@ -1302,7 +1323,7 @@ static int cortex_a53_halt(struct target *target)
 
 	long long then = timeval_ms();
 	for (;; ) {
-		retval = armv8_dbg_rd_EDPRSR( target, &dummy);
+		retval = armv8_dbg_rd_atomic_EDPRSR( target, &dummy);
 		if (retval != ERROR_OK)
 			return retval;
 		/* Look for halted bit */
@@ -1316,7 +1337,7 @@ static int cortex_a53_halt(struct target *target)
 	}
 	//LOG_DEBUG("Halt success with EDPRSR = 0x%08" PRIx32, dummy);
 	//check DLR_EL0 and DSPSR_EL0
-	retval = armv8_dbg_rd_EDSCR( target, &dummy);
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dummy);
 	if(isAArch64(dummy))
 	{
 		target->is_64b=true;
@@ -1332,7 +1353,7 @@ static int cortex_a53_halt(struct target *target)
 	{
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 1, 1, 0, 0), &dummy); //read SCR_EL3 to X0
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 		LOG_DEBUG("Running in AArch64. SCR_EL3=0x%x",dummy);
 //		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x400);//SCR:RW=0,NS=1
 		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
@@ -1341,7 +1362,7 @@ static int cortex_a53_halt(struct target *target)
 
 		      cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 4, 1, 1, 0, 0), &dummy); //read HCR_EL2 to X0
               cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-              retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
+              retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
               LOG_DEBUG("Running in AArch64. HCR_EL2=0x%x",dummy);
 /*              target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
               cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
@@ -1349,47 +1370,47 @@ static int cortex_a53_halt(struct target *target)
 */
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 12, 0, 2, 0), &dummy);    // MRS RMR_EL3, R0
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 		LOG_DEBUG("Read RMR_EL# before DRPS = 0x%x", dummy);
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 3, 4, 5, 0, 0), &dummy);    // MRS DSPSR_EL0, R0
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 		LOG_DEBUG("Read DSPSR_EL0 before DRPS = 0x%x", dummy);
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 3, 4, 5, 1, 0), &dummy);     // MRS DLR_EL0, R0, mov pc?
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read DLR_EL0 before DRPS = 0x%x", dummy);
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 0, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL1, R0, mov pc?
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read SPSR_EL1 before DRPS = 0x%x", dummy);
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 4, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL2, R0, mov pc?
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read SPSR_EL2 before DRPS = 0x%x", dummy);
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL3, R0, mov pc?
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read SPSR_EL3 before DRPS = 0x%x", dummy);
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL3, R0, mov pc?
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read SPSR_EL3 before DRPS = 0x%x", dummy);
 
 		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 0, 0, 2, 2, 0), &dummy);     // MRS MDSCR_EL1, R0, mov pc?
 		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
-		retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &dummy);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read MDSCR_EL1 before DRPS = 0x%x", dummy);
 		// write forever loop into the memory 0xFE800000
@@ -1408,7 +1429,7 @@ static int cortex_a53_halt(struct target *target)
 		cortex_a53_exec_opcode(target, 0xD6BF03E0, &dummy); //0x8F00F3DE=>ERET 0xD6BF03E0=>DRPS
 
 		// dummy has Arch32, 64 target type information.
-		retval = armv8_dbg_rd_EDSCR( target, &dummy);
+		retval = armv8_dbg_rd_atomic_EDSCR( target, &dummy);
 	    LOG_DEBUG("after DRPS, EDSCR = 0x%08" PRIx32, dummy);
 		
 		// set to DSPSR_EL0 to 0x1d0
@@ -1432,14 +1453,14 @@ static int cortex_a53_halt(struct target *target)
 //		cortex_a53_exec_opcode(target, ARMV8_T32_MCR(15, 3, 0, 4, 5, 1), &dummy);     // MSR DLR_EL0, R0, mov pc?
 		cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dummy);    //X0=DTRRX / DBGDTRRXint
 		cortex_a53_exec_opcode(target, ARMV4_5_MCR(15, 3, 0, 4, 5, 1), &dummy);     // MSR DLR_EL0, R0, mov pc?
-	    retval = armv8_dbg_rd_EDSCR( target, &dummy);
+	    retval = armv8_dbg_rd_atomic_EDSCR( target, &dummy);
 	    LOG_DEBUG("after DRPS, EDSCR = 0x%08" PRIx32, dummy);
 
 		//send CTI ACK
-		retval = target_cs_cti_wr32( target, CTIINTACK, 1);
+		retval = target_cs_cti_atomic_wr32( target, CTIINTACK, 1);
 		then = timeval_ms();
 		for (;; ) {
-			retval = target_cs_cti_rd32( target, CTITRIGOUTSTATUS, &dummy);
+			retval = target_cs_cti_atomic_rd32( target, CTITRIGOUTSTATUS, &dummy);
 			if (retval != ERROR_OK) return retval;
 			if ((dummy & 1) == 0) break;
 			if (timeval_ms() > then + 100000) {
@@ -1448,11 +1469,11 @@ static int cortex_a53_halt(struct target *target)
 			}
 		}
 		//resume
-		retval = armv8_cti_wr_RESTART( target ); //restart
+		retval = armv8_cti_wr_atomic_RESTART( target ); //restart
 		if (retval != ERROR_OK) 	return retval;
 		then = timeval_ms();
 		for (;; ) {
-			retval = armv8_dbg_rd_EDPRSR( target, &dummy);
+			retval = armv8_dbg_rd_atomic_EDPRSR( target, &dummy);
 			if (retval != ERROR_OK) return retval;
 			if ((dummy & (1<<11)) != 0) break;
 			if (timeval_ms() > then + 1000) {
@@ -1461,8 +1482,8 @@ static int cortex_a53_halt(struct target *target)
 			}
 		}
 
-		retval = armv8_cti_wr_HALT( target ); //trigger dbg req evt
-		retval = armv8_dbg_rd_EDSCR( target, &dummy);
+		retval = armv8_cti_wr_atomic_HALT( target ); //trigger dbg req evt
+		retval = armv8_dbg_rd_atomic_EDSCR( target, &dummy);
 		LOG_DEBUG("After CTI1 triggered: %d EDSCR 0x%08" PRIx32, retval, dummy);
 
 		target->is_64b=false;
@@ -1577,14 +1598,14 @@ static int cortex_a53_internal_restart(struct target *target)
 	 * disable IRQs by default, with optional override...
 	 */
     /* SQU: for ARMv8, need to do acknowledge halt event then trigger restart */
-	/*retval = armv8_dbg_rd_EDSCR( target, &dscr );
-	retval = target_cs_cti_rd32( target, CTITRIGOUTSTATUS, &dummy);
+	/*retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
+	retval = target_cs_cti_atomic_rd32( target, CTITRIGOUTSTATUS, &dummy);
 	LOG_DEBUG("SQU Before CTI ACK: DSCR= 0x%x  CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);*/
-	retval = target_cs_cti_wr32( target, CTIINTACK, 1);
+	retval = target_cs_cti_atomic_wr32( target, CTIINTACK, 1);
 
 	long long then = timeval_ms();
 	for (;; ) {
-		retval = armv8_cti_rd_STATUS( target, &dummy );
+		retval = armv8_cti_rd_atomic_STATUS( target, &dummy );
 		if (retval != ERROR_OK)
 			return retval;
 		if ((dummy & 1) == 0)
@@ -1594,7 +1615,7 @@ static int cortex_a53_internal_restart(struct target *target)
 			return ERROR_FAIL;
 		}
 	}
-	retval = armv8_dbg_rd_EDSCR( target, &dscr );
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 	if (retval != ERROR_OK)
 		return retval;
 	//LOG_DEBUG("SQU After CTI ACK: DSCR= 0x%x; CTITRIGOUTSTATUS= 0x%" PRIx32, dscr, dummy);
@@ -1602,13 +1623,13 @@ static int cortex_a53_internal_restart(struct target *target)
 	if ((dscr & DSCR_INSTR_COMP) == 0)
 		LOG_ERROR("DSCR InstrCompl must be set before leaving debug!");
 
-	retval = armv8_cti_wr_RESTART( target );
+	retval = armv8_cti_wr_atomic_RESTART( target );
 	if (retval != ERROR_OK)
 		return retval;
 
 	then = timeval_ms();
 	for (;; ) {
-		retval = armv8_dbg_rd_EDPRSR( target, &dummy );
+		retval = armv8_dbg_rd_atomic_EDPRSR( target, &dummy );
 		if (retval != ERROR_OK)
 			return retval;
 		if ((dummy & (1<<11)) != 0)
@@ -1618,8 +1639,8 @@ static int cortex_a53_internal_restart(struct target *target)
 			return ERROR_FAIL;
 		}
 	}
-	retval = armv8_dbg_rd_EDSCR( target, &dscr );
-	retval = armv8_dbg_rd_EDPRSR( target, &dummy );
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
+	retval = armv8_dbg_rd_atomic_EDPRSR( target, &dummy );
 	//LOG_DEBUG("Successfully restart with DSCR= 0x%x EDPRSR= 0x%" PRIx32, dscr, dummy);
 	//for AArch32: dump DFSR, HSR, DFAR, HDAR, HPFAR
 	//HSR: MRC p15,4,<Rt>,c5,c2,0
@@ -1635,7 +1656,7 @@ static int cortex_a53_internal_restart(struct target *target)
 
 	//set EDECCR after restart. Might be too late ?!
 	/*dummy = 8;
-	retval = target_cs_dbg_wr32( target, EDECCR, dummy);*/
+	retval = target_cs_dbg_atomic_wr32( target, EDECCR, dummy);*/
 
 	target->debug_reason = DBG_REASON_NOTHALTED;
 	target->state = TARGET_RUNNING;
@@ -1719,7 +1740,7 @@ static int cortex_a53_debug_entry(struct target *target)
 	LOG_DEBUG("dscr = 0x%08" PRIx32, cortex_a->cpudbg_dscr);
 
 	/* REVISIT surely we should not re-read DSCR !! */
-	retval = armv8_dbg_rd_EDSCR( target, &dscr );
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 	if (retval != ERROR_OK)
 		return retval;
 	/* REVISIT see A8 TRM 12.11.4 steps 2..3 -- make sure that any
@@ -1729,7 +1750,7 @@ static int cortex_a53_debug_entry(struct target *target)
 
 	/*SQU: ARMv8 does not have DSCR_ITR_EN(bit13). Should disable IRQ? Need to revisit*/
 	/*dscr |= 3<<22; //INTdis=b'11
-	retval = armv8_dbg_wr_EDSCR( target, dscr );
+	retval = armv8_dbg_queued_wr_EDSCR( target, dscr );
 	if (retval != ERROR_OK) return retval;*/
 
 	/* disable exception. Cannot do it in init as dpm might not ready?
@@ -1744,24 +1765,24 @@ static int cortex_a53_debug_entry(struct target *target)
 	LOG_DEBUG("SDER is 0x%x. Will edit it", dummy);
 	dummy=0;
 	retval = arm->mcr(target, 15, 0, 1, 1, 1, dummy);
-	retval = armv8_dbg_rd_EDSCR( target, &dscr );*/
-	/*retval = target_cs_dbg_rd32( target, EDECCR, &dummy);
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );*/
+	/*retval = target_cs_dbg_atomic_rd32( target, EDECCR, &dummy);
 	LOG_DEBUG("DSCR= 0x%x  EDECCR=0x%x => reset", dscr, dummy);
-	retval = target_cs_dbg_wr32( target, EDECCR, 0);*/
+	retval = target_cs_dbg_atomic_wr32( target, EDECCR, 0);*/
 	/*dummy=0x11223344;
-	retval = target_cs_dbg_wr32( target, DBGDTRTX_EL0, dummy);
-	retval = armv8_dbg_rd_EDSCR( target, &dscr );
+	retval = target_cs_dbg_atomic_wr32( target, DBGDTRTX_EL0, dummy);
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 	dummy = 0;
-	retval = target_cs_dbg_rd32( target, DBGDTRTX_EL0, &dummy);
-	retval = armv8_dbg_rd_EDSCR( target, &dscr );*/
+	retval = target_cs_dbg_atomic_rd32( target, DBGDTRTX_EL0, &dummy);
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );*/
 
 	/*dummy=0x5A5A55AA;
-	retval = target_cs_dbg_wr32( target, DBGDTRRX_EL0, dummy);
-	retval = armv8_dbg_rd_EDSCR( target, &dscr );
+	retval = target_cs_dbg_atomic_wr32( target, DBGDTRRX_EL0, dummy);
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 	dummy = 0;
-	retval = target_cs_dbg_rd32( target, DBGDTRRX_EL0, &dummy);
-	retval = armv8_dbg_rd_EDSCR( target, &dscr );*/
-	armv8_dbg_rd_EDPRSR( target, &dummy );
+	retval = target_cs_dbg_atomic_rd32( target, DBGDTRRX_EL0, &dummy);
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );*/
+	armv8_dbg_rd_atomic_EDPRSR( target, &dummy );
 
 	/* Examine debug reason */
 	armv8_dpm_report_dscr(arm_dpm, cortex_a->cpudbg_dscr);
@@ -1769,7 +1790,7 @@ static int cortex_a53_debug_entry(struct target *target)
 	if (target->debug_reason == DBG_REASON_WATCHPOINT) {
 		struct target_addr wfar;
 		uint32_t regval;
-		retval = target_cs_dbg_rd32( target, CPUDBG_WFAR, &regval);
+		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_WFAR, &regval);
 		if (retval != ERROR_OK)
 			return retval;
 		
@@ -1891,7 +1912,7 @@ static int cortex_a53_step_64(struct target *target, int current, const struct t
  */
 	target->debug_reason = DBG_REASON_SINGLESTEP;
 
-	retval = target_cs_dbg_wr32( target, EDECR, 1<<2); //set EDECR.SS
+	retval = target_cs_dbg_atomic_wr32( target, EDECR, 1<<2); //set EDECR.SS
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -1909,7 +1930,7 @@ static int cortex_a53_step_64(struct target *target, int current, const struct t
 			return ERROR_FAIL;
 		}
 	}
-	retval = target_cs_dbg_wr32( target, EDECR, 0); //clr EDECR.SS
+	retval = target_cs_dbg_atomic_wr32( target, EDECR, 0); //clr EDECR.SS
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -2363,7 +2384,7 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 	reg->dirty = true;
 
 	/*  clear any abort  */
-	retval = target_cs_dbg_wr32( target, CPUDBG_DRCR, 1<<2);
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_DRCR, 1<<2);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -2410,19 +2431,20 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 	/* We now have a 32 bit aligned buffer that can be written */
 
 	/* Read DSCR */
-	retval = armv8_dbg_rd_EDSCR( target, &dscr );
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 	if (retval != ERROR_OK)
 		goto error_free_buff_w;
 
 	/* Set DTR mode to Fast (2) */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_FAST_MODE;
-	retval = armv8_dbg_wr_EDSCR( target, dscr );
+	/*FIXME: This should be queued */
+	retval = armv8_dbg_queued_wr_EDSCR( target, dscr );
 	if (retval != ERROR_OK)
 		goto error_free_buff_w;
 
 	/* Copy the destination address into R0 */
 	/*  - pend an instruction  MRC p14, 0, R0, c5, c0 */
-	retval = target_cs_dbg_wr32( target, CPUDBG_ITR, ARMV4_5_MRC(14, 0, 0, 0, 5, 0));
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_ITR, ARMV4_5_MRC(14, 0, 0, 0, 5, 0));
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 	/* Write address into DTRRX, which triggers previous instruction */
@@ -2431,14 +2453,14 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 	tmp_addr = *pAddr;
 	/* round down to 32bits */
 	tmp_addr.addr &= (~0x03);
-	retval = target_cs_dbg_wr32( target, CPUDBG_DTRRX, tmp_addr.addr );
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_DTRRX, tmp_addr.addr );
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
 	/* Write the data transfer instruction into the ITR
 	 * (STC p14, c5, [R0], 4)
 	 */
-	retval = target_cs_dbg_wr32( target, CPUDBG_ITR, ARMV4_5_STC(0, 1, 0, 1, 14, 5, 0, 4));
+	retval = target_cs_dbg_atomic_wr32( target, CPUDBG_ITR, ARMV4_5_STC(0, 1, 0, 1, 14, 5, 0, 4));
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
@@ -2450,12 +2472,12 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 
 	/* Switch DTR mode back to non-blocking (0) */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	retval = armv8_dbg_wr_EDSCR( target, dscr );
+	retval = armv8_dbg_queued_wr_EDSCR( target, dscr );
 	if (retval != ERROR_OK)
 		goto error_unset_dtr_w;
 
     /* Check for sticky abort flags in the DSCR */
-	retval = armv8_dbg_rd_EDSCR( target, &dscr );
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 	if (retval != ERROR_OK)
 		goto error_free_buff_w;
 	if (dscr & (DSCR_STICKY_ABORT_PRECISE | DSCR_STICKY_ABORT_IMPRECISE)) {
@@ -2471,9 +2493,9 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 
 error_unset_dtr_w:
 	/* Unset DTR mode */
-	armv8_dbg_rd_EDSCR( target, &dscr );
+	armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	armv8_dbg_wr_EDSCR( target, dscr);
+	armv8_dbg_wr_atomic_EDSCR( target, dscr);
 error_free_buff_w:
 	LOG_ERROR("error");
 	free(tmp_buff);
@@ -2525,7 +2547,7 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 		goto error_free_buff_r;
 
 	/* Read DSCR */
-	retval = armv8_dbg_rd_EDSCR( target, &dscr );
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 
 	/* This algorithm comes from either :
 	 * Cortex-A8 TRM Example 12-24
@@ -2535,13 +2557,13 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 
 	/* Set DTR access mode to stall mode b01  */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_STALL_MODE;
-	retval +=  armv8_dbg_wr_EDSCR( target, dscr );
+	retval +=  armv8_dbg_queued_wr_EDSCR( target, dscr );
 
 	/* Write R0 with value 'address' using write procedure for stall mode */
 	/*   - Write the address for read access into DTRRX */
 	tmp_addr = *pAddr;
 	tmp_addr.addr &= (~0x03);
-	retval += target_cs_dbg_wr32( target, CPUDBG_DTRRX, tmp_addr.addr );
+	retval += target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, tmp_addr.addr );
 	/*  - Copy value from DTRRX to R0 using instruction mrc p14, 0, r0, c5, c0 */
 	cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dscr);
 
@@ -2587,19 +2609,19 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 
 	/* set DTR access mode back to non blocking b00  */
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	retval =  armv8_dbg_wr_EDSCR( target, dscr );
+	retval =  armv8_dbg_queued_wr_EDSCR( target, dscr );
 	if (retval != ERROR_OK)
 		goto error_free_buff_r;
 
 	/* Wait for the final read instruction to finish */
 	do {
-		retval = armv8_dbg_rd_EDSCR( target, &dscr );
+		retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 		if (retval != ERROR_OK)
 			goto error_free_buff_r;
 	} while ((dscr & DSCR_INSTR_COMP) == 0);
 
 	/* Check for sticky abort flags in the DSCR */
-	retval = armv8_dbg_rd_EDSCR( target, &dscr );
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 	if (retval != ERROR_OK)
 		goto error_free_buff_r;
 	if (dscr & (DSCR_STICKY_ABORT_PRECISE | DSCR_STICKY_ABORT_IMPRECISE)) {
@@ -2620,9 +2642,10 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 
 error_unset_dtr_r:
 	/* Unset DTR mode */
-	armv8_dbg_rd_EDSCR( target, &dscr );
+	armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
-	armv8_dbg_wr_EDSCR( target, dscr);
+	/* this sould not be queued */
+	armv8_dbg_wr_atomic_EDSCR( target, dscr);
 error_free_buff_r:
 	LOG_ERROR("error");
 	free(tmp_buff);
@@ -2910,14 +2933,14 @@ static int cortex_a53_handle_target_request(void *priv)
 	if (target->state == TARGET_RUNNING) {
 		uint32_t request;
 		uint32_t dscr;
-		retval = armv8_dbg_rd_EDSCR( target, &dscr );
+		retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 
 		/* check if we have data */
 		while ((dscr & DSCR_DTR_TX_FULL) && (retval == ERROR_OK)) {
-			retval = target_cs_dbg_rd32( target, CPUDBG_DTRTX, &request);
+			retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &request);
 			if (retval == ERROR_OK) {
 				target_request(target, request);
-				retval = armv8_dbg_rd_EDSCR( target, &dscr );
+				retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
 			}
 		}
 	}
@@ -2999,7 +3022,7 @@ static int cortex_a53_examine_first(struct target *target)
 	/* FIXME: Need to write code to find the CTI */
 
 	//if(cpuid==0x410FD030) => 8916
-	retval = target_cs_dbg_rd32( target, CPUDBG_CPUID, &cpuid);
+	retval = target_cs_dbg_atomic_rd32( target, CPUDBG_CPUID, &cpuid);
 	if (retval != ERROR_OK) {
 		LOG_DEBUG("cortex_a53[%d]: Read CPUID Fails: %d", target->coreid, retval );
 		return retval;
@@ -3016,12 +3039,12 @@ static int cortex_a53_examine_first(struct target *target)
 		uint32_t tmp32;
 		uint64_t tmp64;
 		
-		retval = target_cs_dbg_rd32( target, EDDFR, &tmp32 );
+		retval = target_cs_dbg_atomic_rd32( target, EDDFR, &tmp32 );
 		if( retval != ERROR_OK ){
 			return retval;
 		}
 		dfr0 = tmp32;
-		retval = target_cs_dbg_rd32( target, EDDFR, &tmp32 );
+		retval = target_cs_dbg_atomic_rd32( target, EDDFR, &tmp32 );
 		if( retval != ERROR_OK ){
 			return retval;
 		}
diff --git a/src/target/cortex_m.c b/src/target/cortex_m.c
index 89d74f3..151bb65 100755
--- a/src/target/cortex_m.c
+++ b/src/target/cortex_m.c
@@ -81,7 +81,9 @@ static int cortexm_dap_read_coreregister_u32(struct target *target,
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = target_cs_dbg_rd32( target, DCB_DCRDR, value);
+	/* go atomic here - because of 'dcc' comment below */
+	/* REVISIT: What does that comment mean? */
+	retval = target_cs_dbg_atomic_rd32( target, DCB_DCRDR, value);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -89,7 +91,11 @@ static int cortexm_dap_read_coreregister_u32(struct target *target,
 		/* restore DCB_DCRDR - this needs to be in a separate
 		 * transaction otherwise the emulated DCC channel breaks */
 		if (retval == ERROR_OK)
-			retval = target_cs_dbg_wr32( target, DCB_DCRDR, dcrdr);
+			retval = target_cs_dbg_queued_wr32( target, DCB_DCRDR, dcrdr);
+	}
+
+	if( retval == ERROR_OK ){
+		retval = target_cs_dap_run( target );
 	}
 
 	return retval;
@@ -102,6 +108,8 @@ static int cortexm_dap_write_coreregister_u32(struct target *target,
 	int retval;
 	uint32_t dcrdr;
 
+	dcrdr = 0;
+
 	/* because the DCB_DCRDR is used for the emulated dcc channel
 	 * we have to save/restore the DCB_DCRDR when used */
 	if (target->dbg_msg_enabled) {
@@ -114,7 +122,9 @@ static int cortexm_dap_write_coreregister_u32(struct target *target,
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = target_cs_dbg_wr32( target, DCB_DCRSR, regnum | DCRSR_WnR);
+	/* REVISIT: Comment below about DCC channel */
+	/* What does that mean? */
+	retval = target_cs_dbg_atomic_wr32( target, DCB_DCRSR, regnum | DCRSR_WnR);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -122,7 +132,11 @@ static int cortexm_dap_write_coreregister_u32(struct target *target,
 		/* restore DCB_DCRDR - this needs to be in a seperate
 		 * transaction otherwise the emulated DCC channel breaks */
 		if (retval == ERROR_OK)
-			retval = target_cs_dbg_wr32( target, DCB_DCRDR, dcrdr);
+			retval = target_cs_dbg_queued_wr32( target, DCB_DCRDR, dcrdr);
+	}
+
+	if( retval == ERROR_OK ){
+		retval = target_cs_dap_run(target);
 	}
 
 	return retval;
@@ -131,6 +145,7 @@ static int cortexm_dap_write_coreregister_u32(struct target *target,
 static int cortex_m_write_debug_halt_mask(struct target *target,
 	uint32_t mask_on, uint32_t mask_off)
 {
+	int r;
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 
 	/* mask off status bits */
@@ -138,7 +153,8 @@ static int cortex_m_write_debug_halt_mask(struct target *target,
 	/* create new register mask */
 	cortex_m->dcb_dhcsr |= DBGKEY | C_DEBUGEN | mask_on;
 
-	return target_cs_dbg_wr32( target, DCB_DHCSR, cortex_m->dcb_dhcsr);
+	r = target_cs_dbg_atomic_wr32( target, DCB_DHCSR, cortex_m->dcb_dhcsr);
+	return r;
 }
 
 static int cortex_m_clear_halt(struct target *target)
@@ -151,14 +167,15 @@ static int cortex_m_clear_halt(struct target *target)
 	cortex_m_write_debug_halt_mask(target, C_HALT, C_STEP);
 
 	/* Read Debug Fault Status Register */
-	retval = target_cs_dbg_rd32( target, NVIC_DFSR, &cortex_m->nvic_dfsr);
+	retval = target_cs_dbg_queued_rd32( target, NVIC_DFSR, &cortex_m->nvic_dfsr);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* Clear Debug Fault Status */
-	retval = target_cs_dbg_wr32( target, NVIC_DFSR, cortex_m->nvic_dfsr);
+	retval = target_cs_dbg_atomic_wr32( target, NVIC_DFSR, cortex_m->nvic_dfsr);
 	if (retval != ERROR_OK)
 		return retval;
+
 	LOG_DEBUG(" NVIC_DFSR 0x%" PRIx32 "", cortex_m->nvic_dfsr);
 
 	return ERROR_OK;
@@ -178,12 +195,12 @@ static int cortex_m_single_step_core(struct target *target)
 	 * HALT can put the core into an unknown state.
 	 */
 	if (!(cortex_m->dcb_dhcsr & C_MASKINTS)) {
-		retval = target_cs_dbg_wr32( target, DCB_DHCSR,
+		retval = target_cs_dbg_queued_wr32( target, DCB_DHCSR,
 				DBGKEY | C_MASKINTS | C_HALT | C_DEBUGEN);
 		if (retval != ERROR_OK)
 			return retval;
 	}
-	retval = target_cs_dbg_wr32( target, DCB_DHCSR,
+	retval = target_cs_dbg_queued_wr32( target, DCB_DHCSR,
 			DBGKEY | C_MASKINTS | C_STEP | C_DEBUGEN);
 	if (retval != ERROR_OK)
 		return retval;
@@ -191,20 +208,19 @@ static int cortex_m_single_step_core(struct target *target)
 
 	/* restore dhcsr reg */
 	cortex_m->dcb_dhcsr = dhcsr_save;
-	cortex_m_clear_halt(target);
-
-	return ERROR_OK;
+	/* THIS will call dap_run() */
+	return cortex_m_clear_halt(target);
 }
 
 static int cortex_m_enable_fpb(struct target *target)
 {
-	int retval = target_cs_dbg_wr32( target, FP_CTRL, 3);
+	int retval = target_cs_dbg_queued_wr32( target, FP_CTRL, 3);
 	if (retval != ERROR_OK)
 		return retval;
 
 	/* check the fpb is actually enabled */
 	uint32_t fpctrl;
-	retval = target_cs_dbg_rd32( target, FP_CTRL, &fpctrl);
+	retval = target_cs_dbg_atomic_rd32( target, FP_CTRL, &fpctrl);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -225,10 +241,10 @@ static int cortex_m_endreset_event(struct target *target)
 	struct cortex_m_dwt_comparator *dwt_list = cortex_m->dwt_comparator_list;
 
 	/* REVISIT The four debug monitor bits are currently ignored... */
-	retval = target_cs_dbg_rd32( target, DCB_DEMCR, &dcb_demcr);
+	retval = target_cs_dbg_queued_rd32( target, DCB_DEMCR, &dcb_demcr);
 	if (retval != ERROR_OK)
 		return retval;
-	LOG_DEBUG("DCB_DEMCR = 0x%8.8" PRIx32 "", dcb_demcr);
+
 
 	/* this register is used for emulated dcc channel */
 	retval = target_cs_dbg_queued_wr32( target,DCB_DCRDR, 0);
@@ -236,9 +252,12 @@ static int cortex_m_endreset_event(struct target *target)
 		return retval;
 
 	/* Enable debug requests */
-	retval = target_cs_dbg_rd32( target, DCB_DHCSR, &cortex_m->dcb_dhcsr);
+	retval = target_cs_dbg_atomic_rd32( target, DCB_DHCSR, &cortex_m->dcb_dhcsr);
 	if (retval != ERROR_OK)
 		return retval;
+
+	LOG_DEBUG("DCB_DEMCR = 0x%8.8" PRIx32 "", dcb_demcr);
+
 	if (!(cortex_m->dcb_dhcsr & C_DEBUGEN)) {
 		retval = target_cs_dbg_queued_wr32( target,DCB_DHCSR, DBGKEY | C_DEBUGEN);
 		if (retval != ERROR_OK)
@@ -246,7 +265,10 @@ static int cortex_m_endreset_event(struct target *target)
 	}
 
 	/* clear any interrupt masking */
-	cortex_m_write_debug_halt_mask(target, 0, C_MASKINTS);
+	retval = cortex_m_write_debug_halt_mask(target, 0, C_MASKINTS);
+	if( retval != ERROR_OK ){
+		return retval;
+	}
 
 	/* Enable features controlled by ITM and DWT blocks, and catch only
 	 * the vectors we were told to pay attention to.
@@ -274,22 +296,22 @@ static int cortex_m_endreset_event(struct target *target)
 
 	/* Restore FPB registers */
 	for (i = 0; i < cortex_m->fp_num_code + cortex_m->fp_num_lit; i++) {
-		retval = target_cs_dbg_wr32( target, fp_list[i].fpcr_address, fp_list[i].fpcr_value);
+		retval = target_cs_dbg_queued_wr32( target, fp_list[i].fpcr_address, fp_list[i].fpcr_value);
 		if (retval != ERROR_OK)
 			return retval;
 	}
 
 	/* Restore DWT registers */
 	for (i = 0; i < cortex_m->dwt_num_comp; i++) {
-		retval = target_cs_dbg_wr32( target, dwt_list[i].dwt_comparator_address + 0,
+		retval = target_cs_dbg_queued_wr32( target, dwt_list[i].dwt_comparator_address + 0,
 				dwt_list[i].comp);
 		if (retval != ERROR_OK)
 			return retval;
-		retval = target_cs_dbg_wr32( target, dwt_list[i].dwt_comparator_address + 4,
+		retval = target_cs_dbg_queued_wr32( target, dwt_list[i].dwt_comparator_address + 4,
 				dwt_list[i].mask);
 		if (retval != ERROR_OK)
 			return retval;
-		retval = target_cs_dbg_wr32( target, dwt_list[i].dwt_comparator_address + 8,
+		retval = target_cs_dbg_queued_wr32( target, dwt_list[i].dwt_comparator_address + 8,
 				dwt_list[i].function);
 		if (retval != ERROR_OK)
 			return retval;
@@ -301,7 +323,7 @@ static int cortex_m_endreset_event(struct target *target)
 	register_cache_invalidate(armv7m->arm.core_cache);
 
 	/* make sure we have latest dhcsr flags */
-	retval = target_cs_dbg_rd32( target, DCB_DHCSR, &cortex_m->dcb_dhcsr);
+	retval = target_cs_dbg_atomic_rd32( target, DCB_DHCSR, &cortex_m->dcb_dhcsr);
 
 	return retval;
 }
@@ -339,11 +361,12 @@ static int cortex_m_examine_exception_reason(struct target *target)
 	retval = target_cs_dbg_queued_rd32( target, NVIC_SHCSR, &shcsr);
 	if (retval != ERROR_OK)
 		return retval;
+
 	switch (armv7m->exception_number) {
 		case 2:	/* NMI */
 			break;
 		case 3:	/* Hard Fault */
-			retval = target_cs_dbg_rd32( target, NVIC_HFSR, &except_sr);
+			retval = target_cs_dbg_atomic_rd32( target, NVIC_HFSR, &except_sr);
 			if (retval != ERROR_OK)
 				return retval;
 			if (except_sr & 0x40000000) {
@@ -410,7 +433,7 @@ static int cortex_m_debug_entry(struct target *target)
 	LOG_DEBUG(" ");
 
 	cortex_m_clear_halt(target);
-	retval = target_cs_dbg_rd32( target, DCB_DHCSR, &cortex_m->dcb_dhcsr);
+	retval = target_cs_dbg_atomic_rd32( target, DCB_DHCSR, &cortex_m->dcb_dhcsr);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -486,7 +509,7 @@ static int cortex_m_poll(struct target *target)
 	struct cortex_m_common *cortex_m = target_to_cm(target);
 
 	/* Read from Debug Halting Control and Status Register */
-	retval = target_cs_dbg_rd32( target,DCB_DHCSR, &cortex_m->dcb_dhcsr);
+	retval = target_cs_dbg_atomic_rd32( target,DCB_DHCSR, &cortex_m->dcb_dhcsr);
 	if (retval != ERROR_OK) {
 		target->state = TARGET_UNKNOWN;
 		return retval;
@@ -507,7 +530,7 @@ static int cortex_m_poll(struct target *target)
 		detected_failure = ERROR_FAIL;
 
 		/* refresh status bits */
-		retval = target_cs_dbg_rd32( target,DCB_DHCSR, &cortex_m->dcb_dhcsr);
+		retval = target_cs_dbg_atomic_rd32( target,DCB_DHCSR, &cortex_m->dcb_dhcsr);
 		if (retval != ERROR_OK)
 			return retval;
 	}
@@ -627,7 +650,7 @@ static int cortex_m_soft_reset_halt(struct target *target)
 		return retval;
 
 	/* Request a core-only reset */
-	retval = target_cs_dbg_wr32( target, NVIC_AIRCR,
+	retval = target_cs_dbg_atomic_wr32( target, NVIC_AIRCR,
 			AIRCR_VECTKEY | AIRCR_VECTRESET);
 	if (retval != ERROR_OK)
 		return retval;
@@ -637,9 +660,9 @@ static int cortex_m_soft_reset_halt(struct target *target)
 	register_cache_invalidate(cortex_m->armv7m.arm.core_cache);
 
 	while (timeout < 100) {
-		retval = target_cs_dbg_rd32( target,DCB_DHCSR, &dcb_dhcsr);
+		retval = target_cs_dbg_atomic_rd32( target,DCB_DHCSR, &dcb_dhcsr);
 		if (retval == ERROR_OK) {
-			retval = target_cs_dbg_rd32( target,NVIC_DFSR,
+			retval = target_cs_dbg_atomic_rd32( target,NVIC_DFSR,
 					&cortex_m->nvic_dfsr);
 			if (retval != ERROR_OK)
 				return retval;
@@ -882,7 +905,7 @@ static int cortex_m_step(struct target *target, int current,
 
 					/* Wait for pending handlers to complete or timeout */
 					do {
-						retval = target_cs_dbg_rd32( target,
+						retval = target_cs_dbg_atomic_rd32( target,
 								DCB_DHCSR,
 								&cortex_m->dcb_dhcsr);
 						if (retval != ERROR_OK) {
@@ -917,7 +940,7 @@ static int cortex_m_step(struct target *target, int current,
 		}
 	}
 
-	retval = target_cs_dbg_rd32( target,DCB_DHCSR, &cortex_m->dcb_dhcsr);
+	retval = target_cs_dbg_atomic_rd32( target,DCB_DHCSR, &cortex_m->dcb_dhcsr);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -984,7 +1007,7 @@ static int cortex_m_assert_reset(struct target *target)
 
 	/* Enable debug requests */
 	int retval;
-	retval = target_cs_dbg_rd32( target,DCB_DHCSR, &cortex_m->dcb_dhcsr);
+	retval = target_cs_dbg_atomic_rd32( target,DCB_DHCSR, &cortex_m->dcb_dhcsr);
 	if (retval != ERROR_OK)
 		return retval;
 	if (!(cortex_m->dcb_dhcsr & C_DEBUGEN)) {
@@ -1008,7 +1031,7 @@ static int cortex_m_assert_reset(struct target *target)
 	if (!target->reset_halt) {
 		/* Set/Clear C_MASKINTS in a separate operation */
 		if (cortex_m->dcb_dhcsr & C_MASKINTS) {
-			retval = target_cs_dbg_wr32( target, DCB_DHCSR,
+			retval = target_cs_dbg_atomic_wr32( target, DCB_DHCSR,
 					DBGKEY | C_DEBUGEN | C_HALT);
 			if (retval != ERROR_OK)
 				return retval;
@@ -1026,7 +1049,7 @@ static int cortex_m_assert_reset(struct target *target)
 		 * bad vector table entries.  Should this include MMERR or
 		 * other flags too?
 		 */
-		retval = target_cs_dbg_wr32( target, DCB_DEMCR,
+		retval = target_cs_dbg_atomic_wr32( target, DCB_DEMCR,
 				TRCENA | VC_HARDERR | VC_BUSERR | VC_CORERESET);
 		if (retval != ERROR_OK)
 			return retval;
@@ -1042,7 +1065,7 @@ static int cortex_m_assert_reset(struct target *target)
 		 * This has the disadvantage of not resetting the peripherals, so a
 		 * reset-init event handler is needed to perform any peripheral resets.
 		 */
-		retval = target_cs_dbg_wr32( target, NVIC_AIRCR,
+		retval = target_cs_dbg_atomic_wr32( target, NVIC_AIRCR,
 				AIRCR_VECTKEY | ((reset_config == CORTEX_M_RESET_SYSRESETREQ)
 				? AIRCR_SYSRESETREQ : AIRCR_VECTRESET));
 		if (retval != ERROR_OK)
@@ -1062,8 +1085,13 @@ static int cortex_m_assert_reset(struct target *target)
 		  During the intialization CDBGPWRUPACK is pulled low and we
 		  need to wait for it to be set to 1 again.
 		*/
-		retval = dap_dp_poll_register(dap, DP_CTRL_STAT,
-					      CDBGPWRUPACK, CDBGPWRUPACK, 100);
+		if( dap->ignore_csyspwrupreq ){
+			/* We ignore this */
+			retval = ERROR_OK;
+		} else {
+			retval = dap_dp_poll_register(dap, DP_CTRL_STAT,
+										  CDBGPWRUPACK, CDBGPWRUPACK, 100);
+		}
 		if (retval != ERROR_OK) {
 			LOG_ERROR("Failed waitnig for CDBGPWRUPACK");
 			return ERROR_FAIL;
@@ -1075,7 +1103,7 @@ static int cortex_m_assert_reset(struct target *target)
 			 * after reset) on LM3S6918 -- Michael Schwingen
 			 */
 			uint32_t tmp;
-			retval = target_cs_dbg_rd32( target,NVIC_AIRCR, &tmp);
+			retval = target_cs_dbg_atomic_rd32( target,NVIC_AIRCR, &tmp);
 			if (retval != ERROR_OK)
 				return retval;
 		}
@@ -1133,7 +1161,7 @@ int cortex_m_set_breakpoint(struct target *target, struct breakpoint *breakpoint
 		hilo = (breakpoint->address & 0x2) ? FPCR_REPLACE_BKPT_HIGH : FPCR_REPLACE_BKPT_LOW;
 		comparator_list[fp_num].used = 1;
 		comparator_list[fp_num].fpcr_value = (breakpoint->address & 0x1FFFFFFC) | hilo | 1;
-		target_cs_dbg_wr32( target, comparator_list[fp_num].fpcr_address,
+		target_cs_dbg_atomic_wr32( target, comparator_list[fp_num].fpcr_address,
 			comparator_list[fp_num].fpcr_value);
 		LOG_DEBUG("fpc_num %i fpcr_value 0x%" PRIx32 "",
 			fp_num,
@@ -1207,7 +1235,7 @@ int cortex_m_unset_breakpoint(struct target *target, struct breakpoint *breakpoi
 		}
 		comparator_list[fp_num].used = 0;
 		comparator_list[fp_num].fpcr_value = 0;
-		target_cs_dbg_wr32( target, comparator_list[fp_num].fpcr_address,
+		target_cs_dbg_atomic_wr32( target, comparator_list[fp_num].fpcr_address,
 			comparator_list[fp_num].fpcr_value);
 	} else {
 		/* restore original instruction (kept in target endianness) */
@@ -1324,11 +1352,11 @@ int cortex_m_set_watchpoint(struct target *target, struct watchpoint *watchpoint
 	watchpoint->set = dwt_num + 1;
 
 	comparator->comp = watchpoint->address;
-	target_cs_dbg_wr32( target, comparator->dwt_comparator_address + 0,
+	target_cs_dbg_queued_wr32( target, comparator->dwt_comparator_address + 0,
 		comparator->comp);
 
 	comparator->mask = mask;
-	target_cs_dbg_wr32( target, comparator->dwt_comparator_address + 4,
+	target_cs_dbg_queued_wr32( target, comparator->dwt_comparator_address + 4,
 		comparator->mask);
 
 	switch (watchpoint->rw) {
@@ -1342,7 +1370,7 @@ int cortex_m_set_watchpoint(struct target *target, struct watchpoint *watchpoint
 			comparator->function = 7;
 			break;
 	}
-	target_cs_dbg_wr32( target, comparator->dwt_comparator_address + 8,
+	target_cs_dbg_atomic_wr32( target, comparator->dwt_comparator_address + 8,
 		comparator->function);
 
 	LOG_DEBUG("Watchpoint (ID %d) DWT%d 0x%08x 0x%x 0x%05x",
@@ -1379,7 +1407,7 @@ int cortex_m_unset_watchpoint(struct target *target, struct watchpoint *watchpoi
 	comparator = cortex_m->dwt_comparator_list + dwt_num;
 	comparator->used = 0;
 	comparator->function = 0;
-	target_cs_dbg_wr32( target, comparator->dwt_comparator_address + 8,
+	target_cs_dbg_atomic_wr32( target, comparator->dwt_comparator_address + 8,
 		comparator->function);
 
 	watchpoint->set = false;
@@ -1641,6 +1669,7 @@ static int cortex_m_dwt_get_reg(struct reg *reg)
 {
 	struct dwt_reg_state *state = reg->arch_info;
 
+	/*FIXME: Should this be target_dbg_atomic_rd32()? */
 	return target_read_u32(state->target, state->addr, &state->value);
 }
 
@@ -1648,6 +1677,7 @@ static int cortex_m_dwt_set_reg(struct reg *reg, uint8_t *buf)
 {
 	struct dwt_reg_state *state = reg->arch_info;
 
+	/*FIXME: Should this be target_dbg_atomic_wr32()? */
 	return target_write_u32(state->target, state->addr,
 			buf_get_u32(buf, 0, reg->size));
 }
@@ -1708,7 +1738,7 @@ void cortex_m_dwt_setup(struct cortex_m_common *cm, struct target *target)
 	struct cortex_m_dwt_comparator *comparator;
 	int reg, i;
 
-	target_cs_dbg_rd32( target, DWT_CTRL, &dwtcr);
+	target_cs_dbg_atomic_rd32( target, DWT_CTRL, &dwtcr);
 	if (!dwtcr) {
 		LOG_DEBUG("no DWT");
 		return;
@@ -1753,8 +1783,10 @@ fail1:
 				dwt_comp + 3 * i + j);
 
 		/* make sure we clear any watchpoints enabled on the target */
-		target_cs_dbg_wr32( target, comparator->dwt_comparator_address + 8, 0);
+		target_cs_dbg_queued_wr32( target, comparator->dwt_comparator_address + 8, 0);
 	}
+	/* flush any queued items */
+	target_cs_dap_run(target);
 
 	*register_get_last_cache_p(&target->reg_cache) = cache;
 	cm->dwt_cache = cache;
@@ -1795,7 +1827,7 @@ int cortex_m_examine(struct target *target)
 		target_set_examined(target);
 
 		/* Read from Device Identification Registers */
-		retval = target_cs_dbg_rd32( target, CPUID, &cpuid);
+		retval = target_cs_dbg_atomic_rd32( target, CPUID, &cpuid);
 		if (retval != ERROR_OK)
 			return retval;
 
@@ -1810,8 +1842,8 @@ int cortex_m_examine(struct target *target)
 
 		/* test for floating point feature on cortex-m4 */
 		if (i == 4) {
-			target_cs_dbg_rd32( target, MVFR0, &mvfr0);
-			target_cs_dbg_rd32( target, MVFR1, &mvfr1);
+			target_cs_dbg_queued_rd32( target, MVFR0, &mvfr0);
+			target_cs_dbg_atomic_rd32( target, MVFR1, &mvfr1);
 
 			if ((mvfr0 == MVFR0_DEFAULT_M4) && (mvfr1 == MVFR1_DEFAULT_M4)) {
 				LOG_DEBUG("Cortex-M%d floating point feature FPv4_SP found", i);
@@ -1829,6 +1861,10 @@ int cortex_m_examine(struct target *target)
 			 *   Some do, some do not ..
 			 *   there is no means to query the dap
 			 *   and determine the actual implimentation.
+ 			 *------
+			 * You must go by the IDR value of the specific DAP PORT
+			 * This is configured in the DAP 
+ 			 *------
 			 */
 #if 0
 			armv7m->arm.dap->tar_autoincr_block = (1 << 12);
@@ -1838,7 +1874,7 @@ int cortex_m_examine(struct target *target)
 		/* NOTE: FPB and DWT are both optional. */
 
 		/* Setup FPB */
-		target_cs_dbg_rd32( target, FP_CTRL, &fpcr);
+		target_cs_dbg_atomic_rd32( target, FP_CTRL, &fpcr);
 		cortex_m->auto_bp_type = 1;
 		/* bits [14:12] and [7:4] */
 		cortex_m->fp_num_code = ((fpcr >> 8) & 0x70) | ((fpcr >> 4) & 0xF);
@@ -1854,8 +1890,10 @@ int cortex_m_examine(struct target *target)
 			cortex_m->fp_comparator_list[i].fpcr_address = FP_COMP0 + 4 * i;
 
 			/* make sure we clear any breakpoints enabled on the target */
-			target_cs_dbg_wr32( target, cortex_m->fp_comparator_list[i].fpcr_address, 0);
+			target_cs_dbg_queued_wr32( target, cortex_m->fp_comparator_list[i].fpcr_address, 0);
 		}
+		/* Flush the above writes */
+		target_cs_dap_run(target);
 		LOG_DEBUG("FPB fpcr 0x%" PRIx32 ", numcode %i, numlit %i",
 			fpcr,
 			cortex_m->fp_num_code,
@@ -2052,7 +2090,7 @@ COMMAND_HANDLER(handle_cortex_m_vector_catch_command)
 	if (retval != ERROR_OK)
 		return retval;
 
-	retval = target_cs_dbg_rd32( target,DCB_DEMCR, &demcr);
+	retval = target_cs_dbg_atomic_rd32( target,DCB_DEMCR, &demcr);
 	if (retval != ERROR_OK)
 		return retval;
 
@@ -2092,7 +2130,7 @@ write:
 		retval = target_cs_dbg_queued_wr32( target,DCB_DEMCR, demcr);
 		if (retval != ERROR_OK)
 			return retval;
-		retval = target_cs_dbg_rd32( target, DCB_DEMCR, &demcr);
+		retval = target_cs_dbg_atomic_rd32( target, DCB_DEMCR, &demcr);
 		if (retval != ERROR_OK)
 			return retval;
 
diff --git a/tcl/qualcomm/common/jtag_dap_cfg1.cfg b/tcl/qualcomm/common/jtag_dap_cfg1.cfg
old mode 100644
new mode 100755
index 6f3e36a..d20552c
--- a/tcl/qualcomm/common/jtag_dap_cfg1.cfg
+++ b/tcl/qualcomm/common/jtag_dap_cfg1.cfg
@@ -23,5 +23,5 @@ reset_config trst_and_srst
 
 adapter_khz 3000
 
-debug_flags set  dap_debug_flags -1
+#debug_flags set  dap_debug_flags -1
 
-- 
1.9.1


From 4f210fb27657a37c7f88d4b52d9d5d351c0a3c8b Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 87/94] Undo chmod weirdizms from WindDoze

---
 src/target/arm_adi_v5_debug.c         | 0
 src/target/coresight_io.c             | 0
 tcl/qualcomm/common/jtag_dap_cfg1.cfg | 0
 3 files changed, 0 insertions(+), 0 deletions(-)
 mode change 100755 => 100644 src/target/arm_adi_v5_debug.c
 mode change 100755 => 100644 src/target/coresight_io.c
 mode change 100755 => 100644 tcl/qualcomm/common/jtag_dap_cfg1.cfg

diff --git a/src/target/arm_adi_v5_debug.c b/src/target/arm_adi_v5_debug.c
old mode 100755
new mode 100644
diff --git a/src/target/coresight_io.c b/src/target/coresight_io.c
old mode 100755
new mode 100644
diff --git a/tcl/qualcomm/common/jtag_dap_cfg1.cfg b/tcl/qualcomm/common/jtag_dap_cfg1.cfg
old mode 100755
new mode 100644
-- 
1.9.1


From c437b15634bc79d5adde23f02f6b08ff05631c2e Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 88/94] Cleanup log message

---
 src/target/arm_adi_v5_debug.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/target/arm_adi_v5_debug.c b/src/target/arm_adi_v5_debug.c
index 09702ee..07b9311 100644
--- a/src/target/arm_adi_v5_debug.c
+++ b/src/target/arm_adi_v5_debug.c
@@ -480,7 +480,7 @@ int dap_run(struct adiv5_dap *dap)
 {
 	int r;
 	assert(dap->driver.ops != NULL);
-	LOG_DEBUG("DAP FLUSH");
+	//	LOG_DEBUG("DAP FLUSH");
 	r = dap->driver.ops->run(dap);
 	dap_dbg_log_dump( dap );
 	return r;
-- 
1.9.1


From 19216472039ca3daa407d491bbf29240bf5f5a7d Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 89/94] Add recursion block for ARM DAP re-init failure

---
 src/target/adi_v5_jtag.c | 12 +++++++++++-
 src/target/arm_adi_v5.c  |  1 +
 src/target/arm_adi_v5.h  |  1 +
 3 files changed, 13 insertions(+), 1 deletion(-)

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index 5798bc9..d0526ea 100755
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -405,9 +405,19 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 	}
 	
 	if ((ctrlstat & v) != v) {
+		/* this can occur ... if we re-init 
+		 * the DAP on failure
+		 * and the re-init has failed
+		 */
+		if( dap->recursion_block ){
+			LOG_DEBUG("REINIT DAP Fails (recursive)");
+			return ERROR_FAIL;
+		}
 		LOG_DEBUG("reinitializing debug port");
+		dap->recursion_block += 1;
 		retval = dap_debugport_init(dap);
-		LOG_DEBUG("result: %d\n", retval );
+		dap->recursion_block -= 1;
+		LOG_DEBUG("result: %d", retval );
 		/* must still fail the transfer */
 		return ERROR_FAIL;
 	}
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 73a90e6..3e0c144 100755
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -2565,6 +2565,7 @@ struct adiv5_dap *arm_dap_new( const char *name, int transport )
 		LOG_ERROR("no memory for new dap!");
 		return dap;
 	}
+	dap->recursion_block = 0;
 	/*
 	 * Today: calloc() is mostly sufficent :-)
 	 * This will change in the future!
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 83193af..22946e2 100755
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -148,6 +148,7 @@ struct coresight_settings;
  * signals are available).
  */
 struct adiv5_dap {
+	int   recursion_block;
 	const char *dap_name;
 	struct adiv5_dap  *next_dap;
 	/* set by arm_adi_new_dap */
-- 
1.9.1


From 74897675366cef69e01c420c505244448254db79 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 90/94] Add debug print jim callstack function to help debug
 under gdb

---
 src/helper/command.c | 13 ++++++++
 src/helper/jim-nvp.c | 85 +++++++++++++++++++++++++++++++++++++++++++++++++++-
 src/helper/jim-nvp.h |  5 +++-
 3 files changed, 101 insertions(+), 2 deletions(-)

diff --git a/src/helper/command.c b/src/helper/command.c
index 96c38ba..306a2e4 100755
--- a/src/helper/command.c
+++ b/src/helper/command.c
@@ -1315,6 +1315,19 @@ struct command_context *command_init(const char *startup_tcl, Jim_Interp *interp
 		Jim_InitStaticExtensions(interp);
 	}
 
+	/* this is for GDB use when debugging openocd.
+	 * If you want to get the jim callstack
+	 * at the GDB prompt type "print jim_print_callstack()"
+	 * 
+	 * Then look at the stderr *OUTPUT* of Openocd
+	 *
+	 * yes globals are messy, but there is no way to 
+	 * always pass an interp to this function
+	 *
+	 * Because - in some contexts, you do not have
+	 * an interp available to  you.
+	 */
+	jim_callstack_global_interp = interp;
 	context->interp = interp;
 
 	/* Stick to lowercase for HostOS strings. */
diff --git a/src/helper/jim-nvp.c b/src/helper/jim-nvp.c
index c7db57c..b5b1964 100755
--- a/src/helper/jim-nvp.c
+++ b/src/helper/jim-nvp.c
@@ -49,7 +49,6 @@
 #include <jim-nvp.h>
 #include <target/target.h>
 
-
 int Jim_GetNvp(Jim_Interp *interp,
 	Jim_Obj *objPtr, const Jim_Nvp *nvp_table, const Jim_Nvp **result)
 {
@@ -542,4 +541,88 @@ int Jim_GetOpt_Dispatch( Jim_GetOptInfo *goi, const Jim_Getopt_SubCmd *_cmds )
 	Jim_SetResultFormatted( goi->interp, "unknown command: %s", cp );
 	return JIM_ERR;
 }
+
+/*==================================================
+ * DUMP the JIM Debug stack from the GDB command line
+ * 
+ * This exists for use when you are debugging openocd
+ * and need to understand the JIM callstack.
+ *
+ * GDB ... supports a "where" command that tells you
+ *        the "C" callstack
+ * 
+ * However, this does not tell you the JIM callstack.
+ *
+ * This function will print the JIM callstack.
+ */
+Jim_Interp *jim_callstack_global_interp;
+
+static const char *string_of( Jim_Obj *o, const char *what, char *errbuf, size_t errbuf_siz )
+{
+	if( o->bytes ){
+		return o->bytes;
+	}
+	
+	snprintf( errbuf, errbuf_siz, "no string for %s", what );
+	return errbuf;
+}
+
+int jim_print_callstack( void )
+{
+	const char *filename;
+	const char *procname;
+	int        lineno;
+	Jim_Interp *interp;
+	Jim_CallFrame *f;
+	/* we do this static
+	 * because ... we may be in an
+	 * unstable situation with JIM
+	 * Allocating this much off the
+	 * stack may blow up
+	 */
+	static	char filename_buf[100];
+	static	char procname_buf[100];
+	interp = jim_callstack_global_interp;
+	if( interp == NULL ){
+		fprintf(stderr,"No JIM call stack available\n");
+		return 42;
+	}
+
+	f = interp->framePtr;
+
+	int x;
+	x = 0;
+	/* some limits
+	 * in case we go recursivly wacky..
+	 *   Limit to 100 entries
+	 *   And check our pointers... 
+	 */
+	while( (x < 100) && (f != NULL) && (f != interp->topFramePtr) ){
+		/*
+		 * We do *NOT* use JIM functions here.
+		 * Reason: We are in a debug senario
+		 * Jim may be unstable!
+		 *
+		 * We need 2 things:
+		 *    STRINGS - for the filename
+		 *    INTEGERS for the linenumber
+		 *    STRINGS for the procedure name
+		 * We can manually inspect and find these.
+		 */
+		lineno   = f->line;
+		filename = string_of( f->fileNameObj, "filename", filename_buf, sizeof(filename_buf) );
+		procname = string_of( f->nsObj      , "procname", procname_buf, sizeof(procname_buf) );
+		fprintf( stderr, "%d) %s:%d: proc: %s\n", x, filename, lineno, procname );
+		x++;
+		f = f->parent;
+	}
+	fprintf(stderr,"**END**\n");
+	/* GDB wants to print some result... */
+	/* so give it the answer ... */
+	return 42;
+}
+		
+
 	
+
+
diff --git a/src/helper/jim-nvp.h b/src/helper/jim-nvp.h
index 9eb88da..fffc729 100755
--- a/src/helper/jim-nvp.h
+++ b/src/helper/jim-nvp.h
@@ -375,6 +375,9 @@ struct jim_getopt_subcmd {
 
 int Jim_GetOpt_Dispatch( Jim_GetOptInfo *goi, const Jim_Getopt_SubCmd *cmds );
 	
-	
+
+int jim_print_callstack(void);
+extern Jim_Interp *jim_callstack_global_interp;
+
 
 #endif
-- 
1.9.1


From b9ced1894836f9bc00f80837e40d973162e2ce35 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 91/94] Explain how 64bit is determined

---
 src/target/cortex_a53.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 4937a50..0a279e2 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -50,6 +50,20 @@ static int isAArch64(uint32_t dscr)
 		/* examine EL bits [9:8] */
 		//is in debug state
 		//LOG_DEBUG("dscr is 0x%x", dscr);
+		/* 
+		 * Bits [9:8] = define the current CPU EL level
+		 *  00 = EL0 - user mode
+		 *  01 = EL1 - kernel
+		 *  10 = EL2 - aka trustzone
+		 *  11 = EL3 - hypervisor
+		 *
+		 * Next - look at bits 13,12,11,10
+		 * If bit 13 is set - then EL3 is 64bit
+		 * If bit 12 is set - then EL2 is 64bit
+		 * If bit 11 is set - then EL1 is 64bit
+		 * If bit 10 is set - then EL0 is 64bit
+		 */
+		
 		if(dscr & (1<<(((dscr&0x300)>>8)+10))) return 1;
 		else return 0;
 	}
-- 
1.9.1


From 0f81d6772fbb63505d39c3bae347d2ceb3b0fbb7 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 92/94] Be a little better about the dap tar/csw cache

---
 src/target/adi_v5_jtag.c |  8 ++++----
 src/target/arm_adi_v5.c  | 11 +++++++++--
 src/target/arm_adi_v5.h  |  1 +
 3 files changed, 14 insertions(+), 6 deletions(-)

diff --git a/src/target/adi_v5_jtag.c b/src/target/adi_v5_jtag.c
index d0526ea..d3b22fc 100755
--- a/src/target/adi_v5_jtag.c
+++ b/src/target/adi_v5_jtag.c
@@ -385,10 +385,10 @@ static int jtagdp_transaction_endcheck(struct adiv5_dap *dap)
 	 * the CSW and TAR cache values.
 	 */
 	{
-		struct adiv5_dap_port *port;
-		port = dap_current_port( dap );
-		port->cached_csw_valid = false;
-		port->cached_tar_valid = false;
+		int x;
+		for( x = 0 ; x < 256 ; x++ ){
+			dap_ap_tar_invalidate_cache( dap, x );
+		}
 	}
 		
 	LOG_DEBUG("jtag-dp: CTRL/STAT error, 0x%" PRIx32" (sticky:%d, overrun:%d)",
diff --git a/src/target/arm_adi_v5.c b/src/target/arm_adi_v5.c
index 3e0c144..189455b 100755
--- a/src/target/arm_adi_v5.c
+++ b/src/target/arm_adi_v5.c
@@ -257,10 +257,17 @@ struct adiv5_dap_port *dap_current_port( struct adiv5_dap *dap )
  */
 void dap_ap_select(struct adiv5_dap *dap, int ap )
 {
-	struct adiv5_dap_port *p;
 	dap_update_select_reg_cache( dap, ap, -1, -1 );
+}
 
-	p = dap_current_port( dap );
+void dap_ap_tar_invalidate_cache( struct adiv5_dap *dap, int ap )
+{
+	struct adiv5_dap_port *p;
+	if( (ap < 0) || (ap > 255) ){
+		LOG_ERROR("invalid dap port\n");
+		return;
+	}
+	p = &(dap->port[ ap ]);
 	if( p ){
 		p->cached_tar_valid = false;
 		p->cached_tar_reg   = (uint64_t)(-1);
diff --git a/src/target/arm_adi_v5.h b/src/target/arm_adi_v5.h
index 22946e2..a2ab120 100755
--- a/src/target/arm_adi_v5.h
+++ b/src/target/arm_adi_v5.h
@@ -493,6 +493,7 @@ struct target_addr;
 /* required [for now] byt he kinetis.c] flash code */
 
 void dap_ap_select(struct adiv5_dap *dap, int ap );
+void dap_ap_tar_invalidate_cache( struct adiv5_dap *dap, int ap );
 
 /* clear all port cache info we know of */
 void dap_invalidate_port_cache( struct adiv5_dap *dap );
-- 
1.9.1


From d1ecdc8f2d35c311d5bbf46d8c10a62b71b9847b Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 93/94] Markup for armv8 changes review

---
 src/target/armv8.c      |  15 +-
 src/target/cortex_a53.c | 363 ++++++++++++++++++++++++++++++------------------
 2 files changed, 237 insertions(+), 141 deletions(-)

diff --git a/src/target/armv8.c b/src/target/armv8.c
index 4a9d01e..8ffdabf 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -838,10 +838,11 @@ int armv8_get_gdb_reg_list(struct target *target,
  */
 
 /* Read coprocessor */
-static int armv8_mrs(struct target *target,
+static int armv8_mrs_BAD(struct target *target,
 	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
 	uint32_t *value)
 {
+	/* WHYBAD: This uses an function which indirectly translates the opcodes */
 	struct armv8 *armv8 = target_to_armv8( target );
 	struct armv8_dpm *armv8_dpm = armv8_to_armv8_dpm(armv8);
 	struct arm_dpm   *dpm       = armv8_to_arm_dpm(armv8);
@@ -859,10 +860,11 @@ static int armv8_mrs(struct target *target,
 	return retval;
 }
 
-static int armv8_msr(struct target *target,
+static int armv8_msr_BAD(struct target *target,
 	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
 	uint32_t value)
 {
+	/* WHYBAD: This uses an function which indirectly translates the opcodes */
 	struct armv8     *armv8     = target_to_armv8( target );
 	struct armv8_dpm *armv8_dpm = armv8_to_armv8_dpm( armv8 );
 	struct arm_dpm   *dpm       = armv8_to_arm_dpm( armv8 );
@@ -880,10 +882,11 @@ static int armv8_msr(struct target *target,
 	return retval;
 }
 
-static int armv8_drps(struct target *target,
+static int armv8_drps_MAYBEBAD(struct target *target,
 	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
 	uint32_t value)
 {
+	/* WHYBAD: Might not be bad - but this hard code opcode makes me wonder */
 	struct armv8     *armv8     = target_to_armv8( target );
 	struct armv8_dpm *armv8_dpm = armv8_to_armv8_dpm( armv8 );
 	struct arm_dpm   *dpm       = armv8_to_arm_dpm( armv8 );
@@ -920,11 +923,11 @@ int armv8_init_arch_info(struct target *target)
 	struct armv8 *armv8 = target_to_armv8( target );
 
 	if (!armv8->mrs)
-		armv8->mrs = armv8_mrs;
+		armv8->mrs = armv8_mrs_BAD;
 	if (!armv8->msr)
-		armv8->msr = armv8_msr;
+		armv8->msr = armv8_msr_BAD;
 	if (!armv8->drps)
-		armv8->drps = armv8_drps;
+		armv8->drps = armv8_drps_MAYBEBAD;
 	if (!armv8->modeswitch)
 		armv8->modeswitch = armv8_modeswitch;
 
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 0a279e2..622e4a2 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -18,7 +18,7 @@
 #include "arm_adi_v5.h"
 #include <helper/time_support.h>
 
-static int cortex_a53_halt(struct target *target);
+static int cortex_a53_halt_BAD(struct target *target);
 static int cortex_a53_poll(struct target *target);
 static int cortex_a53_debug_entry(struct target *target);
 static int cortex_a53_restore_context(struct target *target, bool bpwp);
@@ -33,7 +33,7 @@ static int cortex_a53_unset_breakpoint(struct target *target,
 static int cortex_a53_mmu(struct target *target, int *enabled);
 static int cortex_a53_virt2phys_64(struct target *target,
         const struct target_addr *in_pVirt, struct target_addr *out_pPhys );
-static int cortex_a53_read_apb_ab_memory(struct target *target,
+static int cortex_a53_read_apb_ab_memory_BAD(struct target *target,
 	const struct target_addr *pAddr, uint32_t size, uint32_t count, uint8_t *buffer);
 
 
@@ -434,8 +434,10 @@ static int cortex_a53_check_address(struct target *target, const struct target_a
 /*  modify cp15_control_reg in order to enable or disable mmu for :
  *  - virt2phys address conversion
  *  - read or write memory in phys or virt address */
-static int cortex_a53_mmu_modify(struct target *target, int enable)
+static int cortex_a53_mmu_modify_BAD(struct target *target, int enable)
 {
+	/* WHYBAD: Executes "arm->mcr()" which is a translated instruction */
+	/* WHYBAD: uses "cortex_a" settings when it should use armv8 only  */
 	struct armv8		*armv8          = target_to_armv8(target);
 	struct arm		*arm            = armv8_to_arm(armv8);
 	struct cortex_a_common	*cortex_a	= armv8_to_cortex_a( armv8 );
@@ -565,6 +567,7 @@ static int cortex_a53_init_debug_access(struct target *target)
 	return cortex_a53_poll(target);
 }
 
+
 /* To reduce needless round-trips, pass in a pointer to the current
  * DSCR value.  Initialize it to zero if you just need to know the
  * value on return from this function; or DSCR_INSTR_COMP if you
@@ -602,6 +605,56 @@ static int cortex_a53_exec_opcode(struct target *target,
 		}
 	}
 
+
+	LOG_DEBUG("execute: 0x%08x", opcode);
+	retval = target_cs_dbg_queued_wr32( target, CPUDBG_ITR, opcode);
+	if (retval != ERROR_OK)
+		return retval;
+
+	then = timeval_ms();
+	do {
+		if( armv8_debug(EXEC_OPCODE) ){
+			LOG_DEBUG("armv8-exec-opcode-poll(2)");
+		}
+		retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Could not read DSCR register");
+			return retval;
+		}
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for cortex_a53_exec_opcode opcode = 0x%08" PRIx32, opcode);
+			return ERROR_FAIL;
+		}
+	} while ((dscr & DSCR_INSTR_COMP) == 0);	/* Wait for InstrCompl bit to be set */
+	if(dscr & 0x40)
+	{
+		LOG_ERROR("Err set for opcode = 0x%x, with DSCR=0x%x", opcode, dscr);
+		//clear the error
+		target_cs_dbg_queued_wr32( target, EDRCR, 1<<2); //set EDRCR.CSE to clear EDSCR.ERR
+	}
+	if (dscr_p)
+		*dscr_p = dscr;
+
+	return retval;
+}
+
+static int cortex_a53_xlate_opcode( struct target *target,
+									uint32_t opcode,
+									uint32_t *opcode_out )
+{
+	uint32_t dscr;
+	int retval;
+	
+	/* Determine what the CPU state is */
+	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
+	if( retval != ERROR_OK ){
+		return retval;
+	}
+	
+	if( armv8_debug(EXEC_OPCODE) ){
+		LOG_DEBUG("AArch64=%d (dscr=0x%08X)", isAArch64(dscr), dscr);
+	}
+	
     //override opcode. SQU TODO: instead of hack here, might need to change to caller to use right opcode for right state
 	if(opcode==0xE12FF000){
 		/* Move CPSR to R0.
@@ -715,37 +768,27 @@ static int cortex_a53_exec_opcode(struct target *target,
     {
     	if(!target->is_64b) LOG_ERROR("SQU: Exec AArch64 opcode=0x%x for AArch32 state", opcode);
     }
+	*opcode_out = opcode;
+	return ERROR_OK;
+}
 
-	LOG_DEBUG("execute: 0x%08x", opcode);
-	retval = target_cs_dbg_queued_wr32( target, CPUDBG_ITR, opcode);
-	if (retval != ERROR_OK)
-		return retval;
 
-	then = timeval_ms();
-	do {
-		if( armv8_debug(EXEC_OPCODE) ){
-			LOG_DEBUG("armv8-exec-opcode-poll(2)");
-		}
-		retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
-		if (retval != ERROR_OK) {
-			LOG_ERROR("Could not read DSCR register");
-			return retval;
-		}
-		if (timeval_ms() > then + 1000) {
-			LOG_ERROR("Timeout waiting for cortex_a53_exec_opcode opcode = 0x%08" PRIx32, opcode);
-			return ERROR_FAIL;
-		}
-	} while ((dscr & DSCR_INSTR_COMP) == 0);	/* Wait for InstrCompl bit to be set */
-	if(dscr & 0x40)
-	{
-		LOG_ERROR("Err set for opcode = 0x%x, with DSCR=0x%x", opcode, dscr);
-		//clear the error
-		target_cs_dbg_queued_wr32( target, EDRCR, 1<<2); //set EDRCR.CSE to clear EDSCR.ERR
+static int cortex_a53_exec_opcode_BAD(struct target *target,
+	uint32_t opcode, uint32_t *dscr_p)
+{
+	/* WHYBAD: This is the "root of the problem" function */
+	/*         This function should not be used or required */
+	/*         because ARMV8 does not execute A32 instructions */
+	/*         the ARMV8 core executes ONLY A64 and T32 opcodes */
+	int r;
+	uint32_t fixed_opcode;
+	r = cortex_a53_xlate_opcode( target, opcode, &fixed_opcode );
+	if( r != ERROR_OK ){
+		return r;
 	}
-	if (dscr_p)
-		*dscr_p = dscr;
+	LOG_ERROR("ERROR: FIXME xlate opcode: 0x%08x to 0x%08x", opcode, fixed_opcode );
 
-	return retval;
+	return cortex_a53_exec_opcode( target, opcode, dscr_p );
 }
 
 
@@ -826,8 +869,9 @@ static int cortex_a53_read_dcc(struct target *target, uint64_t *data,
 	return retval;
 }
 
-static int cortex_a53_dpm_prepare(struct arm_dpm *dpm)
+static int cortex_a53_dpm_prepare_BAD(struct arm_dpm *dpm)
 {
+	/* WHYBAD: This function executes ARMV4_5_MRC() opcode not ARMV8 opcode */
 	struct target		*target		= arm_dpm_to_target( dpm );
 	uint32_t dscr;
 	int retval;
@@ -847,10 +891,11 @@ static int cortex_a53_dpm_prepare(struct arm_dpm *dpm)
 	}
 
 	/* this "should never happen" ... */
+	LOG_ERROR("**FIXME** - Bad opcode here");
 	if (dscr & DSCR_DTR_RX_FULL) {
 		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
 		/* Clear DCCRX */
-		retval = cortex_a53_exec_opcode(
+		retval = cortex_a53_exec_opcode_BAD(
 						target,
 				ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 				&dscr);
@@ -867,24 +912,28 @@ static int cortex_a53_dpm_finish(struct arm_dpm *dpm)
 	return ERROR_OK;
 }
 
-static int cortex_a53_instr_execution(struct arm_dpm *dpm,
+static int cortex_a53_instr_execution_BAD(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t *data)
 {
+	/* WHYBAD: Because ARM_DPM assumes all ARM cpus execute ARM opcodes */
+	/*         Correct solution ARMV8 should not use ARM_DPM */
+	/*         note this is also true of ARMV7M (cortex) */
 	struct target		*target		= arm_dpm_to_target( dpm );
 	int retval;
 	uint32_t dscr = DSCR_INSTR_COMP;
 
 	/* the opcode, writing data to DCC */
-	retval = cortex_a53_exec_opcode(
+	retval = cortex_a53_exec_opcode_BAD(
 			target,
 			opcode,
 			&dscr);
 	return retval;
 }
 
-static int cortex_a53_instr_write_data64_dcc(struct arm_dpm *dpm,
+static int cortex_a53_instr_write_data64_dcc_BAD(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t data)
 {
+	/* WHY BAD: opcode passed to this function *MUST*NOT*BE* armv8 opcode */
 	struct target		*target		= arm_dpm_to_target( dpm );
 	struct armv8		*armv8		= target_to_armv8( target );
 	int retval;
@@ -894,21 +943,27 @@ static int cortex_a53_instr_write_data64_dcc(struct arm_dpm *dpm,
 	if (retval != ERROR_OK)
 		return retval;
 
-	return cortex_a53_exec_opcode(
+	return cortex_a53_exec_opcode_BAD(
 			target,
 			opcode,
 			&dscr);
 }
 
-static int cortex_a53_instr_write_data_dcc(struct arm_dpm *dpm,
+static int cortex_a53_instr_write_data_dcc_BAD(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t data)
 {
-	return cortex_a53_instr_write_data64_dcc(dpm, opcode, (uint64_t)data);
+	/* WHY BAD: opcode passed to this function *MUST*NOT*BE* armv8 opcode */
+	return cortex_a53_instr_write_data64_dcc_BAD(dpm, opcode, (uint64_t)data);
 }
 
-static int cortex_a53_instr_write_data64_r0_mrs(struct arm_dpm *dpm,
+static int cortex_a53_instr_write_data64_r0_mrs_BAD(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t data)
 {
+	/* WHY BAD: part 1 opcode passed to this function *MUST*NOT*BE* armv8 opcode */
+	/* WHY BAD: part 2 this function uses ARMV8 opcode macro to create opcode */
+	/*          but then this function calls exec_opcode() which translates   */
+	/*          the opcode from ARMV4/5 to armv8? Does this imply the ARMV8   */
+	/*          macro below is generating the correct opcode?                 */
 	struct target		*target		= arm_dpm_to_target( dpm );
 	struct armv8		*armv8		= target_to_armv8( target );
 	uint32_t dscr = DSCR_INSTR_COMP;
@@ -923,7 +978,7 @@ static int cortex_a53_instr_write_data64_r0_mrs(struct arm_dpm *dpm,
 
 		
 	/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15 */
-	retval = cortex_a53_exec_opcode(
+	retval = cortex_a53_exec_opcode_BAD(
 			target,
 			ARMV8_A64_MRS(2, 3, 0, 5, 0, 0),
 			&dscr);
@@ -931,7 +986,7 @@ static int cortex_a53_instr_write_data64_r0_mrs(struct arm_dpm *dpm,
 		return retval;
 
 	/* then the opcode, taking data from R0 */
-	retval = cortex_a53_exec_opcode(
+	retval = cortex_a53_exec_opcode_BAD(
 			target,
 			opcode,
 			&dscr);
@@ -940,9 +995,11 @@ static int cortex_a53_instr_write_data64_r0_mrs(struct arm_dpm *dpm,
 }
 
 
-static int cortex_a53_instr_write_data64_r0(struct arm_dpm *dpm,
+static int cortex_a53_instr_write_data64_r0_BAD(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t data)
 {
+	/* WHY BAD: part 1 opcode passed to this function *MUST*NOT*BE* armv8 opcode */
+	/* WHY BAD: part 2 this uses ARMV4_5_MRC() instruction, armv8 does not use those instructions */
 	struct target		*target		= arm_dpm_to_target( dpm );
 	struct armv8		*armv8		= target_to_armv8( target );
 	uint32_t dscr = DSCR_INSTR_COMP;
@@ -957,7 +1014,7 @@ static int cortex_a53_instr_write_data64_r0(struct arm_dpm *dpm,
 		return retval;
 
 	/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15 */
-	retval = cortex_a53_exec_opcode(
+	retval = cortex_a53_exec_opcode_BAD(
 			target,
 			ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 			&dscr);
@@ -965,7 +1022,7 @@ static int cortex_a53_instr_write_data64_r0(struct arm_dpm *dpm,
 		return retval;
 
 	/* then the opcode, taking data from R0 */
-	retval = cortex_a53_exec_opcode(
+	retval = cortex_a53_exec_opcode_BAD(
 			target,
 			opcode,
 			&dscr);
@@ -973,32 +1030,35 @@ static int cortex_a53_instr_write_data64_r0(struct arm_dpm *dpm,
 	return retval;
 }
 
-static int cortex_a53_instr_write_data_r0(struct arm_dpm *dpm,
+static int cortex_a53_instr_write_data_r0_BAD(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t data)
 {
-	return cortex_a53_instr_write_data64_r0(dpm, opcode, (uint64_t)data);
+	/* WHYBAD: This function assumes the instruction will be translated */
+	return cortex_a53_instr_write_data64_r0_BAD(dpm, opcode, (uint64_t)data);
 }
 
-static int cortex_a53_instr_cpsr_sync(struct arm_dpm *dpm)
+static int cortex_a53_instr_cpsr_sync_BAD(struct arm_dpm *dpm)
 {
+	/* WHYBAD: This function assumes the instruction will be translated */
 	struct target *target = arm_dpm_to_target(dpm);
 	uint32_t dscr = DSCR_INSTR_COMP;
 
 	/* "Prefetch flush" after modifying execution status in CPSR */
-	return cortex_a53_exec_opcode(target,
+	return cortex_a53_exec_opcode_BAD(target,
 			ARMV4_5_MCR(15, 0, 0, 7, 5, 4),
 			&dscr);
 }
 
-static int cortex_a53_instr_read_data64_dcc(struct arm_dpm *dpm,
+static int cortex_a53_instr_read_data64_dcc_BAD(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t *data)
 {
+	/* WHYBAD: This function assumes the instruction will be translated */
 	struct target		*target   = arm_dpm_to_target( dpm );
  	int retval;
 	uint32_t dscr = DSCR_INSTR_COMP;
 
 	/* the opcode, writing data to DCC */
-	retval = cortex_a53_exec_opcode(
+	retval = cortex_a53_exec_opcode_BAD(
 			target,
 			opcode,
 			&dscr);
@@ -1012,25 +1072,29 @@ static int cortex_a53_instr_read_data64_dcc(struct arm_dpm *dpm,
 	return retval;
 }
 
-static int cortex_a53_instr_read_data_dcc(struct arm_dpm *dpm,
+static int cortex_a53_instr_read_data_dcc_BAD(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t *data)
 {
+	/* WHYBAD: This function assumes the instruction will be translated */
 	uint64_t tmp;
-	int result=cortex_a53_instr_read_data64_dcc(dpm, opcode, &tmp);
+	int result=cortex_a53_instr_read_data64_dcc_BAD(dpm, opcode, &tmp);
 	*data=(uint32_t)tmp;
 	return result;
 }
 
-static int cortex_a53_instr_read_data64_r0_msr(struct arm_dpm *dpm,
+static int cortex_a53_instr_read_data64_r0_msr_BAD(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t *data)
 {
+	/* WHYBAD: part 1 This function assumes the instruction will be translated */
+	/*         part 2 Does the ARMV8_A64_MRS() instruction get translated also? */
+	/*         so what does the ARMV8_A64_MRS() macro do? This seems so wrong */
 	struct target		*target		= arm_dpm_to_target(dpm);
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 	uint64_t tmp;
 
 		/* the opcode, writing data to R0 */
-	retval = cortex_a53_exec_opcode(
+	retval = cortex_a53_exec_opcode_BAD(
 			target,
 			opcode,
 			&dscr);
@@ -1038,7 +1102,7 @@ static int cortex_a53_instr_read_data64_r0_msr(struct arm_dpm *dpm,
 		return retval;
 
 	/* write R0 to DCC */
-	retval = cortex_a53_exec_opcode(
+	retval = cortex_a53_exec_opcode_BAD(
 			target,
 			ARMV8_A64_MSR(2, 3, 0, 5, 0, 0),
 			&dscr);
@@ -1051,9 +1115,11 @@ static int cortex_a53_instr_read_data64_r0_msr(struct arm_dpm *dpm,
 	return retval;
 }
 
-static int cortex_a53_instr_read_data64_r0(struct arm_dpm *dpm,
+static int cortex_a53_instr_read_data64_r0_BAD(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t *data)
 {
+	/* WHY BAD: This uses ARMV4_5 opcodes and has a hard coded opcode */
+	/*          and expects the opcode to be translated */
 	struct target		*target		= arm_dpm_to_target( dpm );
 	struct armv8		*armv8		= target_to_armv8(target);
 	struct arm              *arm            = armv8_to_arm(armv8);
@@ -1062,7 +1128,7 @@ static int cortex_a53_instr_read_data64_r0(struct arm_dpm *dpm,
 	uint64_t tmp;
 
 	/* the opcode, writing data to R0 */
-	retval = cortex_a53_exec_opcode(
+	retval = cortex_a53_exec_opcode_BAD(
 			target,
 			opcode,
 			&dscr);
@@ -1070,7 +1136,7 @@ static int cortex_a53_instr_read_data64_r0(struct arm_dpm *dpm,
 		return retval;
 
 	/* write R0 to DCC */
-	retval = cortex_a53_exec_opcode(
+	retval = cortex_a53_exec_opcode_BAD(
 			target,
 			ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
 			&dscr);
@@ -1091,12 +1157,13 @@ static int cortex_a53_instr_read_data64_r0(struct arm_dpm *dpm,
 	return retval;
 }
 
-static int cortex_a53_instr_read_data_r0(struct arm_dpm *dpm,
+static int cortex_a53_instr_read_data_r0_BAD(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t *data)
 {
+	/* WHY BAD: This function assumes the opcode will be translated */
 	uint64_t tmp;
 	int result;
-	result = cortex_a53_instr_read_data64_r0(dpm, opcode, &tmp);
+	result = cortex_a53_instr_read_data64_r0_BAD(dpm, opcode, &tmp);
 	*data=(uint32_t)tmp;
 	return result;
 }
@@ -1143,27 +1210,27 @@ static int cortex_a53_dpm_setup(struct armv8 *armv8,uint32_t dfr0)
 	dpm->arm = armv8_to_arm(armv8);
 	dpm->didr = (dfr0>>8&0xF00000)|(dfr0<<8&0xF0000000)|(dfr0<<12&0xF000000);
 
-	dpm->prepare = cortex_a53_dpm_prepare;
+	dpm->prepare = cortex_a53_dpm_prepare_BAD;
 	dpm->finish = cortex_a53_dpm_finish;
 
-	dpm->instr_write_data_dcc = cortex_a53_instr_write_data_dcc;
-	dpm->instr_write_data_r0 = cortex_a53_instr_write_data_r0;
-	dpm->instr_cpsr_sync = cortex_a53_instr_cpsr_sync;
+	dpm->instr_write_data_dcc = cortex_a53_instr_write_data_dcc_BAD;
+	dpm->instr_write_data_r0 = cortex_a53_instr_write_data_r0_BAD;
+	dpm->instr_cpsr_sync = cortex_a53_instr_cpsr_sync_BAD;
 
-	dpm->instr_read_data_dcc = cortex_a53_instr_read_data_dcc;
-	dpm->instr_read_data_r0 = cortex_a53_instr_read_data_r0;
+	dpm->instr_read_data_dcc = cortex_a53_instr_read_data_dcc_BAD;
+	dpm->instr_read_data_r0 = cortex_a53_instr_read_data_r0_BAD;
 
 	dpm->bpwp_enable = cortex_a53_bpwp_enable;
 	dpm->bpwp_disable = cortex_a53_bpwp_disable;
 
-	armv8_dpm->instr_write_data64_dcc = cortex_a53_instr_write_data64_dcc;
-	armv8_dpm->instr_write_data64_r0 = cortex_a53_instr_write_data64_r0;
-	armv8_dpm->instr_read_data64_dcc = cortex_a53_instr_read_data64_dcc;
-	armv8_dpm->instr_read_data64_r0 = cortex_a53_instr_read_data64_r0;
+	armv8_dpm->instr_write_data64_dcc = cortex_a53_instr_write_data64_dcc_BAD;
+	armv8_dpm->instr_write_data64_r0 = cortex_a53_instr_write_data64_r0_BAD;
+	armv8_dpm->instr_read_data64_dcc = cortex_a53_instr_read_data64_dcc_BAD;
+	armv8_dpm->instr_read_data64_r0 = cortex_a53_instr_read_data64_r0_BAD;
 
-	armv8_dpm->instr_execution = cortex_a53_instr_execution;
-	armv8_dpm->instr_write_data64_r0_mrs = cortex_a53_instr_write_data64_r0_mrs;
-	armv8_dpm->instr_read_data64_r0_msr = cortex_a53_instr_read_data64_r0_msr;
+	armv8_dpm->instr_execution = cortex_a53_instr_execution_BAD;
+	armv8_dpm->instr_write_data64_r0_mrs = cortex_a53_instr_write_data64_r0_mrs_BAD;
+	armv8_dpm->instr_read_data64_r0_msr = cortex_a53_instr_read_data64_r0_msr_BAD;
 
 
 	retval = armv8_dpm_setup(armv8_dpm);
@@ -1197,7 +1264,7 @@ static int cortex_a53_halt_smp(struct target *target)
 	while (head != (struct target_list *)NULL) {
 		curr = head->target;
 		if ((curr != target) && (curr->state != TARGET_HALTED))
-			retval += cortex_a53_halt(curr);
+			retval += cortex_a53_halt_BAD(curr);
 		head = head->next;
 	}
 	return retval;
@@ -1308,8 +1375,14 @@ static int cortex_a53_poll(struct target *target)
 	return retval;
 }
 
-static int cortex_a53_halt(struct target *target)
+static int cortex_a53_halt_BAD(struct target *target)
 {
+	/* WHYBAD: part 1 Why can this function pass ARMV8_A64_MRS() and ARMV8_A64_MSR() opcodes
+	 *         to exec_opcode() that will translate the opcode to?
+	 *         Part 2 uses mixed ARMV4_5() macros, 
+	 *         Function should use a single type of opcode for consistancy
+	 */
+	
 	int retval = ERROR_OK;
 	uint32_t dummy;
 
@@ -1365,65 +1438,65 @@ static int cortex_a53_halt(struct target *target)
 	//remove below hack. Changing state should be a request from gdb client, but not forced here
 	if(target->is_64b && target->mode_switch)
 	{
-		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 1, 1, 0, 0), &dummy); //read SCR_EL3 to X0
-		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 6, 1, 1, 0, 0), &dummy); //read SCR_EL3 to X0
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 		LOG_DEBUG("Running in AArch64. SCR_EL3=0x%x",dummy);
 //		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x400);//SCR:RW=0,NS=1
 		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
-		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
-		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 6, 1, 1, 0, 0), &dummy); //SCR_EL3=X0
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(3, 6, 1, 1, 0, 0), &dummy); //SCR_EL3=X0
 
-		      cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 4, 1, 1, 0, 0), &dummy); //read HCR_EL2 to X0
-              cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		      cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 4, 1, 1, 0, 0), &dummy); //read HCR_EL2 to X0
+              cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
               retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
               LOG_DEBUG("Running in AArch64. HCR_EL2=0x%x",dummy);
 /*              target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
-              cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
-              cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 4, 1, 1, 0, 0), &dummy); //HCR_EL2=X0
+              cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
+              cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(3, 4, 1, 1, 0, 0), &dummy); //HCR_EL2=X0
 */
-		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 12, 0, 2, 0), &dummy);    // MRS RMR_EL3, R0
-		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 6, 12, 0, 2, 0), &dummy);    // MRS RMR_EL3, R0
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 		LOG_DEBUG("Read RMR_EL# before DRPS = 0x%x", dummy);
 
-		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 3, 4, 5, 0, 0), &dummy);    // MRS DSPSR_EL0, R0
-		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 3, 4, 5, 0, 0), &dummy);    // MRS DSPSR_EL0, R0
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 		LOG_DEBUG("Read DSPSR_EL0 before DRPS = 0x%x", dummy);
 
-		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 3, 4, 5, 1, 0), &dummy);     // MRS DLR_EL0, R0, mov pc?
-		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 3, 4, 5, 1, 0), &dummy);     // MRS DLR_EL0, R0, mov pc?
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read DLR_EL0 before DRPS = 0x%x", dummy);
 
-		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 0, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL1, R0, mov pc?
-		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 0, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL1, R0, mov pc?
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read SPSR_EL1 before DRPS = 0x%x", dummy);
 
-		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 4, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL2, R0, mov pc?
-		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 4, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL2, R0, mov pc?
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read SPSR_EL2 before DRPS = 0x%x", dummy);
 
-		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL3, R0, mov pc?
-		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL3, R0, mov pc?
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read SPSR_EL3 before DRPS = 0x%x", dummy);
 
-		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL3, R0, mov pc?
-		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL3, R0, mov pc?
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read SPSR_EL3 before DRPS = 0x%x", dummy);
 
-		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 0, 0, 2, 2, 0), &dummy);     // MRS MDSCR_EL1, R0, mov pc?
-		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(2, 0, 0, 2, 2, 0), &dummy);     // MRS MDSCR_EL1, R0, mov pc?
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read MDSCR_EL1 before DRPS = 0x%x", dummy);
@@ -1436,11 +1509,11 @@ static int cortex_a53_halt(struct target *target)
 //		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x1c5);//0,
 		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x1d1);//0, for EL1 ARCH32 bits.
 
-		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
-		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 6, 4, 0, 0, 0), &dummy); //SPSR_EL3 ,=X0
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
+		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(3, 6, 4, 0, 0, 0), &dummy); //SPSR_EL3 ,=X0
 
 		LOG_DEBUG("DRPS");
-		cortex_a53_exec_opcode(target, 0xD6BF03E0, &dummy); //0x8F00F3DE=>ERET 0xD6BF03E0=>DRPS
+		cortex_a53_exec_opcode_BAD(target, 0xD6BF03E0, &dummy); //0x8F00F3DE=>ERET 0xD6BF03E0=>DRPS
 
 		// dummy has Arch32, 64 target type information.
 		retval = armv8_dbg_rd_atomic_EDSCR( target, &dummy);
@@ -1450,11 +1523,11 @@ static int cortex_a53_halt(struct target *target)
 		target_cs_dbg_queued_wr32( target, CPUDBG_DTRTX, 0);
 		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x1D1);
 //		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x1D6); // set to Monitor mode
-//		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);    //X0=DTRRX
-//		cortex_a53_exec_opcode(target, ARMV8_T32_MRC(14, 0, 0, 5, 0, 0), &dummy);    //X0=DTRRX
-//		cortex_a53_exec_opcode(target, ARMV8_T32_MCR(15, 3, 0, 4, 5, 0), &dummy);    // MSR DSPSR_EL0, R0
-		cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dummy);    //X0=DTRRX
-		cortex_a53_exec_opcode(target, ARMV4_5_MCR(15, 3, 0, 4, 5, 0), &dummy);    // MSR DSPSR_EL0, R0
+//		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);    //X0=DTRRX
+//		cortex_a53_exec_opcode_BAD(target, ARMV8_T32_MRC(14, 0, 0, 5, 0, 0), &dummy);    //X0=DTRRX
+//		cortex_a53_exec_opcode_BAD(target, ARMV8_T32_MCR(15, 3, 0, 4, 5, 0), &dummy);    // MSR DSPSR_EL0, R0
+		cortex_a53_exec_opcode_BAD(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dummy);    //X0=DTRRX
+		cortex_a53_exec_opcode_BAD(target, ARMV4_5_MCR(15, 3, 0, 4, 5, 0), &dummy);    // MSR DSPSR_EL0, R0
 
 	    LOG_DEBUG("Asic ROM base is = 0x%08" PRIx64, target->romcbase);
 		// set to 0xFE800000 as PC
@@ -1462,11 +1535,11 @@ static int cortex_a53_halt(struct target *target)
 //		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x100000); //for 8916
 		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, target->romcbase); //0x100084 is for 8916
 //		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0xFE800000);
-//		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);     //X0=DTRRX
-//		cortex_a53_exec_opcode(target, ARMV8_T32_MRC(14, 0, 0, 5, 0, 0), &dummy);    //X0=DTRRX / DBGDTRRXint
-//		cortex_a53_exec_opcode(target, ARMV8_T32_MCR(15, 3, 0, 4, 5, 1), &dummy);     // MSR DLR_EL0, R0, mov pc?
-		cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dummy);    //X0=DTRRX / DBGDTRRXint
-		cortex_a53_exec_opcode(target, ARMV4_5_MCR(15, 3, 0, 4, 5, 1), &dummy);     // MSR DLR_EL0, R0, mov pc?
+//		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);     //X0=DTRRX
+//		cortex_a53_exec_opcode_BAD(target, ARMV8_T32_MRC(14, 0, 0, 5, 0, 0), &dummy);    //X0=DTRRX / DBGDTRRXint
+//		cortex_a53_exec_opcode_BAD(target, ARMV8_T32_MCR(15, 3, 0, 4, 5, 1), &dummy);     // MSR DLR_EL0, R0, mov pc?
+		cortex_a53_exec_opcode_BAD(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dummy);    //X0=DTRRX / DBGDTRRXint
+		cortex_a53_exec_opcode_BAD(target, ARMV4_5_MCR(15, 3, 0, 4, 5, 1), &dummy);     // MSR DLR_EL0, R0, mov pc?
 	    retval = armv8_dbg_rd_atomic_EDSCR( target, &dummy);
 	    LOG_DEBUG("after DRPS, EDSCR = 0x%08" PRIx32, dummy);
 
@@ -1510,9 +1583,12 @@ static int cortex_a53_halt(struct target *target)
 	return retval;
 }
 
-static int cortex_a53_internal_restore(struct target *target, int current,
+static int cortex_a53_internal_restore_BAD(struct target *target, int current,
 	struct target_addr *pAddr, int handle_breakpoints, int debug_execution)
 {
+	/* WHYBAD: this function only supports 32bit address
+	 *         and does not properly support 64bit execution addresses
+	 */
 	struct armv8 *armv8;
 	struct arm   *arm;
 
@@ -1692,7 +1768,7 @@ static int cortex_a53_restore_smp(struct target *target, int handle_breakpoints)
 		curr = head->target;
 		if ((curr != target) && (curr->state != TARGET_RUNNING)) {
 			/*  resume current address , not in step mode */
-			retval += cortex_a53_internal_restore(curr, 1, &addr,
+			retval += cortex_a53_internal_restore_BAD(curr, 1, &addr,
 					handle_breakpoints, 0);
 			retval += cortex_a53_internal_restart(curr);
 		}
@@ -1718,7 +1794,7 @@ static int cortex_a53_resume_64(struct target *target, int current,
 		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
 		return 0;
 	}
-	cortex_a53_internal_restore(target, current, &addr, handle_breakpoints, debug_execution);
+	cortex_a53_internal_restore_BAD(target, current, &addr, handle_breakpoints, debug_execution);
 	if (target->smp) {
 		target->gdb_service->core[0] = -1;
 		retval = cortex_a53_restore_smp(target, handle_breakpoints);
@@ -1830,8 +1906,12 @@ static int cortex_a53_debug_entry(struct target *target)
 	return retval;
 }
 
-static int cortex_a53_post_debug_entry(struct target *target)
+static int cortex_a53_post_debug_entry_BAD(struct target *target)
 {
+	/* WHYBAD: this function uses ARMV4_5 opcodes
+	 *         this function disables the MMU, it should ot
+	 *         this function assumes cortex_a series, it should not
+	 */
 	struct armv8		*armv8		= target_to_armv8(target);
 	struct cortex_a_common	*cortex_a	= armv8_to_cortex_a(armv8);
 	struct armv7a_common	*armv7a		= armv8_to_armv7a(armv8);
@@ -1876,9 +1956,10 @@ static int cortex_a53_post_debug_entry(struct target *target)
 	return ERROR_OK;
 }
 
-static int cortex_a53_step_64(struct target *target, int current, const struct target_addr *pAddr,
+static int cortex_a53_step_64_BAD(struct target *target, int current, const struct target_addr *pAddr,
 	int handle_breakpoints)
 {
+	/* WHYBAD: this function does not support 64bit step modes */
 	struct armv8		*armv8	= target_to_armv8( target );
 	struct arm		*arm	= armv8_to_arm(armv8);
 	struct breakpoint *breakpoint = NULL;
@@ -2359,10 +2440,12 @@ static int cortex_a53_deassert_reset(struct target *target)
 	return ERROR_OK;
 }
 
-static int cortex_a53_write_apb_ab_memory(struct target *target,
+static int cortex_a53_write_apb_ab_memory_BAD(struct target *target,
 	const struct target_addr *pAddr, uint32_t size,
 	uint32_t count, const uint8_t *buffer)
 {
+	/* WHYBAD: This function uses ARMV4_5() opcodes to exeucte cache operations */
+	/* WHYBAD: This function assumes the DCC has a fast mode, armv8 does not */
 	/* write memory through APB-AP */
 	struct armv8         *armv8  = target_to_armv8( target );
 	struct arm *arm = armv8_to_arm(armv8);
@@ -2421,7 +2504,7 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 		 */
 		tmp_addr = *pAddr;
 		tmp_addr.addr &= (~0x03);
-		retval = cortex_a53_read_apb_ab_memory(target, &tmp_addr, 4, 1, tmp_buff);
+		retval = cortex_a53_read_apb_ab_memory_BAD(target, &tmp_addr, 4, 1, tmp_buff);
 		if (retval != ERROR_OK)
 			goto error_free_buff_w;
 	}
@@ -2434,7 +2517,7 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 		int mem_offset = (total_u32-1) * 4;
 		tmp_addr = *pAddr;
 		tmp_addr.addr = (pAddr->addr & ~0x3) + mem_offset;
-		retval = cortex_a53_read_apb_ab_memory(target, &tmp_addr, 4, 1, &tmp_buff[mem_offset]);
+		retval = cortex_a53_read_apb_ab_memory_BAD(target, &tmp_addr, 4, 1, &tmp_buff[mem_offset]);
 		if (retval != ERROR_OK)
 			goto error_free_buff_w;
 	}
@@ -2450,6 +2533,7 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 		goto error_free_buff_w;
 
 	/* Set DTR mode to Fast (2) */
+	LOG_ERROR("DCC FASTMODE is not on ARMV8");
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_FAST_MODE;
 	/*FIXME: This should be queued */
 	retval = armv8_dbg_queued_wr_EDSCR( target, dscr );
@@ -2485,6 +2569,7 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 
 
 	/* Switch DTR mode back to non-blocking (0) */
+	LOG_ERROR("DCC FASTMODE is not on ARMV8");
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
 	retval = armv8_dbg_queued_wr_EDSCR( target, dscr );
 	if (retval != ERROR_OK)
@@ -2508,6 +2593,7 @@ static int cortex_a53_write_apb_ab_memory(struct target *target,
 error_unset_dtr_w:
 	/* Unset DTR mode */
 	armv8_dbg_rd_atomic_EDSCR( target, &dscr );
+	LOG_ERROR("DCC FASTMODE is not on ARMV8");
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
 	armv8_dbg_wr_atomic_EDSCR( target, dscr);
 error_free_buff_w:
@@ -2516,10 +2602,12 @@ error_free_buff_w:
 	return ERROR_FAIL;
 }
 
-static int cortex_a53_read_apb_ab_memory(struct target *target,
+static int cortex_a53_read_apb_ab_memory_BAD(struct target *target,
 	const struct target_addr *pAddr, uint32_t size,
 	uint32_t count, uint8_t *buffer)
 {
+	/* WHYBAD: this function assumes ARMV8 has DCC fast mode, ARMV8 does not */
+	/* WHYBAD: this function uses ARMV4_5() opcodes via translation */
 	struct armv8         *armv8  = target_to_armv8( target );
 	struct arm           *arm    = armv8_to_arm(armv8);
 	
@@ -2570,6 +2658,7 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 	 */
 
 	/* Set DTR access mode to stall mode b01  */
+	LOG_ERROR("DCC FASTMODE is not on ARMV8");
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_STALL_MODE;
 	retval +=  armv8_dbg_queued_wr_EDSCR( target, dscr );
 
@@ -2579,7 +2668,7 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 	tmp_addr.addr &= (~0x03);
 	retval += target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, tmp_addr.addr );
 	/*  - Copy value from DTRRX to R0 using instruction mrc p14, 0, r0, c5, c0 */
-	cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dscr);
+	cortex_a53_exec_opcode_BAD(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dscr);
 
 	/* Write the data transfer instruction (ldc p14, c5, [r0],4)
 	 * and the DTR mode setting to fast mode
@@ -2587,6 +2676,7 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 	 */
 	u8buf_ptr = buf;
 	target_buffer_set_u32(target, u8buf_ptr, ARMV4_5_LDC(0, 1, 0, 1, 14, 5, 0, 4));
+	LOG_ERROR("DCC FASTMODE is not on ARMV8");
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_FAST_MODE;
 	target_buffer_set_u32(target, u8buf_ptr + 4, dscr);
 	/*  group the 2 access CPUDBG_ITR 0x84 and CPUDBG_DSCR 0x88 */
@@ -2622,6 +2712,7 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 			goto error_unset_dtr_r;
 
 	/* set DTR access mode back to non blocking b00  */
+	LOG_ERROR("DCC FASTMODE is not on ARMV8");
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
 	retval =  armv8_dbg_queued_wr_EDSCR( target, dscr );
 	if (retval != ERROR_OK)
@@ -2657,6 +2748,7 @@ static int cortex_a53_read_apb_ab_memory(struct target *target,
 error_unset_dtr_r:
 	/* Unset DTR mode */
 	armv8_dbg_rd_atomic_EDSCR( target, &dscr );
+	LOG_ERROR("DCC FASTMODE is not on ARMV8");
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
 	/* this sould not be queued */
 	armv8_dbg_wr_atomic_EDSCR( target, dscr);
@@ -2751,19 +2843,20 @@ static int cortex_a53_read_memory_64(struct target *target, const struct target_
 	if (retval != ERROR_OK)
 		return retval;
 	/* enable MMU as we could have disabled it for phys access */
-	retval = cortex_a53_mmu_modify(target, 1);
+	retval = cortex_a53_mmu_modify_BAD(target, 1);
 	if (retval != ERROR_OK){
 		return retval;
 	}
-	retval = cortex_a53_read_apb_ab_memory(target, pAddr, size, count, buffer);
+	retval = cortex_a53_read_apb_ab_memory_BAD(target, pAddr, size, count, buffer);
 	return retval;
 }
 
 
-static int cortex_a53_write_phys_memory_64(struct target *target,
+static int cortex_a53_write_phys_memory_64_BAD(struct target *target,
 	const struct target_addr *pAddr, uint32_t size,
 	uint64_t count, const uint8_t *buffer)
 {
+	/* WHYBAD: this function uses ARMV4_5() opcodes, not supported by ARMV8 */
 	struct target_addr              resolved;
 	struct armv8          *armv8  = target_to_armv8( target );
 	struct armv7a_common  *armv7a = armv8_to_armv7a(armv8);
@@ -2798,11 +2891,11 @@ static int cortex_a53_write_phys_memory_64(struct target *target,
 
 	/* write memory through APB-AP */
 	if (!armv7a->is_armv7r) {
-			retval = cortex_a53_mmu_modify(target, 0);
+			retval = cortex_a53_mmu_modify_BAD(target, 0);
 			if (retval != ERROR_OK)
 				return retval;
 	}
-	return cortex_a53_write_apb_ab_memory(target, pAddr, size, count, buffer);
+	return cortex_a53_write_apb_ab_memory_BAD(target, pAddr, size, count, buffer);
 	
  cache_clean:
 
@@ -2886,7 +2979,7 @@ static int cortex_a53_write_memory_64(struct target *target, const struct target
 	}
 	
 	if( pAddr->route == TA_ROUTE_PHYSICAL ){
-		return cortex_a53_write_phys_memory_64( target, pAddr, size, count, buffer );
+		return cortex_a53_write_phys_memory_64_BAD( target, pAddr, size, count, buffer );
 	}
 
 	/* cortex_a53 handles unaligned memory access */
@@ -2918,16 +3011,16 @@ static int cortex_a53_write_memory_64(struct target *target, const struct target
 		if (!mmu_enabled) {
 			resolved = *pAddr;
 			resolved.route = TA_ROUTE_PHYSICAL;
-			retval = cortex_a53_write_phys_memory_64( target, &resolved, size, count, buffer );			
+			retval = cortex_a53_write_phys_memory_64_BAD( target, &resolved, size, count, buffer );			
 		} else {
 			retval = cortex_a53_check_address(target, pAddr);
 			if (retval != ERROR_OK)
 				return retval;
 			/* enable MMU as we could have disabled it for phys access */
-			retval = cortex_a53_mmu_modify(target, 1);
+			retval = cortex_a53_mmu_modify_BAD(target, 1);
 			if (retval != ERROR_OK)
 				return retval;
-			retval = cortex_a53_write_apb_ab_memory(target, pAddr, size, count, buffer);
+			retval = cortex_a53_write_apb_ab_memory_BAD(target, pAddr, size, count, buffer);
 		}
 	}
 	return retval;
@@ -3147,7 +3240,7 @@ static int cortex_a53_init_arch_info(struct target *target,
 
 	/* register arch-specific functions */
 	armv7a->examine_debug_reason = NULL;
-	armv7a->post_debug_entry = cortex_a53_post_debug_entry;
+	armv7a->post_debug_entry = cortex_a53_post_debug_entry_BAD;
 	armv7a->pre_restore_context = NULL;
 	armv7a->armv7a_mmu.read_physical_memory = cortex_a53_read_phys_memory_WRAPPER;
 
@@ -3207,7 +3300,7 @@ static int cortex_a53_virt2phys_64(struct target *target,
 		*out_pPhys = resolved;
 	} else {/*  use this method if armv7a->memory_ap not selected
 		 *  mmu must be enable in order to get a correct translation */
-		retval = cortex_a53_mmu_modify(target, 1);
+		retval = cortex_a53_mmu_modify_BAD(target, 1);
 		if (retval != ERROR_OK)
 			goto done;
 		retval = armv7a_mmu_translate_va_pa(target, in_pVirt->addr, &FIXME, 1);
@@ -3370,7 +3463,7 @@ static struct target_io64 cortexa53_target64 = {
 	// .run_algorithm = armv4_5_run_algorithm, NOT SUPPORTED (64bit reasons)
 
 	.resume = cortex_a53_resume_64,
-	.step = cortex_a53_step_64,
+	.step = cortex_a53_step_64_BAD,
 
 };
 
@@ -3384,7 +3477,7 @@ struct target_type cortexa53_target = {
 	.poll = cortex_a53_poll,
 	.arch_state = armv7a_arch_state,
 
-	.halt = cortex_a53_halt,
+	.halt = cortex_a53_halt_BAD,
 
 	.assert_reset = cortex_a53_assert_reset,
 	.deassert_reset = cortex_a53_deassert_reset,
-- 
1.9.1


From 121ecbaa0aa1f00ce53e3b2ba9448e37b7bafe19 Mon Sep 17 00:00:00 2001
From: "Eric Katzfey" <eric.katzfey@mentalbee.com>
Date: Sat, 17 Sep 2016 16:38:58 -0700
Subject: [PATCH 94/94] Revert "Markup for armv8 changes review"

This reverts commit d1ecdc8f2d35c311d5bbf46d8c10a62b71b9847b

==========================
Code not ready for review!
---
 src/target/armv8.c      |  15 +-
 src/target/cortex_a53.c | 363 ++++++++++++++++++------------------------------
 2 files changed, 141 insertions(+), 237 deletions(-)

diff --git a/src/target/armv8.c b/src/target/armv8.c
index 8ffdabf..4a9d01e 100755
--- a/src/target/armv8.c
+++ b/src/target/armv8.c
@@ -838,11 +838,10 @@ int armv8_get_gdb_reg_list(struct target *target,
  */
 
 /* Read coprocessor */
-static int armv8_mrs_BAD(struct target *target,
+static int armv8_mrs(struct target *target,
 	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
 	uint32_t *value)
 {
-	/* WHYBAD: This uses an function which indirectly translates the opcodes */
 	struct armv8 *armv8 = target_to_armv8( target );
 	struct armv8_dpm *armv8_dpm = armv8_to_armv8_dpm(armv8);
 	struct arm_dpm   *dpm       = armv8_to_arm_dpm(armv8);
@@ -860,11 +859,10 @@ static int armv8_mrs_BAD(struct target *target,
 	return retval;
 }
 
-static int armv8_msr_BAD(struct target *target,
+static int armv8_msr(struct target *target,
 	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
 	uint32_t value)
 {
-	/* WHYBAD: This uses an function which indirectly translates the opcodes */
 	struct armv8     *armv8     = target_to_armv8( target );
 	struct armv8_dpm *armv8_dpm = armv8_to_armv8_dpm( armv8 );
 	struct arm_dpm   *dpm       = armv8_to_arm_dpm( armv8 );
@@ -882,11 +880,10 @@ static int armv8_msr_BAD(struct target *target,
 	return retval;
 }
 
-static int armv8_drps_MAYBEBAD(struct target *target,
+static int armv8_drps(struct target *target,
 	uint32_t op0, uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2, uint32_t Rt,
 	uint32_t value)
 {
-	/* WHYBAD: Might not be bad - but this hard code opcode makes me wonder */
 	struct armv8     *armv8     = target_to_armv8( target );
 	struct armv8_dpm *armv8_dpm = armv8_to_armv8_dpm( armv8 );
 	struct arm_dpm   *dpm       = armv8_to_arm_dpm( armv8 );
@@ -923,11 +920,11 @@ int armv8_init_arch_info(struct target *target)
 	struct armv8 *armv8 = target_to_armv8( target );
 
 	if (!armv8->mrs)
-		armv8->mrs = armv8_mrs_BAD;
+		armv8->mrs = armv8_mrs;
 	if (!armv8->msr)
-		armv8->msr = armv8_msr_BAD;
+		armv8->msr = armv8_msr;
 	if (!armv8->drps)
-		armv8->drps = armv8_drps_MAYBEBAD;
+		armv8->drps = armv8_drps;
 	if (!armv8->modeswitch)
 		armv8->modeswitch = armv8_modeswitch;
 
diff --git a/src/target/cortex_a53.c b/src/target/cortex_a53.c
index 622e4a2..0a279e2 100755
--- a/src/target/cortex_a53.c
+++ b/src/target/cortex_a53.c
@@ -18,7 +18,7 @@
 #include "arm_adi_v5.h"
 #include <helper/time_support.h>
 
-static int cortex_a53_halt_BAD(struct target *target);
+static int cortex_a53_halt(struct target *target);
 static int cortex_a53_poll(struct target *target);
 static int cortex_a53_debug_entry(struct target *target);
 static int cortex_a53_restore_context(struct target *target, bool bpwp);
@@ -33,7 +33,7 @@ static int cortex_a53_unset_breakpoint(struct target *target,
 static int cortex_a53_mmu(struct target *target, int *enabled);
 static int cortex_a53_virt2phys_64(struct target *target,
         const struct target_addr *in_pVirt, struct target_addr *out_pPhys );
-static int cortex_a53_read_apb_ab_memory_BAD(struct target *target,
+static int cortex_a53_read_apb_ab_memory(struct target *target,
 	const struct target_addr *pAddr, uint32_t size, uint32_t count, uint8_t *buffer);
 
 
@@ -434,10 +434,8 @@ static int cortex_a53_check_address(struct target *target, const struct target_a
 /*  modify cp15_control_reg in order to enable or disable mmu for :
  *  - virt2phys address conversion
  *  - read or write memory in phys or virt address */
-static int cortex_a53_mmu_modify_BAD(struct target *target, int enable)
+static int cortex_a53_mmu_modify(struct target *target, int enable)
 {
-	/* WHYBAD: Executes "arm->mcr()" which is a translated instruction */
-	/* WHYBAD: uses "cortex_a" settings when it should use armv8 only  */
 	struct armv8		*armv8          = target_to_armv8(target);
 	struct arm		*arm            = armv8_to_arm(armv8);
 	struct cortex_a_common	*cortex_a	= armv8_to_cortex_a( armv8 );
@@ -567,7 +565,6 @@ static int cortex_a53_init_debug_access(struct target *target)
 	return cortex_a53_poll(target);
 }
 
-
 /* To reduce needless round-trips, pass in a pointer to the current
  * DSCR value.  Initialize it to zero if you just need to know the
  * value on return from this function; or DSCR_INSTR_COMP if you
@@ -605,56 +602,6 @@ static int cortex_a53_exec_opcode(struct target *target,
 		}
 	}
 
-
-	LOG_DEBUG("execute: 0x%08x", opcode);
-	retval = target_cs_dbg_queued_wr32( target, CPUDBG_ITR, opcode);
-	if (retval != ERROR_OK)
-		return retval;
-
-	then = timeval_ms();
-	do {
-		if( armv8_debug(EXEC_OPCODE) ){
-			LOG_DEBUG("armv8-exec-opcode-poll(2)");
-		}
-		retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
-		if (retval != ERROR_OK) {
-			LOG_ERROR("Could not read DSCR register");
-			return retval;
-		}
-		if (timeval_ms() > then + 1000) {
-			LOG_ERROR("Timeout waiting for cortex_a53_exec_opcode opcode = 0x%08" PRIx32, opcode);
-			return ERROR_FAIL;
-		}
-	} while ((dscr & DSCR_INSTR_COMP) == 0);	/* Wait for InstrCompl bit to be set */
-	if(dscr & 0x40)
-	{
-		LOG_ERROR("Err set for opcode = 0x%x, with DSCR=0x%x", opcode, dscr);
-		//clear the error
-		target_cs_dbg_queued_wr32( target, EDRCR, 1<<2); //set EDRCR.CSE to clear EDSCR.ERR
-	}
-	if (dscr_p)
-		*dscr_p = dscr;
-
-	return retval;
-}
-
-static int cortex_a53_xlate_opcode( struct target *target,
-									uint32_t opcode,
-									uint32_t *opcode_out )
-{
-	uint32_t dscr;
-	int retval;
-	
-	/* Determine what the CPU state is */
-	retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
-	if( retval != ERROR_OK ){
-		return retval;
-	}
-	
-	if( armv8_debug(EXEC_OPCODE) ){
-		LOG_DEBUG("AArch64=%d (dscr=0x%08X)", isAArch64(dscr), dscr);
-	}
-	
     //override opcode. SQU TODO: instead of hack here, might need to change to caller to use right opcode for right state
 	if(opcode==0xE12FF000){
 		/* Move CPSR to R0.
@@ -768,27 +715,37 @@ static int cortex_a53_xlate_opcode( struct target *target,
     {
     	if(!target->is_64b) LOG_ERROR("SQU: Exec AArch64 opcode=0x%x for AArch32 state", opcode);
     }
-	*opcode_out = opcode;
-	return ERROR_OK;
-}
 
+	LOG_DEBUG("execute: 0x%08x", opcode);
+	retval = target_cs_dbg_queued_wr32( target, CPUDBG_ITR, opcode);
+	if (retval != ERROR_OK)
+		return retval;
 
-static int cortex_a53_exec_opcode_BAD(struct target *target,
-	uint32_t opcode, uint32_t *dscr_p)
-{
-	/* WHYBAD: This is the "root of the problem" function */
-	/*         This function should not be used or required */
-	/*         because ARMV8 does not execute A32 instructions */
-	/*         the ARMV8 core executes ONLY A64 and T32 opcodes */
-	int r;
-	uint32_t fixed_opcode;
-	r = cortex_a53_xlate_opcode( target, opcode, &fixed_opcode );
-	if( r != ERROR_OK ){
-		return r;
+	then = timeval_ms();
+	do {
+		if( armv8_debug(EXEC_OPCODE) ){
+			LOG_DEBUG("armv8-exec-opcode-poll(2)");
+		}
+		retval = armv8_dbg_rd_atomic_EDSCR( target, &dscr );
+		if (retval != ERROR_OK) {
+			LOG_ERROR("Could not read DSCR register");
+			return retval;
+		}
+		if (timeval_ms() > then + 1000) {
+			LOG_ERROR("Timeout waiting for cortex_a53_exec_opcode opcode = 0x%08" PRIx32, opcode);
+			return ERROR_FAIL;
+		}
+	} while ((dscr & DSCR_INSTR_COMP) == 0);	/* Wait for InstrCompl bit to be set */
+	if(dscr & 0x40)
+	{
+		LOG_ERROR("Err set for opcode = 0x%x, with DSCR=0x%x", opcode, dscr);
+		//clear the error
+		target_cs_dbg_queued_wr32( target, EDRCR, 1<<2); //set EDRCR.CSE to clear EDSCR.ERR
 	}
-	LOG_ERROR("ERROR: FIXME xlate opcode: 0x%08x to 0x%08x", opcode, fixed_opcode );
+	if (dscr_p)
+		*dscr_p = dscr;
 
-	return cortex_a53_exec_opcode( target, opcode, dscr_p );
+	return retval;
 }
 
 
@@ -869,9 +826,8 @@ static int cortex_a53_read_dcc(struct target *target, uint64_t *data,
 	return retval;
 }
 
-static int cortex_a53_dpm_prepare_BAD(struct arm_dpm *dpm)
+static int cortex_a53_dpm_prepare(struct arm_dpm *dpm)
 {
-	/* WHYBAD: This function executes ARMV4_5_MRC() opcode not ARMV8 opcode */
 	struct target		*target		= arm_dpm_to_target( dpm );
 	uint32_t dscr;
 	int retval;
@@ -891,11 +847,10 @@ static int cortex_a53_dpm_prepare_BAD(struct arm_dpm *dpm)
 	}
 
 	/* this "should never happen" ... */
-	LOG_ERROR("**FIXME** - Bad opcode here");
 	if (dscr & DSCR_DTR_RX_FULL) {
 		LOG_ERROR("DSCR_DTR_RX_FULL, dscr 0x%08" PRIx32, dscr);
 		/* Clear DCCRX */
-		retval = cortex_a53_exec_opcode_BAD(
+		retval = cortex_a53_exec_opcode(
 						target,
 				ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 				&dscr);
@@ -912,28 +867,24 @@ static int cortex_a53_dpm_finish(struct arm_dpm *dpm)
 	return ERROR_OK;
 }
 
-static int cortex_a53_instr_execution_BAD(struct arm_dpm *dpm,
+static int cortex_a53_instr_execution(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t *data)
 {
-	/* WHYBAD: Because ARM_DPM assumes all ARM cpus execute ARM opcodes */
-	/*         Correct solution ARMV8 should not use ARM_DPM */
-	/*         note this is also true of ARMV7M (cortex) */
 	struct target		*target		= arm_dpm_to_target( dpm );
 	int retval;
 	uint32_t dscr = DSCR_INSTR_COMP;
 
 	/* the opcode, writing data to DCC */
-	retval = cortex_a53_exec_opcode_BAD(
+	retval = cortex_a53_exec_opcode(
 			target,
 			opcode,
 			&dscr);
 	return retval;
 }
 
-static int cortex_a53_instr_write_data64_dcc_BAD(struct arm_dpm *dpm,
+static int cortex_a53_instr_write_data64_dcc(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t data)
 {
-	/* WHY BAD: opcode passed to this function *MUST*NOT*BE* armv8 opcode */
 	struct target		*target		= arm_dpm_to_target( dpm );
 	struct armv8		*armv8		= target_to_armv8( target );
 	int retval;
@@ -943,27 +894,21 @@ static int cortex_a53_instr_write_data64_dcc_BAD(struct arm_dpm *dpm,
 	if (retval != ERROR_OK)
 		return retval;
 
-	return cortex_a53_exec_opcode_BAD(
+	return cortex_a53_exec_opcode(
 			target,
 			opcode,
 			&dscr);
 }
 
-static int cortex_a53_instr_write_data_dcc_BAD(struct arm_dpm *dpm,
+static int cortex_a53_instr_write_data_dcc(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t data)
 {
-	/* WHY BAD: opcode passed to this function *MUST*NOT*BE* armv8 opcode */
-	return cortex_a53_instr_write_data64_dcc_BAD(dpm, opcode, (uint64_t)data);
+	return cortex_a53_instr_write_data64_dcc(dpm, opcode, (uint64_t)data);
 }
 
-static int cortex_a53_instr_write_data64_r0_mrs_BAD(struct arm_dpm *dpm,
+static int cortex_a53_instr_write_data64_r0_mrs(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t data)
 {
-	/* WHY BAD: part 1 opcode passed to this function *MUST*NOT*BE* armv8 opcode */
-	/* WHY BAD: part 2 this function uses ARMV8 opcode macro to create opcode */
-	/*          but then this function calls exec_opcode() which translates   */
-	/*          the opcode from ARMV4/5 to armv8? Does this imply the ARMV8   */
-	/*          macro below is generating the correct opcode?                 */
 	struct target		*target		= arm_dpm_to_target( dpm );
 	struct armv8		*armv8		= target_to_armv8( target );
 	uint32_t dscr = DSCR_INSTR_COMP;
@@ -978,7 +923,7 @@ static int cortex_a53_instr_write_data64_r0_mrs_BAD(struct arm_dpm *dpm,
 
 		
 	/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15 */
-	retval = cortex_a53_exec_opcode_BAD(
+	retval = cortex_a53_exec_opcode(
 			target,
 			ARMV8_A64_MRS(2, 3, 0, 5, 0, 0),
 			&dscr);
@@ -986,7 +931,7 @@ static int cortex_a53_instr_write_data64_r0_mrs_BAD(struct arm_dpm *dpm,
 		return retval;
 
 	/* then the opcode, taking data from R0 */
-	retval = cortex_a53_exec_opcode_BAD(
+	retval = cortex_a53_exec_opcode(
 			target,
 			opcode,
 			&dscr);
@@ -995,11 +940,9 @@ static int cortex_a53_instr_write_data64_r0_mrs_BAD(struct arm_dpm *dpm,
 }
 
 
-static int cortex_a53_instr_write_data64_r0_BAD(struct arm_dpm *dpm,
+static int cortex_a53_instr_write_data64_r0(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t data)
 {
-	/* WHY BAD: part 1 opcode passed to this function *MUST*NOT*BE* armv8 opcode */
-	/* WHY BAD: part 2 this uses ARMV4_5_MRC() instruction, armv8 does not use those instructions */
 	struct target		*target		= arm_dpm_to_target( dpm );
 	struct armv8		*armv8		= target_to_armv8( target );
 	uint32_t dscr = DSCR_INSTR_COMP;
@@ -1014,7 +957,7 @@ static int cortex_a53_instr_write_data64_r0_BAD(struct arm_dpm *dpm,
 		return retval;
 
 	/* DCCRX to R0, "MRC p14, 0, R0, c0, c5, 0", 0xEE100E15 */
-	retval = cortex_a53_exec_opcode_BAD(
+	retval = cortex_a53_exec_opcode(
 			target,
 			ARMV4_5_MRC(14, 0, 0, 0, 5, 0),
 			&dscr);
@@ -1022,7 +965,7 @@ static int cortex_a53_instr_write_data64_r0_BAD(struct arm_dpm *dpm,
 		return retval;
 
 	/* then the opcode, taking data from R0 */
-	retval = cortex_a53_exec_opcode_BAD(
+	retval = cortex_a53_exec_opcode(
 			target,
 			opcode,
 			&dscr);
@@ -1030,35 +973,32 @@ static int cortex_a53_instr_write_data64_r0_BAD(struct arm_dpm *dpm,
 	return retval;
 }
 
-static int cortex_a53_instr_write_data_r0_BAD(struct arm_dpm *dpm,
+static int cortex_a53_instr_write_data_r0(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t data)
 {
-	/* WHYBAD: This function assumes the instruction will be translated */
-	return cortex_a53_instr_write_data64_r0_BAD(dpm, opcode, (uint64_t)data);
+	return cortex_a53_instr_write_data64_r0(dpm, opcode, (uint64_t)data);
 }
 
-static int cortex_a53_instr_cpsr_sync_BAD(struct arm_dpm *dpm)
+static int cortex_a53_instr_cpsr_sync(struct arm_dpm *dpm)
 {
-	/* WHYBAD: This function assumes the instruction will be translated */
 	struct target *target = arm_dpm_to_target(dpm);
 	uint32_t dscr = DSCR_INSTR_COMP;
 
 	/* "Prefetch flush" after modifying execution status in CPSR */
-	return cortex_a53_exec_opcode_BAD(target,
+	return cortex_a53_exec_opcode(target,
 			ARMV4_5_MCR(15, 0, 0, 7, 5, 4),
 			&dscr);
 }
 
-static int cortex_a53_instr_read_data64_dcc_BAD(struct arm_dpm *dpm,
+static int cortex_a53_instr_read_data64_dcc(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t *data)
 {
-	/* WHYBAD: This function assumes the instruction will be translated */
 	struct target		*target   = arm_dpm_to_target( dpm );
  	int retval;
 	uint32_t dscr = DSCR_INSTR_COMP;
 
 	/* the opcode, writing data to DCC */
-	retval = cortex_a53_exec_opcode_BAD(
+	retval = cortex_a53_exec_opcode(
 			target,
 			opcode,
 			&dscr);
@@ -1072,29 +1012,25 @@ static int cortex_a53_instr_read_data64_dcc_BAD(struct arm_dpm *dpm,
 	return retval;
 }
 
-static int cortex_a53_instr_read_data_dcc_BAD(struct arm_dpm *dpm,
+static int cortex_a53_instr_read_data_dcc(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t *data)
 {
-	/* WHYBAD: This function assumes the instruction will be translated */
 	uint64_t tmp;
-	int result=cortex_a53_instr_read_data64_dcc_BAD(dpm, opcode, &tmp);
+	int result=cortex_a53_instr_read_data64_dcc(dpm, opcode, &tmp);
 	*data=(uint32_t)tmp;
 	return result;
 }
 
-static int cortex_a53_instr_read_data64_r0_msr_BAD(struct arm_dpm *dpm,
+static int cortex_a53_instr_read_data64_r0_msr(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t *data)
 {
-	/* WHYBAD: part 1 This function assumes the instruction will be translated */
-	/*         part 2 Does the ARMV8_A64_MRS() instruction get translated also? */
-	/*         so what does the ARMV8_A64_MRS() macro do? This seems so wrong */
 	struct target		*target		= arm_dpm_to_target(dpm);
 	uint32_t dscr = DSCR_INSTR_COMP;
 	int retval;
 	uint64_t tmp;
 
 		/* the opcode, writing data to R0 */
-	retval = cortex_a53_exec_opcode_BAD(
+	retval = cortex_a53_exec_opcode(
 			target,
 			opcode,
 			&dscr);
@@ -1102,7 +1038,7 @@ static int cortex_a53_instr_read_data64_r0_msr_BAD(struct arm_dpm *dpm,
 		return retval;
 
 	/* write R0 to DCC */
-	retval = cortex_a53_exec_opcode_BAD(
+	retval = cortex_a53_exec_opcode(
 			target,
 			ARMV8_A64_MSR(2, 3, 0, 5, 0, 0),
 			&dscr);
@@ -1115,11 +1051,9 @@ static int cortex_a53_instr_read_data64_r0_msr_BAD(struct arm_dpm *dpm,
 	return retval;
 }
 
-static int cortex_a53_instr_read_data64_r0_BAD(struct arm_dpm *dpm,
+static int cortex_a53_instr_read_data64_r0(struct arm_dpm *dpm,
 	uint32_t opcode, uint64_t *data)
 {
-	/* WHY BAD: This uses ARMV4_5 opcodes and has a hard coded opcode */
-	/*          and expects the opcode to be translated */
 	struct target		*target		= arm_dpm_to_target( dpm );
 	struct armv8		*armv8		= target_to_armv8(target);
 	struct arm              *arm            = armv8_to_arm(armv8);
@@ -1128,7 +1062,7 @@ static int cortex_a53_instr_read_data64_r0_BAD(struct arm_dpm *dpm,
 	uint64_t tmp;
 
 	/* the opcode, writing data to R0 */
-	retval = cortex_a53_exec_opcode_BAD(
+	retval = cortex_a53_exec_opcode(
 			target,
 			opcode,
 			&dscr);
@@ -1136,7 +1070,7 @@ static int cortex_a53_instr_read_data64_r0_BAD(struct arm_dpm *dpm,
 		return retval;
 
 	/* write R0 to DCC */
-	retval = cortex_a53_exec_opcode_BAD(
+	retval = cortex_a53_exec_opcode(
 			target,
 			ARMV4_5_MCR(14, 0, 0, 0, 5, 0),
 			&dscr);
@@ -1157,13 +1091,12 @@ static int cortex_a53_instr_read_data64_r0_BAD(struct arm_dpm *dpm,
 	return retval;
 }
 
-static int cortex_a53_instr_read_data_r0_BAD(struct arm_dpm *dpm,
+static int cortex_a53_instr_read_data_r0(struct arm_dpm *dpm,
 	uint32_t opcode, uint32_t *data)
 {
-	/* WHY BAD: This function assumes the opcode will be translated */
 	uint64_t tmp;
 	int result;
-	result = cortex_a53_instr_read_data64_r0_BAD(dpm, opcode, &tmp);
+	result = cortex_a53_instr_read_data64_r0(dpm, opcode, &tmp);
 	*data=(uint32_t)tmp;
 	return result;
 }
@@ -1210,27 +1143,27 @@ static int cortex_a53_dpm_setup(struct armv8 *armv8,uint32_t dfr0)
 	dpm->arm = armv8_to_arm(armv8);
 	dpm->didr = (dfr0>>8&0xF00000)|(dfr0<<8&0xF0000000)|(dfr0<<12&0xF000000);
 
-	dpm->prepare = cortex_a53_dpm_prepare_BAD;
+	dpm->prepare = cortex_a53_dpm_prepare;
 	dpm->finish = cortex_a53_dpm_finish;
 
-	dpm->instr_write_data_dcc = cortex_a53_instr_write_data_dcc_BAD;
-	dpm->instr_write_data_r0 = cortex_a53_instr_write_data_r0_BAD;
-	dpm->instr_cpsr_sync = cortex_a53_instr_cpsr_sync_BAD;
+	dpm->instr_write_data_dcc = cortex_a53_instr_write_data_dcc;
+	dpm->instr_write_data_r0 = cortex_a53_instr_write_data_r0;
+	dpm->instr_cpsr_sync = cortex_a53_instr_cpsr_sync;
 
-	dpm->instr_read_data_dcc = cortex_a53_instr_read_data_dcc_BAD;
-	dpm->instr_read_data_r0 = cortex_a53_instr_read_data_r0_BAD;
+	dpm->instr_read_data_dcc = cortex_a53_instr_read_data_dcc;
+	dpm->instr_read_data_r0 = cortex_a53_instr_read_data_r0;
 
 	dpm->bpwp_enable = cortex_a53_bpwp_enable;
 	dpm->bpwp_disable = cortex_a53_bpwp_disable;
 
-	armv8_dpm->instr_write_data64_dcc = cortex_a53_instr_write_data64_dcc_BAD;
-	armv8_dpm->instr_write_data64_r0 = cortex_a53_instr_write_data64_r0_BAD;
-	armv8_dpm->instr_read_data64_dcc = cortex_a53_instr_read_data64_dcc_BAD;
-	armv8_dpm->instr_read_data64_r0 = cortex_a53_instr_read_data64_r0_BAD;
+	armv8_dpm->instr_write_data64_dcc = cortex_a53_instr_write_data64_dcc;
+	armv8_dpm->instr_write_data64_r0 = cortex_a53_instr_write_data64_r0;
+	armv8_dpm->instr_read_data64_dcc = cortex_a53_instr_read_data64_dcc;
+	armv8_dpm->instr_read_data64_r0 = cortex_a53_instr_read_data64_r0;
 
-	armv8_dpm->instr_execution = cortex_a53_instr_execution_BAD;
-	armv8_dpm->instr_write_data64_r0_mrs = cortex_a53_instr_write_data64_r0_mrs_BAD;
-	armv8_dpm->instr_read_data64_r0_msr = cortex_a53_instr_read_data64_r0_msr_BAD;
+	armv8_dpm->instr_execution = cortex_a53_instr_execution;
+	armv8_dpm->instr_write_data64_r0_mrs = cortex_a53_instr_write_data64_r0_mrs;
+	armv8_dpm->instr_read_data64_r0_msr = cortex_a53_instr_read_data64_r0_msr;
 
 
 	retval = armv8_dpm_setup(armv8_dpm);
@@ -1264,7 +1197,7 @@ static int cortex_a53_halt_smp(struct target *target)
 	while (head != (struct target_list *)NULL) {
 		curr = head->target;
 		if ((curr != target) && (curr->state != TARGET_HALTED))
-			retval += cortex_a53_halt_BAD(curr);
+			retval += cortex_a53_halt(curr);
 		head = head->next;
 	}
 	return retval;
@@ -1375,14 +1308,8 @@ static int cortex_a53_poll(struct target *target)
 	return retval;
 }
 
-static int cortex_a53_halt_BAD(struct target *target)
+static int cortex_a53_halt(struct target *target)
 {
-	/* WHYBAD: part 1 Why can this function pass ARMV8_A64_MRS() and ARMV8_A64_MSR() opcodes
-	 *         to exec_opcode() that will translate the opcode to?
-	 *         Part 2 uses mixed ARMV4_5() macros, 
-	 *         Function should use a single type of opcode for consistancy
-	 */
-	
 	int retval = ERROR_OK;
 	uint32_t dummy;
 
@@ -1438,65 +1365,65 @@ static int cortex_a53_halt_BAD(struct target *target)
 	//remove below hack. Changing state should be a request from gdb client, but not forced here
 	if(target->is_64b && target->mode_switch)
 	{
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 6, 1, 1, 0, 0), &dummy); //read SCR_EL3 to X0
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 1, 1, 0, 0), &dummy); //read SCR_EL3 to X0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 		LOG_DEBUG("Running in AArch64. SCR_EL3=0x%x",dummy);
 //		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x400);//SCR:RW=0,NS=1
 		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(3, 6, 1, 1, 0, 0), &dummy); //SCR_EL3=X0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 6, 1, 1, 0, 0), &dummy); //SCR_EL3=X0
 
-		      cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 4, 1, 1, 0, 0), &dummy); //read HCR_EL2 to X0
-              cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		      cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 4, 1, 1, 0, 0), &dummy); //read HCR_EL2 to X0
+              cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
               retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
               LOG_DEBUG("Running in AArch64. HCR_EL2=0x%x",dummy);
 /*              target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x31);//SCR:RW=0,NS=1
-              cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
-              cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(3, 4, 1, 1, 0, 0), &dummy); //HCR_EL2=X0
+              cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
+              cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 4, 1, 1, 0, 0), &dummy); //HCR_EL2=X0
 */
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 6, 12, 0, 2, 0), &dummy);    // MRS RMR_EL3, R0
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 12, 0, 2, 0), &dummy);    // MRS RMR_EL3, R0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 		LOG_DEBUG("Read RMR_EL# before DRPS = 0x%x", dummy);
 
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 3, 4, 5, 0, 0), &dummy);    // MRS DSPSR_EL0, R0
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 3, 4, 5, 0, 0), &dummy);    // MRS DSPSR_EL0, R0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 		LOG_DEBUG("Read DSPSR_EL0 before DRPS = 0x%x", dummy);
 
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 3, 4, 5, 1, 0), &dummy);     // MRS DLR_EL0, R0, mov pc?
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 3, 4, 5, 1, 0), &dummy);     // MRS DLR_EL0, R0, mov pc?
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read DLR_EL0 before DRPS = 0x%x", dummy);
 
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 0, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL1, R0, mov pc?
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 0, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL1, R0, mov pc?
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read SPSR_EL1 before DRPS = 0x%x", dummy);
 
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 4, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL2, R0, mov pc?
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 4, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL2, R0, mov pc?
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read SPSR_EL2 before DRPS = 0x%x", dummy);
 
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL3, R0, mov pc?
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL3, R0, mov pc?
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read SPSR_EL3 before DRPS = 0x%x", dummy);
 
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL3, R0, mov pc?
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(3, 6, 4, 0, 0, 0), &dummy);     // MRS SPSR_EL3, R0, mov pc?
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read SPSR_EL3 before DRPS = 0x%x", dummy);
 
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(2, 0, 0, 2, 2, 0), &dummy);     // MRS MDSCR_EL1, R0, mov pc?
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 0, 0, 2, 2, 0), &dummy);     // MRS MDSCR_EL1, R0, mov pc?
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(2, 3, 0, 5, 0, 0), &dummy); //DTRTX=X0
 		retval = target_cs_dbg_atomic_rd32( target, CPUDBG_DTRTX, &dummy);
 
 		LOG_DEBUG("Read MDSCR_EL1 before DRPS = 0x%x", dummy);
@@ -1509,11 +1436,11 @@ static int cortex_a53_halt_BAD(struct target *target)
 //		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x1c5);//0,
 		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x1d1);//0, for EL1 ARCH32 bits.
 
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
-		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MSR(3, 6, 4, 0, 0, 0), &dummy); //SPSR_EL3 ,=X0
+		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy); //X0=DTRRX
+		cortex_a53_exec_opcode(target, ARMV8_A64_MSR(3, 6, 4, 0, 0, 0), &dummy); //SPSR_EL3 ,=X0
 
 		LOG_DEBUG("DRPS");
-		cortex_a53_exec_opcode_BAD(target, 0xD6BF03E0, &dummy); //0x8F00F3DE=>ERET 0xD6BF03E0=>DRPS
+		cortex_a53_exec_opcode(target, 0xD6BF03E0, &dummy); //0x8F00F3DE=>ERET 0xD6BF03E0=>DRPS
 
 		// dummy has Arch32, 64 target type information.
 		retval = armv8_dbg_rd_atomic_EDSCR( target, &dummy);
@@ -1523,11 +1450,11 @@ static int cortex_a53_halt_BAD(struct target *target)
 		target_cs_dbg_queued_wr32( target, CPUDBG_DTRTX, 0);
 		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x1D1);
 //		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x1D6); // set to Monitor mode
-//		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);    //X0=DTRRX
-//		cortex_a53_exec_opcode_BAD(target, ARMV8_T32_MRC(14, 0, 0, 5, 0, 0), &dummy);    //X0=DTRRX
-//		cortex_a53_exec_opcode_BAD(target, ARMV8_T32_MCR(15, 3, 0, 4, 5, 0), &dummy);    // MSR DSPSR_EL0, R0
-		cortex_a53_exec_opcode_BAD(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dummy);    //X0=DTRRX
-		cortex_a53_exec_opcode_BAD(target, ARMV4_5_MCR(15, 3, 0, 4, 5, 0), &dummy);    // MSR DSPSR_EL0, R0
+//		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);    //X0=DTRRX
+//		cortex_a53_exec_opcode(target, ARMV8_T32_MRC(14, 0, 0, 5, 0, 0), &dummy);    //X0=DTRRX
+//		cortex_a53_exec_opcode(target, ARMV8_T32_MCR(15, 3, 0, 4, 5, 0), &dummy);    // MSR DSPSR_EL0, R0
+		cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dummy);    //X0=DTRRX
+		cortex_a53_exec_opcode(target, ARMV4_5_MCR(15, 3, 0, 4, 5, 0), &dummy);    // MSR DSPSR_EL0, R0
 
 	    LOG_DEBUG("Asic ROM base is = 0x%08" PRIx64, target->romcbase);
 		// set to 0xFE800000 as PC
@@ -1535,11 +1462,11 @@ static int cortex_a53_halt_BAD(struct target *target)
 //		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0x100000); //for 8916
 		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, target->romcbase); //0x100084 is for 8916
 //		target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, 0xFE800000);
-//		cortex_a53_exec_opcode_BAD(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);     //X0=DTRRX
-//		cortex_a53_exec_opcode_BAD(target, ARMV8_T32_MRC(14, 0, 0, 5, 0, 0), &dummy);    //X0=DTRRX / DBGDTRRXint
-//		cortex_a53_exec_opcode_BAD(target, ARMV8_T32_MCR(15, 3, 0, 4, 5, 1), &dummy);     // MSR DLR_EL0, R0, mov pc?
-		cortex_a53_exec_opcode_BAD(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dummy);    //X0=DTRRX / DBGDTRRXint
-		cortex_a53_exec_opcode_BAD(target, ARMV4_5_MCR(15, 3, 0, 4, 5, 1), &dummy);     // MSR DLR_EL0, R0, mov pc?
+//		cortex_a53_exec_opcode(target, ARMV8_A64_MRS(2, 3, 0, 5, 0, 0), &dummy);     //X0=DTRRX
+//		cortex_a53_exec_opcode(target, ARMV8_T32_MRC(14, 0, 0, 5, 0, 0), &dummy);    //X0=DTRRX / DBGDTRRXint
+//		cortex_a53_exec_opcode(target, ARMV8_T32_MCR(15, 3, 0, 4, 5, 1), &dummy);     // MSR DLR_EL0, R0, mov pc?
+		cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dummy);    //X0=DTRRX / DBGDTRRXint
+		cortex_a53_exec_opcode(target, ARMV4_5_MCR(15, 3, 0, 4, 5, 1), &dummy);     // MSR DLR_EL0, R0, mov pc?
 	    retval = armv8_dbg_rd_atomic_EDSCR( target, &dummy);
 	    LOG_DEBUG("after DRPS, EDSCR = 0x%08" PRIx32, dummy);
 
@@ -1583,12 +1510,9 @@ static int cortex_a53_halt_BAD(struct target *target)
 	return retval;
 }
 
-static int cortex_a53_internal_restore_BAD(struct target *target, int current,
+static int cortex_a53_internal_restore(struct target *target, int current,
 	struct target_addr *pAddr, int handle_breakpoints, int debug_execution)
 {
-	/* WHYBAD: this function only supports 32bit address
-	 *         and does not properly support 64bit execution addresses
-	 */
 	struct armv8 *armv8;
 	struct arm   *arm;
 
@@ -1768,7 +1692,7 @@ static int cortex_a53_restore_smp(struct target *target, int handle_breakpoints)
 		curr = head->target;
 		if ((curr != target) && (curr->state != TARGET_RUNNING)) {
 			/*  resume current address , not in step mode */
-			retval += cortex_a53_internal_restore_BAD(curr, 1, &addr,
+			retval += cortex_a53_internal_restore(curr, 1, &addr,
 					handle_breakpoints, 0);
 			retval += cortex_a53_internal_restart(curr);
 		}
@@ -1794,7 +1718,7 @@ static int cortex_a53_resume_64(struct target *target, int current,
 		target_call_event_callbacks(target, TARGET_EVENT_RESUMED);
 		return 0;
 	}
-	cortex_a53_internal_restore_BAD(target, current, &addr, handle_breakpoints, debug_execution);
+	cortex_a53_internal_restore(target, current, &addr, handle_breakpoints, debug_execution);
 	if (target->smp) {
 		target->gdb_service->core[0] = -1;
 		retval = cortex_a53_restore_smp(target, handle_breakpoints);
@@ -1906,12 +1830,8 @@ static int cortex_a53_debug_entry(struct target *target)
 	return retval;
 }
 
-static int cortex_a53_post_debug_entry_BAD(struct target *target)
+static int cortex_a53_post_debug_entry(struct target *target)
 {
-	/* WHYBAD: this function uses ARMV4_5 opcodes
-	 *         this function disables the MMU, it should ot
-	 *         this function assumes cortex_a series, it should not
-	 */
 	struct armv8		*armv8		= target_to_armv8(target);
 	struct cortex_a_common	*cortex_a	= armv8_to_cortex_a(armv8);
 	struct armv7a_common	*armv7a		= armv8_to_armv7a(armv8);
@@ -1956,10 +1876,9 @@ static int cortex_a53_post_debug_entry_BAD(struct target *target)
 	return ERROR_OK;
 }
 
-static int cortex_a53_step_64_BAD(struct target *target, int current, const struct target_addr *pAddr,
+static int cortex_a53_step_64(struct target *target, int current, const struct target_addr *pAddr,
 	int handle_breakpoints)
 {
-	/* WHYBAD: this function does not support 64bit step modes */
 	struct armv8		*armv8	= target_to_armv8( target );
 	struct arm		*arm	= armv8_to_arm(armv8);
 	struct breakpoint *breakpoint = NULL;
@@ -2440,12 +2359,10 @@ static int cortex_a53_deassert_reset(struct target *target)
 	return ERROR_OK;
 }
 
-static int cortex_a53_write_apb_ab_memory_BAD(struct target *target,
+static int cortex_a53_write_apb_ab_memory(struct target *target,
 	const struct target_addr *pAddr, uint32_t size,
 	uint32_t count, const uint8_t *buffer)
 {
-	/* WHYBAD: This function uses ARMV4_5() opcodes to exeucte cache operations */
-	/* WHYBAD: This function assumes the DCC has a fast mode, armv8 does not */
 	/* write memory through APB-AP */
 	struct armv8         *armv8  = target_to_armv8( target );
 	struct arm *arm = armv8_to_arm(armv8);
@@ -2504,7 +2421,7 @@ static int cortex_a53_write_apb_ab_memory_BAD(struct target *target,
 		 */
 		tmp_addr = *pAddr;
 		tmp_addr.addr &= (~0x03);
-		retval = cortex_a53_read_apb_ab_memory_BAD(target, &tmp_addr, 4, 1, tmp_buff);
+		retval = cortex_a53_read_apb_ab_memory(target, &tmp_addr, 4, 1, tmp_buff);
 		if (retval != ERROR_OK)
 			goto error_free_buff_w;
 	}
@@ -2517,7 +2434,7 @@ static int cortex_a53_write_apb_ab_memory_BAD(struct target *target,
 		int mem_offset = (total_u32-1) * 4;
 		tmp_addr = *pAddr;
 		tmp_addr.addr = (pAddr->addr & ~0x3) + mem_offset;
-		retval = cortex_a53_read_apb_ab_memory_BAD(target, &tmp_addr, 4, 1, &tmp_buff[mem_offset]);
+		retval = cortex_a53_read_apb_ab_memory(target, &tmp_addr, 4, 1, &tmp_buff[mem_offset]);
 		if (retval != ERROR_OK)
 			goto error_free_buff_w;
 	}
@@ -2533,7 +2450,6 @@ static int cortex_a53_write_apb_ab_memory_BAD(struct target *target,
 		goto error_free_buff_w;
 
 	/* Set DTR mode to Fast (2) */
-	LOG_ERROR("DCC FASTMODE is not on ARMV8");
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_FAST_MODE;
 	/*FIXME: This should be queued */
 	retval = armv8_dbg_queued_wr_EDSCR( target, dscr );
@@ -2569,7 +2485,6 @@ static int cortex_a53_write_apb_ab_memory_BAD(struct target *target,
 
 
 	/* Switch DTR mode back to non-blocking (0) */
-	LOG_ERROR("DCC FASTMODE is not on ARMV8");
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
 	retval = armv8_dbg_queued_wr_EDSCR( target, dscr );
 	if (retval != ERROR_OK)
@@ -2593,7 +2508,6 @@ static int cortex_a53_write_apb_ab_memory_BAD(struct target *target,
 error_unset_dtr_w:
 	/* Unset DTR mode */
 	armv8_dbg_rd_atomic_EDSCR( target, &dscr );
-	LOG_ERROR("DCC FASTMODE is not on ARMV8");
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
 	armv8_dbg_wr_atomic_EDSCR( target, dscr);
 error_free_buff_w:
@@ -2602,12 +2516,10 @@ error_free_buff_w:
 	return ERROR_FAIL;
 }
 
-static int cortex_a53_read_apb_ab_memory_BAD(struct target *target,
+static int cortex_a53_read_apb_ab_memory(struct target *target,
 	const struct target_addr *pAddr, uint32_t size,
 	uint32_t count, uint8_t *buffer)
 {
-	/* WHYBAD: this function assumes ARMV8 has DCC fast mode, ARMV8 does not */
-	/* WHYBAD: this function uses ARMV4_5() opcodes via translation */
 	struct armv8         *armv8  = target_to_armv8( target );
 	struct arm           *arm    = armv8_to_arm(armv8);
 	
@@ -2658,7 +2570,6 @@ static int cortex_a53_read_apb_ab_memory_BAD(struct target *target,
 	 */
 
 	/* Set DTR access mode to stall mode b01  */
-	LOG_ERROR("DCC FASTMODE is not on ARMV8");
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_STALL_MODE;
 	retval +=  armv8_dbg_queued_wr_EDSCR( target, dscr );
 
@@ -2668,7 +2579,7 @@ static int cortex_a53_read_apb_ab_memory_BAD(struct target *target,
 	tmp_addr.addr &= (~0x03);
 	retval += target_cs_dbg_queued_wr32( target, CPUDBG_DTRRX, tmp_addr.addr );
 	/*  - Copy value from DTRRX to R0 using instruction mrc p14, 0, r0, c5, c0 */
-	cortex_a53_exec_opcode_BAD(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dscr);
+	cortex_a53_exec_opcode(target, ARMV4_5_MRC(14, 0, 0, 0, 5, 0), &dscr);
 
 	/* Write the data transfer instruction (ldc p14, c5, [r0],4)
 	 * and the DTR mode setting to fast mode
@@ -2676,7 +2587,6 @@ static int cortex_a53_read_apb_ab_memory_BAD(struct target *target,
 	 */
 	u8buf_ptr = buf;
 	target_buffer_set_u32(target, u8buf_ptr, ARMV4_5_LDC(0, 1, 0, 1, 14, 5, 0, 4));
-	LOG_ERROR("DCC FASTMODE is not on ARMV8");
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_FAST_MODE;
 	target_buffer_set_u32(target, u8buf_ptr + 4, dscr);
 	/*  group the 2 access CPUDBG_ITR 0x84 and CPUDBG_DSCR 0x88 */
@@ -2712,7 +2622,6 @@ static int cortex_a53_read_apb_ab_memory_BAD(struct target *target,
 			goto error_unset_dtr_r;
 
 	/* set DTR access mode back to non blocking b00  */
-	LOG_ERROR("DCC FASTMODE is not on ARMV8");
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
 	retval =  armv8_dbg_queued_wr_EDSCR( target, dscr );
 	if (retval != ERROR_OK)
@@ -2748,7 +2657,6 @@ static int cortex_a53_read_apb_ab_memory_BAD(struct target *target,
 error_unset_dtr_r:
 	/* Unset DTR mode */
 	armv8_dbg_rd_atomic_EDSCR( target, &dscr );
-	LOG_ERROR("DCC FASTMODE is not on ARMV8");
 	dscr = (dscr & ~DSCR_EXT_DCC_MASK) | DSCR_EXT_DCC_NON_BLOCKING;
 	/* this sould not be queued */
 	armv8_dbg_wr_atomic_EDSCR( target, dscr);
@@ -2843,20 +2751,19 @@ static int cortex_a53_read_memory_64(struct target *target, const struct target_
 	if (retval != ERROR_OK)
 		return retval;
 	/* enable MMU as we could have disabled it for phys access */
-	retval = cortex_a53_mmu_modify_BAD(target, 1);
+	retval = cortex_a53_mmu_modify(target, 1);
 	if (retval != ERROR_OK){
 		return retval;
 	}
-	retval = cortex_a53_read_apb_ab_memory_BAD(target, pAddr, size, count, buffer);
+	retval = cortex_a53_read_apb_ab_memory(target, pAddr, size, count, buffer);
 	return retval;
 }
 
 
-static int cortex_a53_write_phys_memory_64_BAD(struct target *target,
+static int cortex_a53_write_phys_memory_64(struct target *target,
 	const struct target_addr *pAddr, uint32_t size,
 	uint64_t count, const uint8_t *buffer)
 {
-	/* WHYBAD: this function uses ARMV4_5() opcodes, not supported by ARMV8 */
 	struct target_addr              resolved;
 	struct armv8          *armv8  = target_to_armv8( target );
 	struct armv7a_common  *armv7a = armv8_to_armv7a(armv8);
@@ -2891,11 +2798,11 @@ static int cortex_a53_write_phys_memory_64_BAD(struct target *target,
 
 	/* write memory through APB-AP */
 	if (!armv7a->is_armv7r) {
-			retval = cortex_a53_mmu_modify_BAD(target, 0);
+			retval = cortex_a53_mmu_modify(target, 0);
 			if (retval != ERROR_OK)
 				return retval;
 	}
-	return cortex_a53_write_apb_ab_memory_BAD(target, pAddr, size, count, buffer);
+	return cortex_a53_write_apb_ab_memory(target, pAddr, size, count, buffer);
 	
  cache_clean:
 
@@ -2979,7 +2886,7 @@ static int cortex_a53_write_memory_64(struct target *target, const struct target
 	}
 	
 	if( pAddr->route == TA_ROUTE_PHYSICAL ){
-		return cortex_a53_write_phys_memory_64_BAD( target, pAddr, size, count, buffer );
+		return cortex_a53_write_phys_memory_64( target, pAddr, size, count, buffer );
 	}
 
 	/* cortex_a53 handles unaligned memory access */
@@ -3011,16 +2918,16 @@ static int cortex_a53_write_memory_64(struct target *target, const struct target
 		if (!mmu_enabled) {
 			resolved = *pAddr;
 			resolved.route = TA_ROUTE_PHYSICAL;
-			retval = cortex_a53_write_phys_memory_64_BAD( target, &resolved, size, count, buffer );			
+			retval = cortex_a53_write_phys_memory_64( target, &resolved, size, count, buffer );			
 		} else {
 			retval = cortex_a53_check_address(target, pAddr);
 			if (retval != ERROR_OK)
 				return retval;
 			/* enable MMU as we could have disabled it for phys access */
-			retval = cortex_a53_mmu_modify_BAD(target, 1);
+			retval = cortex_a53_mmu_modify(target, 1);
 			if (retval != ERROR_OK)
 				return retval;
-			retval = cortex_a53_write_apb_ab_memory_BAD(target, pAddr, size, count, buffer);
+			retval = cortex_a53_write_apb_ab_memory(target, pAddr, size, count, buffer);
 		}
 	}
 	return retval;
@@ -3240,7 +3147,7 @@ static int cortex_a53_init_arch_info(struct target *target,
 
 	/* register arch-specific functions */
 	armv7a->examine_debug_reason = NULL;
-	armv7a->post_debug_entry = cortex_a53_post_debug_entry_BAD;
+	armv7a->post_debug_entry = cortex_a53_post_debug_entry;
 	armv7a->pre_restore_context = NULL;
 	armv7a->armv7a_mmu.read_physical_memory = cortex_a53_read_phys_memory_WRAPPER;
 
@@ -3300,7 +3207,7 @@ static int cortex_a53_virt2phys_64(struct target *target,
 		*out_pPhys = resolved;
 	} else {/*  use this method if armv7a->memory_ap not selected
 		 *  mmu must be enable in order to get a correct translation */
-		retval = cortex_a53_mmu_modify_BAD(target, 1);
+		retval = cortex_a53_mmu_modify(target, 1);
 		if (retval != ERROR_OK)
 			goto done;
 		retval = armv7a_mmu_translate_va_pa(target, in_pVirt->addr, &FIXME, 1);
@@ -3463,7 +3370,7 @@ static struct target_io64 cortexa53_target64 = {
 	// .run_algorithm = armv4_5_run_algorithm, NOT SUPPORTED (64bit reasons)
 
 	.resume = cortex_a53_resume_64,
-	.step = cortex_a53_step_64_BAD,
+	.step = cortex_a53_step_64,
 
 };
 
@@ -3477,7 +3384,7 @@ struct target_type cortexa53_target = {
 	.poll = cortex_a53_poll,
 	.arch_state = armv7a_arch_state,
 
-	.halt = cortex_a53_halt_BAD,
+	.halt = cortex_a53_halt,
 
 	.assert_reset = cortex_a53_assert_reset,
 	.deassert_reset = cortex_a53_deassert_reset,
-- 
1.9.1

